{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"about/","title":"Sobre mi","text":"<p>Joan Gerard Camarena Estruch.</p> <p>Pendent de resum</p>"},{"location":"","title":"Acc\u00e9s a Dades - Informaci\u00f3 del m\u00f2dul","text":""},{"location":"#modul-didactic-acces-a-dades-curs-2025-2026","title":"Modul Did\u00e0ctic Acc\u00e9s a Dades. Curs 2025-2026","text":"<ul> <li>2on Desenvolupament d'Aplicacions Multiplataforma (DAM)</li> <li>IES Jaume II el Just</li> <li>Tavernes de la Valldigna</li> <li>La programaci\u00f3 did\u00e0ctica est\u00e0 en desenvolupamnet. En breu la tindreu enlla\u00e7ada</li> <li>AULES SEMIPRESENCIAL</li> </ul>"},{"location":"#professor","title":"Professor","text":"<ul> <li>Joan Gerard Camarena</li> </ul>"},{"location":"#continguts-del-modul","title":"Continguts del m\u00f2dul","text":"<ul> <li>Unitat 1. Fitxers. Formats. Exportacinos i importacions</li> <li>Unitat 2. Connectors a bases de dades</li> <li>Unitat 3. Hibernate</li> <li>Unitat 4. Bases de Dades Objecte relacionals i OO</li> <li>Unitat 5. Spring. API Rest</li> <li>Unitat 6. MongoDB</li> </ul>"},{"location":"#temporitzacio","title":"Temporitzaci\u00f3","text":""},{"location":"#avaluacio","title":"Avaluaci\u00f3","text":"<p>L'avaluaci\u00f3 \u00e9s el mecanisme que far\u00e9 servir per a avaluar els vostres coneixemnets. I hem de considerar diferents aspectes:</p> <ul> <li>El cicle \u00e9s semipresencial per la qual cosa l'assist\u00e8ncia no \u00e9s obligat\u00f2ria.</li> </ul> <p>Tipus d'activitats</p> <ul> <li>Es desenvoluparan una serie d'exercicis pr\u00e0ctics que haureu de lliurar i entregar. Aquestes pr\u00e0ctiques podrien necessitar d'una part oral on haureu de demostrar que enteneu el que heu entregat i que sou els autors de la pr\u00e0ctica. Si el professor te dubtes raonables que no ho heu fet vosaltres, la pr\u00e0ctica puntuar\u00e0 com un zero. Aquest exercicis ponderar\u00e0n el 20%.</li> <li> <p>Examens de cada avaluaci\u00f3, programats ja des de l'inici de curs:</p> </li> <li> <p>1a avaluaci\u00f3: setmana del 8 de desembre</p> </li> <li>2a Avaluaci\u00f3: setmana del 2 de mar\u00e7</li> <li>3a avaluaci\u00f3: setmana del 25 de maig</li> <li> <p>Dins de cada examen, podran apar\u00e8ixer exercicis de tres tipus: </p> <ul> <li>test, amb preguntes de 3 o 4 opcions, descontant puntaci\u00f3 les preguntes err\u00f2nies</li> <li>preguntes de teoria o pr\u00e0ctica a resoldre en paper</li> <li>exercicis a resoldre amb el ordinador </li> </ul> <p>Els examens ponderar\u00e0n el 80% de la nota</p> </li> <li> <p>L'\u00fas d'eines de Intel\u00b7lig\u00e8ncia Artificial (ChatGPT, Copilot o similat) est\u00e0 terminatment prohibit en la elaboraci\u00f3 de pr\u00e0ctiques i examens. La detecci\u00f3 o sospita raonable de qualssel \u00fas implica un zero en dita pr\u00e0ctica i/o examen.</p> </li> </ul> <p>Per a aprovar l'assignatura, podr\u00e0s fer-ho de 3 maneres distintes:</p> <p>A. Avaluaci\u00f3 cont\u00ednua</p> <p>Al llarg del curs l'alumnat anir\u00e0 presentant els treballs obligatoris i examinant-se de cadascuna de les avaluacions.</p> <p>Per poder examinar-se del m\u00f2dul en cada avaluaci\u00f3, caldr\u00e0 haver presentat els exercicis obligatoris i haver-los aprovat.</p> <p>Nota avaluaci\u00f3: 20% nota pr\u00e0ctiques +  80% nota ex\u00e0mens</p> <p>Consideracions:</p> <ul> <li>Cal haver entregat totes les pr\u00e0ctiques i activitats obligat\u00f2ries</li> <li>Cal haver tret almenys un 4 en cada examen per a fer mitja </li> </ul> <p>NO hi han examens de recuperaci\u00f3 parcial de cada tema/bloc tem\u00e0tic. Al final de curs es faran les recuperacions pertinents de cada avaluaci\u00f3 suspesa.</p> <p>Si a final de curs l'alumne o alumna ha aprovat l'avaluaci\u00f3 cont\u00ednua (ha presentat tots els treballs i ha aprovat les 3 avaluacios al llarg del curs), no caldr\u00e0 que es presente a la convocat\u00f2ria ordin\u00e0ria ni extraordin\u00e0ria.</p> <p>B. Convocat\u00f2ria ordin\u00e0ria (principis de juny habitualment)</p> <p>2 possibles opcions:</p> <ol> <li>Si un alumne o alumna no ha aprovat alguna avaluaci\u00f3, abans de la convocat\u00f2ria de juny haur\u00e0 de lliurar els treballs que li falten i nom\u00e9s s'examinar\u00e0 de la part suspesa en l'avaluaci\u00f3 cont\u00ednua al llarg del curs.</li> <li>Independentment de l'assist\u00e8ncia a classe i dels treballs lliurats, un alumne o alumna podr\u00e0 examinar-se en la convocat\u00f2ria ordin\u00e0ria, per\u00f2 de tot el curs sencer. La nota d'aquest examen ser\u00e0 la nota final del curs</li> </ol> <p>C. Convocat\u00f2ria extraordin\u00e0ria (finals de juny habitualment)</p> <p>Qui no haja aprovat el curs ni en l'avaluaci\u00f3 cont\u00ednua ni en l'ordin\u00e0ria de juny, hauria d'anar a la convocat\u00f2ria extraordin\u00e0ria amb tot el temari de l'assignatura (encara que haguera aprovat alguna avaluaci\u00f3).</p>"},{"location":"license/","title":"Llic\u00e8ncia","text":"<p>Aquest treball est\u00e0 llicenciat sota una Llic\u00e8ncia Internacional de Creative Commons Reconeixement-NoComercial-CompartirIgual 4.0.</p> <p>Ets lliure de:</p> <ul> <li>Compartir: copiar i redistribuir el material en qualsevol format o mitj\u00e0.</li> <li>Adaptar: remesclar, transformar i crear a partir del material.</li> </ul> <p>Sota els seg\u00fcents termes:</p> <ul> <li>Reconeixement: has de donar el cr\u00e8dit adequat, proporcionar un enlla\u00e7 a la llic\u00e8ncia i indicar si s'han realitzat canvis. Ho pots fer de qualsevol manera raonable, per\u00f2 no d'una manera que suggereixi que el llicenciador et dona suport o avala l'\u00fas que en fas.</li> <li>NoComercial: no pots utilitzar el material amb fins comercials.</li> <li>CompartirIgual: si remescles, transformes o crees a partir del material, has de distribuir les teves contribucions sota la mateixa llic\u00e8ncia que l'original.</li> </ul> <p>Per a m\u00e9s detalls, consulta el text complet de la llic\u00e8ncia a https://creativecommons.org/licenses/by-nc-sa/4.0/legalcode.</p>"},{"location":"Practiques/APAC1/","title":"1. Entorn i execuci\u00f3 del programa","text":"<p>En aquesta primera Activitat de Pr\u00e0ctica d'Avaluaci\u00f3 Continuada (APAC1), implementarem la part de persist\u00e8ncia de fitxers d'un projecte de figures geom\u00e8triques parcialment fet.</p> <p>Disposeu d'un fitxer comprimit amb el projecte Gradle APAC1_AD, amb la implementaci\u00f3 de la jerarquia de figures i altres utilitats.</p> <p>El projecte ha estat creat amb <code>gradle init</code>, que crea una petita estructura de directoris i fitxers per a nosaltres, com ara els llan\u00e7adors <code>gradlew</code> i <code>gradlew.bat</code> (que no utilitzarem).</p> <p>Per construir el projecte, farem:</p> Bash<pre><code>$ gradle build\nBUILD SUCCESSFUL in 1 s\n5 actionable tasks : 5 up-to-date\n</code></pre> <p>i per a executar-lo:</p> Bash<pre><code>gradle run --console plain\n</code></pre> <p>l'opci\u00f3  <code>--console plain</code> evita missatges per consola de l'execuci\u00f3 del programa. Adem\u00e9s, per a passar arguments al programa (tamany de l'\u00e0rea de dibuix) ho indicarem com segueix <code>--args=\"500 500\"</code>. </p> <p>Un cop el programa en execuci\u00f3, ens apareixer\u00e0 a la consola:</p> Text Only<pre><code># Figura: \n</code></pre> <p>Aquest programa ens permet dibuixar una escena formada per diverses figures. Les opcions disponibles compatibles amb la versi\u00f3 actual s\u00f3n:</p> <ul> <li><code>dimensions ample alt</code>: Estableix l'al\u00e7ada i l'amplada del canvas o llen\u00e7ol.</li> <li><code>cercle x y radi #color</code>: Afegeix un cercle a l'escena actual. El cercle es col\u00b7locar\u00e0 a les coordenades <code>x, y</code>, amb el radi especificat i un color en format <code>#RRGGBB</code>. Aquest color \u00e9s validat per una funci\u00f3 d'utilitat implementada a les llibreries.</li> <li><code>rectangle x y altura amplada #color</code>: Afegeix un rectangle col\u00b7locat a les coordenades <code>x, y</code>, amb les mesures especificades i un color.</li> <li><code>linia x1 y1 x2 y2 #color</code>: Afegeix una l\u00ednia des del punt d'inici <code>(x1, y1)</code> fins al punt final <code>(x2, y2)</code> i amb el color especificat. El programa estableix un gruix fixat de 3 p\u00edxels per a la l\u00ednia.</li> <li><code>draw</code>: Obre una finestra JavaFX i dibuixa totes les figures emmagatzemades i introdu\u00efdes en un canvas. Quan tanquem la finestra, l'aplicaci\u00f3 finalitzar\u00e0.</li> </ul>"},{"location":"Practiques/APAC1/#2-noves-funcionalitats","title":"2. Noves funcionalitats","text":"<p>Per tal de millorar el programa base, hem d'afegir la persist\u00e8ncia de dades, afegint funcions per emmagatzemar i recuperar escenes. Les ordres que hem de implementar s\u00f3n:</p> <ul> <li><code>import [fitxer.txt | fitxer.obj]</code> \\(\\rightarrow\\) Importar\u00e0 de disc les configuracions de les escenes (el dibuix), emmagatzemades en fitxers de text o fitxers d'objectes. El programa decidir\u00e0 el format tenint en compte l'extensi\u00f3 del fitxer.</li> <li><code>export [fitxer.txt | fitxer.obj | fitxer.svg | fitxer.json]</code> \\(\\rightarrow\\) Exportar\u00e0 a disc la configuraci\u00f3 actual de l'escena, guardant-la en fitxers de text, fitxers d'objectes, format svg (un format xml especial) o format json. El programa decidir\u00e0 el format tenint en compte l'extensi\u00f3 del fitxer.</li> </ul> <p>Nota</p> <p>Tots els fitxers es guardaran a l'arrel del programa</p>"},{"location":"Practiques/APAC1/#21-fitxers-dexemples","title":"2.1. Fitxers d'exemples","text":"<p>Fitxer de Text</p> <p>Text Only<pre><code>dimensions 500 500\nrectangle 10 10 480 480 #ccccee \ncercle 250 250 100 #aaaaaa\nlinia 50 250 450 250 #aaaaaa\nlinia 50 50 50 450 #aaaaaa\nlinia 450 40 450 450 #aaaaaa\n</code></pre> Arxiu SVG</p> XML<pre><code>&lt;?xmlversion=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?&gt;\n&lt;svg height=\"500\" width=\"500\"&gt;\n  &lt;rect fill=\"#ccccee\" height=\"480\" width=\"480\" x=\"10\" y=\"10\"/&gt;\n  &lt;circle cx=\"250\" cy=\"250\" fill=\"#aaaaaa\" r=\"100\"/&gt;\n  &lt;line stroke=\"#aaaaaa\" stroke-width=\"3\" x1=\"50\" x2=\"450\" y1=\"250\" y2=\"250\"/&gt;\n  &lt;line stroke=\"#aaaaaa\" stroke-width=\"3\" x1=\"50\" x2=\"50\" y1=\"50\" y2=\"450\"/&gt;\n  &lt;line stroke=\"#aaaaaa\" stroke-width=\"3\" x1=\"450\" x2=\"450\" y1=\"40\" y2= \"450\"/&gt;\n&lt;/svg&gt;\n</code></pre> <p>Nota</p> <p>Aquest tipus d'XML es fa perqu\u00e8 despr\u00e9s d'exportar aquesta escena, pots obrir-la amb Inkscape. Pots utilitzar-lo per comprovar que ho has fet b\u00e9.</p> <p>Format JSON</p> JSON<pre><code>{\"escena\": {\n    \"width\": 320,\n    \"height\": 320\n    \"figuras\": [\n        {\"cercle\": {\n            \"r\": \"26\",\n            \"cx\": \"166\",\n            \"cy\": \"105\",\n            \"fill\": \"#94c147\"\n        }},\n        {\"rectangle\": {\n            \"x\": \"137\",\n            \"width\": \"58\",\n            \"y\": \"108\",\n            \"fill\": \"#ffffff\",\n            \"height\": \"58\"\n        }},\n        {\"rectangle\": {\n            \"x\": \"139\",\n            \"width\": \"52\",\n            \"y\": \"111\",\n            \"fill\": \"#94c147\",\n            \"height\": \"52\"\n        }}\n     ],\n}}\n</code></pre>"},{"location":"Practiques/APAC1/#3-estructura-del-projecte","title":"3. Estructura del Projecte","text":"<p>Primer, tenim el fitxer <code>build.gradle</code>, amb informaci\u00f3 sobre la construcci\u00f3 del projecte, amb llibreries de gr\u00e0fics i JSON. En la nostra estructura de projecte, tenim:</p> <p>Text Only<pre><code>main\n  |-- java\n  |   `--com\n  |      `-- ieseljust\n            `-- ad\n                `-- figures\n                    |-- App.java\n                    |-- cercle.java\n                    |-- escena.java\n                    |-- figura.java\n                    |-- FileManager.java\n                    |-- HexColorValidator.java\n                    |-- Linia.java\n                    |-- punt.java\n                    `-- Rectangle.java\n</code></pre> Com a podeu veure, dins de la carpeta src, podem tenir en compte:</p> <ul> <li>App \\(\\rightarrow\\) classe principal. Mostra el prompt i crea el canvas. No cal que modifiquis aquesta classe.</li> <li>figura, cercle, linia, rectangle, punt \\(\\rightarrow\\) aquestes classes formen l'arbre d'her\u00e8ncia (excepte punt). Tenen els atributs i m\u00e8todes necessaris. Probablement necessitar\u00e0s afegir m\u00e8todes per obtenir la representaci\u00f3 d'aquesta classe en text, json o xml. Tamb\u00e9 cal que facis les classes necess\u00e0ries serialitzables.</li> <li>escena \\(\\rightarrow\\) cont\u00e9 alguns atributs i la col\u00b7lecci\u00f3 de figures.</li> <li>FileManager \\(\\rightarrow\\) classe que s'encarrega del proc\u00e9s d'emmagatzematge. Hem de fer la feina principal en aquesta classe, com es mostra al seg\u00fcent punt.</li> </ul>"},{"location":"Practiques/APAC1/#4-classe-filemanager","title":"4. Classe <code>FileManager</code>","text":"<p>Com ja hem explicat, aqu\u00ed \u00e9s on has de guardar i recuperar la informaci\u00f3 en diversos formats.</p>"},{"location":"Practiques/APAC1/#41-metode-exists","title":"4.1. M\u00e8tode <code>exists</code>","text":"Java<pre><code>public Boolean Exists(String file)\n</code></pre> <p>Retornar\u00e0 un valor l\u00f2gic en funci\u00f3 de l'exist\u00e8ncia del fitxer o no.</p>"},{"location":"Practiques/APAC1/#42-metode-importfromtext","title":"4.2. M\u00e8tode <code>importFromText</code>","text":"<p>Java<pre><code>public Escena importFromText(String file)\n</code></pre> Importa una escena en format de text, en el format indicat al principi d'aquest document. Tens un parell d'imatges per provar. Com pots veure, rep la ruta del fitxer en format de cadena i retornar\u00e0 un objecte de tipus Escena.</p> <p>Cal tenir en compte que, a m\u00e9s de les figures, pot apar\u00e8ixer la comanda <code>dimensions</code>, que indicar\u00e0 que haurem de modificar les dimensions de l'Escena.</p>"},{"location":"Practiques/APAC1/#43-metode-importfromobj","title":"4.3. M\u00e8tode <code>importFromObj</code>","text":"Java<pre><code>public Escena importFromObj(String file)\n</code></pre> <p>Importar una escena serialitzada en format d'objecte, en el format indicat al principi d'aquest document. A la carpeta imgs, tens un parell d'imatges per provar. Com pots veure, rep la ruta del fitxer en format de cadena i retornar\u00e0 un objecte de tipus Escena.</p>"},{"location":"Practiques/APAC1/#44-metode-exporttext","title":"4.4. M\u00e8tode <code>exportText</code>","text":"<p>Java<pre><code>public Boolean exportText(Escena escena, String file)\n</code></pre> Aquest m\u00e8tode exportar\u00e0 una escena donada a un fitxer de text, en el format especificat anteriorment, per poder-les llegir amb <code>importFromText</code>.</p> <p>El m\u00e8tode rebr\u00e0 l'objecte Escena i una cadena amb el nom del fitxer a desar, amb l'extensi\u00f3 <code>.txt</code>.</p> <p>Per implementar aquest m\u00e8tode, et ser\u00e0 \u00fatil implementar un m\u00e8tode anomenat <code>getAsText</code> (o similar) en cada tipus de figura, que retorni la pr\u00f2pia figura en el format desitjat. D'aquesta manera, per exportar l'escena, recorrerem les diferents figures i obtindrem la representaci\u00f3 de cadascuna d'elles.</p>"},{"location":"Practiques/APAC1/#45-metode-exportobj","title":"4.5. M\u00e8tode <code>exportObj</code>","text":"Java<pre><code>public Boolean exportObj(Escena escena, String file)\n</code></pre> <p>Aquest m\u00e8tode exportar\u00e0 una escena donada a un fitxer d'objectes, per poder-lo llegir amb <code>importFromObj</code>.</p> <p>El m\u00e8tode rebr\u00e0 l'objecte Escena i una cadena amb el nom del fitxer a desar, amb l'extensi\u00f3 <code>.obj</code>.</p> <p>Atenci\u00f3</p> <p>Recorda utilitzar el modificador <code>Serializable</code> en les classes necess\u00e0ries.</p>"},{"location":"Practiques/APAC1/#46-metode-exportsvg","title":"4.6. M\u00e8tode <code>exportSVG</code>","text":"Java<pre><code>public Boolean exportSVG(Escena escena, String file)\n</code></pre> <p>Aquest m\u00e8tode exportar\u00e0 una escena donada a un fitxer <code>svg</code>, en el format xml especificat anteriorment a les p\u00e0gines anteriors. El m\u00e8tode rebr\u00e0 l'objecte Escena i una cadena amb el nom del fitxer a desar, amb l'extensi\u00f3 <code>.svg</code>.</p> <p>Alguns detalls del format:</p> <ul> <li>Inclourem <code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?&gt;</code> sempre.</li> <li>L'element arrel \u00e9s l'etiqueta <code>&lt;svg&gt;</code>, amb dos atributs width i height.</li> <li>Cada figura heretada ser\u00e0 l'equivalent a l'etiqueta <code>rect</code>, <code>circle</code> i <code>line</code>. Mira l'exemple del document.</li> <li>Per obtenir una posici\u00f3 correcta del cercle, has d'afegir el radi a la posici\u00f3 de la figura: <code>this.posicio.getX()+this.radi</code> i <code>this.posicio.getY()+this.radi</code></li> </ul> <p>Important</p> <p>Per obtenir una implementaci\u00f3 correcta d'aquest m\u00e8tode (i altres que vindran), \u00e9s interessant seguir els seg\u00fcents passos:</p> <ul> <li>Declara un m\u00e8tode abstracte a la classe Figura. <code>getAsSVG()</code>, per exemple.</li> <li>Implementa aquest m\u00e8tode a cada classe descendents.</li> </ul>"},{"location":"Practiques/APAC1/#47-metode-exportjson","title":"4.7. M\u00e8tode <code>exportJSON</code>","text":"Java<pre><code>public Boolean exportJSON(Escena escena,String filename)\n</code></pre> <p>Aquest m\u00e8tode crear\u00e0 una representaci\u00f3 JSON de l'escena que rep el m\u00e8tode. Com es va mencionar a la nota anterior, \u00e9s una pr\u00e0ctica interessant crear el m\u00e8tode <code>getAsJson()</code> a la classe superior i implementar-lo a les classes inferiors.</p> <p>Atenci\u00f3</p> <p>Per treballar de manera m\u00e9s eficient, implementa els m\u00e8todes de la seg\u00fcent manera:</p> <ul> <li><code>importFromText</code>, per importar una escena completa i poder-la dibuixar.</li> <li><code>exportToText</code>, per comprovar que la teva escena sigui igual que l'original.</li> <li><code>exportToObj</code>, per desar una escena importada des de text.</li> <li><code>importFromObj</code>, per comprovar que l'exportada s'ha fet correctament.</li> <li>Finalment, la resta d'exports, a SVG i JSON.</li> </ul>"},{"location":"Practiques/APAC1/#5-entrega-de-la-practica","title":"5. Entrega de la pr\u00e0ctica","text":"<p>Per fer l'enviament de la pr\u00e0ctica, heu de seguir els seg\u00fcents passos:</p> <ul> <li>Executeu <code>gradle clean</code> per netejar tots els paquets i llibreries.</li> <li>Comprimiu la carpeta del projecte. El format zip \u00e9s obligatori.</li> <li>Pugeu la pr\u00e0ctica a la plataforma aules, evitant correus electr\u00f2nics o altres eines de comunicaci\u00f3.</li> </ul>"},{"location":"Practiques/APAC2/","title":"1. Visi\u00f3 General","text":"<p>Anem a crear un client de SGBD, com el MySQL Workbench, per\u00f2 en una versi\u00f3 de consola amb una shell i un prompt. El nostre client ens permet connectar-nos a un servidor, seleccionar una base de dades i finalment executar diverses consultes SQL.</p>"},{"location":"Practiques/APAC2/#11-mode-de-servidor","title":"1.1. Mode de servidor","text":"<p>En iniciar el nostre programa, demanar\u00e0 les dades del servidor.</p> Bash<pre><code>gradle run --console plain\n...\n$ Server: 127.0.0.1\n$ Port: 3308\n$ Username: root\n$ Password:\n$ (root) on 127.0.0.1:3308&gt;\n</code></pre> <p>Com podeu veure a l'\u00faltima l\u00ednia, el prompt \u00e9s <code>(usuari) a IP:port&gt;</code>. El nostre client mostra sempre on estem connectats.</p> <p>La llista d'ordres que el nostre client acceptar\u00e0 quan estigui connectat \u00e9s (mode servidor):</p> <ul> <li><code>show database</code> o <code>show db</code> \\(\\rightarrow\\) mostra una llista amb totes les bases de dades del nostre SGBD.</li> <li><code>info</code> \\(\\rightarrow\\) mostra informaci\u00f3 sobre el SGBD i la configuraci\u00f3 de la connexi\u00f3.</li> <li><code>import nom_del_script</code> \\(\\rightarrow\\) permet carregar un script SQL des d'un fitxer.</li> <li><code>use nom_de_la_bd</code> \\(\\rightarrow\\) canvia el nostre programa al mode base de dades.</li> <li><code>quit</code> \\(\\rightarrow\\) finalitza el nostre programa.</li> </ul>"},{"location":"Practiques/APAC2/#12-mode-de-base-de-dades","title":"1.2. Mode de Base de Dades","text":"<p>Un cop estiguem connectats a un servidor i haguem seleccionat una base de dades, el nostre client entrar\u00e0 en el mode de base de dades:</p> Bash<pre><code>$ (root) on 127.0.0.1:3308&gt;use Ciclismo\n$ (root) on 127.0.0.1:3308[Ciclismo]&gt;\n</code></pre> <p>Pots veure que el nom de la base de dades s'afegeix al prompt i ara el programa est\u00e0 esperant ordres per a la base de dades. Has d'implementar aquestes comandes:</p> <ul> <li><code>sh tables</code> \\(\\rightarrow\\) mostra totes les taules de la base de dades seleccionada.</li> <li><code>describe nom_de_la_taula</code> \\(\\rightarrow\\) mostra la descripci\u00f3 d'aquesta taula: camps, tipus de dades i claus prim\u00e0ries com a m\u00ednim.</li> <li><code>insert Nom_de_la_Taula</code> \\(\\rightarrow\\) de manera interactiva, demana a l'usuari el valor de cada camp i insereix una nova fila.</li> <li><code>sql</code> \\(\\rightarrow\\) executa qualsevol consulta a la base de dades seleccionada.</li> <li><code>quit</code> \\(\\rightarrow\\) torna al mode SGBD.</li> </ul>"},{"location":"Practiques/APAC2/#2-estructura-del-projecte-i-consells","title":"2. Estructura del projecte i consells","text":"<p>El projecte cont\u00e9 les seg\u00fcents classes:</p> <p></p> <p>Anem a revisar les funcions de classe</p>"},{"location":"Practiques/APAC2/#21-servermanager","title":"2.1. ServerManager","text":"<p>Cont\u00e9 el main, i quan s'inicia, demana a l'usuari la informaci\u00f3 del servidor. A continuaci\u00f3, inicia la classe <code>ConnectionManager</code> amb els valors proporcionats.</p>"},{"location":"Practiques/APAC2/#22-connectionmanager","title":"2.2. ConnectionManager","text":"<p>Gestiona la consola principal del programa i t\u00e9 com a atributs:</p> Java<pre><code>String server;\nString port;\nString user;\nString pass;\n</code></pre> <p>i com a m\u00e8todes:</p> <ul> <li><code>ConnectionManager()</code> \\(\\rightarrow\\) constructor per defecte.</li> <li><code>ConnectionManager(String server, String port, String user, String pass)</code> \\(\\rightarrow\\) constructor general.</li> <li><code>public Connection connectDBMS()</code> \\(\\rightarrow\\) inicia i retorna una connexi\u00f3.</li> <li><code>public void showInfo()</code> \\(\\rightarrow\\) mostra la informaci\u00f3 del servidor.</li> <li><code>public void showDatabases()</code> \\(\\rightarrow\\) mostra les taules del servidor.</li> <li><code>public void importScript(String script)</code> \\(\\rightarrow\\) carrega i executa un script.</li> <li><code>public void startShell()</code> \\(\\rightarrow\\) inicia la consola del servidor. Aquesta consola ja est\u00e0 gaireb\u00e9 implementada.</li> </ul>"},{"location":"Practiques/APAC2/#23-gestor-de-base-de-dades","title":"2.3. Gestor de Base de Dades","text":"<p>Gestiona la consola del mode base de dades i necessita un atribut addicional respecte al Gestor de Connexi\u00f3:</p> Java<pre><code>String server;\nString port;\nString user;\nString pass;\nString dbname;\n</code></pre> <p>i com a m\u00e8todes:</p> <ul> <li><code>DatabaseManager()</code> \\(\\rightarrow\\) constructor per defecte.</li> <li><code>DatabaseManager(String server, String port, String user, String pass,String dbname)</code> \\(\\rightarrow\\) constructor general.</li> <li><code>public Connection connectDatabase()</code> \\(\\rightarrow\\) inicia i retorna una connexi\u00f3 a la base de dades actual.</li> <li><code>public void insertIntoTable(String table)</code> \\(\\rightarrow\\) inicia l'assistent d'inserci\u00f3 per a la taula donada.</li> <li><code>public void showDescTable(String table)</code> \\(\\rightarrow\\) mostra la metadades de la taula.</li> <li><code>public void executeSelect(String query)</code> \\(\\rightarrow\\) executa una consulta donada (de qualsevol tipus) i mostra els resultats a la pantalla, si n'hi ha.</li> <li><code>public void startShell()</code> \\(\\rightarrow\\) inicia la consola del mode base de dades. Has de fer una implementaci\u00f3 completa.</li> </ul>"},{"location":"Practiques/APAC2/#3-insercions-a-les-taules","title":"3. Insercions a les taules.","text":"<p>El m\u00e8tode <code>insertIntoTable</code> \u00e9s probablement el m\u00e9s dif\u00edcil de la tasca, ja que cal demanar primer les metadades de la taula per con\u00e8ixer els camps i els tipus de dades de la taula, i despr\u00e9s demanar a l'usuari els valors i els formats.</p> <p>El consell que es donar\u00e0 \u00e9s crear tres llistes amb:</p> <ol> <li>Llista de camps que cal inserir.</li> <li>Llista de valors que s'assignaran.</li> <li>Llista de tipus de cada camp.</li> </ol> <p>A m\u00e9s, cal generar una llista o cadena de marcadors de posici\u00f3 amb tants <code>?</code> com sigui necessari.</p> <p>Consell</p> <p>Recorda que, en demanar les metadades de la taula, les columnes que necessites s\u00f3n:</p> Text Only<pre><code>- Columna 4: nom de la columna\n- Columna 6: tipus de dades de la columna\n- Columna 18: nullable o no. Aquest camp \u00e9s obligatori si no \u00e9s nullable.\n- Columna 23: incremental o no. No necessites aquest camp si \u00e9s incremental.\n</code></pre> <p>Finalment, verifica l'ajust dels placeholders, ja que depenen del tipus de dades. Tindre en compte que:</p> <ul> <li>Les dades <code>int</code> faran servir <code>setInt()</code></li> <li>Les dades <code>datetime</code> faran servir <code>setDate()</code>, amb un casting a <code>java.sql.Date</code> en compte de <code>java.Date</code></li> <li>Per defecte el <code>setString</code> i confiar que el casting autom\u00e0tic fa\u00e7a la seua feina.</li> </ul> <p>\u00a9 Joan Gerard Camarena, October-2022</p> <p>\u00a9 \u00daltima revisi\u00f3, October-2024</p>"},{"location":"Practiques/APAC3/","title":"APAC3","text":"<p>Notes sobre l'enunciat i pr\u00e0ctica</p> <p>Aquesta pr\u00e0ctica \u00e9s d'enunciat obert. Has de crear la teua pr\u00f2pia tasca, amb certes limitacions, com comprendr\u00e0s. Has de fer un programa que fa\u00e7a el manteniment d'una base de dades a la teua elecci\u00f3: podr\u00e0s crear-la de zero o escollir-ne alguna que conegues o cercar a internet.</p>"},{"location":"Practiques/APAC3/#1-la-base-de-dades","title":"1. La base de dades","text":"<p>Les restriccions de la base de dades s\u00f3n:</p> <ul> <li>Ha de contenir com a m\u00ednim tres entitats.</li> <li>Ha de contenir com a m\u00ednim tres relacions, una de cada classe: <code>1-1</code>, <code>1-M</code> i <code>N:M</code>. Si vols, pots crear una relaci\u00f3 reflexiva.</li> <li>Utilitza MySQL</li> </ul>"},{"location":"Practiques/APAC3/#2-el-programa","title":"2. El programa","text":""},{"location":"Practiques/APAC3/#21-estructura","title":"2.1. Estructura","text":"<p>Crea un programa Hibernate amb l'objectiu de realitzar les operacions b\u00e0siques de CRUD a la base de dades (Create, Read, Update i Delete). Mapeja totes les entitats i relacions de la base de dades.</p>"},{"location":"Practiques/APAC3/#22-crud","title":"2.2. CRUD","text":"<p>Com tot el treball de cada entitat \u00e9s el mateix (canviant el nom de l'entitat), nom\u00e9s has de crear un CRUD complet per a una entitat. A continuaci\u00f3, crea m\u00e8todes per inserir, eliminar, actualitzar i seleccionar informaci\u00f3 d'una entitat.</p>"},{"location":"Practiques/APAC3/#23-relacions","title":"2.3. Relacions","text":"<p>Imagina que tenim una relaci\u00f3 <code>1:M</code>, un <code>Autor</code> escriu diversos <code>Llibres</code>. Amb les teves pr\u00f2pies relacions, fes el mateix de la seg\u00fcent manera:</p>"},{"location":"Practiques/APAC3/#231-tasca-1","title":"2.3.1. Tasca 1","text":"<p>Has de mostrar registres d'una entitat, per exemple <code>mostra Autor</code>. Aquesta comanda mostrar\u00e0 tots els autors de la base de dades. Per\u00f2 si la comanda \u00e9s <code>mostra -r Autor</code>, mostrar\u00e0 per a cada autor els llibres que ha escrit. (<code>r</code> significa recursivament)</p>"},{"location":"Practiques/APAC3/#232-tasca-2","title":"2.3.2. Tasca 2","text":"<p>Quan vulguis inserir un nou Llibre, pots executar <code>afegir Llibre</code>, i despr\u00e9s, de manera interactiva, el programa demanar\u00e0 els valors del llibre i el crear\u00e0 i emmagatzemar\u00e0, establint l'Autor com a <code>null</code>. Per\u00f2 si executes <code>afegir -r Llibre</code>, el programa mostrar\u00e0 tots els autors de la base de dades. L'usuari en seleccionar\u00e0 un, i aquest Autor es configurar\u00e0 com a autor del llibre.</p> <p>En el proc\u00e9s de selecci\u00f3 de l'Autor, hi haur\u00e0 una opci\u00f3 addicional (Autor 0, per exemple) quan l'autor del llibre no estigui a la base de dades, i crearem un nou Autor i despr\u00e9s l'assignarem al Llibre. Tant l'Autor com el Llibre es desaran.</p>"},{"location":"Practiques/APAC3/#3-tasca","title":"3. Tasca.","text":"<p>Per pujar la tasca a la plataforma, nom\u00e9s cal que escriguis un enlla\u00e7 a un repositori privat de GitHub de l'estudiant. Has d'afegir l'usuari del teu professor com a convidat del teu repositori (<code>joange</code> - jgcamarena@ieseljust.com). La tasca es presentar\u00e0 amb els seg\u00fcents punts.</p> <p>En la carpeta del teu treball has de tenir:</p> <ol> <li>Un script amb la creaci\u00f3 de taules de la base de dades i alguna dada d'exemple. Has de generar-ho amb MySQL Workbench sql dump.</li> <li>Una imatge de l'estructura de la teva base de dades, creada amb MySQL Workbench reverse engineering.</li> <li>Un projecte Maven que implementi els requisits d'aquest text.</li> <li>Fitxer <code>Readme.md</code> amb documentaci\u00f3 sobre el teu programa.</li> </ol>"},{"location":"Practiques/APAC3/#31-punt-de-control-1-la-base-de-dades","title":"3.1. Punt de control 1. La base de dades.","text":"<p>En aquesta tasca has de presentar el teu repositori quan hagis acabat les parts 1 i 2. El professor ho marcar\u00e0 com a <code>OK</code> abans de comen\u00e7ar a programar la part 3.</p>"},{"location":"Practiques/APAC3/#32-punt-de-control-2-el-programa","title":"3.2. Punt de control 2. El programa.","text":"<p>Quan hagis acabat la tasca, presenta el teu repositori.</p> <p>(c) Joan Gerard Camarena Estruch, novembre 2022</p>"},{"location":"UD1_Files/1_File_System/","title":"1. Sistema de fitxers","text":""},{"location":"UD1_Files/1_File_System/#11-introduccio","title":"1.1. Introducci\u00f3","text":"<p>En els inicis de la inform\u00e0tica, els fitxers eren l'\u00fanic mecanisme per emmagatzemar informaci\u00f3. Avui en dia, els sistemes operatius gestionen els dispositius d'emmagatzematge de manera gaireb\u00e9 transparent per a l'usuari. Sense entrar en detalls de les tecnologies de emmagatzematge subjacents, ens ofereixen una abstracci\u00f3 mitjan\u00e7ant la qual nom\u00e9s hem de preocupar-nos de dos conceptes: fitxers i directoris.</p> <ul> <li>Fitxer \u2192 contenidors d'informaci\u00f3 (de tot tipus i format).</li> <li>Directoris \u2192 organitzadors de fitxers, i poden contenir fitxers i altres directoris.</li> </ul> <p>Seguint amb la informaci\u00f3 (el contingut del fitxer), podem trobar una classificaci\u00f3 cl\u00e0ssica:</p> <ul> <li>Fitxer de text \u2192 la informaci\u00f3 s'emmagatzema en fitxers, de manera que es pot veure o obrir amb qualsevol editor de text pla, com ara vi, nano o notepad.</li> <li>Fitxer binari \u2192 la informaci\u00f3 s'emmagatzema codificada en format binari. Com ja sap l'estudiant, qualsevol tipus d'informaci\u00f3 (text, n\u00fameros, fotos, etc.) es pot traduir a 0 i 1. En el nostre cas (programadors), podem transformar objectes i variables de diferents maneres.</li> </ul> <p>Cal tenir en compte que...</p> <ul> <li>Tot i que emmagatzemem informaci\u00f3 en fitxers de text, apareix un nou concepte: estructura. Si organitzem la informaci\u00f3 de diferents maneres, podem parlar de fitxers csv, fitxers xml, fitxers json. Els fitxers csv, xml i json s\u00f3n estructures, perqu\u00e8 al cap i a la fi, tots ells s\u00f3n fitxers de text.</li> <li>La gent pensa que els fitxers de text s\u00f3n febles per emmagatzemar informaci\u00f3, per\u00f2 no \u00e9s cert. Les t\u00e8cniques criptogr\u00e0fiques ens ofereixen m\u00e8todes per emmagatzemar informaci\u00f3 de manera segura dins dels fitxers de text. Per exemple, <code>htpasswd</code> a apache o <code>/etc/shadoW</code> en sistemes Linux. A sota podeu veure un exemple de clau p\u00fablica PGP, emmagatzemada en un fitxer de text.</li> </ul> Bash<pre><code>-----BEGIN PGP PUBLIC KEY BLOCK-----\nComment: Alice's OpenPGP certificate\nComment: https://www.ietf.org/id/draft-bre-openpgp-samples-01.html\n\nmDMEXEcE6RYJKwYBBAHaRw8BAQdArjWwk3FAqyiFbFBKT4TzXcVBqPTB3gmzlC/U\nb7O1u120JkFsaWNlIExvdmVsYWNlIDxhbGljZUBvcGVucGdwLmV4YW1wbGU+iJAE\n...\nDAAKCRDyMVUMT0fjjlnQAQDFHUs6TIcxrNTtEZFjUFm1M0PJ1Dng/cDW4xN80fsn\n0QEA22Kr7VkCjeAEC08VSTeV+QFsmz55/lntWkwYWhmvOgE=\n=iIGO\n-----END PGP PUBLIC KEY BLOCK-----\n</code></pre>"},{"location":"UD1_Files/1_File_System/#12-accedint-al-sistema-de-fitxers-en-java","title":"1.2. Accedint al sistema de fitxers en Java","text":"<p><code>Java</code> ens ofereix diverses maneres d'accedir al sistema de fitxers. Aquesta manera \u00e9s independent del dispositiu subjacent que emmagatzema la informaci\u00f3. El dispositiu pot ser un disc dur, un disc ssd, una unitat \u00f2ptica, etc. La classe que ens ofereix aquesta possibilitat \u00e9s la classe File. Repassarem els principals aspectes d'aquesta classe i despr\u00e9s revisarem alguns exemples.</p> <ul> <li> <p>El constructor de la classe est\u00e0 sobrecarregat, com la majoria de les classes de Java. Podem utilitzar:</p> <ul> <li><code>File(File parent, String child)</code> \u2192 Crea una nova inst\u00e0ncia de File a partir d'un directori pare abstracte i una cadena de directori fill.</li> <li><code>File(String pathname)</code> \u2192 Crea una nova inst\u00e0ncia de File convertint la cadena de directori donada en un directori abstracte.</li> <li><code>File(String parent, String child)</code> \u2192 Crea una nova inst\u00e0ncia de File a partir d'una cadena de directori pare i una cadena de directori fill.</li> <li><code>File(URI uri)</code> \u2192 Crea una nova inst\u00e0ncia de File convertint el file: URI donat en un directori abstracte.</li> </ul> </li> <li> <p>Per accedir al fitxer hem d'utilitzar un nom de ruta. Aquesta \u00e9s la ruta, i tenim dues possibilitats:</p> <ul> <li>Ruta absoluta \u2192 la ruta des del directori arrel del sistema fins al fitxer que volem, comen\u00e7ant amb <code>/</code> en sistemes Linux o <code>letra:</code> en sistemes Windows. Recorda utilitzar <code>/</code> per separar carpetes en Linux i <code>\\\\</code> en Windows. No \u00e9s un error, ja que la barra invertida \u00e9s un s\u00edmbol amb un significat propi, hem d'escapar-la, duplicant-la per obtenir el significat que volem.</li> <li>Ruta relativa \u2192 suposem que el fitxer que volem es troba a la mateixa carpeta que el projecte/programa que estem executant. En aquest cas, nom\u00e9s proporcionem el nom del fitxer, sense cap carpeta al principi de la ruta.</li> </ul> </li> </ul> Java<pre><code>// absolute paths\nFile f=new File(\"/home/joange/texto.md\") //  Linux\nFile f=new File(\"C:\\\\Usuarios\\\\joange\\\\Dektop\\\\texto.md\") //  Windows\n...\n// relative paths\nFile f=new File(\"texto.md\") //  Linux\nFile f=new File(\"docs\\\\texto.md\") //  Windows\n</code></pre> <ul> <li>La mateixa classe <code>File</code> s'utilitza per accedir tant a un fitxer regular com a un directori. \u00c9s tasca del programador diferenciar-los mitjan\u00e7ant els m\u00e8todes de fitxer, aix\u00ed com comprovar si un fitxer existeix. Per fer aix\u00f2, podem utilitzar diversos m\u00e8todes com:<ul> <li><code>boolean exists()</code> \u2192 retorna true si l'objecte de fitxer existeix i false en cas contrari.</li> <li><code>boolean isFile()</code> i <code>isDirectory()</code> \u2192 retorna true si l'objecte \u00e9s un fitxer regular o un directori. \u00d2bviament, aquests m\u00e8todes s\u00f3n exclusius.</li> </ul> </li> </ul>"},{"location":"UD1_Files/1_File_System/#13-creant-fitxers","title":"1.3. Creant fitxers","text":"<p>Si volem crear una carpeta o un fitxer regular, podem utilitzar aquests m\u00e8todes:</p> <ul> <li><code>boolean createNewFile()</code> \u2192 Crea de manera at\u00f2mica un nou fitxer buit amb el nom especificat si i nom\u00e9s si un fitxer amb aquest nom encara no existeix.</li> <li><code>static FilecreateTempFile(String prefix, String suffix)</code> \u2192 Crea un fitxer buit al directori temporal per defecte, utilitzant el prefix i el sufix especificats per generar el seu nom.</li> <li><code>boolean mkdir()</code> \u2192 Crea el directori amb el nom especificat.</li> <li><code>boolean mkdirs()</code> \u2192 Crea el directori amb el nom especificat, incloent qualsevol directori pare necessari per\u00f2 que no existeixi.</li> <li><code>boolean renameTo(File dest)</code> \u2192 Canvia el nom del fitxer especificat.</li> <li><code>boolean delete()</code> \u2192 Elimina el fitxer o directori especificat.</li> </ul> <p>Atenci\u00f3</p> <ul> <li>En les seccions seg\u00fcents estudiarem com crear fitxers quan hi guardem contingut. En altres paraules, no cal crear el fitxer ad hoc i despr\u00e9s omplir-lo. Hi ha mecanismes per crear el fitxer de manera automatitzada.</li> <li>La difer\u00e8ncia entre mkdir i mkdirs \u00e9s que la segona opci\u00f3 crear\u00e0 tots els directoris entre el sistema de fitxers arrel i el directori actual, mentre que la primera requereix que la ruta ja existeixi.</li> </ul>"},{"location":"UD1_Files/1_File_System/#14-demanant-propietats-del-fitxer","title":"1.4. Demanant propietats del fitxer","text":"<p>Normalment obrim fitxers per escriure o llegir el seu contingut, per\u00f2 a vegades necessitem demanar les propietats del fitxer, com ara la mida, els permisos, etc. La classe File ens ajudar\u00e0 de nou.</p> <p>Informaci\u00f3 general:</p> <ul> <li><code>boolean exists()</code> \u2192 Comprova si el fitxer o directori indicat per aquesta ruta abstracta existeix.</li> <li><code>long lastModified()</code> \u2192 Retorna el temps en qu\u00e8 es va modificar per \u00faltima vegada el fitxer indicat per aquesta ruta abstracta.</li> <li><code>long length()</code> \u2192 Retorna la mida del fitxer indicat per aquesta ruta abstracta.</li> </ul> <p>Informaci\u00f3 sobre els permisos. Aquesta informaci\u00f3 \u00e9s la mateixa que l'usuari pot obtenir amb <code>ls -la</code> en el format de <code>chmod</code>:</p> <ul> <li><code>boolean canExecute()</code> \u2192 Comprova si l'aplicaci\u00f3 pot executar el fitxer indicat per aquesta ruta abstracta.</li> <li><code>boolean canRead()</code> \u2192 Comprova si l'aplicaci\u00f3 pot llegir el fitxer indicat per aquesta ruta abstracta.</li> <li><code>boolean canWrite()</code> \u2192 Comprova si l'aplicaci\u00f3 pot modificar el fitxer indicat per aquesta ruta abstracta.</li> </ul> <p>Contingut d'un directori:</p> <ul> <li><code>String[] list()</code> \u2192 Retorna un array de cadenes amb els noms dels fitxers i directoris del directori indicat per aquesta ruta abstracta.</li> <li><code>File[] listFiles()</code> \u2192 Retorna un array de rutes abstractes que indiquen els fitxers del directori indicat per aquesta ruta abstracta.</li> <li><code>String[] list(FilenameFilter filter)</code> \u2192 Retorna un array de cadenes amb els noms dels fitxers i directoris del directori indicat per aquesta ruta abstracta que compleixen el filtre especificat.</li> <li><code>File[] listFiles(FilenameFilter filter)</code> \u2192 Retorna un array de rutes abstractes que indiquen els fitxers i directoris del directori indicat per aquesta ruta abstracta que compleixen el filtre especificat.</li> </ul> <p>Consell</p> <p>Suggerim a l'estudiant que busqui informaci\u00f3 sobre la classe FilenameFilter.</p>"},{"location":"UD1_Files/1_File_System/#141-exercici-resolt","title":"1.4.1. Exercici resolt","text":"<p>Analitza i explica el seg\u00fcent bloc de codi Java<pre><code>public static void main(String[] args) {\n        String ruta = args[0];\n        File f = new File(ruta);\n\n        if (f.exists()) {\n            if (f.isFile()) {\n                System.out.println(\"El tama\u00f1o es de \" + f.length());\n                System.out.println(\"Puede ejecturase: \" + f.canExecute());\n                System.out.println(\"Puede leerse: \" + f.canRead());\n                System.out.println(\"Puede escribirse: \" + f.canWrite());\n            } else {\n                String[] losArchivos = f.list();\n                System.out.println(\"El directorio \" + ruta + \" contiene:\");\n                for (String archivo : losArchivos) {\n                    System.out.println(\"\\t\" + archivo);\n                }\n            }\n\n        } else {\n            System.out.println(\"El fichero o ruta no existe\");\n        }\n}\n</code></pre></p> <p>Soluci\u00f3</p> <ol> <li>Aquest programa llegeix des de la l\u00ednia de comandes una ruta i crea un objecte File.</li> <li>A continuaci\u00f3, comprova si la ruta existeix o no al sistema de fitxers. En cas que no existeixi, el programa finalitza.</li> <li>Si la ruta existeix, el seg\u00fcent pas \u00e9s verificar si \u00e9s un fitxer:<ol> <li>Llegim algunes propietats trivials com la mida i els permisos.</li> </ol> </li> <li>Si la ruta apuntada pel fitxer \u00e9s un directori, obtenim el contingut d'aquest directori i el mostrem a la pantalla.</li> </ol>"},{"location":"UD1_Files/2_Reading_and_writing_files/","title":"1. Lectura i escriptura de fitxers","text":"<p>Java ofereix una gran varietat de maneres de manipular el contingut dels fitxers, aportant gran poder per\u00f2 tamb\u00e9 complexitat al mateix temps.</p> <p>La lectura i escriptura de fitxers en Java es fa a trav\u00e9s de fluxos de dades o <code>streams</code>, que poden ser orientats a bytes o considerats com un conjunt de car\u00e0cters. El concepte de fitxer, que \u00e9s est\u00e0tic, ha de diferenciar-se del concepte de flux, que t\u00e9 un car\u00e0cter din\u00e0mic: un fitxer es guarda al disc, per\u00f2 des del punt de vista de l'aplicaci\u00f3, ens interessa la transfer\u00e8ncia d'aquesta informaci\u00f3 des del fitxer al nostre programa. Una comparaci\u00f3 cl\u00e0ssica: els fluxos serien com canonades d'aigua, mentre que els fitxers serien dip\u00f2sits. El concepte de flux de dades, a part de l'\u00e0mbit dels fitxers, tamb\u00e9 ser\u00e0 aplicable a la transfer\u00e8ncia d'informaci\u00f3, per exemple a trav\u00e9s de la xarxa o entre processos.</p> <p>Els fluxes es poden classificar en:</p> <ul> <li><code>flux d'entrada</code>: Aquells que van des d'una font (per exemple, un fitxer) al programa.</li> <li><code>flux de sortida</code>: Aquells que surten del programa cap a una destinaci\u00f3 (per exemple, un fitxer).</li> </ul> <p>Quan llegim i emmagatzemem dades, hem de tenir molt de compte amb els tipus de dades amb els quals treballem, ja que la mateixa seq\u00fc\u00e8ncia de bits al disc representa informaci\u00f3 diferent segons el tipus de dades utilitzat. Inclos quan es tracta del mateix tipus de dades, com en el cas dels car\u00e0cters, cal tenir cura especial, ja que diferents sistemes poden utilitzar diferents codificacions. Java, per exemple, per al tipus char utilitza Unicode de 16 bits (UTF-16), per\u00f2 podem intentar accedir a fitxers codificats, per exemple, amb UTF-8 o ASCII.</p> <p>Les superclasses pare per al maneig de corrents orientats a bytes s\u00f3n <code>InputStream</code> i <code>OutputStream</code>. D'elles en deriven altres, per\u00f2 per a la gesti\u00f3 de fitxers ens interessen dues: <code>FileInputStream</code> i <code>FileOutputStream</code>.</p>"},{"location":"UD1_Files/2_Reading_and_writing_files/#11-fileinputstream","title":"1.1. FileInputStream","text":"<p>La classe <code>FileInputStream</code> s'utilitza per accedir a fitxers per a la lectura i t\u00e9 dos constructors principals:</p> <ul> <li><code>FileInputStream (File f)</code> \u2192 Rep un objecte de tipus <code>File</code>, que far\u00e0 refer\u00e8ncia a l'objecte que llegirem.</li> <li><code>FileInputStream (String name)</code> \u2192 Rep una cadena amb el nom o la ruta de la ubicaci\u00f3 del fitxer a llegir.</li> </ul> <p>Els principals m\u00e8todes que tenim per a aquesta classe s\u00f3n:</p> <ul> <li><code>int read()</code> \u2192 M\u00e8tode de lectura seq\u00fcencial abstracte: Retorna un enter corresponent al seg\u00fcent byte d'un flux d'entrada (fitxer, vector de bytes...). Si arriba al final de la seq\u00fc\u00e8ncia, retorna <code>-1</code>. En cas d'error, llan\u00e7ar\u00e0 una excepci\u00f3 de tipus <code>IOException</code>.</li> <li><code>int read(byte[] buffer)</code> \u2192 Llegeix un nombre determinat de bytes de l'entrada (tant com el tamany del buffer), els guarda al buffer i retorna el nombre de bytes llegits efectivament, que com a m\u00e0xim ser\u00e0 igual al tamany del buffer. Si no hi ha bytes disponibles, retorna <code>-1</code>.</li> <li><code>int available()</code> \u2192 Indica els bytes disponibles per a la lectura.</li> <li><code>long skip(long des)</code> \u2192 Salta tants bytes com indica el par\u00e0metre. El valor de retorn \u00e9s el nombre de bytes que s'han descartat efectivament (pot ser menor que el que hem indicat si arribem al final, per exemple).</li> <li><code>int close()</code> \u2192 Tanca el flux de dades.</li> </ul>"},{"location":"UD1_Files/2_Reading_and_writing_files/#12-fileoutputstream","title":"1.2. FileOutputStream","text":"<p>La classe <code>FileOutputStream</code> s'utilitza per accedir a fitxers per a l'escriptura. T\u00e9 els seg\u00fcents constructors:</p> <ul> <li><code>FileOutputStream (File f)</code> \u2192 Rep un objecte de tipus <code>File</code> i l'obre en mode escriptura. En cas que no existeixi, es crear\u00e0, i si ja existeix, es sobreescriur\u00e0.</li> <li><code>FileOutputStream (String name)</code> \u2192 Rep una cadena amb el nom o la ruta de la ubicaci\u00f3 del fitxer a escriure, i l'obre en mode escriptura. En cas que no existeixi, es crear\u00e0, i si ja existeix, es sobreescriur\u00e0.</li> <li><code>FileOutputStream (File f, boolean append)</code> \u2192 Rep un objecte de tipus <code>File</code> i l'obre en mode afegir, per escriure al final. Si no existeix, es crear\u00e0, i si ja existeix, s'escriur\u00e0 darrere (nom\u00e9s si append est\u00e0 establert a <code>True</code>).</li> <li><code>FileOutputStream (String name, boolean append)</code> \u2192 Rep una cadena amb el nom o la ruta de la ubicaci\u00f3 del fitxer a escriure i l'obre en mode afegir, per escriure al final. Si no existeix, es crear\u00e0, i si ja existeix, s'escriur\u00e0 darrere (nom\u00e9s si append est\u00e0 establert a <code>True</code>).</li> </ul> <p>Els principals m\u00e8todes de la classe s\u00f3n:</p> <ul> <li><code>write(int byte)</code> \u2192 Escriu el byte al flux de sortida. Encara que aquest par\u00e0metre \u00e9s un enter, nom\u00e9s s'escriu un byte. Si hi ha un error, es llan\u00e7ar\u00e0 una excepci\u00f3 de tipus <code>IOException</code>.</li> <li><code>void write(byte[] buffer)</code> \u2192 Escriu el contingut del buffer (vector de bytes) al fitxer. Si el buffer \u00e9s nul, llan\u00e7ar\u00e0 una excepci\u00f3.</li> <li><code>void write(byte[] buffer, int pos, int length)</code> \u2192 Escriu el contingut del <code>buffer</code> (vector de bytes) des de la posici\u00f3 <code>pos</code>, i tants bytes com s'indiquin en <code>length</code>.</li> <li><code>void flush()</code> \u2192 For\u00e7a l'escriptura dels bytes restants a la mem\u00f2ria cau al fitxer de sortida.</li> <li><code>void close()</code> \u2192 Tanca el flux de sortida i allibera els recursos.</li> </ul>"},{"location":"UD1_Files/2_Reading_and_writing_files/#121-exercici-resolt","title":"1.2.1. Exercici resolt","text":"<p>Crea un programa senzill en Java que copie un fitxer a un altre fitxer byte a byte. El fitxer origen i el fitxer dest\u00ed s'indicaran a trav\u00e9s de la l\u00ednia de comandes.</p> <p>Soluci\u00f3</p> Java<pre><code>class FileCopy {\n    /*\n    Class to test FileInputStream and FileOutputStream. \n\n    Copy byte to byte of files\n\n    Sintaxi:\n        FileCopy sourceFile destinationFile.\n\n    */\n    public static void main(String[] args) throws Exception {\n        // Byte readed from source\n        int bytes;        \n        // Bytes (effectively) writen to dest\n        long bytesCopied=0; \n\n        // Streams \n\n        FileInputStream fis= null;\n        FileOutputStream fos=null;\n\n        // To provide information about source\n        File f; \n\n\n        // Are the arguments ok?\n        if(args.length!=2){\n            System.out.println(\"Nombre d'arguments erroni. Sintaxi:\\n FileCopy fitxerOrigen fitxerDesti\");\n            return;\n        }\n\n        try{\n\n            // show source size\n            f=new File(args[0]);\n            System.out.println(\"Total: \"+f.length()+\" bytes\");\n\n            // Create streams          \n            fis=new FileInputStream(args[0]);\n            fos=new FileOutputStream(args[1]);\n\n            do {\n                // read one byte from source\n                bytes=fis.read();                 \n                // write in destination\n                if (bytes!=-1)\n                    fos.write(bytes);\n                // Update number of bytes\n                bytesCopied++;                    \n\n                // Show progress (think alternatives as exercise)\n                System.out.print(\"\\rCopiats \"+(bytesCopied-1)+\" bytes...\");\n            }while (bytes!=-1);\n            System.out.println(\"Done it!\");\n\n\n        }catch (IOException exc){\n            System.out.println(\"Error d'entrada i eixida: \"+exc);\n        }finally {\n            // At the end, we have to close the files, either an error exists or not.\n            try {\n                if (fis!=null) fis.close();\n            }catch (IOException exc){\n                System.out.println(\"Error en tancar el fitxer d'origen.\");\n            }\n            try {\n                if(fos!=null) fos.close();\n            }catch (IOException exc){\n                System.out.println(\"Error en tancar el fitxer dest\u00ed.\");\n            }\n        }\n    }\n}\n</code></pre> <p>Pensa i comprova</p> <p>Amb el programa d'exemple que hem vist, podr\u00edem copiar fitxers de tot tipus: text, \u00e0udio, v\u00eddeo. Prova-ho tu mateix i comprova que el contingut \u00e9s el mateix.</p> <p>Repte</p> <p>Intenta canviar l'\u00faltim programa per llegir les dades en blocs de 32 bytes, utilitzant els m\u00e8todes adequats de les classes. Comparteix la teva soluci\u00f3 al f\u00f2rum.</p>"},{"location":"UD1_Files/2_Reading_and_writing_files/#13-fitxers-de-text","title":"1.3. Fitxers de text","text":"<p>Com s'ha dit, Java permet gestionar fluxos amb orientaci\u00f3 a bytes o amb orientaci\u00f3 a car\u00e0cters. Les classes abstractes per a la gesti\u00f3 de fluxos orientats a car\u00e0cters s\u00f3n <code>Reader</code> i <code>Writer</code>. Aquestes classes deriven d'altres, per\u00f2 per a la gesti\u00f3 de fitxers ens centrem en <code>FileReader</code> i <code>FileWriter</code>.</p>"},{"location":"UD1_Files/2_Reading_and_writing_files/#131-filereader","title":"1.3.1. <code>FileReader</code>","text":"<p>La classe <code>FileReader</code> serveix per accedir a fitxers per a la lectura i t\u00e9 dos constructors:</p> <ul> <li><code>FileReader (File f)</code> \u2192 Rep un objecte de tipus <code>File</code>, que far\u00e0 refer\u00e8ncia a l'objecte del qual s'obtindr\u00e0 la informaci\u00f3.</li> <li><code>FileReader (String name)</code> \u2192 Rep una cadena amb el nom o la ruta del fitxer.</li> </ul> <p>Els m\u00e8todes que tenim per a aquesta classe s\u00f3n molt semblants als que tenim per a <code>FileInputStream</code>, amb la difer\u00e8ncia que ara llegim car\u00e0cters en comptes de bytes. Un aspecte a tenir en compte \u00e9s que aquests car\u00e0cters es representaran en el format del sistema operatiu amfitri\u00f3 (UTF-8 en el cas de Linux), a difer\u00e8ncia de l'UTF-16 utilitzat per altres classes d'emmagatzematge intern:</p> <ul> <li><code>int read()</code> \u2192 Llegeix el seg\u00fcent car\u00e0cter del flux d'entrada i el retorna com a enter. Si no queden car\u00e0cters, retorna -1, i si hi ha un error, llan\u00e7a una excepci\u00f3 de tipus IOException.</li> <li><code>int read(char[] buffer)</code> \u2192 Omple el buffer amb tants car\u00e0cters de l'entrada com tingui (com a m\u00e0xim). Retorna el nombre de car\u00e0cters llegits efectivament. Aquest nombre ser\u00e0 la longitud del buffer o menys si no hi ha prou car\u00e0cters per llegir. Si no n'hi ha cap, retorna -1.</li> <li><code>int available()</code> \u2192 Retorna el nombre de car\u00e0cters disponibles per a la lectura.</li> <li><code>long skip(long des)</code> \u2192 Salta tants car\u00e0cters com indica el par\u00e0metre. El valor de retorn \u00e9s el nombre de car\u00e0cters que s'han descartat efectivament (pot ser menor que el que hem indicat si arribem al final, per exemple).</li> <li><code>int close()</code> \u2192 Tanca el flux de dades.</li> </ul>"},{"location":"UD1_Files/2_Reading_and_writing_files/#132-filewriter","title":"1.3.2. <code>FileWriter</code>","text":"<p>La classe FileWriter seria l'equivalent de <code>FileOutputStream</code> en la versi\u00f3 de fluxes orientats a car\u00e0cters. Els constructors de la classe s\u00f3n:</p> <ul> <li><code>FileWriter (File f)</code> \u2192 Obre el fitxer especificat per <code>File</code> per a l'escriptura. Si el fitxer no existeix, es crear\u00e0, i si ja existeix, es borraran els continguts.</li> <li><code>FileWriter (String name)</code> \u2192 Obre el fitxer especificat per una cadena amb el nom i la ruta en mode escriptura. Si no existeix, es crear\u00e0, i si ja existeix, es borraran els continguts.</li> <li><code>FileWriter (File f, boolean append)</code> \u2192 Rep un objecte de tipus <code>File</code> i l'obre en mode afegir, per escriure al final. Si no existeix, es crear\u00e0, i si ja existeix, s'escriur\u00e0 darrere.</li> <li><code>FileWriter (String name, boolean append)</code> \u2192 Rep una cadena amb el nom o la ruta de la ubicaci\u00f3 del fitxer a escriure i l'obre en mode afegir, per escriure al final. Si no existeix, es crear\u00e0, i si ja existeix, s'escriur\u00e0 darrere.</li> </ul> <p>Els principals m\u00e8todes de la classe <code>FileWriter</code> s\u00f3n molt similars als de <code>OutputStream</code>:</p> <ul> <li><code>write(int character)</code> \u2192 Escriu el car\u00e0cter al flux de sortida, amb la codificaci\u00f3 pr\u00f2pia del sistema operatiu. Si hi ha un error, es llan\u00e7a una excepci\u00f3 de tipus <code>IOException</code>.</li> <li><code>void write(char[] buffer)</code> \u2192 Escriu el contingut del buffer (vector de car\u00e0cters) al fitxer. Si el buffer \u00e9s nul, llan\u00e7ar\u00e0 una excepci\u00f3.</li> <li><code>void write(char[] buffer, int pos, int length)</code> \u2192 Escriu el contingut del buffer (array de car\u00e0cters) des de la posici\u00f3 pos, i tants bytes com s'indiquin en length.</li> <li><code>void flush()</code> \u2192 For\u00e7a l'escriptura dels bytes restants a la mem\u00f2ria cau al fitxer de sortida.</li> <li><code>void close()</code> \u2192 Tanca el flux de sortida i allibera els recursos.</li> <li><code>void write(String text)</code> \u2192 Escriu tot el contingut de text al fitxer.</li> </ul>"},{"location":"UD1_Files/2_Reading_and_writing_files/#133-exercici-resolt","title":"1.3.3. Exercici resolt","text":"<p>Crea un programa senzill en Java que fusioni tots els fitxers dins d'una carpeta en un \u00fanic fitxer. La carpeta d'origen i el fitxer de destinaci\u00f3 s'indicaran en la crida del programa. Suposem que tots els fitxers dins d'aquesta carpeta s\u00f3n fitxers de text.</p> <p>Soluci\u00f3</p> Java<pre><code>class FusionaTextos {\n// Codi del programa\n}\n```     /*\n\n\n    Sintax:\n        MergeTexts DirectoriOrigen FitxerDest\u00ed\n\n    */\n    public static void main(String[] args) throws Exception {\n\n        File dir; // Source dir\n        // Collection of files from that dir\n        File[] files; \n\n        // readed characters\n        int characters;\n\n        // Input and Output Streams \n        FileReader fin=null;\n        FileWriter fout=null;\n\n        // Check the args\n        if(args.length!=2){\n            System.out.println(\"Nombre d'arguments erroni. Sintaxi:\\n mergeTexts DirectoriOrigen fitxerDesti\");\n            return;\n        }\n\n        try{\n\n            // We get the list of Files\n            dir=new File(args[0]);\n            files=dir.listFiles();\n\n\n            // Open and close output stream (in order to create the file)\n            fout=new FileWriter(args[1]);\n            fout.close();\n\n            // Re-open it\n            fout=new FileWriter(args[1], true);\n\n            // Iterate among the list\n            for (int i=0; i&lt;files.length; i++){\n                // open input stream\n                fin=new FileReader(args[0]+\"/\"+files[i].getName());\n                System.out.println(\"Merging \"+args[0]+\"/\"+files[i].getName());\n                // and merge to the output one\n                do {\n                    characters=fin.read();                 \n                    if (characters!=-1)\n                        fout.write(characters);\n                }while (characters!=-1);\n                fin.close(); //close the file merged\n\n            }\n            fout.close(); //close the output file\n\n        }catch (Exception exc){\n            // Catch all the exception (we coud improve it)\n            System.out.println(\"Input/Output error: \"+exc);\n        }\n    }\n}\n</code></pre> <p>Millora el teu codi</p> <p>Intenta millorar el codi anterior creant una funci\u00f3 <code>merge()</code>. Haur\u00edem de cridar-la dins del bucle principal.</p>"},{"location":"UD1_Files/2_Reading_and_writing_files/#14-decoradors","title":"1.4. Decoradors","text":"<p>Patr\u00f3 de disseny decorador</p> <p>Les classes de decorador s\u00f3n aquelles que hereten d'una certa classe i proporcionen funcionalitats afegides a l'original. En el cas dels fluxos d'entrada i sortida, tenim decoradors que ens permeten llegir o escriure l\u00ednies completes en comptes de byte a byte, o guardar en un cert format de dades. Simplifica la nostra feina, afegint una manera m\u00e9s natural i amigable per a utilitzar les classes base.</p> <p>La classe <code>InputStream</code> t\u00e9 diversos decoradors, per\u00f2 ens centrarem en els seg\u00fcents:</p> <ul> <li><code>DataInputStream</code> \u2192 Permet llegir dades de qualsevol tipus (enter, l\u00f2gic, etc.)</li> <li><code>ObjectInputStream</code> \u2192 Afegeix la opci\u00f3 de llegir un objecte sencer</li> </ul> <p>D'altra banda, la classe <code>OutputStream</code> tamb\u00e9 t\u00e9 diferents decoradors, entre els quals destaquem:</p> <ul> <li><code>DataOutputStream</code> \u2192 Permet escriure dades de qualsevol tipus (enter, l\u00f2gic, etc.)</li> <li><code>PrintStream</code> \u2192 Permet escriure dades de qualsevol tipus i tamb\u00e9 accepta els m\u00e8todes <code>printf</code> i <code>println</code></li> <li><code>ObjectOutputStream</code> \u2192 Permet escriure (serialitzar) objectes</li> </ul> <p>Pel que fa a les classes de decorador per a fluxos orientats a car\u00e0cters, tenim, d'una banda, els decoradors de <code>Reader</code> (m\u00e9s destacats):</p> <ul> <li><code>BufferedReader</code> \u2192 Crea un buffer d'entrada, permetent, per exemple, llegir una l\u00ednia completa</li> </ul> <p>I per a l'escriptura:</p> <ul> <li><code>BufferedWriter</code> \u2192 Crea un buffer de sortida, permetent, per exemple, escriure una l\u00ednia completa</li> <li><code>PrintWriter</code> \u2192 Permet escriure dades de diferents tipus i t\u00e9 m\u00e8todes com <code>printf</code> i <code>println</code></li> </ul> <p>La classe <code>BufferedReader</code>, entre altres, t\u00e9 el m\u00e8tode <code>readLine()</code>, que permet llegir una l\u00ednia sencera del fitxer fins al final de la l\u00ednia, molt \u00fatil en fitxers de text.</p> <p>Per la seva banda, la classe <code>BufferedWriter</code> proporciona el m\u00e8tode <code>newLine()</code> per introduir el car\u00e0cter de retorn de carro i el m\u00e8tode <code>write(String cadena, int inici, int longitud)</code> per escriure una cadena o una part espec\u00edfica.</p> <p>L'altre decorador per a l'escriptura \u00e9s el <code>PrintWriter</code>, que ens ofereix els m\u00e8todes <code>print(dades)</code>, <code>println(dades)</code> i <code>printf()</code> per a la formataci\u00f3.</p> <p>Alternatives a...</p> <p>\u00d2bviament, podr\u00edeu:</p> <ul> <li>concatenar <code>\\n</code> al final de cada cadena en cada m\u00e8tode <code>print()</code> en comptes de cridar <code>newLine()</code>.</li> <li>utilitzar <code>println()</code> en comptes de cridar <code>newLine()</code>.</li> </ul>"},{"location":"UD1_Files/2_Reading_and_writing_files/#141-exercici-resolt","title":"1.4.1. Exercici resolt","text":"<p>Crea un programa per copiar un fitxer de text afegint el n\u00famero de l\u00ednia al principi de cada l\u00ednia.</p> <p>Soluci\u00f3</p> Java<pre><code>public class NumberLines {\n    public static void main(String[] args) throws Exception {\n\n        // Input and Output\n        BufferedReader fin;\n        PrintWriter fout;\n\n        // line counter\n        int num_linia;\n        // readed line\n        String linia;\n\n        // check args\n        if (args.length != 2) {\n            System.out.println(\"Nombre d'arguments erroni. Sintaxi:\\n numberLines fitxer eixida\");\n            return;\n        }\n\n        // Creare decorators\n        fin = new BufferedReader(new FileReader(args[0]));\n        fout = new PrintWriter(new FileWriter(args[1]));\n\n        num_linia = 1;\n        do {\n            // Read the line\n            linia = fin.readLine();\n            if (linia != null) {\n                fout.println(num_linia + \". \" + linia);\n            }\n            num_linia++;\n        } while (linia != null); // until we can't read\n\n        // close all\n        fin.close();\n        fout.close();\n\n    }\n}\n</code></pre>"},{"location":"UD1_Files/2_Reading_and_writing_files/#15-fitxers-binaris","title":"1.5. Fitxers Binaris","text":"<p>En aquesta secci\u00f3 i les seg\u00fcents veurem com emmagatzemar diferents tipus de dades i objectes en fitxers de diferents formats: fitxers binaris, fitxers XML o JSON. Ara ens centrarem en els fitxers binaris, tant per emmagatzemar dades estructurades, d'una banda, com objectes, de l'altra, en un proc\u00e9s conegut com a serialitzaci\u00f3.</p>"},{"location":"UD1_Files/2_Reading_and_writing_files/#151-emmagatzemar-dades-estructurades-en-fitxers-binaris","title":"1.5.1. Emmagatzemar dades estructurades en fitxers binaris","text":"<p>En la secci\u00f3 anterior vam veure com treballar amb fitxers de car\u00e0cters i de bytes. En el cas dels fitxers de bytes, hem vist com llegir-los i escriure'ls seq\u00fcencialment, byte a byte fins al final del fitxer. Ara veurem com emmagatzemar dades estructurades en fitxers binaris i com poder-les llegir.</p> <p>Imaginem que volem guardar la seg\u00fcent taula, que combina dades de diferents tipus. Aquest exemple apareixer\u00e0 a les seg\u00fcents seccions.</p> Modul Hores Qualificaci\u00f3 Acc\u00e9s a Dades 6 8.45 Programaci\u00f3 de serveis i processos 3 9.0 Desenvolupament d'interf\u00edcies 6 8.0 Programaci\u00f3 Multim\u00e8dia i dispositius m\u00f2bils 5 7.34 Sistemes de Gesti\u00f3 Empresarial 5 8.2 Empresa i iniciativa emprenedora 3 7.4 <p>Com podem veure, tenim dades de text, dades num\u00e8riques enteres i reals. Si volem mantenir els tipus, els fluxos orientats a car\u00e0cters com <code>Reader</code> o <code>Writer</code> no seran \u00fatils, aix\u00ed que haur\u00edem d'utilitzar <code>InputStream</code> i <code>OutputStream</code>. El desavantatge \u00e9s que seria necessari saber exactament quantes dades ocupa cada tipus de dada.</p> <p>Per tal de desar aquestes estructures eficientment, podem fer servir les classes <code>DataInputStream</code> i <code>DataOutputStream</code>, que s\u00f3n decoradors de fluxos i que ens ofereixen els seg\u00fcents m\u00e8todes per desar o recuperar dades de diferents tipus, sense haver de preocupar-nos de quant ocupen internament. Com podeu veure, hi ha m\u00e8todes rec\u00edprocs per llegir i escriure cada tipus de dada b\u00e0sic.</p> <code>DataInputStream</code> <code>DataOutputStream</code> Descripci\u00f3 <code>byte readByte()</code> <code>void writeByte(int)</code> un byte <code>short readShort()</code> <code>void writeShort(short)</code> enter curt <code>int readInt()</code> <code>void writeInt(int)</code> un enter <code>long readLong()</code> <code>void writeLong(long)</code> un enter llarg <code>float readFloat()</code> <code>void writeFloat(float)</code> real de precisi\u00f3 simple <code>double readDouble()</code> <code>void writeDouble(double)</code> real doble <code>char readChar()</code> <code>void writeChar(int)</code> un car\u00e0cter Unicode <code>String readUTF()</code> <code>void writeUTF(String)</code> \u00a0un String UTF-8 <p>Tip</p> <p>Una cadena <code>UTF-8</code> \u00e9s diferent d'una String. Quan es guarda una cadena, com \u00e9s evident, es guarda tots els car\u00e0cters. En desar-la com a cadena UTF-8, s'afegeix informaci\u00f3 sobre la longitud de la cadena, i aquesta informaci\u00f3 \u00e9s essencial per tallar aquestes cadenes quan es llegeixin en el futur.</p> <p>Imagina que guardes dues cadenes, \"euro\" i \"sport\". El resultat ser\u00e0, al final, \"eurosport\". Quan alg\u00fa obri aquest fitxer en el futur, com sabr\u00e0 el nombre de cadenes emmagatzemades (\"euro\", \"sport\" o simplement \"eurosport\" (canal de televisi\u00f3))?</p> <p>En desar-ho com a UTF-8, quan guardes \"euro\" i \"sport\", el resultat \u00e9s \"4euro5sport\". Quan alg\u00fa intenti llegir-ho, primer veur\u00e0 un '4' i llegir\u00e0 \"euro\". Despr\u00e9s, veur\u00e0 un '5' i llegir\u00e0 \"sport\".</p> <p>Cal destacar que si es guarda \"eurosport\", el resultat ser\u00e0 \"9eurosport\". Prova d'escriure un programa d'exemple amb aquesta cadena, obrint el fitxer resultant amb un editor hexadecimal.</p>"},{"location":"UD1_Files/2_Reading_and_writing_files/#152-exercici-resolt","title":"1.5.2. Exercici resolt","text":"<p>Escriu un programa que tingui les dades emmagatzemades en tres arrays paral\u00b7lels, que emmagatzemen les dades dels m\u00f2duls de DAM. Escriu dues funcions, una per escriure aquestes dades en un fitxer i una altra per llegir-les. Considera emmagatzemar les dades agrupades per m\u00f2dul, en comptes de nom, hores i qualificaci\u00f3.</p> <p>Soluci\u00f3</p> Java<pre><code>public class Moduls{\n\n    // several arrays with modules data\n    String[] moduls={\"Acc\u00e9s a Dades\", \"Programaci\u00f3 de serveis i processos\", \"Desenvolupament d'interf\u00edcies\", \"Programaci\u00f3 Multim\u00e8dia i dispositiud m\u00f2bils\", \"Sistemes de Gesti\u00f3 Empresarial\", \"Empresa i iniciativa emprenedora\"};\n    int[]  hores={6, 3, 6, 5, 5, 3};\n    double[] notes={8.45, 9.0, 8.0, 7.34, 8.2, 7.4};\n\n    public void readFiLe(String name) throws IOException {\n        // Per lleginr el fitxer binari, creem un DataInputStream\n        // a partir del FileInputStream creat a partir del nom\n        DataInputStream f = new DataInputStream(new FileInputStream(name));\n\n        // Mentre el DataInputStream tinga dades disponibles\n        while (f.available()&gt;0){\n            // Llegirem del fitxer cada dada, amb l'ordre corresponent\n            // en funci\u00f3 del tipus\n            // (per tant, hem de saber l'ordre en qu\u00e8 guardem!)\n            System.out.println(\"M\u00f2dul: \" + f.readUTF());\n            System.out.println(\"Hores: \" + f.readInt());\n            System.out.println(\"Notes: \" + f.readDouble());\n            System.out.println();\n        }\n        f.close();\n    }\n\n    public void writeFile(String name) throws IOException{\n        // Per escriure el fitxer, fem \u00fas de DataOutputStream\n        DataOutputStream f = new DataOutputStream(new FileOutputStream(name));\n\n        // Recorrerem qualsevol dels vectors (tots haurien de tindre)\n        // la mateixa longitud\n        for (int i=0;i&lt;this.moduls.length;i++){\n            // I per a cada posici\u00f3, escriurem en funci\u00f3 del tipus de dada\n            f.writeUTF(this.moduls[i]);\n            f.writeInt(this.hores[i]);\n            f.writeDouble(this.notes[i]);\n\n        }\n        f.close();\n    }\n\n    public static void main(String[] args) throws IOException {\n\n        // Comprovem els arguments\n        if (args.length!=2){\n            System.out.println(\"Nombre d'arguments incorrecte.\\n\\nSintaxi: \\n\\t java Moduls [read | write] fitxer.dat\");\n            System.exit(0);\n        }\n\n        // Defining the class\n        Moduls moduls=new Moduls();\n\n        // Depending the args, we will proceed\n        if (args[0].equals(\"read\")) \n        moduls.readFiLe(args[1]);\n        else if (args[0].equals(\"write\")) \n        moduls.writeFile(args[1]);\n        else \n        System.out.println(\"No entenc l'ordre \"+args[0]+\"\\n\");\n    }\n}\n</code></pre>"},{"location":"UD1_Files/2_Reading_and_writing_files/#16-serialitzant-objectes","title":"1.6. Serialitzant Objectes","text":"<p>Java proporciona un sistema gen\u00e8ric de serialitzaci\u00f3 d'objectes: un sistema recursiu que itera sobre cada objecte contingut en una inst\u00e0ncia, fins arribar als tipus primitius, que s'emmagatzemen com un array de bytes. A part d'aquesta informaci\u00f3 dels tipus primitius, tamb\u00e9 s'emmagatzema informaci\u00f3 addicional o metadades espec\u00edfiques de cada classe, com ara el nom o els atributs, entre d'altres. Gr\u00e0cies a aquestes metadades, que descriuen els objectes que guardem, podem automatitzar la serialitzaci\u00f3 de manera gen\u00e8rica, assegurant-nos que posteriorment podrem llegir els objectes.</p> <p>El desavantatge d'aquest m\u00e8tode \u00e9s que quan canviem la definici\u00f3 de la classe (per exemple, afegint un atribut m\u00e9s o canviant el seu tipus), les metadades es modifiquen i no podr\u00edem llegir els objectes serialitzats amb versions anteriors de la classe. A m\u00e9s, tamb\u00e9 cal tenir en compte que aquest \u00e9s un mecanisme espec\u00edfic de Java i que no podrem consultar aquests objectes des d'altres llenguatges.</p> <p>Per tot aix\u00f2, altres t\u00e8cniques s\u00f3n preferibles per a l'emmagatzematge permanent d'objectes, que veurem m\u00e9s endavant, per\u00f2 la serialitzaci\u00f3 pot ser \u00fatil per a l'emmagatzematge temporal, dins de la mateixa execuci\u00f3 de l'aplicaci\u00f3.</p> <p>Qu\u00e8 \u00e9s aix\u00f2?</p> <p>Investigaci\u00f3: intenta trobar informaci\u00f3 sobre SerialVersionUID i per a qu\u00e8 \u00e9s important.</p>"},{"location":"UD1_Files/2_Reading_and_writing_files/#161-la-interficie-serializable-i-els-decorators","title":"1.6.1. La interf\u00edcie <code>Serializable</code> i els <code>Decorators</code>","text":"<p>Si volem que una classe sigui serializable, ha de implementar la interf\u00edcie <code>Serializable</code>, la qual t\u00e9 com a \u00fanic prop\u00f2sit actuar com a marcador per indicar al JVM que la classe pot ser serialitzada, per tant, aquesta classe no tindr\u00e0 m\u00e8todes.</p> <p>Cal dir que totes les classes corresponents als tipus b\u00e0sics ja implementen la interf\u00edcie Serializable, aix\u00ed com la classe String, contenidors i Arrays. En el cas de les col\u00b7leccions, dep\u00e8n dels seus continguts, si els seus elements s\u00f3n serialitzables, la col\u00b7lecci\u00f3 tamb\u00e9 ho ser\u00e0. Si l'objecte que volem serialitzar o els seus objectes no implementen la interf\u00edcie Serializable, es llan\u00e7ar\u00e0 l'excepci\u00f3 <code>NotSerializableException</code>.</p> <p>Els decoradors <code>ObjectInputStream</code> i <code>ObjectOutputStream</code> ens ofereixen la capacitat de serialitzar qualsevol objecte deserialitzable. Per escriure un objecte, farem \u00fas del m\u00e8tode <code>writeObject</code> de <code>ObjectOutputStream</code>, i per llegir-lo farem \u00fas de <code>readObject</code> de <code>ObjectInputStream</code>.</p> <p>Ovelles amb ovelles</p> <p>Cal tenir en compte que la lectura d'objectes s'ha de fer en inst\u00e0ncies de la mateixa classe que es va guardar. En cas contrari, es llan\u00e7ar\u00e0 una excepci\u00f3 <code>ClassCastException</code>. A m\u00e9s, cal tenir el codi compilat de la classe per evitar l'excepci\u00f3 <code>ClassNotFoundException</code>.</p> <p>A m\u00e9s, <code>readObject</code> retorna un Object, i necessitem un objecte d'una classe espec\u00edfica. Per aquest motiu, cal fer una conversi\u00f3 de Object a la classe necess\u00e0ria. Els conceptes d'her\u00e8ncia s\u00f3n molt importants per garantir programes robustos.</p>"},{"location":"UD1_Files/2_Reading_and_writing_files/#162-exercici-resolt","title":"1.6.2. Exercici resolt","text":"<p>Comen\u00e7ant amb la mateixa base de la classe <code>Moduls</code> de l'exercici anterior, crearem una classe <code>Modul</code> per emmagatzemar un \u00fanic m\u00f2dul. Aquest tipus de classes es coneixen com a POJO (Plain Old Java Objects) i estan dissenyades nom\u00e9s per emmagatzemar informaci\u00f3. (Apareixer\u00e0 m\u00e9s endavant, juntament amb les classes BEAN).</p> <p>Un cop creada la classe <code>Modul</code>, escriu un programa per desar objectes directament en un fitxer. Despr\u00e9s, escriu la funci\u00f3 complement\u00e0ria per llegir tots els objectes emmagatzemats en aquest fitxer.</p> <p>Soluci\u00f3</p> Java<pre><code>/**\n    Class to storage a single module in memory\n*/\n\nclass Modul implements Serializable{\n    String nom;\n    int hores;\n    double nota;\n\n    public Modul(){\n        // Constructor buit\n    }\n\n    public Modul(String nom, int hores, double nota){\n        this.nom=nom;\n        this.hores=hores;\n        this.nota=nota;\n    }\n\n    public String getModul() {return this.nom;}\n    public int getHores() {return this.hores;}\n    public double getNota() {return this.nota;}\n} \n\n/**\n    Write and Read modules to/from file\n*/\n\npublic class Moduls2 {\n\n    // Arrays with source data\n    String[] moduls = {\"Acc\u00e9s a Dades\", \"Programaci\u00f3 de serveis i processos\", \"Desenvolupament d'interf\u00edcies\", \"Programaci\u00f3 Multim\u00e8dia i dispositiud m\u00f2bils\", \"Sistemes de Gesti\u00f3 Empresarial\", \"Empresa i iniciativa emprenedora\"};\n    int[] hores = {6, 3, 6, 5, 5, 3};\n    double[] notes = {8.45, 9.0, 8.0, 7.34, 8.2, 7.4};\n\n    public void EscriuObjecte(String nom) throws IOException {\n\n        //destination file\n        ObjectOutputStream f = new ObjectOutputStream(new FileOutputStream(nom));\n\n        Modul m; // Single object\n\n        // loop along the arrays\n        for (int i = 0; i &lt; this.moduls.length; i++) {\n            m = new Modul(this.moduls[i], this.hores[i], this.notes[i]);\n            f.writeObject(m);\n        }\n\n        // close the file\n        f.close();\n\n    }\n\n    public void LligObjecte(String nom) throws IOException, ClassNotFoundException {\n\n        // input file\n        ObjectInputStream f = new ObjectInputStream(new FileInputStream(nom));\n\n        Modul m;\n        // we don't know how many objects exists in the file.\n        try {\n            while (true) { // forever\n\n                m = (Modul) f.readObject();\n\n                // show the module\n                System.out.println(\"Modul: \" + m.getModul());\n                System.out.println(\"Hores: \" + m.getHores());\n                System.out.println(\"Nota: \" + m.getNota());\n                System.out.println();\n\n            }\n        } catch (EOFException ex) {\n            f.close();\n        }\n\n    }\n\n    public static void main(String[] args) throws IOException, ClassNotFoundException {\n\n        // test the args\n        if (args.length != 2) {\n            System.out.println(\"Nombre d'arguments incorrecte.\\n\\nSintaxi: \\n\\t java Moduls2 [ read | write ] fitxer.obj\");\n            System.exit(0);\n        }\n\n        Moduls2 moduls = new Moduls2();\n\n        // depending the args\n        if (args[0].equals(\"read\")) {\n            moduls.LligObjecte(args[1]);\n        } else if (args[0].equals(\"write\")) {\n            moduls.EscriuObjecte(args[1]);\n        } else {\n            System.out.println(\"No entenc l'ordre \" + args[0] + \"\\n\");\n        }\n\n    }\n\n}\n</code></pre> <p>Less work, but the same in the end</p> <p>You probably will think about it: If all in Java inherits from Object, an ArrayList is an Object...Can I save or load an entire ArrayList in one unique call?. Try it as an improvement of the last exercise.</p>"},{"location":"UD1_Files/3_XML_Files/","title":"1. Arxius XML","text":""},{"location":"UD1_Files/3_XML_Files/#11-perque-xml","title":"1.1. Perqu\u00e8 XML?","text":"<p>Quan volem desar dades que puguin ser llegides per diferents aplicacions i plataformes, \u00e9s millor utilitzar formats d'emmagatzematge est\u00e0ndard que m\u00faltiples aplicacions puguin entendre (portabilitat). Un cas molt espec\u00edfic s\u00f3n els llenguatges de marcatge, i el m\u00e9s conegut \u00e9s l'est\u00e0ndard XML (eXtensible Markup Language).</p> <p>Amb els documents XML, estructuram la informaci\u00f3 inserint marques o etiquetes entre la informaci\u00f3. Aquestes etiquetes tenen un inici i un final, i poden niuar-se dins d'altres, aix\u00ed com contenir informaci\u00f3 textual. Com que la informaci\u00f3 ser\u00e0 textual, no tenim el problema de la representaci\u00f3 de dades diferents, ja que qualsevol dada, de qualsevol tipus, es convertir\u00e0 en text. Per evitar tamb\u00e9 el problema dels diferents sistemes d'codificaci\u00f3 de text, XML permet incloure a l'encap\u00e7alament del document la codificaci\u00f3 utilitzada per desar el document.</p> <p>La manera de desar informaci\u00f3 en XML, de manera jer\u00e0rquica, \u00e9s molt similar a la manera com ho fan els objectes en una aplicaci\u00f3, de manera que aquests es poden traduir de manera relativament convenient en un document XML. Comencem amb el nostre exemple anterior:</p> Module Hours Qualificaci\u00f3 Acc\u00e9s a Dades 6 8.45 Programaci\u00f3 de serveis i processos 3 9.0 Desenvolupament d'interf\u00edcies 6 8.0 Programaci\u00f3 Multim\u00e8dia i dispositius m\u00f2bils 5 7.34 Sistemes de Gesti\u00f3 Empresarial 5 8.2 Empresa i iniciativa emprenedora 3 7.4 <p>pot representar-se en etiquetes <code>xml</code>:</p> XML<pre><code>&lt;curs&gt;\n    &lt;modul&gt;\n      &lt;nom&gt;Acc\u00e9s a Dades&lt;/nom&gt;\n      &lt;hores&gt;6&lt;/hores&gt;\n      &lt;qualificacio&gt;8.45&lt;/qualificacio&gt;\n    &lt;/modul&gt;\n    &lt;modul&gt;\n      &lt;nom&gt;Programaci\u00f3 de serveis i processos&lt;/nom&gt;\n      &lt;hores&gt;3&lt;/hores&gt;\n      &lt;qualificacio&gt;9.0&lt;/qualificacio&gt;\n    &lt;/modul&gt;\n    &lt;modul&gt;\n      &lt;nom&gt;Desenvolupament d'interf\u00edcies&lt;/nom&gt;\n      &lt;hores&gt;6&lt;/hores&gt;\n      &lt;qualificacio&gt;8.0&lt;/qualificacio&gt;\n    &lt;/modul&gt;\n    &lt;modul&gt;\n      &lt;nom&gt;Programaci\u00f3 Multim\u00e8dia i dispositiud m\u00f2bils&lt;/nom&gt;\n      &lt;hores&gt;5&lt;/hores&gt;\n      &lt;qualificacio&gt;7.34&lt;/qualificacio&gt;\n    &lt;/modul&gt;\n    &lt;modul&gt;\n      &lt;nom&gt;Sistemes de Gesti\u00f3 Empresarial&lt;/nom&gt;\n      &lt;hores&gt;5&lt;/hores&gt;\n      &lt;qualificacio&gt;8.2&lt;/qualificacio&gt;\n    &lt;/modul&gt;\n    &lt;modul&gt;\n      &lt;nom&gt;Empresa i iniciativa emprenedora&lt;/nom&gt;\n      &lt;hores&gt;3&lt;/hores&gt;\n      &lt;qualificacio&gt;7.4&lt;/qualificacio&gt;\n    &lt;/modul&gt;\n&lt;/curs&gt;\n</code></pre> <p>o pot ser representat amb etiquetes i atributs:</p> <p>XML<pre><code>&lt;curs&gt;\n    &lt;modul nom=\"Acc\u00e9s a Dades\" hores=\"6\" qualificacio=\"8.45\" &gt;\n    &lt;modul nom=\"Programaci\u00f3 de serveis i processos\" \"hores\"=3 qualificacio=\"9.0\" &gt;\n    &lt;modul nom =\"Desenvolupament d'interf\u00edcies\" hores=\"6\" qualificacio=\"8.0\" &gt;\n    &lt;/modul&gt;\n    &lt;modul nom=\"Programaci\u00f3 Multim\u00e8dia i dispositiud m\u00f2bils\" hores=\"5\" qualificacio=\"7,34\"&gt;\n    &lt;modul nom=\"Sistemes de Gesti\u00f3 Empresarial\" hores=\"5\" \"qualificacio\"=8.2 /&gt;\n    &lt;modul nom=\"Empresa i iniciativa emprenedora\"  hores=\"3\" qualificacio=\"7.4\" /&gt;\n    &lt;/modul&gt;\n&lt;/curs&gt;\n</code></pre> Un analitzador XML \u00e9s una classe que permet analitzar un fitxer XML i extreure informaci\u00f3 d'ell, relacionant-la segons la seva posici\u00f3 en la jerarquia. Els analitzadors, segons la seva forma de funcionar, poden ser:</p> <ul> <li>Analitzadors seq\u00fcencials o sint\u00e0ctics, que extreuen el contingut a mesura que es descobreixen les etiquetes d'obertura i tancament. S\u00f3n molt r\u00e0pids, per\u00f2 tenen el problema que cal llegir tot el document per accedir a una part espec\u00edfica. En Java hi ha el parser SAX (Simple API for XML) com a analitzador seq\u00fcencial.</li> <li>Analitzadors jer\u00e0rquics, que s\u00f3n els m\u00e9s utilitzats i que guarden totes les dades del document XML a la mem\u00f2ria, en forma d'una estructura jer\u00e0rquica (DOM o Document Object Model), sent els preferits per a aplicacions que han de llegir les dades de manera m\u00e9s cont\u00ednua.</li> </ul>"},{"location":"UD1_Files/3_XML_Files/#12-el-model-dobjectes-de-document-dom","title":"1.2. El Model d'Objectes de Document (DOM)","text":"<p>El DOM (Document Object Model) \u00e9s l'estructura especificada per la W3C on s'emmagatzema la informaci\u00f3 dels documents XML. El DOM s'ha relacionat principalment amb el m\u00f3n web, amb HTML i Javascript com a principals impulsors. En Java, el DOM s'implementa utilitzant interf\u00edcies.</p> <p>La interf\u00edcie principal del DOM a Java \u00e9s <code>Document</code>, i representa el document XML complet. Com que \u00e9s una interf\u00edcie, es pot implementar en diverses classes.</p> <p>Cal tenir en compte que...</p> <p>Una interf\u00edcie \u00e9s una mena de plantilla per construir classes i generalment est\u00e0 composta per un conjunt de declaracions de cap\u00e7alera de m\u00e8todes no implementats que especifiquen com es comporten una o m\u00e9s classes. A m\u00e9s, una classe pot implementar una o m\u00e9s interf\u00edcies. En aquest cas, la classe haur\u00e0 de declarar i definir tots els m\u00e8todes de cada una de les interf\u00edcies o declarar-se com a classe abstracta.</p> <p>Cal tenir en compte que una interf\u00edcie no s'ha de confondre amb una classe abstracta, ja que hi ha algunes difer\u00e8ncies. Per exemple, una interf\u00edcie t\u00e9 tots els m\u00e8todes abstractes, no pot declarar variables d'inst\u00e0ncia, una classe pot implementar diverses interf\u00edcies per\u00f2 no heretar de diverses superclasses, i una interf\u00edcie no ha de pert\u00e0nyer a cap jerarquia, de manera que les classes que no tenen cap relaci\u00f3 d'her\u00e8ncia poden implementar la mateixa interf\u00edcie.</p> <p>A part de <code>Document</code>, la W3C tamb\u00e9 defineix la classe abstracta <code>DocumentBuilder</code>, que permet crear el DOM a partir de l'XML. A m\u00e9s, s'especifica la classe <code>DocumentBuilderFactory</code>, que ens permet fabricar <code>DocumentBuilders</code>, ja que, al ser abstracta, no es pot instanciar directament.</p> <p>Cal dir, com a advert\u00e8ncia, que Java ofereix moltes llibreries des de les quals importar Document. Les llibreries que utilitzarem per analitzar XML seran:</p> <ul> <li>La llibreria <code>java.xml.parsers.*</code>, que oferir\u00e0 les classes <code>DocumentBuilderFactory</code> i <code>DocumentBuilder</code>, i</li> <li>La llibreria <code>org.w3c.dom.*</code> per a la classe <code>Document</code>.</li> </ul>"},{"location":"UD1_Files/3_XML_Files/#121-documentbuilder-i-documentbuilderfactory","title":"1.2.1. <code>DocumentBuilder</code> i <code>DocumentBuilderFactory</code>","text":"<p>Com s'ha dit, <code>DocumentBuilder</code> defineix una API per obtenir inst\u00e0ncies DOM d'un document XML. Per obtenir una inst\u00e0ncia de la classe, s'ha d'utilitzar la classe <code>DocumentBuilderFactory</code>, i concretament el m\u00e8tode <code>newDocumentBuilder()</code>:</p> <p>D'altra banda, per llegir i interpretar el document XML, la classe <code>DocumentBuilderFactory</code> proporciona el m\u00e8tode <code>parse()</code>, que analitza un XML indicat per un fitxer i retorna un objecte <code>Document</code>.</p> <p>Veurem tot aix\u00f2 amb un exemple. Continuem emmagatzemant dades sobre els m\u00f2duls del curs, per\u00f2 ara amb XML. El seg\u00fcent m\u00e8tode ens servir\u00e0 per obrir un document XML, analitzar-lo i retornar el DOM generat en un <code>Document</code>. El podem utilitzar en qualsevol lloc dels nostres programes, ja que la tasca \u00e9s sempre similar:</p> Java<pre><code>public Document OpenXML(String name) throws IOException,SAXException, ParserConfigurationException, FileNotFoundException {\n\n    // Create an instance of DocumentBuilderFactory\n    DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n    // Using the DocumentBuilderFactory instance we create a DocumentBuilder\n    DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n    //And we use DocumentBuilder's \"parse\" method to get the document\n    Document doc = dBuilder.parse(new File(name));\n\n    return document;\n}\n</code></pre> <p>S'ha de dir que la funci\u00f3 anterior es podria simplificar sense utilitzar les declaracions interm\u00e8dies, per\u00f2 est\u00e0 una mica ofuscada.</p> Java<pre><code>public Document OpenXML(String name) throws IOException,SAXException, ParserConfigurationException, FileNotFoundException {\n     return DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(name);\n}\n</code></pre> <p>D'altra banda, la classe <code>DocumentBuilder</code> tamb\u00e9 ens permet crear un nou DOM amb el m\u00e8tode <code>newDocument()</code>. Aix\u00f2 ens servir\u00e0 m\u00e9s endavant per emmagatzemar els nous documents XML. El procediment \u00e9s el seg\u00fcent:</p> <ul> <li>Primer de tot, hem de crear un nou DOM amb <code>newDocument()</code>.</li> <li>Afegir els elements i,</li> <li>Despr\u00e9s emmagatzemar-ho en un fitxer.</li> </ul> <p>En seccions posteriors, veurem com fer tot aix\u00f2. Per ara, ens centrarem en interpretar i llegir el DOM.</p> <p>Per a m\u00e9s informaci\u00f3, pots consultar les classes DocumentBuilder i DocumentBuilderFactory al API de OpenJDK.</p>"},{"location":"UD1_Files/3_XML_Files/#13-classes-i-metodes-de-dom","title":"1.3. Classes i M\u00e8todes de DOM","text":"<p>Fins ara hem vist com obrir i analitzar un document XML amb <code>DocumentBuilder</code> per crear un objecte de tipus <code>Document</code>. En aquesta secci\u00f3 veurem com treballar amb aquest document per accedir als diferents elements. Com sabem, el DOM t\u00e9 una estructura jer\u00e0rquica, formada per nodes. Els diferents tipus de nodes que podem trobar s\u00f3n:</p> <ul> <li><code>Document</code> \u2192 que \u00e9s el node principal i representa tot l'XML.</li> <li><code>Element</code> \u2192 que representa les diferents etiquetes (incloent l'etiqueta arrel). En altres paraules, totes les etiquetes s\u00f3n Elements, unes dins d'altres.</li> <li><code>TextElement</code> \u2192 que representa el contingut d'una etiqueta de text.</li> <li><code>Attribute</code> \u2192 que representa els atributs.</li> </ul> <p>Totes aquestes interf\u00edcies deriven de la interf\u00edcie <code>Node</code>, per tant, heretaran els seus atributs i m\u00e8todes, i a m\u00e9s, proporcionaran els seus propis atributs i m\u00e8todes.</p> <p>A continuaci\u00f3, veurem els m\u00e8todes m\u00e9s importants de cada interf\u00edcie:</p>"},{"location":"UD1_Files/3_XML_Files/#131-metodes-de-node","title":"1.3.1. M\u00e8todes de Node","text":"<p>M\u00e8todes relacionats amb l'obtenci\u00f3 d'informaci\u00f3</p> <ul> <li><code>String getNodeName()</code> \u2192 Obt\u00e9 el nom del node actual</li> <li><code>short getNodeType()</code> \u2192 Obt\u00e9 el tipus de node (ELEMENT_NODE, ATTRIBUTE_NODE, TEXT_NODE...)</li> <li><code>String getNodeValue()</code>\u2192 Obt\u00e9 el valor del node</li> <li><code>NodeList getChildNodes()</code> \u2192 Obt\u00e9 una llista amb els nodes fills</li> <li><code>Node getFirstChild()</code> \u2192 Retorna el primer fill</li> <li><code>Node getLastChild()</code> \u2192 Retorna l'\u00faltim fill</li> <li><code>NamedNodeMap getAttributes()</code> \u2192 Retorna una llista amb els atributs del node</li> <li><code>Node getParentNode()</code> \u2192 Retorna el node pare</li> <li><code>String getTextContent()</code> \u2192 Retorna el text contingut en l'element i els seus descendents</li> <li><code>boolean hasChildNodes()</code> \u2192 Retorna <code>true</code> si el node t\u00e9 algun fill</li> <li><code>boolean hasAttributes()</code> \u2192 Retorna <code>true</code> si el node t\u00e9 algun atribut</li> </ul> <p>M\u00e8todes relacionats amb l'escriptura</p> <ul> <li><code>Node appendChild(Node node)</code> \u2192 Afegeix un nou node com a \u00faltim fill.</li> <li><code>void removeChild(Node node)</code> \u2192 Elimina el node especificat dels nodes fills.</li> </ul>"},{"location":"UD1_Files/3_XML_Files/#132-metodes-de-la-interficies-element","title":"1.3.2. M\u00e8todes de la interf\u00edcies Element:","text":"<p>M\u00e8todes relacionats amb l'obtenci\u00f3 d'informaci\u00f3</p> <ul> <li><code>String getAttribute(String name)</code> \u2192 Retorna el valor de l'atribut donat pel nom.</li> <li><code>NodeList getElementsByTagName(String name)</code> \u2192 Retorna una llista de nodes fills que coincideixen amb el nom donat.</li> <li><code>boolean hasAttribute(String name)</code> \u2192 Retorna true si l'element t\u00e9 l'atribut donat.</li> </ul> <p>M\u00e8todes relacionats amb l'escriptura</p> <ul> <li><code>void setAttribute(String name, String value)</code> \u2192 Afegeix un atribut a l'element, amb el nom i valor donats.</li> <li><code>void removeAttribute(String name)</code> \u2192 Elimina l'atribut indicat pel nom.</li> </ul>"},{"location":"UD1_Files/3_XML_Files/#133-metodes-de-la-interficie-document","title":"1.3.3. M\u00e8todes de la interf\u00edcie Document:","text":"<p>M\u00e8todes relacionats amb l'obtenci\u00f3 d'informaci\u00f3</p> <ul> <li><code>Element getDocumentElement()</code> \u2192 Retorna l'element arrel del document.</li> <li><code>NodeList getElementsByTagName(String name)</code> \u2192 Retorna una llista de nodes fills que coincideixen amb el nom donat.</li> </ul> <p>M\u00e8todes relacionats amb l'escriptura</p> <ul> <li><code>Element createElement(String name)</code> \u2192 Crea un nou element amb el nom donat.</li> <li><code>Text createTextNode(String text)</code> \u2192 Crea un nou element de text.</li> <li><code>Node appendChild(Node node)</code> \u2192 Afegeix un nou node fill.</li> </ul> <p>Els objectes de tipus <code>NodeList</code>, que representen una llista de nodes, ofereixen el m\u00e8tode <code>item(int index)</code> per accedir als diferents nodes de la llista, indicant el seu ordre.</p>"},{"location":"UD1_Files/3_XML_Files/#14-lectura-de-fitxers-xml","title":"1.4. Lectura de fitxers XML","text":"<p>Anem a repassar tots els conceptes d'aquesta secci\u00f3 amb una pr\u00e0ctica. Crearem una classe que inclogui tots els m\u00e8todes necessaris per obrir, llegir, mostrar i escriure fitxers XML. Treballarem amb el document de la secci\u00f3 anterior.</p> <p>Per comen\u00e7ar a llegir el document, el primer que haurem de fer \u00e9s obtenir l'element arrel del document amb <code>getDocumentElement()</code>, que retorna un objecte de tipus <code>Element</code>. Recorda que la variable doc cont\u00e9 tot el DOM, llegit amb el m\u00e8tode explicat anteriorment:</p> Java<pre><code>Element root = doc.getDocumentElement();\n</code></pre> <p>Amb aquest element arrel, ja podem mostrar tot el contingut amb <code>getTextContent()</code>. Es mostrar\u00e0 a la pantalla en format de text, nom\u00e9s s'imprimir\u00e0:</p> Java<pre><code>System.out.println(root.getTextContent());\n</code></pre> <p>Per\u00f2 el que ens interessa \u00e9s rec\u00f3rrer tot el DOM i accedir als seus elements. Per fer-ho, a partir d'aquest element arrel, seguirem els seg\u00fcents passos:</p> <ol> <li>Cerquem tots els tags <code>&lt;modul&gt;</code> amb <code>getElementsByTagName</code>. Aquest m\u00e8tode ens retorna una llista de nodes (objecte de tipus <code>NodeList</code>).</li> <li>Ser\u00e0 necessari rec\u00f3rrer la llista de nodes (<code>NodeList</code>) per accedir a cada element. Per fer-ho, cal utilitzar el m\u00e8tode <code>item(int index)</code>, que retornar\u00e0 un element de tipus <code>Node</code>, i que s'ha de convertir expl\u00edcitament a <code>Element</code> amb una operaci\u00f3 de cast.</li> <li>Per a cada element, accedirem al nom del node per mostrar el nom i l'ordre, utilitzant <code>getNodeName()</code>.</li> <li>Cerquem les diferents etiquetes trobades dins de cada m\u00f2dul ('nom', 'hores' i 'qualificacio') amb <code>getElementsByTagName()</code>. Aquest m\u00e8tode ens tornar\u00e0 una NodeList per a cada tipus d'etiqueta. Com nom\u00e9s tindrem un element, nom\u00e9s cal accedir a l'element \u00fanic, representat per <code>item(0)</code>.</li> <li>Cal destacar que amb el que hem vist fins ara tindrem la primera (i \u00fanica) etiqueta 'nom', 'hores' o 'qualificacio' del m\u00f2dul, per\u00f2 encara no estem en el contingut, ja que aix\u00f2 \u00e9s un element de tipus <code>TEXT_NODE</code>. Per accedir-hi, haurem d'accedir al primer fill de l'etiqueta (<code>getFirstChild()</code>) i obtenir el seu valor amb <code>getNodeValue()</code>.</li> </ol> Java<pre><code>    // We will get a list of nodes (Step 1)\n    NodeList modules = root.getElementsByTagName(\"modul\");\n\n    // For each node (Step 2)\n    for (int i = 0; i &lt; modules.getLength(); i++) {\n        Element el = (Element) modules.item(i);\n\n        // Display the node name (Step 3)\n        System.out.println(el.getNodeName() + \" \" + (i + 1));\n\n        // And we show the value of the different tags \n        System.out.println(\"Nom: \" + el.getElementsByTagName(\"nom\").item(0).getFirstChild().getNodeValue());\n        System.out.println(\"Hores: \" + el.getElementsByTagName(\"hores\").item(0).getFirstChild().getNodeValue());\n        System.out.println(\"Qualificaci\u00f3: \" + el.getElementsByTagName(\"qualificacio\").item(0).getFirstChild().getNodeValue());\n        System.out.println();\n    }\n}\n</code></pre>"},{"location":"UD1_Files/3_XML_Files/#15-escriure-fitxers-xml","title":"1.5. Escriure fitxers XML","text":"<p>Ara anem a la part d'escriptura dels documents XML. Per aix\u00f2, partirem d'un fitxer que ja cont\u00e9 la informaci\u00f3 en format binari dels m\u00f2duls (per exemple, de la secci\u00f3 anterior), el llegirem i importarem la seva informaci\u00f3 en format XML.</p> <p>El primer que hem de fer \u00e9s llegir el fitxer d'objectes utilitzant un <code>ObjectInputStream</code>:</p> Java<pre><code>ObjectInputStream f = new ObjectInputStream(new FileInputStream(file));\n</code></pre> <p>I crearem un document buit amb les classes <code>DocumentBuilder</code> i <code>DocumentBuilderFactory</code>:</p> Java<pre><code>Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n</code></pre> <p>Un cop tenim el document buit, creem l'element arrel (curs) i l'afegim al document:</p> Java<pre><code>Element root = doc.createElement(\"curso\");\ndoc.appendChild(root);\n</code></pre> <p>Recorda que accedirem al fitxer d'objectes, aix\u00ed que haurem de saber exactament com \u00e9s la classe que volem llegir i accedir als m\u00e8todes corresponents per obtenir informaci\u00f3 sobre ella. Per aix\u00f2, primer, has de definir un objecte de tipus <code>Modul</code>, i llegirem el fitxer d'objectes amb el m\u00e8tode <code>readObject</code> de <code>File</code>. Un cop h\u00e0gim llegit un objecte, crearem l'etiqueta que engloba cadascun d'ells: l'etiqueta <code>modul</code>:</p> Java<pre><code>Modul m = (Modul) f.readObject();\nElement modul = doc.createElement(\"modul\");\n</code></pre> <p>And inside it, as we extract the different properties of the Modul object, we will create child nodes and add them to the module. For example, for the module name:</p> Java<pre><code>Element name = doc.createElement(\"nom\");\nname.appendChild(doc.createTextNode(m.getNom()));\nmodule.appendChild(name);\n</code></pre> <p>Com podem veure, hem creat un objecte de tipus Element amb l'etiqueta 'nom', i hem afegit com a fill un node de tipus text (TEXT_NODE), que hem extret directament de l'objecte <code>Modul m</code> amb la seva pr\u00f2pia funci\u00f3 <code>getModul()</code>. A m\u00e9s, hem afegit aquesta etiqueta a l'etiqueta <code>&lt;modul&gt;</code>, amb <code>appendChild</code>.</p> <p>Haurem de fer el mateix per a les hores de cada m\u00f2dul i la qualificaci\u00f3, per\u00f2 per aix\u00f2, haurem de tenir en compte que els m\u00e8todes getHores i getNota no retornen una cadena de text, sin\u00f3 un enter i un decimal, de manera que hauran de ser convertits a text:</p> Java<pre><code>Element hours = doc.createElement(\"hores\");\nhours.appendChild(doc.createTextNode(Integer.toString(m.getHores())));\nmodule.appendChild(hours);\n\nElement qualification = doc.createElement(\"qualificacio\");\nqualification.appendChild(doc.createTextNode(Double.toString(m.getNote())));\nmodule.appendChild(grade);\n</code></pre> <p>Posarem tot aquest procediment dins d'un bucle que recorrer\u00e0 tot el fitxer d'objectes. Un cop h\u00e0gim llegit cada un dels m\u00f2duls, haurem d'afegir-los a l'element arrel amb:</p> Java<pre><code>root.appendChild(module);\n</code></pre> <p>And we will already have our XML document at the root. Now we would have to convert this object of type <code>Element</code> into a text string in order to be able to write it to the disk. For this, we will make use of the <code>Transformer</code> utility.</p>"},{"location":"UD1_Files/3_XML_Files/#151-transformer","title":"1.5.1. Transformer","text":"<p>Java ens ofereix l'utilitat <code>Transformer</code> per convertir informaci\u00f3 entre diferents formats jer\u00e0rquics, com ara l'objecte Document que cont\u00e9 el DOM del nostre XML, a un fitxer de text XML.</p> <p>La classe <code>Transformer</code>, com <code>DocumentBuilder</code>, tamb\u00e9 \u00e9s una classe abstracta, per la qual cosa tamb\u00e9 requereix una f\u00e0brica per ser instanciada. La classe Transformer treballa amb dos tipus d'adaptadors. Els adaptadors s\u00f3n classes que fan compatibles diferents jerarquies. Aquests adaptadors s\u00f3n <code>Source</code> i <code>Result</code>. Les classes que implementen aquests adaptadors seran les encarregades de fer compatibles els diferents tipus de contenidors amb el que requereix la classe Transformer. Aix\u00ed, i per aclarir-ho, tenim les classes <code>DOMSource</code>, <code>SAXSource</code> o <code>StreamSource</code>, que s\u00f3n adaptadors del contenidor d'origen de la informaci\u00f3 per a DOM, SAX o Stream; i <code>DOMResult</code>, <code>SAXResult</code> i <code>StreamResult</code> com a adaptadors equivalents per al contenidor de destinaci\u00f3.</p> <p>En el nostre cas, ja que tenim un DOM i volem convertir-lo en un Stream, necessitarem un <code>DomSource</code> i un <code>StreamResult</code>. Veurem el codi necessari per fer-ho:</p> Java<pre><code>Transformer trans = TransformerFactory.newInstance().newTransformer();\nDOMSource source = new DOMSource(doc);\nStreamResult result = new StreamResult(new FileOutputStream(file+\".xml\"));\n</code></pre> <p>El primer que hem fet \u00e9s crear un objecte de tipus <code>Transformer</code> amb el m\u00e8tode <code>newTransformer()</code> d'una inst\u00e0ncia (newInstance()) de la f\u00e0brica de Transformers TransformerFactory. A continuaci\u00f3, hem definit la font (source) i el resultat (resultat) per a la transformaci\u00f3, sent la font un DomSource creat a partir del doc que cont\u00e9 el nostre document, i el resultat un StreamResult, que escriur\u00e0 el flux al disc a trav\u00e9s d'un FileOutputStream.</p> <p>Finalment, fem la transformaci\u00f3 d'un element a un altre, que generar\u00e0 autom\u00e0ticament el fitxer XML de sortida:</p> Java<pre><code>trans.transform(source, result);\n</code></pre>"},{"location":"UD1_Files/3_XML_Files/#16-tecniques-avancades-vinculacio-xml","title":"1.6. T\u00e8cniques avan\u00e7ades: vinculaci\u00f3 XML","text":"<p>La t\u00e8cnica de vinculaci\u00f3 consisteix en generar classes Java amb formats espec\u00edfics, com ara XML, de manera que cada etiqueta o atribut XML correspongui a una propietat d'una determinada classe. Aquesta correspond\u00e8ncia s'anomena mapeig.</p> <p>En Java, hi ha diferents llibreries per a la vinculaci\u00f3 o mapeig: JAXB, JuBX, XMLBinding, etc. JAXB (Java Architecture for XML Binding) \u00e9s una potent llibreria que s'ha incl\u00f2s en l'est\u00e0ndard des de JDK 6, per\u00f2 s'ha eliminat a la versi\u00f3 11 i es suggereix incloure-la com a paquet extern. JAXB fa servir anotacions per obtenir la informaci\u00f3 necess\u00e0ria per al mapeig de la vinculaci\u00f3. Les anotacions s\u00f3n indicacions especials de Java que permeten associar informaci\u00f3 i funcionalitat als objectes, sense interferir en l'estructura del model de dades. Les anotacions es poden associar amb un paquet, una classe, un atribut o un par\u00e0metre, i es declaren amb el s\u00edmbol <code>@</code> davant del nom de l'anotaci\u00f3. Quan el compilador detecta una anotaci\u00f3, crea una inst\u00e0ncia i l'injecta a l'element afectat, sense interferir en la classe mateixa. Quan una aplicaci\u00f3 necessita la informaci\u00f3 de les anotacions, pot obtenir la inst\u00e0ncia injectada.</p> <p>Per exemple, a la classe <code>Modul</code> que hav\u00edem definit, far\u00edem servir l'anotaci\u00f3 <code>@XmlRootElement</code> per indicar l'element arrel del m\u00f2dul, i les anotacions <code>@XmlElement</code> per indicar que els setters de la classe tamb\u00e9 escriuran elements XML.</p> Java<pre><code>@XmlRootElement\nclass Modul {\n\n    String nom;\n    int hores;\n    double nota;\n\n    public String getNom() { return nom; }\n    @XmlElement\n    public void setNom(String nom) { this.nom = nom; }\n\n\n    public int getHores() { return hores; }\n    @XmlElement\n    public void setHores(int hores) { this.hores = hores; }\n\n    public double getNota() { return nota; }\n    @XmlElement\n    public void setNota(double nota) { this.nota = nota;}\n\n\n}\n</code></pre> <p>Amb aix\u00f2 tindr\u00edem nom\u00e9s la classe amb les anotacions preparades per desar un m\u00f2dul com a document XML. Per desar tota la jerarquia haur\u00edem de crear la classe <code>Curs</code>, que contindria un <code>ArrayList</code> de m\u00f2duls.</p> <p>Pel que fa a aquest curs, no aprofundirem m\u00e9s en aquesta t\u00e8cnica, ja que per als nostres prop\u00f2sits, l'an\u00e0lisi XML que hem vist a les seccions anteriors \u00e9s suficient.</p> <p>Cada vegada m\u00e9s</p> <p>Utilitzarem moltes anotacions en aquest curs, mantingueu la calma...</p>"},{"location":"UD1_Files/4_JSON_Files/","title":"1. Arxius JSON","text":"<p>JSON \u00e9s un altre format de text lleuger per a l'intercanvi de dades. JSON significa JavaScript Object Notation i \u00e9s un subconjunt de la notaci\u00f3 literal d'objectes del llenguatge, que s'ha adoptat juntament amb XML com un dels principals est\u00e0ndards per a l'intercanvi i emmagatzematge de dades.</p> <p>Una de les avantatges de JSON respecte a XML \u00e9s la facilitat d'escriure analitzadors, per\u00f2 el que \u00e9s m\u00e9s important \u00e9s que expressa la mateixa cosa que XML per\u00f2 d'una manera molt m\u00e9s concreta i concisa, per la qual cosa s'utilitza habitualment en entorns on el flux de dades \u00e9s important, com \u00e9s el cas dels servidors de Google, Yahoo, etc., que atenen milions d'usuaris.</p>"},{"location":"UD1_Files/4_JSON_Files/#11-format-json","title":"1.1. Format JSON","text":"<p>La especificaci\u00f3 completa es pot veure aqu\u00ed</p> <p>Els tipus de dades que podem representar en JSON s\u00f3n:</p> <ul> <li>Nombres, tant enters com decimals.</li> <li>Cadenes de text, expressades entre cometes i amb la possibilitat d'incloure seq\u00fc\u00e8ncies d'escapament.</li> <li>Booleans, per representar els valors <code>true</code> i <code>false</code>.</li> <li>Null, per representar el valor <code>null</code>.</li> <li>Array, per representar llistes de zero o m\u00e9s valors, de qualsevol tipus, tancades entre claud\u00e0tors i separades per comes.</li> <li>Objectes, com a col\u00b7leccions de parells <code>&lt;clau&gt;:&lt;valor&gt;</code>, separats per comes i entre claus, i de qualsevol tipus de valor.</li> </ul> <p>Ho veurem millor amb un exemple ben conegut: el dels m\u00f2duls amb els quals estem treballant:</p> JSON<pre><code>{\n  \"curs\": [\n        {\n          \"nom\": \"Acc\u00e9s a Dades\",\n          \"hores\": 6,\n          \"qualificacio\":  8.45\n        },\n        {\n          \"nom\": \"Programaci\u00f3 de serveis i processos\",\n          \"hores\": 3,\n          \"qualificacio\": 9.0\n        },\n        {\n          \"nom\": \"Desenvolupament d'interf\u00edcies\",\n          \"hores\": 6,\n          \"qualificacio\": 8.0\n        },\n        {\n          \"nom\": \"Programaci\u00f3 Multim\u00e8dia i dispositius m\u00f2bils\",\n          \"hores\": 5,\n          \"qualificacio\": 7.34\n        },\n        {\n          \"nom\": \"Sistemes de Gesti\u00f3 Empresarial\",\n          \"hores\": 5,\n          \"qualificacio\": 8.2\n        },\n        {\n          \"nom\": \"Empresa i iniciativa emprenedora\",\n          \"hores\": 3,\n          \"qualificacio\": 7.4\n        }\n      ]\n}\n</code></pre> <p>Veurem com <code>curs</code> \u00e9s un array o una llista de m\u00f2duls (encara que ara no utilitzem l'etiqueta \"modul\"), que en aquest cas s\u00f3n objectes amb tres elements: el nom, que \u00e9s una cadena de car\u00e0cters, les hores, que \u00e9s un enter, i la qualificaci\u00f3, que es representa com un nombre decimal. Cal destacar que, com en XML, tamb\u00e9 necessitem un objecte arrel, en aquest cas l'element \"curs\".</p> <p>Internet est\u00e0 ple de serveis que ofereixen informaci\u00f3 en format JSON. Per exemple, podeu visitar:</p> <ul> <li>https://arkhamdb.com/api/public/card/01001</li> <li>https://swapi.dev/api/films/1/</li> <li>http://hp-api.herokuapp.com/api/characters</li> </ul> <p>Hi ha una \u00e0mplia gamma de llibreries de Java per manipular documents JSON (GSON, Jackson, JSON.simple...). En el nostre cas, utilitzarem la llibreria <code>org.json</code>, que podem consultar al repositori Maven: https://mvnrepository.com/artifact/org.json/json</p> <p>A la seg\u00fcent secci\u00f3 comentarem la funcionalitat de la llibreria, i en un document adjunt, veurem com incorporar-la als nostres projectes mitjan\u00e7ant el gestor de depend\u00e8ncies Gradle.</p>"},{"location":"UD1_Files/4_JSON_Files/#12-orgjson","title":"1.2. <code>org.JSON</code>","text":"<p>La biblioteca proporciona un conjunt de classes per analitzar documents JSON en Java, aix\u00ed com convertidors entre JSON i XML. Entre les classes que ofereix, podr\u00edem destacar:</p> <ul> <li><code>JSONObject</code> \u2192 Emmagatzema parells clau-valor de forma desordenada. Els valors poden ser Boolean, JSONArray, Number, String, JSONObject i <code>NULL</code>. Els constructors prenen diferents representacions (String, mapes, beans) i els emmagatzemen com un conjunt d'elements clau-valor.</li> <li><code>JSONTokener</code> \u2192 Analitza una cadena JSON i s'utilitza internament per JSONObject i altres classes per analitzar cadenes JSON.</li> <li><code>JSONArray</code> \u2192 Emmagatzema una seq\u00fc\u00e8ncia de valors i representa un array JSON.</li> <li><code>JSONWriter</code> \u2192 Proporciona una forma de produir text JSON. T\u00e9 un m\u00e8tode <code>append(String)</code> que afegeix m\u00e9s text a un objecte JSON de tipus text, a m\u00e9s dels m\u00e8todes <code>key(String)</code> i <code>value(String)</code> per afegir claus i valors a una cadena JSON. La classe tamb\u00e9 permet escriure un array.</li> </ul>"},{"location":"UD1_Files/4_JSON_Files/#13-creacio-de-fitxers-json","title":"1.3. Creaci\u00f3 de fitxers JSON","text":"<p>Els nostres exemples es basen en les dades dels m\u00f2duls de DAM vistos a les seccions anteriors. Considera aquest bloc de codi com a punt de partida on es crea un array <code>Curs</code> i s'omple amb m\u00f2duls:</p> Java<pre><code>private void creaCurs() {    \n    // Aquest m\u00e8tode inicializa l'objecte \"Curs\" de la classe JSONLib\n    // que no \u00e9s m\u00e9s que un vector de m\u00f2duls\n\n    // Definim els vectors per inicialitzar dades\n    String[] moduls={\"Acc\u00e9s a Dades\", \"Programaci\u00f3 de serveis i processos\", \"Desenvolupament d'interf\u00edcies\", \"Programaci\u00f3 Multim\u00e8dia i dispositiud m\u00f2bils\", \"Sistemes de Gesti\u00f3 Empresarial\", \"Empresa i iniciativa emprenedora\"};\n    int[]  hores={6, 3, 6, 5, 5, 3};\n    double[] notes={8.45, 9.0, 8.0, 7.34, 8.2, 7.4};\n\n    // Recorrem els vectors, creant els objectes\n    // de tipus Modul i guardant-los en Curs\n    for (int i=0;i&lt;moduls.length;i++){\n        Modul m = new Modul(moduls[i], hores[i], notes[i]);\n        this.Curs.add(m);\n    }\n}\n</code></pre> <p>Per crear el fitxer JSON complet, hem de crear JSON individuals que representin cada objecte. A causa que aquest objecte obt\u00e9 la informaci\u00f3 dels objectes, \u00e9s una bona idea crear m\u00e8todes dins de l'objecte del m\u00f2dul per obtenir la representaci\u00f3 JSON de cada objecte:</p> Java<pre><code>public JSONObject getModulJSON(){\n    JSONObject modul = new JSONObject();\n\n    modul.put(\"nom\", this.nom);        \n    modul.put(\"hores\", this.hores);\n    modul.put(\"nota\",  this.nota);\n\n    // Si volguerem afegir un element nul, \n    // hauriem de fer:\n    // modul.put(\"atribut\", JSONObject.NULL);\n\n    return modul;\n\n};\n</code></pre> <p>Un cop resolt el JSON individual, hem de crear el JSON principal, aquell que cont\u00e9 tots els m\u00f2duls. \u00c9s f\u00e0cil de suposar que l'element principal ser\u00e0 un array, que contindr\u00e0 tots els objectes de m\u00f2dul a l'interior.</p> Java<pre><code>private JSONObject creaJSON() {\n\n        // root element \"Curs\"\n        JSONObject curs = new JSONObject();\n\n        // who is a JSONArray\n        JSONArray jsarray = new JSONArray();\n\n        // we populate the array with individual modules\n        for (Modul m : this.Curs) {\n            JSONObject modul_json = m.getModulJSON();\n            jsarray.put(modul_json);\n        }\n\n        // Create the curs element with the array\n        curs.put(\"curs\", jsarray);\n\n        return (curs);\n    }\n</code></pre> <p>Finalment, necessitem guardar-ho en un fitxer de text al disc. Aquest bloc de codi emmagatzema un JSONObject utilitzant un FileWriter amb una indentaci\u00f3 espec\u00edfica:</p> Java<pre><code>private void escriuJSON(String filename, JSONObject jso){\n\n    try {\n        FileWriter file = new FileWriter(filename);\n        file.write(jso.toString(4)); // 4 s\u00f3n els espais d'indentaci\u00f3\n        file.close();\n\n    } catch (IOException e) {\n        System.out.println(\"Error, no es pot crear el fitxer \"+filename);\n    }\n}\n</code></pre>"},{"location":"UD1_Files/4_JSON_Files/#14-lectura-de-fitxers-json","title":"1.4. Lectura de fitxers JSON","text":"<p>Per tal de llegir fitxers JSON, hem de dividir la tasca en dues parts. En primer lloc, i molt senzill, \u00e9s llegir del fitxer a una cadena de text i cridar al constructor de JSONObject amb aquesta cadena. Despr\u00e9s, hem de processar-la.</p> Java<pre><code>private JSONObject LligJSON(String filename){\n    try {\n        // Amb FileReader llegirem car\u00e0cter a \n        // car\u00e0cter el fitxer i l'afegim al string myJson\n        FileReader file = new FileReader(filename); \n        String myJson=\"\";\n\n        int i;\n        while ((i=file.read()) != -1) \n            myJson=myJson+((char) i);\n\n        //System.out.println(myJson);\n        file.close();\n\n        // I fem \u00fas del constructor de JSONObject\n        // al que li passem un string amb el JSON:\n        return (new JSONObject(myJson));\n\n\n    } catch (Exception e)\n    {\n        System.out.println(\"Error llegint el fitxer\");\n        return null;\n    }\n\n}\n</code></pre> <p>Un cop tenim el principal <code>JSONObject</code>, necessitem recuperar el <code>JSONArray</code> (anomenat curs). Podem utilitzar el m\u00e8tode length() per rec\u00f3rrer tots els m\u00f2duls amb un bucle <code>for</code>. Per obtenir els objectes individuals d'un JSONObject, s'utilitza el m\u00e8tode <code>get(string label)</code>, que retorna l'objecte etiquetat. Cal tenir cura del tipus i fer conversions quan sigui necessari. En l'exemple anterior, nom\u00e9s mostrem el JSON, en lloc de crear objectes a la mem\u00f2ria.</p> Java<pre><code>private void MostraJson(JSONObject json){\n\n    // amb el m\u00e8tode getJSONArray obtenim el primer\n    // element \"curs\", que era una llista\n    JSONArray jsa=json.getJSONArray(\"curs\");\n\n    // I ara recorrem aquesta llista:\n    for (int i = 0; i &lt; jsa.length(); i++) {\n        // Agafem cada element de l'array amb \"get\"\n        JSONObject modul=(JSONObject)jsa.get(i);\n        // Amb el get anterior tindrem objectes JSON \n        // de m\u00f2duls, tipus:\n        // {\"nom\": \"Modul\", \"hores\": hores, \"nota\": nota }\n        // Als valors d'aquests parells tamb\u00e9 accedirem amb get:\n        System.out.println(\"Modul: \"+ modul.get(\"nom\"));\n        System.out.println(\"Hores: \"+ modul.get(\"hores\"));\n\n        System.out.println(\"Nota: \"+modul.get(\"nota\"));\n\n        /*\n        En esta funci\u00f3 escrivim els objectes JSON. Si volgu\u00e9rem\n        crear de nou l'estructura d'objectes, crear\u00edem cadascun \n        dels m\u00f2duls amb:\n            Modul m=new Modul(modul.get(\"nom\"), modul.get(\"hores\"), modul.get(\"nota\"));\n        */\n    }\n}\n</code></pre>"},{"location":"UD1_Files/5_CSV/","title":"5. Arxius separats per comes. CSV","text":""},{"location":"UD1_Files/5_CSV/#1-arxius-csv","title":"1. Arxius CSV","text":"<p>Un fitxer de valors separats per comes (CSV) \u00e9s un fitxer de text est\u00e0ndard que utilitza una coma (<code>,</code>) per separar els valors. Cada l\u00ednia del fitxer consisteix en un o m\u00e9s camps separats per comes. Cada camp pot o no estar tancat entre cometes dobles. A m\u00e9s, diversos formats utilitzen diferents car\u00e0cters com a separador, com el punt i coma (<code>;</code>) o el s\u00edmbol de numeral (<code>#</code>). </p> <p>El RFC 4180 defineix el format o les definicions d'un fitxer CSV o fitxer de text/csv.</p> <p>El format CSV \u00e9s \u00fatil per coses com:</p> <ol> <li>Senzill d'implementar i de llegir, a m\u00e9s de compatibilitat entre plataformes. Aix\u00f2 \u00e9s degut a que son fitxer de text pla.</li> <li>Compatibilitat: programes com Excel i Google Sheets permeten la manipulaci\u00f3 d'aquest fitxer. Adem\u00e9s la majoria de llenguatges moderns incorporen llibreries de manipulaci\u00f3 d'aquest format</li> <li>Ocupa menys espai que els seus respectius JSON o CSV, degut a que les etiquetes sols apareixen un cop, en la linia de cap\u00e7alera. S'ha convertit en l'est\u00e0ndar de facte (no imposat per ning\u00fa, sin\u00f2 per la pr\u00f2pia comunitat) per a representar conjunts de dades per a IA i Big Data</li> </ol> El CSV \u00e9s molt \u00fatil si les dades son simples i no son estructurades. JsonXMLCSV JSON<pre><code>{\"curs\": [\n{\n    \"hores\": 6,\n    \"nom\": \"Acc\u00e9s a Dades\",\n    \"nota\": 8.45\n},\n{\n    \"hores\": 3,\n    \"nom\": \"Programaci\u00f3 de serveis i processos\",\n    \"nota\": 9\n},\n{\n    \"hores\": 6,\n    \"nom\": \"Desenvolupament d'interf\u00edcies\",\n    \"nota\": 8\n},\n{\n    \"hores\": 5,\n    \"nom\": \"Programaci\u00f3 Multim\u00e8dia i dispositiud m\u00f2bils\",\n    \"nota\": 7.34\n},\n{\n    \"hores\": 5,\n    \"nom\": \"Sistemes de Gesti\u00f3 Empresarial\",\n    \"nota\": 8.2\n},\n{\n    \"hores\": 3,\n    \"nom\": \"Empresa i iniciativa emprenedora\",\n    \"nota\": 7.4\n}\n]}\n</code></pre> XML<pre><code>&lt;curs&gt;\n    &lt;modul&gt;\n        &lt;nom&gt;Acc\u00e9s a Dades&lt;/nom&gt;\n        &lt;hores&gt;6&lt;/hores&gt;\n        &lt;qualificacio&gt;8.45&lt;/qualificacio&gt;\n    &lt;/modul&gt;\n    &lt;modul&gt;\n        &lt;nom&gt;Programaci\u00f3 de serveis i processos&lt;/nom&gt;\n        &lt;hores&gt;3&lt;/hores&gt;\n        &lt;qualificacio&gt;9.0&lt;/qualificacio&gt;\n    &lt;/modul&gt;\n    &lt;modul&gt;\n        &lt;nom&gt;Desenvolupament d'interf\u00edcies&lt;/nom&gt;\n        &lt;hores&gt;6&lt;/hores&gt;\n        &lt;qualificacio&gt;8.0&lt;/qualificacio&gt;\n    &lt;/modul&gt;\n    &lt;modul&gt;\n        &lt;nom&gt;Programaci\u00f3 Multim\u00e8dia i dispositiud m\u00f2bils&lt;/nom&gt;\n        &lt;hores&gt;5&lt;/hores&gt;\n        &lt;qualificacio&gt;7.34&lt;/qualificacio&gt;\n    &lt;/modul&gt;\n    &lt;modul&gt;\n        &lt;nom&gt;Sistemes de Gesti\u00f3 Empresarial&lt;/nom&gt;\n        &lt;hores&gt;5&lt;/hores&gt;\n        &lt;qualificacio&gt;8.2&lt;/qualificacio&gt;\n    &lt;/modul&gt;\n    &lt;modul&gt;\n        &lt;nom&gt;Empresa i iniciativa emprenedora&lt;/nom&gt;\n        &lt;hores&gt;3&lt;/hores&gt;\n        &lt;qualificacio&gt;7.4&lt;/qualificacio&gt;\n    &lt;/modul&gt;\n&lt;/curs&gt;\n</code></pre> Text Only<pre><code>Nom,Hores,Nota\nAcc\u00e9s a Dades,6,8.449999809265137\nProgramaci\u00f3 de serveis i processos,3,9.0\nDesenvolupament d'interf\u00edcies,6,8.0\nProgramaci\u00f3 Multim\u00e8dia i dispositiud m\u00f2bils,5,7.340000152587891\nSistemes de Gesti\u00f3 Empresarial,5,8.199999809265137\nEmpresa i iniciativa emprenedora,3,7.400000095367432\n</code></pre> El CSV no \u00e9s adequat en dades estructurades JSONXMLCSV JSON<pre><code>{\n\"persona\": {\n    \"nom\": \"Joan\",\n    \"edat\": 30,\n    \"adre\u00e7a\": {\n    \"carrer\": \"Carrer Gran\",\n    \"ciutat\": \"Barcelona\",\n    \"codi_postal\": \"08001\"\n    }\n},\n\"hobbies\": [\"lectura\", \"escalada\", \"viatjar\"],\n\"contactes\": [\n    {\n    \"nom\": \"Marta\",\n    \"telefon\": \"123456789\",\n    \"relacio\": \"amic\"\n    },\n    {\n    \"nom\": \"Pau\",\n    \"telefon\": \"987654321\",\n    \"relacio\": \"company\"\n    }\n]\n}\n</code></pre> XML<pre><code>&lt;persona&gt;\n    &lt;nom&gt;Joan&lt;/nom&gt;\n    &lt;edat&gt;30&lt;/edat&gt;\n    &lt;adre\u00e7a codi_postal=\"08001\"&gt;\n        &lt;carrer&gt;Carrer Gran&lt;/carrer&gt;\n        &lt;ciutat&gt;Barcelona&lt;/ciutat&gt;\n    &lt;/adre\u00e7a&gt;\n    &lt;hobbies&gt;\n        &lt;hobby&gt;lectura&lt;/hobby&gt;\n        &lt;hobby&gt;escalada&lt;/hobby&gt;\n        &lt;hobby&gt;viatjar&lt;/hobby&gt;\n    &lt;/hobbies&gt;\n    &lt;contactes&gt;\n        &lt;contacte relacio=\"amic\"&gt;\n            &lt;nom&gt;Marta&lt;/nom&gt;\n            &lt;telefon&gt;123456789&lt;/telefon&gt;\n        &lt;/contacte&gt;\n        &lt;contacte relacio=\"company\"&gt;\n            &lt;nom&gt;Pau&lt;/nom&gt;\n            &lt;telefon&gt;987654321&lt;/telefon&gt;\n        &lt;/contacte&gt;\n    &lt;/contactes&gt;\n&lt;/persona&gt;\n</code></pre> <p>Text Only<pre><code>nom,edat,carrer,ciutat,codi_postal,hobby,relacio_contacte,nom_contacte,telefon_contacte\nJoan,30,Carrer Gran,Barcelona,08001,lectura,,,\nJoan,30,Carrer Gran,Barcelona,08001,escalada,,,\nJoan,30,Carrer Gran,Barcelona,08001,viatjar,,,\nJoan,30,Carrer Gran,Barcelona,08001,,amic,Marta,123456789\nJoan,30,Carrer Gran,Barcelona,08001,,company,Pau,987654321\n</code></pre> Hem aplanat les dades, cosa que porta molta redund\u00e0ncia i poca claredat</p>"},{"location":"UD1_Files/5_CSV/#2-separador","title":"2. Separador","text":"<p>En cas que el s\u00edmbol utilitzat com a separador aparegui dins dels valors, \u00e9s una bona idea tancar el contingut entre cometes. Es pot veure un exemple de fitxer CSV aqu\u00ed:</p> Text Only<pre><code>Chevrolet Chevelle Concours (sw);0;8;350.0;165.0;4142.;11.5;70;US\nFord Torino (sw);0;8;351.0;153.0;4034.;11.0;70;US\nPlymouth Satellite (sw);0;8;383.0;175.0;4166.;10.5;70;US\nAMC Rebel SST (sw);0;8;360.0;175.0;3850.;11.0;70;US\nDodge Challenger SE;15.0;8;383.0;170.0;3563.;10.0;70;US\nPlymouth Cuda 340;14.0;8;340.0;160.0;3609.;8.0;70;US\nFord Mustang Boss 302;0;8;302.0;140.0;3353.;8.0;70;US\n</code></pre>"},{"location":"UD1_Files/5_CSV/#3-processament","title":"3. Processament","text":"<p>La manera de processar un fitxer CSV en Java \u00e9s:</p> <ol> <li>Obrir el fitxer com a fitxer de text per a la lectura. Hem de llegir l\u00ednia per l\u00ednia, ja que cada l\u00ednia \u00e9s un registre. Llegir una l\u00ednia en una variable de tipus <code>String</code>.</li> <li>Processar els registres individuals:<ol> <li>Podem separar cada camp. Una bona opci\u00f3 \u00e9s utilitzar el m\u00e8tode <code>split(char)</code> de la classe String. Obtinguem un array de cadenes amb els valors dels camps individuals.</li> <li>Processar cada valor de camp segons les necessitats.</li> </ol> </li> </ol> <p>Atenci\u00f3</p> <p>\u00c9s una bona idea comen\u00e7ar a utilitzar les classes abstractes <code>Files</code> i <code>Paths</code>. Aquestes classes milloren l'\u00fas de la classe File i les seves classes derivades, oferint m\u00e8todes \u00fatils que ens permeten realitzar operacions r\u00e0pides amb menys l\u00ednies de codi. Per exemple, la seg\u00fcent l\u00ednia, a partir del <code>filename</code>, l'obre i despr\u00e9s llegeix tot el fitxer, retornant una llista amb les l\u00ednies separades en cada element de la col\u00b7lecci\u00f3.</p> Java<pre><code>List&lt;String&gt; lines=Files.readAllLines(Paths.get(filename));\n</code></pre> <p>M\u00e9s informaci\u00f3 a:</p> Text Only<pre><code>- [Files](https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/nio/file/Files.html)\n- [Paths](https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/nio/file/Paths.html)\n</code></pre>"},{"location":"UD1_Files/5_CSV/#4-exercici-proposat","title":"4. Exercici proposat","text":"<p>A partir de la classe m\u00f2dul vista anteriorment:</p> <ol> <li>Afig un constructor que a partir de una l\u00ednia del CSV cree el objecte m\u00f2dul</li> <li>Afig un m\u00e8tode a la cl\u00e0sseque convertisca el objecte en un l\u00ednia CSV</li> <li>Crea un func\u00edo que guarda tot el array de curs a un arxiu CSV</li> <li>Compara el tamany del fitxer respecte al JSON o XML</li> <li>Crea una funci\u00f3 que llig el CSV i genere els objectes a l'array</li> </ol>"},{"location":"UD1_Files/5_CSV/#ampliacio","title":"Ampliaci\u00f3","text":"<p>A aules tens un dataset d'entrenament de models de IA. Es trata de wine_reviews, opinions i caarcter\u00ed\u00edstiques sobre molts vins del m\u00f3n (el dataset pesa &gt;= 50MB). Les caracter\u00edstiques que tenim son (primera l\u00ednea del csv):</p> Text Only<pre><code>,country,description,designation,points,price,\nprovince,region_1,region_2,taster_name,\ntaster_twitter_handle,title,variety,winery\n</code></pre> <p>Eixa primer coma al principi \u00e9s que hi ha una primera columna que \u00e9s el id de cara review, per tant podria ser perfectament  <code>id,country,description,designation,points,price, province,region_1,region_2,taster_name, taster_twitter_handle,title,variety,winery</code></p> <p>Es demana:</p> <ol> <li>Carrergar-lo en mem\u00f2ria. Quina estructura trobes que \u00e9s la \u00f2ptima?</li> <li>Quantes reviews hi han en total</li> <li>Localitza i genera un llistat de:</li> <li>Aquelles reviews que els falta alguna columna</li> <li>Aquelles columnes que els falta alguna data en alguna fila</li> </ol>"},{"location":"UD1_Files/5_Extra_Formats/","title":"1. Extra formats","text":"<p>En aquesta secci\u00f3 estudiarem dos tipus de fitxers de text que s'utilitzen \u00e0mpliament en inform\u00e0tica i la forma de treballar amb ells.</p>"},{"location":"UD1_Files/5_Extra_Formats/#11-fitxers-csv","title":"1.1. Fitxers CSV","text":"<p>Un fitxer de valors separats per comes (CSV) \u00e9s un fitxer de text est\u00e0ndard que utilitza una coma (<code>,</code>) per separar els valors. Cada l\u00ednia del fitxer consisteix en un o m\u00e9s camps separats per comes. Cada camp pot o no estar tancat entre cometes dobles. A m\u00e9s, diversos formats utilitzen diferents car\u00e0cters com a separador, com el punt i coma (<code>;</code>) o el s\u00edmbol de numeral (<code>#</code>). El RFC 4180 defineix el format o les definicions d'un fitxer CSV o fitxer de text/csv.</p> <p>En cas que el s\u00edmbol utilitzat com a separador aparegui dins dels valors, \u00e9s una bona idea tancar el contingut entre cometes. Es pot veure un exemple de fitxer CSV aqu\u00ed:</p> Text Only<pre><code>Chevrolet Chevelle Concours (sw);0;8;350.0;165.0;4142.;11.5;70;US\nFord Torino (sw);0;8;351.0;153.0;4034.;11.0;70;US\nPlymouth Satellite (sw);0;8;383.0;175.0;4166.;10.5;70;US\nAMC Rebel SST (sw);0;8;360.0;175.0;3850.;11.0;70;US\nDodge Challenger SE;15.0;8;383.0;170.0;3563.;10.0;70;US\nPlymouth Cuda 340;14.0;8;340.0;160.0;3609.;8.0;70;US\nFord Mustang Boss 302;0;8;302.0;140.0;3353.;8.0;70;US\n</code></pre> <p>La manera de processar un fitxer CSV en Java \u00e9s:</p> <ol> <li>Obrir el fitxer com a fitxer de text per a la lectura. Hem de llegir l\u00ednia per l\u00ednia, ja que cada l\u00ednia \u00e9s un registre. Llegir una l\u00ednia en una variable de tipus <code>String</code>.</li> <li>Processar els registres individuals:<ol> <li>Podem separar cada camp. Una bona opci\u00f3 \u00e9s utilitzar el m\u00e8tode <code>split(char)</code> de la classe String. Obtinguem un array de cadenes amb els valors dels camps individuals.</li> <li>Processar cada valor de camp segons les necessitats.</li> </ol> </li> </ol> <p>Atenci\u00f3</p> <p>\u00c9s una bona idea comen\u00e7ar a utilitzar les classes abstractes <code>Files</code> i <code>Paths</code>. Aquestes classes milloren l'\u00fas de la classe File i les seves classes derivades, oferint m\u00e8todes \u00fatils que ens permeten realitzar operacions r\u00e0pides amb menys l\u00ednies de codi. Per exemple, la seg\u00fcent l\u00ednia, a partir del <code>filename</code>, l'obre i despr\u00e9s llegeix tot el fitxer, retornant una llista amb les l\u00ednies separades en cada element de la col\u00b7lecci\u00f3.</p> Java<pre><code>List&lt;String&gt; lines=Files.readAllLines(Paths.get(filename));\n</code></pre> <p>More info in:</p> <ul> <li>Files</li> <li>Paths</li> </ul>"},{"location":"UD1_Files/5_Extra_Formats/#12-fitxers-de-propietats","title":"1.2. Fitxers de propietats","text":""},{"location":"UD1_Files/5_Extra_Formats/#121-fitxer-de-propietats","title":"1.2.1. Fitxer de propietats","text":"<p>Finalment, per\u00f2 no menys important, us mostrarem un tipus de fitxer de text important, que s\u00f3n els fitxers de propietats. Aquests fitxers emmagatzemen, com ja sabeu, diverses propietats que s'utilitzen durant l'execuci\u00f3 del programa. Quan el programa s'inicia, carrega aquestes propietats i ajusta diverses opcions. Exemples d'aquests fitxers s\u00f3n <code>my.conf</code> a MySQL, <code>php.ini</code> a PHP, etc.</p> <p>L'aspecte d'aquest fitxer consisteix en diverses l\u00ednies (una per propietat) i cada l\u00ednia t\u00e9 el format <code>atribut=valor</code>. Per exemple, un suposat fitxer:</p> Text Only<pre><code># properties of my program\nport=1234\nvolume=90\nbright=56\nload_on_start=true\n</code></pre> <p>La manera de processar un fitxer de propietats en Java \u00e9s similar a un CSV:</p> <ol> <li>Obrir com a fitxer de text per a la lectura. Hem de llegir l\u00ednia per l\u00ednia, ja que cada l\u00ednia \u00e9s una propietat diferent. Llegir una l\u00ednia en una variable de tipus <code>String</code>.</li> <li>Processar els registres individuals:<ol> <li>Podem separar cada camp. Una bona opci\u00f3 \u00e9s utilitzar el m\u00e8tode <code>split(char)</code> de la classe String. Obtinguem un array de cadenes amb els valors dels camps individuals. Els separadors normalment s\u00f3n <code>=</code>, <code>:</code>.</li> <li>L'esquerra del separador \u00e9s el nom de la propietat.</li> <li>La dreta del separador \u00e9s el valor de la propietat.</li> <li>Cal tenir en compte que si una l\u00ednia comen\u00e7a amb barra (<code>#</code>), \u00e9s un comentari i s'ignorar\u00e0.</li> </ol> </li> </ol>"},{"location":"UD1_Files/5_Extra_Formats/#122-propietats-de-java","title":"1.2.2. Propietats de Java","text":"<p>Java t\u00e9 un objecte molt \u00fatil per gestionar aquest tipus d'informaci\u00f3. Amb els objectes preperties de Java, podem emmagatzemar un conjunt de propietats amb una taula de hash (b\u00e0sicament una parella clau-valor). T\u00e9 m\u00e8todes preparats per carregar i desar des de i cap a fluxos de text o, fins i tot, fitxers XML. Alguns m\u00e8todes interessants per a les propietats s\u00f3n:</p> <p>Lectura des de fitxer (text o XML)</p> <ul> <li><code>void load(InputStream inStream)</code> \u2192 Llegeix un conjunt de propietats (parelles clau-element) des del flux d'entrada de bytes.</li> <li><code>void load(Reader reader)</code> \u2192 Llegeix un conjunt de propietats (parelles clau-element) des del flux d'entrada de car\u00e0cters en un format senzill orientat a l\u00ednies.</li> <li><code>void loadFromXML(InputStream in)</code> \u2192 Carrega totes les propietats representades pel document XML en el flux d'entrada especificat en aquesta taula de propietats.</li> </ul> <p>Escriptura en fitxer (text o XML)</p> <ul> <li><code>void store(OutputStream out, String comments)</code> \u2192 Escriu aquest conjunt de propietats (parelles clau-element) en aquesta taula de propietats al flux de sortida en un format adequat per carregar-lo en una taula de propietats utilitzant el m\u00e8tode load(InputStream).</li> <li><code>void store(Writer writer, String comments)</code> \u2192 Escriu aquest conjunt de propietats (parelles clau-element) en aquesta taula de propietats al flux de car\u00e0cters de sortida en un format adequat per utilitzar el m\u00e8tode load(Reader).</li> <li><code>void storeToXML(OutputStream os, String comment)</code> \u2192 Emmet un document XML que representa totes les propietats contingudes en aquesta taula.</li> </ul> <p>Treball amb propietats (heretat de HashTable)</p> <ul> <li><code>Set&lt;K&gt; keySet()</code> \u2192 Retorna una vista de conjunt de les claus contingudes en aquest mapa.</li> <li><code>V get(Object key)</code> \u2192 Retorna el valor (<code>V</code>) al qual s'assigna la clau especificada, o <code>null</code> si aquest mapa no cont\u00e9 cap assignaci\u00f3 per a la clau.</li> <li><code>boolean  containsKey(Object key)</code> Comprova si l'objecte especificat \u00e9s una clau d'aquesta taula de hash.</li> <li><code>V put(K key, V value)</code> \u2192 Assigna la clau especificada al valor especificat en aquesta taula de hash.</li> <li><code>V remove(Object key)</code> \u2192 Elimina la clau (i es retorna el valor corresponent) d'aquesta taula de hash.</li> </ul>"},{"location":"UD1_Files/5_Extra_Formats/#123-programa-dexemple","title":"1.2.3. Programa d'exemple","text":"<p>En el seg\u00fcent programa, podeu veure un exemple de lectura i creaci\u00f3 de fitxers de propietats en Java.</p> Java<pre><code>    /**\n     * Load the file specified and show its properties in different ways\n     * @param filename \n     */\n    private void loadAndShowProperties(String filename) {\n\n        Properties properties = new Properties();\n\n        try {\n            properties.load(new FileInputStream(new File(filename)));\n\n            System.out.println(\"Whole set: \" + properties);\n\n            properties.list(System.out);\n\n            Set&lt;Object&gt; keys = properties.keySet( );\n\n            System.out.println(\"My listing: \");\n            for (Object key : keys) {\n                System.out.println(key + \" - \" + properties.getProperty((String) key));\n            }\n\n        } catch (FileNotFoundException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (IOException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n\n    }\n\n    /**\n     * Create a properties object, populated with samples and stores into a \n     * text file and a XML file\n     * @throws IOException \n     */\n    private void writeProperties() throws IOException {\n        Properties props = new Properties();\n\n        props.put(\"Color\", \"Green\");\n        props.put(\"Range\", \"123\");\n        props.put(\"Visible\", \"false\");\n        props.put(\"Size\", \"Big\");\n        props.put(\"Status\", \"functional\");\n        props.put(\"Value\", \"345.24\");\n\n        props.store(new FileWriter(new File(\"propis.properties\")), \"Sample props file\");\n\n        props.storeToXML(new FileOutputStream(new File(\"propis.xml\")), \"Sample XML Props\");\n    }\n</code></pre>"},{"location":"UD1_Files/5_Extra_Formats/#13-entorn-arxius-env-i-dot_env","title":"1.3. Entorn, arxius <code>.env</code> i <code>dot_env</code>","text":""},{"location":"UD1_Files/5_Extra_Formats/#131-per-que-utilitzar-variables-dentorn","title":"1.3.1. Per qu\u00e8 utilitzar variables d'entorn?","text":"<p>Les variables d'entorn s\u00f3n un aspecte crucial per configurar i gestionar aplicacions en diferents entorns, com ara desenvolupament, proves i producci\u00f3. Proporcionen una manera de passar din\u00e0micament dades de configuraci\u00f3 a les aplicacions sense codificar valors directament al codi font. Aquest enfocament millora la flexibilitat, portabilitat i seguretat de les aplicacions.</p> <p>En Java, accedir a les variables d'entorn \u00e9s senzill, gr\u00e0cies a la classe <code>System</code>, que proporciona m\u00e8todes per obtenir les variables d'entorn. Aquesta capacitat \u00e9s especialment \u00fatil per a:</p> <ul> <li>Configurar par\u00e0metres de l'aplicaci\u00f3 com ara URL de bases de dades, claus d'API i rutes de fitxers.</li> <li>Gestionar configuracions espec\u00edfiques de l'entorn sense alterar el codi font.</li> <li>Mantenir informaci\u00f3 sensible, com ara contrasenyes i tokens, fora del codi font.</li> </ul> <p>Entenent com utilitzar de manera efectiva les variables d'entorn en Java, els desenvolupadors poden crear aplicacions m\u00e9s adaptables i segures.</p>"},{"location":"UD1_Files/5_Extra_Formats/#132-obtenir-variables-dentorn","title":"1.3.2. Obtenir variables d'entorn","text":"<p>Per accedir a les variables d'entorn en Java, podeu utilitzar el m\u00e8tode <code>System.getenv()</code>. Aquest m\u00e8tode est\u00e0 sobrecarregat i pot ser:</p> <ul> <li><code>System.getenv()</code> \u2192 retorna un objecte <code>Map</code> que cont\u00e9 totes les variables d'entorn i els seus valors corresponents.</li> <li><code>System.getenv(String)</code> \u2192 retorna una <code>String</code> amb el valor de la variable d'entorn espec\u00edfica o null si no existeix.</li> </ul> <p>Com recuperar les variables d'entorn en Java:</p> Java<pre><code>Map&lt;String, String&gt; env = System.getenv();\n\n// Accedir a una variable d'entorn espec\u00edfica\nString value = env.get(\"NOM_VARIABLE\");\n\n// Imprimir totes les variables d'entorn\nfor (Map.Entry&lt;String, String&gt; entry : env.entrySet()) {\n    System.out.println(entry.getKey() + \" = \" + entry.getValue());\n}\n</code></pre> <p>Tingueu en compte que:</p> <ul> <li>La classe Map retorna una col\u00b7lecci\u00f3 d'entrades amb parelles clau-valor.</li> <li>Les variables d'entorn distingeixen entre maj\u00fascules i min\u00fascules, aix\u00ed que assegureu-vos d'utilitzar les maj\u00fascules de manera correcta en accedir-hi.</li> </ul>"},{"location":"UD1_Files/5_Extra_Formats/#133-lalternativa-dot-env","title":"1.3.3. L'alternativa <code>dot-env</code>","text":"<p>Emmagatzemar la configuraci\u00f3 a l'entorn \u00e9s un dels principis d'una aplicaci\u00f3 de dotze factors. Qualsevol cosa que pugui canviar entre els entorns de desplegament, com ara els recursos de les bases de dades o les credencials dels serveis externs, s'ha d'extreure del codi i emmagatzemar en variables d'entorn.</p> <p>Per\u00f2 no sempre \u00e9s pr\u00e0ctic establir variables d'entorn en m\u00e0quines de desenvolupament o servidors d'integraci\u00f3 cont\u00ednua on s'executen diversos projectes. <code>Dotenv</code> carrega les variables d'un fitxer <code>.env</code> a l'entorn quan s'inicia.</p> <p>Desafortunadament, Java no admet de forma nativa la c\u00e0rrega de fitxers <code>.env</code>, per\u00f2 podeu utilitzar llibreries externes per aconseguir aquesta tasca. Una de les llibreries populars per a aquest prop\u00f2sit \u00e9s <code>dotenv-java</code>. Aquesta llibreria us permet carregar f\u00e0cilment les variables d'entorn d'un fitxer .env a la vostra aplicaci\u00f3 Java. https://github.com/cdimascio/dotenv-java</p> <p>Afegiu la depend\u00e8ncia</p> <p>Primer, heu d'afegir la llibreria <code>dotenv-java</code> al vostre projecte. Si feu servir Maven, afegiu la seg\u00fcent depend\u00e8ncia al fitxer pom.xml:</p> XML<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.github.cdimascio&lt;/groupId&gt;\n    &lt;artifactId&gt;java-dotenv&lt;/artifactId&gt;\n    &lt;version&gt;5.2.2&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Si feu servir Gradle, afegiu el seg\u00fcent al fitxer build.gradle:</p> Text Only<pre><code>implementation 'io.github.cdimascio:java-dotenv:5.2.2'\n</code></pre> <p>Creeu el fitxer <code>.env</code></p> <p>El fitxer .env \u00e9s com un fitxer de configuraci\u00f3. Podeu emmagatzemar-lo a la ruta arrel de la vostra aplicaci\u00f3</p> Text Only<pre><code>DATABASE_URL=jdbc:mysql://localhost:3306/testdb\nDATABASE_USER=root\nDATABASE_PASSWORD=password\n</code></pre> <p>Carregueu la configuraci\u00f3</p> Java<pre><code>import io.github.cdimascio.dotenv.Dotenv;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Load the .env file\n        Dotenv dotenv = Dotenv.load();\n\n        // Retrieve environment variables\n        String databaseUrl = dotenv.get(\"DATABASE_URL\");\n        String databaseUser = dotenv.get(\"DATABASE_USER\");\n        String databasePassword = dotenv.get(\"DATABASE_PASSWORD\");\n\n        // Print the values\n        System.out.println(\"Database URL: \" + databaseUrl);\n        System.out.println(\"Database User: \" + databaseUser);\n        System.out.println(\"Database Password: \" + databasePassword);\n\n        // Use the variables as needed\n        // For example, establish a database connection using these variables\n    }\n}\n</code></pre> <p>Atenci\u00f3</p> <p>Tingueu en compte que amb la llibreria java dotenv, utilitzareu <code>dotenv.get()</code> en comptes del m\u00e8tode <code>System.getenv()</code>, ja que esteu accedint a un fitxer local.</p>"},{"location":"UD1_Files/6_Properties/","title":"6. Arxius de propietats","text":""},{"location":"UD1_Files/6_Properties/#1-fitxer-de-propietats","title":"1. Fitxer de propietats","text":"<p>Finalment, per\u00f2 no menys important, us mostrarem un tipus de fitxer de text important, que s\u00f3n els fitxers de propietats. Aquests fitxers emmagatzemen, com ja sabeu, diverses propietats que s'utilitzen durant l'execuci\u00f3 del programa. Quan el programa s'inicia, carrega aquestes propietats i ajusta diverses opcions. Exemples d'aquests fitxers s\u00f3n <code>my.conf</code> a MySQL, <code>php.ini</code> a PHP, etc.</p> <p>L'aspecte d'aquest fitxer consisteix en diverses l\u00ednies (una per propietat) i cada l\u00ednia t\u00e9 el format <code>atribut=valor</code>. Per exemple, un suposat fitxer:</p> Text Only<pre><code># properties of my program\nport=1234\nvolume=90\nbright=56\nload_on_start=true\n</code></pre> <p>La manera de processar un fitxer de propietats manualment en Java \u00e9s similar a un CSV:</p> <ol> <li>Obrir com a fitxer de text per a la lectura. Hem de llegir l\u00ednia per l\u00ednia, ja que cada l\u00ednia \u00e9s una propietat diferent. Llegir una l\u00ednia en una variable de tipus <code>String</code>.</li> <li>Processar els registres (l\u00ednies) de manera individual:<ol> <li>Podem separar cada camp. Una bona opci\u00f3 \u00e9s utilitzar el m\u00e8tode <code>split(char)</code> de la classe String. Obtinguem un array de cadenes amb els valors dels camps individuals. Els separadors normalment s\u00f3n <code>=</code>, <code>:</code>. Tindran com \u00e9s l\u00f2gic dos camps:</li> <li>L'esquerra del separador \u00e9s el nom de la propietat.</li> <li>La dreta del separador \u00e9s el valor de la propietat.</li> <li>Cal tenir en compte que si una l\u00ednia comen\u00e7a amb barra (<code>#</code>), \u00e9s un comentari i s'ignorar\u00e0.</li> </ol> </li> </ol> <p>Exercici proposart</p> <ol> <li>Fes un programa al qual carregues les propietats d'un fitxer i les guardes en variables</li> <li> <p>Analitza la problem\u00e0tica de:</p> <ul> <li>Quantes properties cont\u00e9 un fitxer? </li> <li>Com les guarde amb variables \"planes\"?</li> <li>Existeix alguna alternativa millor?</li> </ul> </li> </ol>"},{"location":"UD1_Files/6_Properties/#2-propietats-de-java","title":"2. Propietats de Java","text":"<p>Java t\u00e9 un objecte molt \u00fatil per gestionar aquest tipus d'informaci\u00f3. Amb els objectes properties de Java, podem emmagatzemar un conjunt de propietats amb una taula de hash (b\u00e0sicament una parella clau-valor). T\u00e9 m\u00e8todes preparats per carregar i desar des de i cap a fluxos de text o, fins i tot, fitxers XML. Alguns m\u00e8todes interessants per a les propietats s\u00f3n:</p> <p>Lectura des de fitxer (text o XML)</p> <ul> <li><code>void load(InputStream inStream)</code> \u2192 Llegeix un conjunt de propietats (parelles clau-element) des del flux d'entrada de bytes.</li> <li><code>void load(Reader reader)</code> \u2192 Llegeix un conjunt de propietats (parelles clau-element) des del flux d'entrada de car\u00e0cters en un format senzill orientat a l\u00ednies.</li> <li><code>void loadFromXML(InputStream in)</code> \u2192 Carrega totes les propietats representades pel document XML en el flux d'entrada especificat en aquesta taula de propietats.</li> </ul> <p>Escriptura en fitxer (text o XML)</p> <ul> <li><code>void store(OutputStream out, String comments)</code> \u2192 Escriu aquest conjunt de propietats (parelles clau-element) en aquesta taula de propietats al flux de sortida en un format adequat per carregar-lo en una taula de propietats utilitzant el m\u00e8tode load(InputStream).</li> <li><code>void store(Writer writer, String comments)</code> \u2192 Escriu aquest conjunt de propietats (parelles clau-element) en aquesta taula de propietats al flux de car\u00e0cters de sortida en un format adequat per utilitzar el m\u00e8tode load(Reader).</li> <li><code>void storeToXML(OutputStream os, String comment)</code> \u2192 Emmet un document XML que representa totes les propietats contingudes en aquesta taula.</li> </ul> <p>Treball amb propietats (heretat de HashTable)</p> <ul> <li><code>Set&lt;K&gt; keySet()</code> \u2192 Retorna una vista de conjunt de les claus contingudes en aquest mapa.</li> <li><code>V get(Object key)</code> \u2192 Retorna el valor (<code>V</code>) al qual s'assigna la clau especificada, o <code>null</code> si aquest mapa no cont\u00e9 cap assignaci\u00f3 per a la clau.</li> <li><code>boolean  containsKey(Object key)</code> Comprova si l'objecte especificat \u00e9s una clau d'aquesta taula de hash.</li> <li><code>V put(K key, V value)</code> \u2192 Assigna la clau especificada al valor especificat en aquesta taula de hash.</li> <li><code>V remove(Object key)</code> \u2192 Elimina la clau (i es retorna el valor corresponent) d'aquesta taula de hash.</li> </ul>"},{"location":"UD1_Files/6_Properties/#21-programa-dexemple","title":"2.1. Programa d'exemple","text":"<p>En el seg\u00fcent programa, podeu veure un exemple de lectura i creaci\u00f3 de fitxers de propietats en Java.</p> Java<pre><code>    /**\n     * Load the file specified and show its properties in different ways\n     * @param filename \n     */\n    private void loadAndShowProperties(String filename) {\n\n        Properties properties = new Properties();\n\n        try {\n            properties.load(new FileInputStream(new File(filename)));\n\n            System.out.println(\"Whole set: \" + properties);\n\n            properties.list(System.out);\n\n            Set&lt;Object&gt; keys = properties.keySet( );\n\n            System.out.println(\"My listing: \");\n            for (Object key : keys) {\n                System.out.println(key + \" - \" + properties.getProperty((String) key));\n            }\n\n        } catch (FileNotFoundException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (IOException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n\n    }\n\n    /**\n     * Create a properties object, populated with samples and stores into a \n     * text file and a XML file\n     * @throws IOException \n     */\n    private void writeProperties() throws IOException {\n        Properties props = new Properties();\n\n        props.put(\"Color\", \"Green\");\n        props.put(\"Range\", \"123\");\n        props.put(\"Visible\", \"false\");\n        props.put(\"Size\", \"Big\");\n        props.put(\"Status\", \"functional\");\n        props.put(\"Value\", \"345.24\");\n\n        props.store(new FileWriter(new File(\"propis.properties\")), \"Sample props file\");\n\n        props.storeToXML(new FileOutputStream(new File(\"propis.xml\")), \"Sample XML Props\");\n    }\n</code></pre>"},{"location":"UD1_Files/6_Properties/#3-entorn-arxius-env-i-dot_env","title":"3. Entorn, arxius <code>.env</code> i <code>dot_env</code>","text":""},{"location":"UD1_Files/6_Properties/#31-per-que-utilitzar-variables-dentorn","title":"3.1. Per qu\u00e8 utilitzar variables d'entorn?","text":"<p>Les variables d'entorn s\u00f3n un aspecte crucial per configurar i gestionar aplicacions en diferents entorns, com ara desenvolupament, proves i producci\u00f3. Proporcionen una manera de passar din\u00e0micament dades de configuraci\u00f3 a les aplicacions sense codificar valors directament al codi font. Aquest enfocament millora la flexibilitat, portabilitat i seguretat de les aplicacions.</p> <p>En Java, accedir a les variables d'entorn \u00e9s senzill, gr\u00e0cies a la classe <code>System</code>, que proporciona m\u00e8todes per obtenir les variables d'entorn. Aquesta capacitat \u00e9s especialment \u00fatil per a:</p> <ul> <li>Configurar par\u00e0metres de l'aplicaci\u00f3 com ara URL de bases de dades, claus d'API i rutes de fitxers.</li> <li>Gestionar configuracions espec\u00edfiques de l'entorn sense alterar el codi font.</li> <li>Mantenir informaci\u00f3 sensible, com ara contrasenyes i tokens, fora del codi font.</li> </ul> <p>Entenent com utilitzar de manera efectiva les variables d'entorn en Java, els desenvolupadors poden crear aplicacions m\u00e9s adaptables i segures.</p>"},{"location":"UD1_Files/6_Properties/#32-obtenir-variables-dentorn","title":"3.2. Obtenir variables d'entorn","text":"<p>Per accedir a les variables d'entorn en Java, podeu utilitzar el m\u00e8tode <code>System.getenv()</code>. Aquest m\u00e8tode est\u00e0 sobrecarregat i pot ser:</p> <ul> <li><code>System.getenv()</code> \u2192 retorna un objecte <code>Map</code> que cont\u00e9 totes les variables d'entorn i els seus valors corresponents.</li> <li><code>System.getenv(String)</code> \u2192 retorna una <code>String</code> amb el valor de la variable d'entorn espec\u00edfica o null si no existeix.</li> </ul> <p>Com recuperar les variables d'entorn en Java:</p> Java<pre><code>Map&lt;String, String&gt; env = System.getenv();\n\n// Accedir a una variable d'entorn espec\u00edfica\nString value = env.get(\"NOM_VARIABLE\");\n\n// Imprimir totes les variables d'entorn\nfor (Map.Entry&lt;String, String&gt; entry : env.entrySet()) {\n    System.out.println(entry.getKey() + \" = \" + entry.getValue());\n}\n</code></pre> <p>Tingueu en compte que:</p> <ul> <li>La classe Map retorna una col\u00b7lecci\u00f3 d'entrades amb parelles clau-valor.</li> <li>Les variables d'entorn distingeixen entre maj\u00fascules i min\u00fascules, aix\u00ed que assegureu-vos d'utilitzar les maj\u00fascules de manera correcta en accedir-hi.</li> </ul>"},{"location":"UD1_Files/6_Properties/#33-lalternativa-dot-env","title":"3.3. L'alternativa <code>dot-env</code>","text":"<p>Emmagatzemar la configuraci\u00f3 a l'entorn \u00e9s un dels principis d'una aplicaci\u00f3 de dotze factors. Qualsevol cosa que pugui canviar entre els entorns de desplegament, com ara els recursos de les bases de dades o les credencials dels serveis externs, s'ha d'extreure del codi i emmagatzemar en variables d'entorn.</p> <p>Per\u00f2 no sempre \u00e9s pr\u00e0ctic establir variables d'entorn en m\u00e0quines de desenvolupament o servidors d'integraci\u00f3 cont\u00ednua on s'executen diversos projectes. <code>Dotenv</code> carrega les variables d'un fitxer <code>.env</code> a l'entorn quan s'inicia.</p> <p>Desafortunadament, Java no admet de forma nativa la c\u00e0rrega de fitxers <code>.env</code>, per\u00f2 podeu utilitzar llibreries externes per aconseguir aquesta tasca. Una de les llibreries populars per a aquest prop\u00f2sit \u00e9s <code>dotenv-java</code>. Aquesta llibreria us permet carregar f\u00e0cilment les variables d'entorn d'un fitxer .env a la vostra aplicaci\u00f3 Java. https://github.com/cdimascio/dotenv-java</p> <p>Afegiu la depend\u00e8ncia</p> <p>Primer, heu d'afegir la llibreria <code>dotenv-java</code> al vostre projecte. Si feu servir Maven, afegiu la seg\u00fcent depend\u00e8ncia al fitxer pom.xml:</p> XML<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.github.cdimascio&lt;/groupId&gt;\n    &lt;artifactId&gt;java-dotenv&lt;/artifactId&gt;\n    &lt;version&gt;5.2.2&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Si feu servir Gradle, afegiu el seg\u00fcent al fitxer build.gradle:</p> Text Only<pre><code>implementation 'io.github.cdimascio:java-dotenv:5.2.2'\n</code></pre> <p>Creeu el fitxer <code>.env</code></p> <p>El fitxer .env \u00e9s com un fitxer de configuraci\u00f3. Podeu emmagatzemar-lo a la ruta arrel de la vostra aplicaci\u00f3</p> Text Only<pre><code>DATABASE_URL=jdbc:mysql://localhost:3306/testdb\nDATABASE_USER=root\nDATABASE_PASSWORD=password\n</code></pre> <p>Carregueu la configuraci\u00f3</p> Java<pre><code>import io.github.cdimascio.dotenv.Dotenv;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Load the .env file\n        Dotenv dotenv = Dotenv.load();\n\n        // Retrieve environment variables\n        String databaseUrl = dotenv.get(\"DATABASE_URL\");\n        String databaseUser = dotenv.get(\"DATABASE_USER\");\n        String databasePassword = dotenv.get(\"DATABASE_PASSWORD\");\n\n        // Print the values\n        System.out.println(\"Database URL: \" + databaseUrl);\n        System.out.println(\"Database User: \" + databaseUser);\n        System.out.println(\"Database Password: \" + databasePassword);\n\n        // Use the variables as needed\n        // For example, establish a database connection using these variables\n    }\n}\n</code></pre> <p>Atenci\u00f3</p> <p>Tingueu en compte que amb la llibreria java dotenv, utilitzareu <code>dotenv.get()</code> en comptes del m\u00e8tode <code>System.getenv()</code>, ja que esteu accedint a un fitxer local.</p>"},{"location":"UD1_Files/7_Llibreries_Conversores/","title":"7. Llibreries conversores","text":"<p>En aquesta unitat  anem a estudiar algunes llibreries que ens permeten accelerar el proc\u00e9s de manipular els tipus de fitxers estudiats pr\u00e8viament. Aquestes biblioteques faran servir classes serialitzadores i/o anotacions a les nostres classes per a definir la estrucutra dels fitxers a partir de les classes.</p>"},{"location":"UD1_Files/7_Llibreries_Conversores/#1-jackson","title":"1. Jackson","text":""},{"location":"UD1_Files/7_Llibreries_Conversores/#11-que-es-jackson","title":"1.1. Qu\u00e8 \u00e9s Jackson?","text":"<p>Ja hem vist que en algun moment haur\u00e0s de gestionar dades en format JSON (JavaScript Object Notation). Jackson \u00e9s una llibreria de Java que simplifica enormement aquest proc\u00e9s, convertint-se en una eina pr\u00e0cticament imprescindible en l'ecosistema Java modern.</p> <p>Jackson fa una cosa molt concreta i la fa excepcionalment b\u00e9: la seriaci\u00f3 i deseriatzaci\u00f3 de dades entre objectes Java i el seu equivalent en format JSON.</p> <ul> <li>Seriaci\u00f3 (o Marshalling): Converteix un objecte Java (una inst\u00e0ncia d'una classe) en una cadena de text amb format JSON.</li> </ul> <p>Deseriatzaci\u00f3 (o Unmarshalling): El proc\u00e9s invers, converteix una cadena de text JSON en un objecte Java equivalent.</p>"},{"location":"UD1_Files/7_Llibreries_Conversores/#12-que-necessite","title":"1.2. Qu\u00e8 necessite?","text":"<p>Necessitem afegir la seg\u00fcent denpend\u00e8ncia al nostre porjecte:</p> XML<pre><code>&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n        &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;\n        &lt;version&gt;2.19.0&lt;/version&gt; &lt;!-- o la versi\u00f3 m\u00e9s actual --&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre> <p>Jackson far\u00e0 servir principalment les seg\u00fcents classes:</p> <ul> <li><code>ObjectMapper</code>: \u00c9s la classe principal de Jackson i s'encarrega de la conversi\u00f3 entre objectes Java i JSON:</li> <li><code>writeValue()</code>: M\u00e8tode per convertir un objecte Java en JSON.</li> <li><code>readValue()</code>: M\u00e8tode per convertir JSON en un objecte Java.</li> <li><code>JsonNode</code>: Aquesta classe permet treballar amb arbres JSON en format node i \u00e9s \u00fatil quan no coneixes l'estructura exacta del JSON.</li> </ul>"},{"location":"UD1_Files/7_Llibreries_Conversores/#13-exemple","title":"1.3. Exemple","text":"<p>Si partim d'una classe o conjunt de classes sense cap modificaci\u00f3 a la classe, ens far\u00e0 un objecte JSNO com segueix</p> Classe de partidaCodi JavaJSON Resultant <p>Java<pre><code>public class Llibre {\n    private int id;\n    private String titol;\n    private String genere;\n\n   // Constructors habitual\n\n    // Getters i setters\n</code></pre> }</p> Java<pre><code>// Creem l'ObjectMapper\nObjectMapper objectMapper = new ObjectMapper();\n\n// Convertim l'objecte a JSON\nString json = null;\ntry {\n    // string a pelo, sin formato\n    json = objectMapper.writeValueAsString(llibre);\n    System.out.println(json);\n    // aix\u00ed millor\n    json = objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(llibre);\n    System.out.println(json);\n} // falta la captura d'excepcions\n</code></pre> JSON<pre><code>{\"id\":1,\"titol\":\"Quijote\",\"genere\":\"Caballeria\"}\n{\n\"id\" : 1,\n\"titol\" : \"Quijote\",\n\"genere\" : \"Caballeria\"\n}\n</code></pre> <p>Com podem veure el resultat \u00e9s molt acceptable</p> I un Array o objectes amb arrays Objecte Autor amb un array de llibres i array de llibresArray de llibresArray de autors Java<pre><code>Llibre llibre1 = new Llibre(1, \"La casa de los esp\u00edritus\", \"Realista\");\nLlibre llibre2 = new Llibre(2, \"Cien a\u00f1os de soledad\", \"Realista\");\nLlibre llibre3 = new Llibre(3, \"El amor en los tiempos del c\u00f3lera\", \"Rom\u00e0ntic\");\nLlibre llibre4 = new Llibre(4, \"La sombra del viento\", \"Misteri\");\nLlibre llibre5 = new Llibre(5, \"El juego del \u00e1ngel\", \"Misteri\");\nLlibre llibre6 = new Llibre(6, \"Kafka en la orilla\", \"Filos\u00f2fic\");\nLlibre llibre7 = new Llibre(7, \"Norwegian Wood\", \"Drama\");\nLlibre llibre8 = new Llibre(8, \"1Q84\", \"Ci\u00e8ncia ficci\u00f3\");\n\n// Creem 5 autors\nAutor autor1 = new Autor(1, \"Isabel Allende\", \"Xile\", Arrays.asList(llibre1, llibre2));\nAutor autor2 = new Autor(2, \"Gabriel Garc\u00eda M\u00e1rquez\", \"Col\u00f2mbia\", Arrays.asList(llibre3));\nAutor autor3 = new Autor(3, \"Carlos Ruiz Zaf\u00f3n\", \"Espanya\", Arrays.asList(llibre4, llibre5));\nAutor autor4 = new Autor(4, \"Haruki Murakami\", \"Jap\u00f3\", Arrays.asList(llibre6, llibre7, llibre8));\nAutor autor5 = new Autor(5, \"Elena Ferrante\", \"It\u00e0lia\", Arrays.asList());\n\n// Imprimim els autors\nautors = Arrays.asList(autor1, autor2, autor3, autor4, autor5);\n\nllibres=Arrays.asList(llibre1, llibre2, llibre3, llibre4, llibre5, llibre6, llibre7, llibre8);\n</code></pre> JSON<pre><code>[ {\n    \"id\" : 1,\n    \"titol\" : \"La casa de los esp\u00edritus\",\n    \"genere\" : \"Realista\"\n    }, {\n    \"id\" : 2,\n    \"titol\" : \"Cien a\u00f1os de soledad\",\n    \"genere\" : \"Realista\"\n    }, {\n    \"id\" : 3,\n    \"titol\" : \"El amor en los tiempos del c\u00f3lera\",\n    \"genere\" : \"Rom\u00e0ntic\"\n    }, {\n    \"id\" : 4,\n    \"titol\" : \"La sombra del viento\",\n    \"genere\" : \"Misteri\"\n    }, {\n    \"id\" : 5,\n    \"titol\" : \"El juego del \u00e1ngel\",\n    \"genere\" : \"Misteri\"\n    }, {\n    \"id\" : 6,\n    \"titol\" : \"Kafka en la orilla\",\n    \"genere\" : \"Filos\u00f2fic\"\n    }, {\n    \"id\" : 7,\n    \"titol\" : \"Norwegian Wood\",\n    \"genere\" : \"Drama\"\n    }, {\n    \"id\" : 8,\n    \"titol\" : \"1Q84\",\n    \"genere\" : \"Ci\u00e8ncia ficci\u00f3\"\n    } ]\n</code></pre> JSON<pre><code>    [ {\n        \"id\" : 1,\n        \"nom\" : \"Isabel Allende\",\n        \"nacionalitat\" : \"Xile\",\n        \"llibres\" : [ {\n            \"id\" : 1,\n            \"titol\" : \"La casa de los esp\u00edritus\",\n            \"genere\" : \"Realista\"\n        }, {\n            \"id\" : 2,\n            \"titol\" : \"Cien a\u00f1os de soledad\",\n            \"genere\" : \"Realista\"\n        } ]\n        }, {\n        \"id\" : 2,\n        \"nom\" : \"Gabriel Garc\u00eda M\u00e1rquez\",\n        \"nacionalitat\" : \"Col\u00f2mbia\",\n        \"llibres\" : [ {\n            \"id\" : 3,\n            \"titol\" : \"El amor en los tiempos del c\u00f3lera\",\n            \"genere\" : \"Rom\u00e0ntic\"\n        } ]\n        }, {\n        \"id\" : 3,\n        \"nom\" : \"Carlos Ruiz Zaf\u00f3n\",\n        \"nacionalitat\" : \"Espanya\",\n        \"llibres\" : [ {\n            \"id\" : 4,\n            \"titol\" : \"La sombra del viento\",\n            \"genere\" : \"Misteri\"\n        }, {\n            \"id\" : 5,\n            \"titol\" : \"El juego del \u00e1ngel\",\n            \"genere\" : \"Misteri\"\n        } ]\n        }, {\n        \"id\" : 4,\n        \"nom\" : \"Haruki Murakami\",\n        \"nacionalitat\" : \"Jap\u00f3\",\n        \"llibres\" : [ {\n            \"id\" : 6,\n            \"titol\" : \"Kafka en la orilla\",\n            \"genere\" : \"Filos\u00f2fic\"\n        }, {\n            \"id\" : 7,\n            \"titol\" : \"Norwegian Wood\",\n            \"genere\" : \"Drama\"\n        }, {\n            \"id\" : 8,\n            \"titol\" : \"1Q84\",\n            \"genere\" : \"Ci\u00e8ncia ficci\u00f3\"\n        } ]\n        }, {\n        \"id\" : 5,\n        \"nom\" : \"Elena Ferrante\",\n        \"nacionalitat\" : \"It\u00e0lia\",\n        \"llibres\" : [ ]\n        } ]\n</code></pre>"},{"location":"UD1_Files/7_Llibreries_Conversores/#14-modificant-algunes-propietats-del-json","title":"1.4. Modificant algunes propietats del json","text":"<p><code>Jackson</code> ofereix un ampli conjunt d'anotacions per a personalitzar el proc\u00e9s de conversi\u00f3 sense haver de modificar la l\u00f2gica del codi. Algunes b\u00e0siques son:</p> <ul> <li><code>@JsonProperty</code> pots canviar el nom d'un camp en el JSON</li> <li><code>@JsonIgnore</code> pots ometre un atribut, i amb </li> <li><code>@JsonFormat</code> pots definir el format d'una data.</li> </ul> <p>Exemple:</p> Java<pre><code>public class Llibre2 {\n\n    // Canviem \"id\" per \"isbn\"\n    @JsonProperty(\"isbn\")  // Opcional, ja que el nom de l'atribut coincideix amb el nom del JSON\n    private int isbn;\n\n    @JsonProperty(\"titol_llibre\")  // Canvia el nom de \"titol\" a \"titol_llibre\" al JSON\n    private String titol;\n\n    private String genere;\n\n    @JsonIgnore  // Omiteix el camp \"notaInterna\" a l'hora de convertir a JSON\n    private String notaInterna;\n\n    @JsonFormat(pattern = \"dd-MM-yyyy\")  // Personalitza el format de la data\n    private Date dataPublicacio;\n\n    // Constructor, getters i settes\n}\n</code></pre>"},{"location":"UD1_Files/7_Llibreries_Conversores/#15-avancem-continugt","title":"1.5. Avancem continugt","text":"<p><code>Spring</code>, el workbench que estudiarem a l'unitat 6, fa servir internament Jackson per a seriar els objectes i retornar-los mitjan\u00e7ant la seua API. De vegades ens podrem trobar problemes quan tenim objectes doblement enlla\u00e7ats, com per exemple un <code>Jugador</code> que ha pertany un <code>Equip</code> on dins dels <code>Equips</code> tenim guardat els seus <code>Jugador</code>.</p> <p>Aquest problema no \u00e9s nou, ja que por apareixer tamb\u00e9 al generar el propi <code>toString</code> i l'aparicic\u00f3 del fam\u00f3s missatge <code>StackOverflowException</code> degut a la recursi\u00f3 infinita d'anar d'un objecte a altre.</p> <p>Per a evitar-ho amb la serialitzaci\u00f3 amb JSON, disposem de <code>@JsonManagedReference</code> i <code>@JsonBackReference</code>.</p> <ul> <li><code>@JsonManagedReference</code>: Es col\u00b7loca a la propietat que s'ha de serialitzar normalment (el \"pare\" o el costat \"cap avant\" de la relaci\u00f3). En aquesta classe S\u00ed volem que aparega les propietats. Al nostre exemple, seria la llista de <code>Jugadors</code> dins de la classe <code>Equip</code>.</li> <li><code>@JsonBackReference</code>: Es col\u00b7loca a la propietat que causa el bucle i que no es tornar\u00e0 a serialitzar (el \"fill\" o el costat \"cap enrere\"). En aquest cas, seria la propietat <code>Equip</code> dins de la classe <code>Jugador</code>. Aix\u00f2 el que provoca tamb\u00e9 \u00e9s que no es mostre l'equip al convertir el jugador</li> </ul> EquipJugadorCodi d'exempleEixida Java<pre><code>public class Equip {\n\n    public long id;\n    public String nom;\n\n    @JsonManagedReference\n    public List&lt;Jugador&gt; jugadors;\n\n    // Constructors Getters i Setters (omesos per brevetat)\n}\n</code></pre> Java<pre><code>public class Jugador {\n\npublic long id;\npublic String nom;\npublic int dorsal;\n\n@JsonBackReference()\npublic Equip equip;\n\n// Constructors Getters i Setters\n</code></pre> Java<pre><code>    public void testReferencies(){\n    // 1. Creem l'equip\n    Equip valenciaCF = new Equip(1, \"Val\u00e8ncia CF\");\n\n    // 2. Creem els jugadors\n    Jugador jugador1 = new Jugador(10, \"Pepelu\", 18);\n    Jugador jugador2 = new Jugador(20, \"Hugo Duro\", 9);\n    Jugador jugador3 = new Jugador(25, \"Giorgi Mamardashvili\", 1);\n\n    // 3. Afegim els jugadors a l'equip (establint la relaci\u00f3 bidireccional)\n    valenciaCF.afegirJugador(jugador1);\n    valenciaCF.afegirJugador(jugador2);\n    valenciaCF.afegirJugador(jugador3);\n\n    // 4. Mostrem l'equip (i els seus jugador)\n    sampleObjectToJson(valenciaCF);\n\n    // 5. Mostrem un jugador (per\u00f2 no l'equip)\n    sampleObjectToJson(jugador1);\n}\n</code></pre> JSON<pre><code>{\n    \"id\" : 1,\n    \"nom\" : \"Val\u00e8ncia CF\",\n    \"jugadors\" : [ {\n        \"id\" : 10,\n        \"nom\" : \"Pepelu\",\n        \"dorsal\" : 18\n    }, {\n        \"id\" : 20,\n        \"nom\" : \"Hugo Duro\",\n        \"dorsal\" : 9\n    }, {\n        \"id\" : 25,\n        \"nom\" : \"Giorgi Mamardashvili\",\n        \"dorsal\" : 1\n    } ]\n}\n{\n    \"id\" : 10,\n    \"nom\" : \"Pepelu\",\n    \"dorsal\" : 18\n}\n</code></pre> <p>Investiga</p> <p>Prova a buscar una soluci\u00f3 m\u00e9s completa amb <code>@JsonIdentityInfo</code></p>"},{"location":"UD1_Files/7_Llibreries_Conversores/#2-jaxb","title":"2. JAXB","text":"<p>Per processar XML, saps que amb DOM, has de rec\u00f3rrer arbres de nodes (NodeList, Element, Attr). JAXB (Java Architecture for XML Binding) representa un canvi de paradigma. En lloc de veure l'XML com un arbre de nodes, JAXB el tracta com una font de dades per a objectes Java. La seva funci\u00f3 principal \u00e9s actuar com un pont autom\u00e0tic entre el m\u00f3n dels documents XML i el m\u00f3n dels teus objectes de domini (POJOs - Plain Old Java Objects). - Unmarshalling: \u00c9s el proc\u00e9s de llegir un document XML i convertir-lo autom\u00e0ticament en una estructura d'objectes Java. JAXB llegeix l'XML, instancia les classes corresponents i assigna els valors als seus camps. - Marshalling: \u00c9s el proc\u00e9s invers. Agafa un objecte Java i el converteix en la seva representaci\u00f3 XML equivalent.</p> <p>De manera molt similar a com la llibreria Jackson ho fa amb JSON, JAXB utilitza anotacions per mapejar les classes i els camps de Java amb els elements i atributs de l'XML.</p> <p>Primerament caldr\u00e0 afegir la depend\u00e8ncia de JABX al POM (en projectes maven)</p> XML<pre><code>    &lt;dependency&gt;\n        &lt;groupId&gt;jakarta.xml.bind&lt;/groupId&gt;\n        &lt;artifactId&gt;jakarta.xml.bind-api&lt;/artifactId&gt;\n        &lt;version&gt;4.0.2&lt;/version&gt;\n    &lt;/dependency&gt;\n\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.glassfish.jaxb&lt;/groupId&gt;\n        &lt;artifactId&gt;jaxb-runtime&lt;/artifactId&gt;\n        &lt;version&gt;4.0.5&lt;/version&gt;\n    &lt;/dependency&gt;\n</code></pre>"},{"location":"UD1_Files/7_Llibreries_Conversores/#21-anotacions-a-nivell-general-o-de-classe","title":"2.1. Anotacions a nivell general o de classe","text":"<ul> <li><code>@XmlRootElement</code> \u2192 \u00c9s l'anotaci\u00f3 m\u00e9s important. Indica que aquesta classe pot ser l'element arrel d'un document XML. Sense ella, JAXB no sabria per on comen\u00e7ar a l'hora de fer marshalling d'un objecte.</li> <li><code>@XmlAccessorType</code> \u2192  Defineix quins camps de la classe s'han d'incloure en el proc\u00e9s de binding per defecte. L'opci\u00f3 m\u00e9s comuna \u00e9s <code>XmlAccessType.FIELD</code></li> <li><code>@XmlType</code> \u2192 Permet definir l'ordre en qu\u00e8 apareixeran els elements dins de l'XML generat, la qual cosa \u00e9s molt \u00fatil per crear documents amb una estructura predefinida i consistent. <code>@XmlType(propOrder = { \"nom\", \"dorsal\", \"demarcacio\" })</code></li> </ul>"},{"location":"UD1_Files/7_Llibreries_Conversores/#22-anotacions-a-nivell-de-atribut","title":"2.2. Anotacions a nivell de atribut","text":"<ul> <li><code>@XmlElement</code>  \u2192 indica que \u00e9s un element XML</li> <li><code>@XmlAttribute</code> \u2192 indica que ser\u00e0 com un atribut</li> <li><code>@XmlElementWrapper</code> \u2192 indica que aquesta llista \u00e9s una colecci\u00f3 d'elements</li> <li><code>@XmlTransient</code> \u2192 indica que aquest atribut no es processa (com el JSONIgnore)</li> </ul>"},{"location":"UD1_Files/7_Llibreries_Conversores/#23-i-el-problema-de-la-recursio","title":"2.3. I el problema de la recursi\u00f3","text":"<p>La soluci\u00f3 per a la recursivitat en JAXB es fa normalment amb les anotacions @XmlID i @XmlIDREF. Vegem l'exemple amb Jugador i Equip</p> <ul> <li><code>@XmlID</code>: Es posa en un camp que actua com a identificador \u00fanic (i ha de ser de tipus <code>String</code>). Aquest ser\u00e0 l'id del nostre Equip.</li> <li><code>@XmlIDREF</code>: Es posa en el camp que fa la refer\u00e8ncia de tornada (el camp equip dins de Jugador). En lloc d'incrustar tot l'objecte, JAXB nom\u00e9s escriur\u00e0 el valor de l'identificador (@XmlID) de l'objecte referenciat.</li> </ul>"},{"location":"UD1_Files/7_Llibreries_Conversores/#24-exemple","title":"2.4. Exemple","text":"Classe JugadorClasse EquipCodi JavaXML resultant Java<pre><code>import com.fasterxml.jackson.annotation.JsonBackReference;\nimport jakarta.xml.bind.annotation.*;\n\n@XmlAccessorType(XmlAccessType.FIELD)\n@XmlType(propOrder = {\"id\",\"nom\",\"equip\"}) // Defineix l'ordre dels elements interns\npublic class Jugador {\n\n    @XmlElement\n    public long id;\n\n    @XmlElement\n    public String nom;\n\n    @XmlAttribute\n    public int dorsal;\n\n    @JsonBackReference()\n    @XmlIDREF   // &lt;-- Aquesta \u00e9s la clau per evitar la recursivitat!\n    public Equip equip;\n\n    // Constructors\n    public Jugador() {}\n\n    public Jugador(long id, String nom, int dorsal) {\n        this.id = id;\n        this.nom = nom;\n        this.dorsal = dorsal;\n    }\n\n    // Getters i Setters\n    public void setEquip(Equip equip) {\n        this.equip = equip;\n    }\n\n    // La resta de getters i setters s'ometen per brevetat\n}\n</code></pre> Java<pre><code>import com.fasterxml.jackson.annotation.JsonManagedReference;\nimport jakarta.xml.bind.annotation.*;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n@XmlRootElement(name = \"equip\")\n@XmlAccessorType(XmlAccessType.FIELD) // Processa els camps directament\npublic class Equip {\n\n    @XmlAttribute // L'ID de l'equip ser\u00e0 un atribut\n    @XmlID      // Aquest \u00e9s l'identificador \u00fanic per a JAXB\n    public String id; // Canviat a String per complir amb @XmlID que requereix String\n\n    @XmlElement\n    public String nom;\n\n    @JsonManagedReference\n    @XmlElementWrapper(name = \"elsJjugadors\") // Etiqueta que envoltar\u00e0 la llista\n    @XmlElement(name = \"jugador\")      // Nom per a cada element de la llista\n    public List&lt;Jugador&gt; jugadors;\n\n    // Constructors\n    public Equip() {\n        this.jugadors = new ArrayList&lt;&gt;();\n    }\n\n    public Equip(String id, String nom) {\n        this.id = id;\n        this.nom = nom;\n        this.jugadors = new ArrayList&lt;&gt;();\n    }\n\n    // M\u00e8tode d'ajuda per afegir jugadors i establir la relaci\u00f3\n    public void afegirJugador(Jugador jugador) {\n        this.jugadors.add(jugador);\n        jugador.setEquip(this);\n    }\n\n    // Getters i Setters (omesos per brevetat)\n}\n</code></pre> Java<pre><code>public  void testXML(String Filename){\n\n    try{\n            // 1. Creem l'equip i els jugadors\n            Equip valenciaCF = new Equip(\"Valencia2025\", \"Val\u00e8ncia CF\");\n\n            Jugador j1 = new Jugador(10, \"Pepelu\", 18);\n            Jugador j2 = new Jugador(20, \"Hugo Duro\", 9);\n\n            // 2. Vinculem els jugadors a l'equip\n            valenciaCF.afegirJugador(j1);\n            valenciaCF.afegirJugador(j2);\n\n            // 3. Creem el context JAXB per a les classes que utilitzarem\n            JAXBContext context = JAXBContext.newInstance(Equip.class);\n\n            // 4. Creem el Marshaller\n            Marshaller marshaller = context.createMarshaller();\n\n            // Configurem la propietat per a una sortida XML formatada (indentada)\n            marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);\n\n            // 5. Convertim l'objecte a XML i ho mostrem per la sortida est\u00e0ndard\n            System.out.println(\"--- Resultat XML Generat ---\");\n            marshaller.marshal(valenciaCF, System.out);\n\n            // 6. Tamb\u00e9 podem guardar el XML en un fitxer\n            if (Filename!=null &amp;&amp; !Filename.isEmpty()){\n                marshaller.marshal(valenciaCF, new java.io.File(Filename));\n            }\n        }\n    catch (JAXBException e) {\n        throw new RuntimeException(e);\n    }\n\n}\n</code></pre> XML<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?&gt;\n&lt;equip id=\"Valencia2025\"&gt;\n    &lt;nom&gt;Val\u00e8ncia CF&lt;/nom&gt;\n    &lt;elsJjugadors&gt;\n        &lt;jugador dorsal=\"18\"&gt;\n            &lt;id&gt;10&lt;/id&gt;\n            &lt;nom&gt;Pepelu&lt;/nom&gt;\n            &lt;equip&gt;Valencia2025&lt;/equip&gt;\n        &lt;/jugador&gt;\n        &lt;jugador dorsal=\"9\"&gt;\n            &lt;id&gt;20&lt;/id&gt;\n            &lt;nom&gt;Hugo Duro&lt;/nom&gt;\n            &lt;equip&gt;Valencia2025&lt;/equip&gt;\n        &lt;/jugador&gt;\n    &lt;/elsJjugadors&gt;\n&lt;/equip&gt;\n</code></pre>"},{"location":"UD1_Files/7_Llibreries_Conversores/#3-commons-csv","title":"3. Commons CSV","text":"<p>Finalment el format CSV el veurem sols mitjan\u00e7ant un exemple amb la llibreria <code>Commons CSV</code>. Caldr\u00e0 afegir:</p> XML<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;\n    &lt;artifactId&gt;commons-csv&lt;/artifactId&gt;\n    &lt;version&gt;1.11.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> Dades originals al CSVCLasse PeliculaCodi de c\u00e0rregaIxida del programa Text Only<pre><code>titol,director,any,generes\nInception,Christopher Nolan,2010,Sci-Fi\nThe Dark Knight,Christopher Nolan,2008,Action\nInterstellar,Christopher Nolan,2014,Sci-Fi\n,Bong Joon-ho,2019,Thriller\nJoker,Todd Phillips,2019,Crime\nAvengers: Endgame,Anthony Russo,2019,Action\n1917,Sam Mendes,2019,War\nTenet,,2020,Sci-Fi\nSoul,Pete Docter,2020,Animation\nKnives Out,Rian Johnson,2019,Mystery\nJojo Rabbit,Taika Waititi,2019,Comedy\nFord v Ferrari,James Mangold,2019,Drama\nThe Irishman,Martin Scorsese,,Crime\nOnce Upon a Time in Hollywood,Quentin Tarantino,2019,Drama\nLittle Women,Greta Gerwig,2019,Drama\nMarriage Story,Noah Baumbach,2019,Drama\nLa La Land,Damien Chazelle,2016,Musical\nDunkirk,Christopher Nolan,2017,War\nBlade Runner 2049,Denis Villeneuve,2017,Sci-Fi\nArrival,Denis Villeneuve,2016,Sci-Fi\n</code></pre> Java<pre><code>// Classe Pel\u00b7l\u00edcula\npublic class Pelicula {\n    private String titol;\n    private String director;\n    private int any;\n    private String genere;\n\n    public Pelicula(String titol, String director, int any, String genere) {\n        this.titol = titol;\n        this.director = director;\n        this.any = any;\n        this.genere = genere;\n    }\n\n    @Override\n    public String toString() {\n        return \"Pelicula{\" +\n                \"titol='\" + titol + '\\'' +\n                \", director='\" + director + '\\'' +\n                \", any=\" + any +\n                \", genere='\" + genere + '\\'' +\n                '}';\n    }\n}\n</code></pre> Java<pre><code>public void testCommonCSV(){\n    String csvFile = \"peliculas.csv\";  // Ruta del CSV\n    List&lt;Pelicula&gt; pelicules = new ArrayList&lt;&gt;();\n    int numRecords=0;\n    try{\n        FileReader reader = new FileReader(csvFile);\n\n        CSVFormat format = CSVFormat.DEFAULT.builder()\n                .setHeader()\n                .setSkipHeaderRecord(true)\n                .build();\n\n        CSVParser csvParser = new CSVParser(reader, format);\n\n        for (CSVRecord record : csvParser) {\n            numRecords++;\n            String titol = record.get(\"titol\");\n            String director = record.get(\"director\");\n            String anyStr = record.get(\"any\");\n            String genere = record.get(\"generes\");\n\n            // Comprovem si alguna dada \u00e9s nula o buida\n            if (titol == null || titol.isEmpty() ||\n                director == null || director.isEmpty() ||\n                anyStr == null || anyStr.isEmpty() ||\n                genere == null || genere.isEmpty()) {\n                continue;  // Saltar aquesta pel\u00b7l\u00edcula\n            }\n\n            int any = Integer.parseInt(anyStr);\n            Pelicula pelicula = new Pelicula(titol, director, any, genere);\n            pelicules.add(pelicula);\n        }\n    } catch (FileNotFoundException ex) {\n        throw new RuntimeException(ex);\n    } catch (IOException ex) {\n        throw new RuntimeException(ex);\n    }\n\n    System.out.print(Colors.green+\"S'han llegit \"+numRecords+\" registres\"+Colors.reset);\n    System.out.println(Colors.yellow+\". Per\u00f2 finalment llegides \" + pelicules.size()+ Colors.reset);\n    // Mostrem totes les pel\u00b7l\u00edcules carregades\n    for (Pelicula p : pelicules) {\n        System.out.println(p);\n    }\n}\n</code></pre> Text Only<pre><code>S'han llegit 20 registresPer\u00f2 finalment llegides 17\nPelicula{titol='Inception', director='Christopher Nolan', any=2010, genere='Sci-Fi'}\nPelicula{titol='The Dark Knight', director='Christopher Nolan', any=2008, genere='Action'}\nPelicula{titol='Interstellar', director='Christopher Nolan', any=2014, genere='Sci-Fi'}\nPelicula{titol='Joker', director='Todd Phillips', any=2019, genere='Crime'}\nPelicula{titol='Avengers: Endgame', director='Anthony Russo', any=2019, genere='Action'}\nPelicula{titol='1917', director='Sam Mendes', any=2019, genere='War'}\nPelicula{titol='Soul', director='Pete Docter', any=2020, genere='Animation'}\nPelicula{titol='Knives Out', director='Rian Johnson', any=2019, genere='Mystery'}\nPelicula{titol='Jojo Rabbit', director='Taika Waititi', any=2019, genere='Comedy'}\nPelicula{titol='Ford v Ferrari', director='James Mangold', any=2019, genere='Drama'}\nPelicula{titol='Once Upon a Time in Hollywood', director='Quentin Tarantino', any=2019, genere='Drama'}\nPelicula{titol='Little Women', director='Greta Gerwig', any=2019, genere='Drama'}\nPelicula{titol='Marriage Story', director='Noah Baumbach', any=2019, genere='Drama'}\nPelicula{titol='La La Land', director='Damien Chazelle', any=2016, genere='Musical'}\nPelicula{titol='Dunkirk', director='Christopher Nolan', any=2017, genere='War'}\nPelicula{titol='Blade Runner 2049', director='Denis Villeneuve', any=2017, genere='Sci-Fi'}\nPelicula{titol='Arrival', director='Denis Villeneuve', any=2016, genere='Sci-Fi'}\n</code></pre>"},{"location":"UD2_Connectors/1_Object_relational_impedance_mismatch/","title":"1. Desfassament objecte-relacional","text":"<p>Els Sistemes de Gesti\u00f3 de Bases de Dades (SGBD) es basen principalment en el model Entitat-Relaci\u00f3 (E/R), on la informaci\u00f3 s'emmagatzema en diverses taules relacionades entre si. \u00c9s una tecnologia senzilla i eficient, que ha resistit al pas dels anys i que encara \u00e9s el model utilitzat per la majoria de bases de dades i SGBD actualment. Malgrat el seu \u00e8xit, el model t\u00e9 algunes limitacions, com la representaci\u00f3 de informaci\u00f3 mal estructurada o complexa.</p> <p>Els models conceptuals ens ajuden a modelar una realitat complexa i es basen en un proc\u00e9s d'abstracci\u00f3 de la realitat. Cada model t\u00e9 una manera de capturar aquesta realitat, per\u00f2 tots ells estan m\u00e9s propers a la mentalitat humana que a la mem\u00f2ria d'un ordinador.</p> <p>Quan modelitzem una base de dades, fem servir el model conceptual d'Entitat-Relaci\u00f3 i posteriorment fem un proc\u00e9s de transformaci\u00f3 en taules i normalitzaci\u00f3 d'aquest model per obtenir un model de dades relacional.</p> <p>En el cas de la programaci\u00f3 orientada a objectes, intentem representar la realitat mitjan\u00e7ant objectes i les relacions entre ells. Aquest \u00e9s un altre tipus de model conceptual, per\u00f2 que t\u00e9 com a objectiu representar la mateixa realitat que el model relacional.</p> <p>Aix\u00ed doncs, tenim dues aproximacions diferents per representar la realitat d'un problema: el Model Relacional de la base de dades i el model Orientat a Objectes de les nostres aplicacions.</p>"},{"location":"UD2_Connectors/1_Object_relational_impedance_mismatch/#11-representacio-de-la-informacio-amb-el-model-relacional","title":"1.1. Representaci\u00f3 de la informaci\u00f3 amb el model relacional","text":"<p>El model relacional es basa en taules i la relaci\u00f3 entre elles:</p> <ul> <li>Cada taula t\u00e9 tantes columnes com atributs volem representar i tantes files com registres o elements d'aquest tipus cont\u00e9.</li> <li>Les taules tenen una clau prim\u00e0ria, que identifica cada un dels registres, i pot estar formada per un o m\u00e9s atributs.</li> <li>La relaci\u00f3 entre taules es representa mitjan\u00e7ant claus externes, que consisteixen en incloure en una taula la clau prim\u00e0ria d'una altra taula, com a refer\u00e8ncia a aquesta. Quan s'elimina un registre d'una taula, la clau prim\u00e0ria del qual \u00e9s referenciada per un altre, s'ha de garantir que es mant\u00e9 la integritat referencial de la base de dades. Aleshores, abans d'aquesta eliminaci\u00f3 d'una clau prim\u00e0ria, podem:<ul> <li>No permetre l'eliminaci\u00f3 (NO ACTION),</li> <li>Realitzar l'eliminaci\u00f3 en cascada, eliminant tamb\u00e9 tots els registres que feien refer\u00e8ncia a la clau prim\u00e0ria del registre eliminat (CASCADE),</li> <li>Establir a null (SET NULL), de manera que la clau externa que feia refer\u00e8ncia a la clau prim\u00e0ria de l'altra taula prengui el valor de <code>NULL</code>.</li> </ul> </li> <li>Els diferents camps de les taules tamb\u00e9 poden tenir certes restriccions associades, com ara:<ul> <li>Restricci\u00f3 de valor no nul, de manera que el camp no pot ser nul en cap cas,</li> <li>Restricci\u00f3 d'unicitat en un o diversos camps, de manera que el valor ha de ser \u00fanic a tota la taula.</li> <li>Restricci\u00f3 de domini, o el que \u00e9s el mateix, pot tenir un conjunt de valors possibles per defecte.</li> </ul> </li> </ul> <p>Atenci\u00f3</p> <p>Primary keys have both properties: non-null value and uniqueness.</p>"},{"location":"UD2_Connectors/1_Object_relational_impedance_mismatch/#111-exemple","title":"1.1.1. Exemple","text":"<p>Una base de dades per emmagatzemar informaci\u00f3 sobre jugadors, jocs, etc., pot ser aix\u00ed:</p> <p></p> <p>Implementada amb el SGBD <code>MySQL</code>:</p> SQL<pre><code>CREATE SCHEMA IF NOT EXISTS `BDJocs` DEFAULT CHARACTER SET utf8 ;\nUSE `BDJocs` ;\n\nCREATE TABLE IF NOT EXISTS `BDJocs`.`jugador` (\n  `id` INT NOT NULL,\n  `nick` VARCHAR(45) NULL,\n  `dataRegistre` DATETIME NULL,\n  PRIMARY KEY (`id`))\nENGINE = InnoDB;\n\nCREATE TABLE IF NOT EXISTS `BDJocs`.`Genere` (\n  `id` INT NOT NULL,\n  `nom` VARCHAR(45) NULL,\n  `descripci\u00f3` VARCHAR(256) NULL,\n  PRIMARY KEY (`id`))\nENGINE = InnoDB;\n\nCREATE TABLE IF NOT EXISTS `BDJocs`.`Joc` (\n  `id` INT NOT NULL,\n  `nom` VARCHAR(45) NULL,\n  `descripci\u00f3` VARCHAR(256) NULL,\n  `Genere_id` INT NOT NULL,\n  PRIMARY KEY (`id`),\n  INDEX `fk_Joc_Genere1_idx` (`Genere_id` ASC),\n  CONSTRAINT `fk_Joc_Genere1`\n    FOREIGN KEY (`Genere_id`)\n    REFERENCES `BDJocs`.`Genere` (`id`)\n    ON DELETE NO ACTION\n    ON UPDATE NO ACTION)\nENGINE = InnoDB;\n\nCREATE TABLE IF NOT EXISTS `BDJocs`.`Puntuacions` (\n  `jugador_id` INT NOT NULL,\n  `Joc_id` INT NOT NULL,\n  `puntuacio` INT NULL,\n  PRIMARY KEY (`jugador_id`, `Joc_id`),\n  INDEX `fk_jugador_has_Joc_Joc1_idx` (`Joc_id` ASC),\n  INDEX `fk_jugador_has_Joc_jugador1_idx` (`jugador_id` ASC),\n  CONSTRAINT `fk_jugador_has_Joc_jugador1`\n    FOREIGN KEY (`jugador_id`)\n    REFERENCES `BDJocs`.`jugador` (`id`)\n    ON DELETE NO ACTION\n    ON UPDATE NO ACTION,\n  CONSTRAINT `fk_jugador_has_Joc_Joc1`\n    FOREIGN KEY (`Joc_id`)\n    REFERENCES `BDJocs`.`Joc` (`id`)\n    ON DELETE NO ACTION\n    ON UPDATE NO ACTION)\nENGINE = InnoDB;\n</code></pre>"},{"location":"UD2_Connectors/1_Object_relational_impedance_mismatch/#12-representacio-de-la-informacio-amb-el-model-orientat-a-objectes","title":"1.2. Representaci\u00f3 de la informaci\u00f3 amb el model orientat a objectes","text":"<p>Com l'entitat-relaci\u00f3, el model orientat a objectes \u00e9s un model de dades conceptual, per\u00f2 que d\u00f3na import\u00e0ncia a la modelitzaci\u00f3 dels objectes.</p> <p>Un objecte pot representar qualsevol element conceptual: entitats, processos, accions... Un objecte no nom\u00e9s representa les caracter\u00edstiques o propietats, sin\u00f3 que tamb\u00e9 es centra en els processos que pateixen. En termes del model orientat a objectes, diem que un objecte \u00e9s dades m\u00e9s operacions o comportament.</p> <p>A la unitat introduct\u00f2ria ja vam revisar la programaci\u00f3 orientada a objectes, aix\u00ed que ens limitarem a una breu revisi\u00f3 dels conceptes principals:</p> <ul> <li>Un objecte \u00e9s una entitat amb certes propietats i cert comportament.</li> <li>En termes de POO, les propietats es coneixen com a atributs, i el conjunt dels seus valors determina l'estat de l'objecte en un moment donat.</li> <li>El comportament est\u00e0 determinat per una s\u00e8rie de funcions i procediments que anomenem m\u00e8todes, i que modifiquen l'estat de l'objecte.</li> <li>Un objecte tamb\u00e9 tindr\u00e0 un nom amb el qual s'identifica.</li> <li>Una classe \u00e9s una abstracci\u00f3 d'un conjunt d'objectes, i un objecte ha de pert\u00e0nyer necess\u00e0riament a alguna classe.</li> <li>Les classes defineixen els atributs i m\u00e8todes que els objectes d'aquesta classe tindran.</li> <li>Un objecte es diu que \u00e9s una inst\u00e0ncia d'una classe.</li> </ul> <p>El mateix exemple que hem representat recentment, amb una representaci\u00f3 orientada a objectes podria ser:</p> <p></p> <p>Com podem veure, t\u00e9 una estructura similar, a la qual tamb\u00e9 hem afegit alguns m\u00e8todes com ara getters i setters. A m\u00e9s, les diferents classes no tenen un atribut identificador, ja que cada objecte s'identifica a si mateix. Aqu\u00ed tenim una petita aproximaci\u00f3 de com implementar\u00edem aquesta jerarquia en Java.</p> <p>La classe <code>Genere</code> \u00e9s una classe POJO, que nom\u00e9s emmagatzema informaci\u00f3 (nom i descripci\u00f3 del tipus de joc) i implementa getters i setters.</p> Java<pre><code>public class Genere {\n    protected String nom;\n    protected String descripcio;\n\n    public Genere(String nom, String descripcio) {\n        this.nom = nom;\n        this.descripcio = descripcio;\n    }\n\n    public String getNom() {return nom;}\n    public void setNom(String nom) {this.nom = nom;}\n\n    public String getDescripcio() {return descripcio;}\n    public void setDescripcio(String descripcio) {\n        this.descripcio = descripcio;\n    }\n}\n</code></pre> <p>La classe <code>Joc</code> emmagatzema el nom, la descripci\u00f3 i el g\u00e8nere del joc. A difer\u00e8ncia del model relacional, on el que s'emmagatzema seria una clau externa al g\u00e8nere, ja que aqu\u00ed no tenim claus externes, emmagatzemem l'objecte mateix (la refer\u00e8ncia).</p> Java<pre><code>public class Joc {\n\n    protected String nom;\n    protected String descripcio;\n    protected Genere genere;\n\n    public Joc(String nom, String descripcio, Genere genere) {\n        this.nom = nom;\n        this.descripcio = descripcio;\n        this.genere = genere;\n\n    }\n\n    public String getNom() {return this.nom;}\n    public void setNom(String nom) {this.nom = nom;}\n\n    public String getDescripcio() {return this.descripcio;}\n    public void setDescripcio(String descripcio) {\n        this.descripcio= descripcio;\n    }\n\n    public Genere getGenere() {return this.genere;}\n\n    public void setGenere(Genere genere) {this.genere = genere;}\n}\n</code></pre> <p>La classe <code>Registre</code> presenta la relaci\u00f3 entre <code>Jugador</code> i <code>Joc</code> (quan un jugador juga a un joc) i emmagatzema els punts i una refer\u00e8ncia al joc.</p> Java<pre><code>public class Registre {\n    private int puntuacio;\n    private Joc joc;\n\n    public Registre(int puntuacio, Joc joc) {\n        this.puntuacio = puntuacio;\n        this.joc = joc;\n    }\n\n    public int getPuntuacio() {return puntuacio;}\n    public void setPuntuacio(int puntuacio) {\n        this.puntuacio = puntuacio;\n    }\n\n    public Joc getJoc() {return joc;}\n\n    public void setJoc(Joc joc) {this.joc = joc;}   \n}\n</code></pre> <p>I finalment, la classe <code>Jugador</code> emmagatzema el sobrenom i la data de registre per a cada jugador, i despr\u00e9s, un array amb tots els jocs que el jugador ha jugat:</p> Java<pre><code>public class Jugador {\n\n    private String nick;\n    private Date dataRegistre;\n    private Set&lt;Registre&gt; puntuacions;\n\n    public Jugador(String nick, Date dataRegistre) {\n        this.nick = nick;\n        this.dataRegistre = dataRegistre;\n    }\n\n    public String getNick() {return nick;}\n    public void setNick(String nick) {this.nick = nick;}\n\n    public Date getDataRegistre() {return dataRegistre;}\n    public void setDataRegistre(Date dataRegistre) {\n        this.dataRegistre = dataRegistre;\n    }\n\n    public Set getPuntuacions() {return this.puntuacions;}\n    public void setPuntuacio(Joc joc, int puntuacio) {\n        Registre registre = new Registre(puntuacio, joc);\n        this.puntuacions.add(registre);\n    }\n}\n</code></pre> <p>La interf\u00edcie <code>Set</code> i la classe <code>HashSet</code></p> <p><code>Set</code> \u00e9s una interf\u00edcie del paquet <code>java.util</code> que tracta una col\u00b7lecci\u00f3 o conjunt d'elements sense desordre i sense duplicats.</p> <p>D'altra banda, <code>HashSet</code> \u00e9s una classe que implementa la interf\u00edcie <code>Set</code> i que es basa en una taula de hash, una estructura de dades que permet localitzar objectes basant-se en una clau que indica la posici\u00f3 a la taula, permetent l'acc\u00e9s directe a l'element, el que els fa ideals per a cerques, insercions i eliminacions.</p>"},{"location":"UD2_Connectors/1_Object_relational_impedance_mismatch/#13-model-relacional-vs-model-orientat-a-objectes","title":"1.3. Model Relacional vs Model Orientat a Objectes","text":"<p>Conceptualment, el model orientat a objectes \u00e9s un model din\u00e0mic, que es centra en els objectes i en els processos que aquests experimenten, per\u00f2 que no t\u00e9 en compte, des del principi, la seva persist\u00e8ncia. Hem de ser capa\u00e7os, per tant, de guardar els estats dels objectes de manera permanent i carregar-los quan l'aplicaci\u00f3 els necessiti, aix\u00ed com mantenir la consist\u00e8ncia entre aquestes dades emmagatzemades i els objectes que les representen a l'aplicaci\u00f3.</p> <p>Una manera d'oferir aquesta persist\u00e8ncia als objectes seria utilitzar un SGBD Relacional, per\u00f2 ens trobarem amb algunes complicacions. La primera, des d'un punt de vista conceptual, \u00e9s que el model Entitat-Relaci\u00f3 es centra en les dades, mentre que el model orientat a objectes es centra en els objectes, entesos com a grups de dades i les operacions realitzades sobre ells.</p> <p>Una altra difer\u00e8ncia, for\u00e7a important, \u00e9s la vinculaci\u00f3 dels elements entre un model i un altre. D'una banda, el model relacional afegeix informaci\u00f3 addicional a les taules en forma de clau externa, mentre que en el model orientat a objectes no necessitem aquesta dada externa, sin\u00f3 que la vinculaci\u00f3 entre objectes es fa a trav\u00e9s de refer\u00e8ncies entre ells. Un objecte, per exemple, no necessitar\u00e0 una clau prim\u00e0ria, ja que l'objecte s'identifica per si mateix.</p> <p>Com hem vist a l'exemple de les seccions anteriors, les taules en el model relacional tenien una clau prim\u00e0ria per identificar els objectes i claus externes per expressar les relacions, mentre que en el model orientat a objectes aquestes desapareixen, expressant les relacions entre objectes mitjan\u00e7ant refer\u00e8ncies. A m\u00e9s, la manera com s'expressen aquestes relacions tamb\u00e9 \u00e9s diferent. En el model relacional, per exemple, el registre de puntuacions \u00e9s una taula que enlla\u00e7a la taula de jugadors amb la taula de jocs i afegeix la puntuaci\u00f3 del jugador en el joc. D'altra banda, en la implementaci\u00f3 en Java que hem fet, tenim objectes de tipus <code>Registre</code> que emmagatzemen una puntuaci\u00f3 i una refer\u00e8ncia al joc, per\u00f2 \u00e9s la classe Jugador la que mant\u00e9 el conjunt de registres de les seves puntuacions.</p> <p>D'altra banda, en manipular les dades, cal tenir en compte que el model relacional disposa de llenguatges (principalment SQL) dissenyats exclusivament per a aquest prop\u00f2sit, mentre que en un llenguatge orientat a objectes funciona de manera diferent, per la qual cosa ser\u00e0 necessari incorporar mecanismes que permetin fer aquestes consultes des del llenguatge de programaci\u00f3. A m\u00e9s, quan obtenim els resultats de la consulta, tamb\u00e9 ens trobem amb un altre problema, i \u00e9s la conversi\u00f3 dels resultats. Quan es fa una consulta a una base de dades, sempre es retorna un resultat en forma de taula, per la qual cosa ser\u00e0 necessari transformar aquests resultats en estats dels objectes de l'aplicaci\u00f3.</p> <p>Totes aquestes difer\u00e8ncies impliquen el que es coneix com a desfassament relacional-objecte, i que ens obligar\u00e0 a fer determinades conversions entre objectes i taules quan volem guardar la informaci\u00f3 en un SGBD. En aquesta unitat i en les seg\u00fcents, veurem com superar aquest retard des de diferents enfocaments.</p>"},{"location":"UD2_Connectors/2_Connectors/","title":"1. Connectors","text":""},{"location":"UD2_Connectors/2_Connectors/#11-larquitectura-client-servidor-en-sgbd","title":"1.1. L'arquitectura client-servidor en SGBD","text":"<p>Un cop coneixem el retard relacional-objecte, centrem-nos en com accedir a bases de dades relacionals des dels llenguatges de programaci\u00f3. Els SGBD, es van popularitzar als anys 80, i s\u00f3n els m\u00e9s estesos actualment. Llevat d'algunes excepcions, funcionen seguint una arquitectura client-servidor, de manera que tenim un servidor on executa el SGBD i diversos clients que es connecten al servidor i fan les peticions corresponents.</p> <p>Els SGBD oferien els seus propis llenguatges de programaci\u00f3, per\u00f2 estaven molt lligats a ells, i el manteniment de l'aplicaci\u00f3 era molt car. Per aquest motiu, la tend\u00e8ncia era desacoblar (separar) els SGBD del llenguatge de programaci\u00f3, i fer \u00fas d'est\u00e0ndards de connexi\u00f3 entre ells.</p> <p>Gr\u00e0cies a l'arquitectura client-servidor, els SGBD van poder separar les dades d'una banda i els programes per accedir-hi per altres. Aquesta versatilitat tenia un petit inconvenient, i \u00e9s que calia desenvolupar d'una banda el servidor, per\u00f2 de l'altra, tamb\u00e9 la part del client per poder connectar-se als servidors. Aquestes connexions entre clients i servidors requeriran protocols i llenguatges espec\u00edfics. Aqu\u00ed neix el concepte de middleware, ent\u00e8s com una capa interm\u00e8dia de persist\u00e8ncia, formada per biblioteques, llenguatges i protocols ubicats al client i al servidor i que permeten connectar la base de dades amb les aplicacions.</p> <p>Tot i que inicialment cada SGBD va implementar solucions espec\u00edfiques, es van imposar est\u00e0ndards, entre els quals trobem el llenguatge de consulta SQL (Structured Query Language), i que va suposar un gran avan\u00e7, ja que va unificar la manera d'accedir a les bases de dades, encara que les aplicacions van continuar requereixen una API per fer \u00fas de SQL.</p>"},{"location":"UD2_Connectors/2_Connectors/#12-protocols-dacces-a-bases-de-dades","title":"1.2. Protocols d'acc\u00e9s a bases de dades","text":"<p>Quan parlem de protocols d'acc\u00e9s a bases de dades, ens trobem amb dues regles principals de connexi\u00f3:</p> <ul> <li>ODBC (Open Data Base Connectivity): Aquesta \u00e9s una API (Application Program Interface) desenvolupada per Microsoft per a sistemes Windows que permet afegir diferents connectors a diverses bases de dades relacionals basades en SQL, d'una manera senzilla i transparent. Utilitzant ODBC, les aplicacions poden obrir connexions a la base de dades, enviar consultes, actualitzacions i gestionar els resultats.</li> <li>JDBC (Java Database Connectivity), que defineix una API multiplataforma que els programes Java poden utilitzar per connectar-se al SGBD.</li> </ul>"},{"location":"UD2_Connectors/2_Connectors/#13-jdbc","title":"1.3. JDBC","text":"<p>Com hem dit, JDBC \u00e9s una API de connexi\u00f3 a bases de dades espec\u00edfica de Java. El seu mode de funcionament \u00e9s el seg\u00fcent:</p> <ul> <li>S'ofereix una API, encapsulada en classes, que garanteix uniformitat en la manera en qu\u00e8 les aplicacions es connecten a la base de dades, independentment del SGBD subjacent.</li> <li>Necessitarem un controlador per a cada base de dades a la qual volem connectar-nos. Java no t\u00e9 cap llibreria ODBC espec\u00edfica, per\u00f2, per no perdre el potencial d'aquestes connexions, s'han incorporat controladors especials que actuen com a adaptadors entre JDBC i ODBC, de manera que \u00e9s possible, a trav\u00e9s d'aquest pont, connectar qualsevol aplicaci\u00f3 Java amb qualsevol connexi\u00f3 ODBC. Actualment, gaireb\u00e9 tots els SGBD tenen controladors JDBC, per\u00f2 en cas que no en tingueu coneixement, podeu fer servir aquest pont ODBC-JDBC.</li> </ul>"},{"location":"UD2_Connectors/2_Connectors/#131-arquitectura-jdbc","title":"1.3.1. Arquitectura JDBC","text":"<p>La biblioteca est\u00e0ndard JDBC proporciona un conjunt d'interf\u00edcies independents de la implementaci\u00f3. Els controladors de cada DBMS seran els encarregats de la implementaci\u00f3. Les aplicacions, per accedir a la base de dades, hauran d'utilitzar les interf\u00edcies JDBC, de manera que la implementaci\u00f3 de cada DBMS sigui completament transparent per a l'aplicaci\u00f3.</p> <p></p> <p>Com podem veure, les aplicacions Java accedeixen als diferents m\u00e8todes que l'API especifica com a interf\u00edcies, per\u00f2 s\u00f3n els controladors els que accedeixen a la base de dades.</p> <p>Cal dir que les aplicacions poden utilitzar diversos controladors JDBC simult\u00e0niament i accedir, per tant, a m\u00faltiples bases de dades. L'aplicaci\u00f3 especifica un controlador JDBC utilitzant una URL (Universal Resource Locator) al gestor de controladors, i aquest \u00e9s el responsable d'establir correctament les connexions amb les bases de dades a trav\u00e9s dels controladors. Els controladors poden ser de diferents tipus:</p> <ul> <li>Tipus I o controladors de pont, caracteritzats per fer \u00fas de tecnologia externa a JDBC i actuar com a adaptadors entre JDBC i la tecnologia espec\u00edfica utilitzada. Un exemple \u00e9s el pont JDBC-ODBC.</li> <li>Tipus II o controladors amb API parcialment nativa, o controladors natius. Estan entrenats d'una banda en Java i de l'altra fan \u00fas de llibreries del sistema operatiu. El seu \u00fas es deu a alguns SGBD que incorporen connectors propietaris que no segueixen cap est\u00e0ndard (normalment pre-ODBC/JDBC).</li> <li>Tipus III o controladors Java a trav\u00e9s de protocol de xarxa, que s\u00f3n controladors desenvolupats en Java que tradueixen les crides JDBC a un protocol de xarxa contra un servidor intermedi. \u00c9s un sistema molt flexible, ja que els canvis en la implementaci\u00f3 de la base de dades no afecten les aplicacions.</li> <li>Tipus IV o 100% Java pures, tamb\u00e9 anomenats protocol natius, i aquests s\u00f3n controladors escrits \u00edntegrament en Java. Les sol\u00b7licituds al SGBD es realitzen a trav\u00e9s del protocol de xarxa que utilitza el mateix SGBD, de manera que no \u00e9s necessari cap codi natiu al client ni un servidor intermediari. \u00c9s l'alternativa que s'ha acabat imposant, ja que no requereix cap tipus d'instal\u00b7laci\u00f3.</li> </ul>"},{"location":"UD2_Connectors/2_Connectors/#14-mysql-docker-workbench","title":"1.4. MySQL, Docker, Workbench","text":"<p>Aquest any farem servir MySQL com a SGBD, per la seva \u00e0mplia utilitzaci\u00f3 en diversos contextos i per la seva simplicitat. Per utilitzar-lo, has d'instal\u00b7lar <code>mysql-server</code> com a servei al teu sistema, com has estudiat els \u00faltims anys.</p> <p>El servidor MySQL es pot instal\u00b7lar al teu ordinador, o b\u00e9 pots instal\u00b7lar-lo en una m\u00e0quina virtual o configurar-lo com a contenidor Docker. Per tenir un sistema m\u00e9s net, l'opci\u00f3 recomanada \u00e9s amb contenidor Docker, ja que podr\u00e0s executar diverses versions de MySQL sense interfer\u00e8ncies entre elles.</p> <p>Note</p> <p>Teniu una documentaci\u00f3 addicional sobre com crear un contenidor MySQL en un document anomenat Docker per a MySQL. Aix\u00ed doncs, i pel que fa a la resta del document, assumirem que ja teniu la imatge de Docker de MySQL i un contenidor en execuci\u00f3 al port <code>3308</code> (MySQL utilitza el port 3306 per defecte, per\u00f2 en el nostre contenidor exposarem el servei al port 3308, en cas que ja tingueu un servidor MySQL local en execuci\u00f3 al port 3306).</p> Bash<pre><code># Remember that to create the container (only fisrt time)\n\ndocker run --name mysql-srv\n      -p 3308:3306\n      -e MYSQL_ROOT_PASSWORD=\"root\"\n      -d mysql:latest\n\n# It will create and start the container\n\n# To stop the container\ndocker stop mysql-srv\n\n# And to start the container ( AVOID TO run IT AGAIN !!!)\ndocker start mysql-srv\n</code></pre> <p>I finalment, per\u00f2 no menys important, evidentment, podeu utilitzar una eina gr\u00e0fica per accedir a MySQL, com ara <code>mysql-workbench</code> o <code>dbeaver</code>. Heu de configurar una connexi\u00f3 al port de Docker:</p> <p></p> <p>Espai</p> <p>Revisa les notes del teu m\u00f2dul de bases de dades sobre com treballar amb Workbench:</p> Text Only<pre><code>- Carrega i executa scripts SQL\n- Recupera l'estructura de la base de dades\n- Edita i crea SQL\n- Edita i guarda dades\n</code></pre> <p>Disposes del scrip Esquema BD Jocs per carregar els exemples dels apunts</p>"},{"location":"UD2_Connectors/3_Connecting/","title":"1. Connectant a bases de dades","text":""},{"location":"UD2_Connectors/3_Connecting/#11-controlador-jdbc-de-mysql","title":"1.1. Controlador JDBC de MySQL","text":"<p>Per tal de crear programes Java utilitzant el controlador de MySQL, necessitem carregar-lo en el nostre programa i pr\u00e8viament en el nostre entorn de desenvolupament. Com utilitzarem <code>Gradle</code>, anem a veure com fer-ho:</p> <ol> <li>Hem de trobar la versi\u00f3 del controlador del nostre servidor JDBC, i ho podem trobar al repositori central de Maven https://mvnrepository.com.</li> <li>Cerquem <code>mysql jdbc</code>, i obtindrem com a primer resultat MySQL Connector/J.</li> <li>Assegureu-vos de seleccionar la versi\u00f3 correcta, i despr\u00e9s seleccioneu el gestor de paquets (gradle, maven, etc.) i obtindreu:</li> </ol> Bash<pre><code>// https://mvnrepository.com/artifact/mysql/mysql-connector-java\nimplementation group: 'mysql', name: 'mysql-connector-java', version: '8.0.30'\n</code></pre> <ol> <li>Quan deseu o compileu el vostre projecte, podreu importar els controladors correctament.</li> </ol> <p></p>"},{"location":"UD2_Connectors/3_Connecting/#12-url-de-connexio","title":"1.2. URL de connexi\u00f3","text":"<p>Un cop hagueu importat el controlador, heu de dir al vostre programa Java com connectar-vos a la vostra base de dades i finalment connectar-vos-hi. Per a aquesta tasca, hem de crear una <code>Connection</code> utilitzant una URL especial anomenada URL de connexi\u00f3. Com altres URL, una URL de connexi\u00f3 pot contenir:</p> <ul> <li>Protocol \\(\\rightarrow\\) utilitzarem <code>jdbc</code>.</li> <li>SGBD \\(\\rightarrow\\) podr\u00edem utilitzar <code>mysql</code>, <code>postgres</code>, <code>sqlite</code>, <code>sqlserver</code> o qualsevol SGBD amb un connector JDBC.</li> <li>Adre\u00e7a del servidor \\(\\rightarrow\\) podem utilitzar tant un nom complet com l'adre\u00e7a IP del servidor.</li> <li>[opcional]Port \\(\\rightarrow\\) el port on el servidor est\u00e0 escoltant. Si no s'utilitza cap, el controlador intentar\u00e0 connectar-se al port per defecte. Recordeu separar el port de l'adre\u00e7a amb <code>:</code>.</li> <li>Altres par\u00e0metres, separant-los amb <code>?</code> al principi i amb <code>&amp;</code> entre els par\u00e0metres. Per exemple:<ul> <li>user=<code>usuari</code></li> <li>pass=<code>contrasenya</code></li> <li>useUnicode=<code>true</code></li> <li>characterEncoding=<code>UTF-8</code></li> </ul> </li> </ul> <p>Una mostra de URL de connexi\u00f3 pot ser:</p> Java<pre><code>String connectionUrl = \"jdbc:mysql://localhost:3308/Cycling?useUnicode=true&amp;characterEncoding=UTF-8&amp;user=root&amp;password=root\";\n</code></pre> <p>Una opci\u00f3 millor seria:</p> Java<pre><code>String server=\"localhost\";\nint port=3308;\nString user=\"root\";\nString pass=\"root\";\nString DBName=\"Cycling\";\nString connectionUrl = \"jdbc:mysql://\"+server+\":\"+port;\nconnectionUrl+=\"/\" + DBName;\nconnectionUrl+=\"?useUnicode=true&amp;characterEncoding=UTF-8\";\nconnectionUrl+=\"&amp;user=\"+user;\nconnectionUrl+=\"&amp;password=\"+pass;\n</code></pre> <p>Atenci\u00f3</p> <p>Tingueu en compte que tots dos exemples s\u00f3n codi hard-coded, ja que teniu els valors del servidor (usuari i contrasenya) escrits dins de cadenes de text. \u00c9s millor opci\u00f3 emmagatzemar aquests valors dins de variables o fitxers de propietats.</p>"},{"location":"UD2_Connectors/3_Connecting/#13-classe-connection","title":"1.3. Classe <code>Connection</code>","text":"<p>En Java, la classe necess\u00e0ria per gestionar el controlador \u00e9s <code>java.sql.DriverManager</code>. Intenta carregar els controladors del sistema quan llegeix la propietat dels controladors JDBC, per\u00f2 podem indicar que es carregui utilitzant la instrucci\u00f3:</p> Java<pre><code>Class.forName(\"com.mysql.cj.jdbc.Driver\");\n</code></pre> <p>La classe que centralitzar\u00e0 totes les operacions amb la base de dades \u00e9s <code>java.sql.Connection</code>, i l'hem d'obtenir des del <code>DriverManager</code> amb qualsevol dels 3 m\u00e8todes est\u00e0tics que t\u00e9:</p> <ul> <li><code>static Connection getConnection(String url)</code> \\(\\rightarrow\\) Retorna una connexi\u00f3, si \u00e9s possible, a la base de dades amb els par\u00e0metres especificats a la URL de connexi\u00f3. Recordeu de crear una URL de connexi\u00f3 a partir de la part anterior.</li> <li><code>static Connection getConnection(String url, Properties info)</code> \\(\\rightarrow\\) Retorna una connexi\u00f3, si \u00e9s possible, a la base de dades, amb alguns par\u00e0metres especificats a la URL i altres en un objecte de propietats (<code>Properties</code> classe estudiada a la unitat 1). Veurem exemples m\u00e9s endavant.</li> <li><code>static Connection getConnection(String url, String user, String pass)</code> \\(\\rightarrow\\) Retorna una connexi\u00f3, si \u00e9s possible, a la base de dades amb els par\u00e0metres especificats a la URL. Les dades d'usuari i contrasenya es proporcionen en dos par\u00e0metres addicionals, de manera que no cal escriure'ls a la URL de connexi\u00f3.</li> </ul> <p>Una mostra inicial ser\u00e0:</p> Java<pre><code>public static void main (String [] args ) \n  throws ClassNotFoundException, SQLException{\n\n    Class.forName(\"com.mysql.cj.jdbc.Driver\");\n    String server=\"localhost\";\n    int port=3308;\n    String user=\"root\";\n    String pass=\"root\";\n    String DBName=\"Cycling\";\n    String connectionUrl = \"jdbc:mysql://\"+server+\":\"+port;\n    connectionUrl+=\"/\" + DBName;\n    connectionUrl+=\"?useUnicode=true&amp;characterEncoding=UTF-8\";\n\n   Connection conn = DriverManager.getConnection(connectionUrl,user,pass);\n\n   // if no exception is catched, you are connected to your DBMS\n</code></pre> <p>Amb l'objecte <code>Connection</code> que tenim ara connectat, enviarem les nostres consultes i demanarem informaci\u00f3, com veurem m\u00e9s endavant.</p>"},{"location":"UD2_Connectors/3_Connecting/#14-organitzant-la-nostra-connexio","title":"1.4. Organitzant la nostra connexi\u00f3","text":"<p>La nostra aplicaci\u00f3 s'ha de connectar a una (o m\u00e9s) bases de dades. Podem fer moltes peticions a aquestes base de dades, i si estem implementant una aplicaci\u00f3 multithreaded, el nombre de peticions pot augmentar molt. Per aix\u00f2, hem de controlar on i quan es creen i es tanquen les connexions. Una bona idea \u00e9s crear una classe que encapsuli tots aquests processos. L'esquelet d'aquesta classe seria el seg\u00fcent:</p> Java<pre><code>public class ConnexioBD {\n\n    private Connection laConnexio = null;\n\n    // write here access variables, like user, server or whatever\n\n    private void connect() {\n        // do the connetion (look the sample). \n        // Take care. private method. It will be called inside the class\n    }\n\n    // close connection, if it's opened\n    public void disConnect() {\n        if (laConnexio != null) {\n            laConnexio.close();\n        }\n    }\n\n    // returns the connection. \n    // It will be create first time of after closed\n    public Connection getConexio(){\n        if (laConnexio == null) {\n            this.connect();\n        }\n        return this.laConnexio;\n    } \n}\n</code></pre>"},{"location":"UD2_Connectors/3_Connecting/#141-exercici-resolt","title":"1.4.1. Exercici resolt","text":"<p>Crea un projecte \u00fanic amb dues classes. Una per connectar-te a la teva base de dades, com l'\u00faltim exemple, i una classe principal que es connecti i mostri si hi ha hagut algun error.</p> <p>La soluci\u00f3 de l'exercici est\u00e0 enlla\u00e7ada aqu\u00ed connexio.properties i ConnexioDB.java</p>"},{"location":"UD2_Connectors/4_Resultset/","title":"1. Classe <code>ResultSet</code>.","text":"<p>Ara que estem connectats a la base de dades, \u00e9s hora de comen\u00e7ar a demanar informaci\u00f3 al DBMS. Aquesta informaci\u00f3 es proporcionar\u00e0 en forma de consultes (SQL) o altres m\u00e8todes, per\u00f2 gaireb\u00e9 el 90% de les vegades, com en el cas de les consultes SQL, la informaci\u00f3 retornada es troba en un format tabular. Els formats tabulars s\u00f3n ben coneguts perqu\u00e8 programes com MySQL Workbench o DBeaver mostren les dades d'aquesta manera.</p> <p>En Java, la classe que permet treballar amb dades en format tabular provinents de bases de dades es diu <code>Resultset</code>. Un <code>Resultset</code> est\u00e0 compost per una taula (files i columnes) i un punter a una fila, anomenat cursor.</p> <p></p> <ol> <li>Quan recuperem dades de les bases de dades, la informaci\u00f3 es guarda a la taula i el cursor apunta a una fila imagin\u00e0ria buida anomenada <code>beforeFirst</code>.</li> <li><code>Resultset</code> cont\u00e9 un m\u00e8tode especial anomenat <code>next()</code>, que fa dues accions:</li> <li>Retorna <code>true</code> si hi ha una fila de dades despr\u00e9s de la fila actual apuntada pel cursor i <code>false</code> en cas contrari.</li> <li>Avan\u00e7a el cursor i apunta a la seg\u00fcent fila, sols si hi havia una.</li> <li>Quan el cursor d'un <code>Resultset</code> retorna <code>false</code>, significa que s'han visitat totes les files i ara el cursor apunta a una altra fila imagin\u00e0ria anomenada <code>afterLast</code>.</li> </ol> <p>Quan el cursor apunta a una fila real, \u00e9s quan podem recuperar les dades de les columnes de la fila actual. Podem utilitzar un m\u00e8tode especial i sobrecarregat, de la seg\u00fcent manera:</p> <ul> <li><code>getXXX(int posici\u00f3Columna)</code> \\(\\rightarrow\\) retorna les dades, on <code>XXX</code> \u00e9s un tipus de dades (Int, Float, Double, String, etc.) de la posici\u00f3 de la columna, comen\u00e7ant per 1.</li> <li><code>getXXX(String nomColumna)</code> \\(\\rightarrow\\) retorna les dades, on <code>XXX</code> \u00e9s un tipus de dades (Int, Float, Double, String, etc.) de la columna amb el nom proporcionat.</li> </ul> <p>Perill</p> <p>Tingueu en compte:</p> <ul> <li>Les columnes comencen en 1 en lloc de 0, a difer\u00e8ncia dels arrays.</li> <li>Si no coneixeu el tipus de dades d'una columna, podeu utilitzar <code>getObject</code> i aquest retornar\u00e0 un <code>Object</code> gen\u00e8ric.</li> <li>Aquests m\u00e8todes poden generar una <code>SQLException</code> si el rang o el nom de la columna est\u00e0 fora de rang o no existeix.</li> </ul>"},{"location":"UD2_Connectors/4_Resultset/#11-resulsetmetadata","title":"1.1. ResulSetMetaData","text":"<p>Els ResultSets d'una consulta tamb\u00e9 tenen un conjunt de metadades. Aquestes metadades es poden obtenir utilitzant <code>ResultSetMetaData</code>. Els m\u00e8todes m\u00e9s rellevants d'aquesta classe s\u00f3n:</p> <ul> <li><code>int getColumnCount()</code> \\(\\rightarrow\\) Obt\u00e9 el nombre de columnes al ResultSet.</li> <li><code>String getColumnName(index)</code> \\(\\rightarrow\\) Obt\u00e9 el nom de la columna indicada en l'\u00edndex (recorda que el primer \u00e9s 1).</li> <li><code>String getColumnTypeName(index)</code> \\(\\rightarrow\\) Obt\u00e9 el tipus de la columna.</li> </ul> <p>ResulSetMetaData s'obt\u00e9 de cada ResultSet generat pr\u00e8viament, amb el m\u00e8tode <code>getMetaData()</code>.</p>"},{"location":"UD2_Connectors/4_Resultset/#12-algorisme-resultset","title":"1.2. Algorisme ResultSet","text":"<p>Independentment del contingut de dades del teu ResultSet, la manera en qu\u00e8 hem de treballar \u00e9s la seg\u00fcent:</p> Java<pre><code>// Connect to DB\nConnection conn = ...;\n\n// recover data\nResultSet rst= conn...\n\n// while data available exists\nwhile (rst.next()){\n    //process the current row\n}\n</code></pre> <p>Sigues conscient de que:</p> <ul> <li>Dins del bucle while no cal cridar <code>next()</code> de nou. Es salta una fila en cas contrari.</li> <li>Quan s'han processat les darreres files, <code>next()</code> retorna <code>false</code> i el bucle finalitza.</li> </ul>"},{"location":"UD2_Connectors/4_Resultset/#13-exemple","title":"1.3. Exemple","text":"<p>En aquest bloc de codi, anem a veure un exemple breu per executar una consulta (<code>Select * from table</code>). Veurem altres consultes en les seccions seg\u00fcents.</p> Java<pre><code>//with a previous connection\nString taula=\"Jocs\";\nResultSet rst = con.createStatement().executeQuery(\"SELECT * FROM \" +taula);\nSystem.out.println(Colors.Cyan);\nSystem.out.println(\"\");\nSystem.out.println(\"Contingut de \" + taula);\nSystem.out.println(\"******************************\");\n\nResultSetMetaData rsmdQuery = rst.getMetaData();\n\n// print the columns name\nfor (int i = 1; i &lt;= rsmdQuery.getColumnCount(); i++)\n  System.out.print(String.format(\"%-25.25s\",rsmdQuery.getColumnName(i)));\n\nSystem.out.println();\nSystem.out.println(Colors.Reset);\n\n// print the values\nwhile (rs.next()) {\n  for (int i = 1; i &lt;= rsmdQuery.getColumnCount(); i++)\n  System.out.print(String.format(\"%-25.25s \",rst.getString(i)));\n  System.out.println();\n}\n</code></pre>"},{"location":"UD2_Connectors/5_Metadata/","title":"1. Metadata de la base de dades","text":"<p>Abans de recuperar dades, estudiarem com obtenir informaci\u00f3 sobre la base de dades a la qual estem connectats. Les metadades d'una base de dades descriuen l'estructura que t\u00e9: les taules que componen la base de dades, els camps que formen aquestes taules, els tipus d'aquests camps, etc. Tot i que normalment coneixem aquesta estructura pr\u00e8viament, \u00e9s possible que en necessitem informaci\u00f3 en alguna ocasi\u00f3, per aix\u00f2 tenim les interf\u00edcies <code>DatabaseMetaData</code> i <code>ResultSetMetaData</code>.</p> <p>La interf\u00edcie <code>DatabaseMetaData</code> ens proporciona informaci\u00f3 sobre les taules i vistes de la base de dades, aix\u00ed com la seva estructura. A continuaci\u00f3 tenim alguns dels m\u00e8todes m\u00e9s rellevants d'aquesta interf\u00edcie.</p> <ul> <li><code>String getDatabaseProductName()</code> \\(\\rightarrow\\) Obt\u00e9 el nom del SGBD.</li> <li><code>String getDriverName()</code> \\(\\rightarrow\\) Obt\u00e9 el nom del controlador JDBC que s'est\u00e0 utilitzant.</li> <li><code>String getURL()</code> \\(\\rightarrow\\) Obt\u00e9 l'URL de la connexi\u00f3.</li> <li><code>String getUserName()</code> \\(\\rightarrow\\) Obt\u00e9 el nom de l'usuari connectat a la base de dades.</li> <li><code>ResultSet getTables(String catalog, String schema, String patternTableName, String[] type)</code> \\(\\rightarrow\\) Obt\u00e9 informaci\u00f3 de les taules disponibles en el cat\u00e0leg indicat.</li> <li><code>ResultSet getColumns(String catalog, String schema, String patternNameTable, String patternColumnName)</code> \\(\\rightarrow\\) Obt\u00e9 informaci\u00f3 dels camps de la taula especificada en el cat\u00e0leg i esquema indicats.</li> <li><code>ResultSet getPrimaryKeys(String catalog, String schema, String patternNameTable)</code> \\(\\rightarrow\\) Obt\u00e9 la llista de camps que formen la clau prim\u00e0ria.</li> <li><code>ResultSet getImportedKeys(String catalog, String schema, String patternNameTable)</code> \\(\\rightarrow\\) Obt\u00e9 una llista amb les claus externes definides a la taula.</li> <li><code>ResultSet getExportedKeys(String catalog, String schema, String patternNameTable)</code> \\(\\rightarrow\\) Obt\u00e9 una llista amb les claus externes que apunten a aquesta taula.</li> </ul> <p>Informaci\u00f3</p> <p>En aquest punt, cal assenyalar que els termes cat\u00e0leg i esquema tendeixen a confondre's. Segons els est\u00e0ndards, un cat\u00e0leg cont\u00e9 diversos esquemes, amb informaci\u00f3 detallada del sistema, des de la forma d'emmagatzematge intern fins als esquemes conceptuals. En un cat\u00e0leg, sembla que hi ha un esquema anomenat INFORMATION_SCHEMA, amb les vistes i dominis de l'esquema d'informaci\u00f3 del sistema.</p> <p>En tot cas, la majoria dels SGBD coincideixen el cat\u00e0leg amb el nom de la base de dades. A m\u00e9s, en aquesta consulta especifiquem el nom de la base de dades com a cat\u00e0leg, mentre que si obrim MySQLWorkbench, la base de dades es representa com un esquema. Podeu trobar m\u00e9s informaci\u00f3 sobre aix\u00f2 en aquests enlla\u00e7os:</p> <ul> <li>https://stackoverflow.com/questions/7022755/whats-the-difference-between-a-catalog-and-a-schema-in-a-relational-database</li> <li>https://www.quora.com/What-is-the-difference-between-system-catalog-and-database-schemain-a-Database</li> </ul>"},{"location":"UD2_Connectors/5_Metadata/#11-exercisi-resolt","title":"1.1. Exercisi resolt","text":"<p>Anem a crear un programa Java que mostri informaci\u00f3 interna d'una base de dades <code>BDJocs</code>, mitjan\u00e7ant <code>DataBaseMetaData</code>. Veurem el programa pas a pas.</p> <p>Info</p> <p>Podeu veure tota la informaci\u00f3 del m\u00e8tode i com les dades s'emmagatzemen en cada ResultSet del m\u00e8tode en aquest enlla\u00e7.</p>"},{"location":"UD2_Connectors/5_Metadata/#111-crear-la-connection","title":"1.1.1. Crear la connection","text":"<p>Recorda com connectar-te a un SGBD de manera senzilla:</p> Java<pre><code>// load JDBC driver\n2 Class.forName(\"com.mysql.cj.jdbc.Driver\");\n3 // Connecto to DBMS and DB BDJosc, with user and pass\n4 Connection con = DriverManager.getConnection(\"jdbc:mysql://localhost:3308/BDJocs\", \"root\", \"root\");\n</code></pre> <p>Molt senzill, carrega el controlador i connecta't a la base de dades de la manera que hem estudiat.</p>"},{"location":"UD2_Connectors/5_Metadata/#112-recupera-les-metadades-del-sgbd-i-mostra-les-en-un-format-amigable","title":"1.1.2. Recupera les metadades del SGBD i mostra-les en un format amigable","text":"<p>Utilitzarem la classe <code>Color</code> per mostrar les dades en format de text en la consola. Teniu aquesta classe a l'APAC1, dins del projecte.</p> Java<pre><code>// get the metadata\nDatabaseMetaData dbmd = con.getMetaData();\n\nSystem.out.println(Colors.Blue+\"\\nDBMS information--------\"+Colors.Reset);\nSystem.out.println(Colors.Bright_White+\"SGBD:\\t\"+Colors.Reset + dbmd.getDatabaseProductName());\nSystem.out.println(Colors.Bright_White+\"SGBD:\\t\"+Colors.Reset + dbmd.getDriverName());\nSystem.out.println(Colors.Bright_White+\"SGBD:\\t\"+Colors.Reset + dbmd.getURL());\nSystem.out.println(Colors.Bright_White+\"SGBD:\\t\"+Colors.Reset + dbmd.getUserName());\n</code></pre> <p>Com podeu veure, obtenim el nom del SGBD, el controlador, l'URL i l'usuari que estem utilitzant. \u00d2bviament, \u00e9s el mateix que vam posar quan vam crear l'objecte <code>Connection</code>, per\u00f2 \u00e9s un bon exemple per mostrar informaci\u00f3.</p>"},{"location":"UD2_Connectors/5_Metadata/#113-recuperar-taules-en-un-esquemabase-de-dades","title":"1.1.3. Recuperar taules en un esquema/base de dades","text":"<p>Utilitzant el m\u00e8tode <code>getTables()</code> podem recuperar les taules i m\u00e9s informaci\u00f3. Suposem que <code>BDJocs</code> existeix al nostre SGBD:</p> Java<pre><code>System.out.println(Colors.Bright_White+String.format(\"%-15s %-15s %-15s\",\"Database\",\"Table\",\"Type\"));\nSystem.out.println(\"-------------------------------------------------------\"+Colors.Reset);\nResultSet rsmd = dbmd.getTables(\"BDJocs\", null, null, null);\nwhile (rsmd.next()) {\n  System.out.println(String.format(\"%-15s %-15s %-15s\",rsmd.getString(1),rsmd.getString(3),rsmd.getString(4)));\n}\n</code></pre> <p>Comentaris:</p> <p>Repassa <code>String.format()</code> per establir una longitud espec\u00edfica de cada columna.</p> <p>Segons la documentaci\u00f3 de javadoc, obtenim que el ResultSet retornat per <code>getTables</code> t\u00e9 les seg\u00fcents columnes:</p> <ol> <li>TABLE_CAT String \u2192 cat\u00e0leg de la taula (pot ser nul)</li> <li>TABLE_SCHEM String \u2192 esquema de la taula (pot ser nul)</li> <li>TABLE_NAME String \u2192 nom de la taula</li> <li>TABLE_TYPE String \u2192 tipus de taula. Els tipus t\u00edpics s\u00f3n \"TABLE\", \"VIEW\", \"SYSTEM TABLE\", \"GLOBAL TEMPORARY\", \"LOCAL TEMPORARY\", \"ALIAS\", \"SYNONYM\".</li> <li>REMARKS String \u2192 comentari explicatiu sobre la taula</li> <li>TYPE_CAT String \u2192 cat\u00e0leg dels tipus (pot ser nul)</li> <li>TYPE_SCHEM String \u2192 esquema dels tipus (pot ser nul)</li> <li>TYPE_NAME String \u2192 nom del tipus (pot ser nul)</li> <li>SELF_REFERENCING_COL_NAME String \u2192 nom de la columna \"identificador\" designada d'una taula indicada (pot ser nul)</li> <li>REF_GENERATION String \u2192 especifica com es creen els valors a SELF_REFERENCING_COL_NAME. Els valors poden ser \"SYSTEM\", \"USER\", \"DERIVED\". (pot ser nul)</li> </ol> <p>Obtenim les columnes 1, 3 i 4.</p>"},{"location":"UD2_Connectors/5_Metadata/#114-obtenir-les-columnes-de-la-taula","title":"1.1.4. Obtenir les columnes de la taula","text":"<p>\u00c9s el moment d'obtenir les columnes d'una taula, utilitzant el m\u00e8tode <code>getColumns()</code>:</p> Java<pre><code>String table=...; // we set the name of an existing table\nResultSet columnes = dbmd.getColumns(\"BDJocs\",null , taula, null);\nSystem.out.println(Colors.Bright_White+String.format(\"%-25s %-15 s%-15s\",\"Atribut/Claus\",\"Tipus\",\"Pot ser nul?\"+Colors.reset));\n\nwhile (columnes.next()){\n    String columnName=columnes.getString(4);\n    String tipus=columnes.getString(6);\n    String nullable=columnes.getString(18);\n\n    System.out.println(String.format(\"%-25s %-15s %15s\",columnName,tipus,nullable));\n}\n</code></pre> <p>Comentaris:</p> <ul> <li><code>getColumns()</code> retorna un ResultSet amb 24 columnes, amb molta informaci\u00f3 de la taula. Nom\u00e9s obtenim les columnes 4, 6 i 18 amb el nom, el tipus i si pot ser nul. Podeu consultar la documentaci\u00f3 de javadoc per obtenir m\u00e9s informaci\u00f3.</li> <li>De la mateixa manera, per obtenir informaci\u00f3 sobre les claus, podem utilitzar:<ul> <li><code>getPrimaryKeys()</code> retorna un ResultSet amb les claus prim\u00e0ries de les taules.</li> <li><code>getExportedKeys()</code> retorna un ResultSet amb les columnes que apunten a la clau prim\u00e0ria de la taula actual. Aix\u00f2 significa tots els camps d'altres taules que apunten a la clau prim\u00e0ria de la taula actual.</li> <li><code>getImportedKeys()</code> retorna un ResultSet amb les columnes que s\u00f3n claus prim\u00e0ries importades a la taula actual. Aix\u00f2 significa les columnes que s\u00f3n claus externes (i apunten a una clau prim\u00e0ria d'altres taules).</li> </ul> </li> </ul> <p>Teniu tot l'exemple a la carpeta <code>DatabaseMeta</code> de l'aplicaci\u00f3 d'exemple i al seg\u00fcent enlla\u00e7.</p>"},{"location":"UD2_Connectors/6_CRUD/","title":"1. Statements and CRUD operations","text":"<p>En aquesta secci\u00f3 estudiarem l'objectiu principal de treballar amb bases de dades: manipular dades. Sempre treballarem amb la mateixa plantilla:</p> <ol> <li>Connectar a la base de dades.</li> <li>Preparar la consulta.</li> <li>Executar la consulta.</li> <li>Processament de les dades, si \u00e9s necessari.</li> </ol> <p>El punt 1 s'ha estudiat a les seccions anteriors.</p> <p>Per crear les consultes, haurem d'utilitzar les seg\u00fcents classes/interfaces:</p> <ul> <li><code>Statement</code> \\(\\rightarrow\\) Es fa servir de manera general i \u00e9s \u00fatil quan volem realitzar sent\u00e8ncies SQL est\u00e0tiques, ja que no accepta par\u00e0metres. Creem un <code>Statement</code> amb el m\u00e8tode <code>createStatement()</code> de la classe <code>Connection</code>.</li> <li><code>PreparedStatement</code> \\(\\rightarrow\\) Es fa servir quan volem llan\u00e7ar diverses consultes i, a m\u00e9s, es permet realitzar sent\u00e8ncies din\u00e0miques. Creem un <code>PreparedStatement</code> amb el m\u00e8tode <code>prepareStatement()</code> de la classe <code>Connection</code>.</li> <li><code>CallableStatement</code> \\(\\rightarrow\\) Es fa servir per accedir a procediments emmagatzemats a la base de dades i tamb\u00e9 accepta par\u00e0metres d'entrada. Creem un <code>CallableStatement</code> amb el m\u00e8tode <code>prepareCall()</code> de la classe <code>Connection</code>.</li> </ul> <p>Quan la sent\u00e8ncia est\u00e0 preparada, la podem executar amb:</p> <ul> <li><code>executeQuery</code> \\(\\rightarrow\\) Executa sent\u00e8ncies que esperem que retornin dades (consultes SELECT). El valor de retorn d'aquesta execuci\u00f3 \u00e9s, com ja suposareu, un ResultSet.</li> <li><code>executeUpdate</code> \\(\\rightarrow\\) Executa sent\u00e8ncies que no s'espera que retornin dades, per\u00f2 que s'utilitzaran per modificar la base de dades connectada (consultes INSERT, DELETE, UPDATE i CREATE TABLE).</li> </ul>"},{"location":"UD2_Connectors/6_CRUD/#11-create-insert","title":"1.1. Create (Insert)","text":"<p>Anem a veure un exemple senzill de declaraci\u00f3 <code>INSERT</code>.</p> Java<pre><code>ConnexioDB conDB=new ConnexioDB(\"BDJocs\");\nConnection con=conDB.getConnexio();\n\nString SQL=\"INSERT INTO Joc VALUES (1, 'Double Dragon', 'Dos germans bessons experts en arts marcials s`han de fer cam\u00ed en un escenari urb\u00e0 on  membres de bandes rivals volen deixar-los fora de combat.', 1);\";\n\nStatement st=con.createStatement();\n\nint affectedRows=st.executeUpdate(SQL);\n\nSystem.out.println(affectedRows+ \"row has been inserted\");\n</code></pre> <p>Com podeu veure, \u00e9s molt f\u00e0cil d'entendre el codi. Creem una declaraci\u00f3 buida i despr\u00e9s executem l'SQL \"per se\". L'execuci\u00f3 retorna el nombre de files inserides. Veurem millors maneres d'inserir dades, utilitzant scripts.</p> <p>Info</p> <p>Aquest codi \u00e9s una versi\u00f3 redu\u00efda, ja que quan treballem amb bases de dades poden apar\u00e8ixer <code>SQLException</code>. Suposem que el proc\u00e9s de connexi\u00f3 ja s'ha realitzat.</p>"},{"location":"UD2_Connectors/6_CRUD/#12-read-select","title":"1.2. Read (Select)","text":"<p>La lectura \u00e9s el proc\u00e9s m\u00e9s important que farem, ja que nom\u00e9s amb el proc\u00e9s d'inici de sessi\u00f3 dins d'una aplicaci\u00f3 estem recuperant informaci\u00f3 d'una base de dades. En tots els casos, hem d'escriure la sent\u00e8ncia (SQL), executar-la i finalment processar les dades retornades. Depenent de com preparem la sent\u00e8ncia, podem distingir entre:</p> <ol> <li>Sent\u00e8ncies fixes</li> <li>Sent\u00e8ncies variables</li> <li>Sent\u00e8ncies preparades</li> </ol> <p>Veurem amb detall ambdues maneres. Utilitzarem per aix\u00f2 l'script <code>Instituto.sql</code> i la base de dades.</p>"},{"location":"UD2_Connectors/6_CRUD/#121-sentencies-fixes","title":"1.2.1. Sent\u00e8ncies fixes","text":"<p>Aquestes sent\u00e8ncies, com el seu nom indica, s\u00f3n sent\u00e8ncies fixes o constants. L'SQL \u00e9s fixa i no t\u00e9 cap variable.</p> Java<pre><code>// The query\nString SQL=\"Select * from Persona\";\n// The statement\nStatement st=con.createStatement();\n// The execution\nResultSet rst=st.executeQuery(SQL);\n\n// processing\nwhile(rst.next()){\n    System.out.print(ConsoleColors.BLUE_BRIGHT+ \"Person: \"+ ConsoleColors.RESET);\n    /*\n    System.out.println(\n            rst.getString(3)+ \", \"+\n            rst.getString(2)+ \" \"+\n            rst.getInt(4));\n    */\n    System.out.println(\n            rst.getString(\"apellidos\")+ \", \"+\n            rst.getString(\"nombre\")+ \" \"+\n            rst.getInt(\"edad\"));\n}\n\nrst.close();\n</code></pre> <p>En el processament de la informaci\u00f3, ResultSet t\u00e9:</p> <ul> <li><code>type getType(int columnIndex)</code> \\(\\rightarrow\\) m\u00e8tode sobrecarregat que retorna el tipus de dades donat, utilitzant l'\u00edndex de columna del ResultSet. Recorda que la primera columna \u00e9s 1 en comptes de 0. El tipus pot ser Int, String, Double, etc. si coneixes el tipus. Per a columnes desconegudes, pots utilitzar <code>Object</code> com a tipus gen\u00e8ric.</li> <li><code>type getType(String columnName)</code> $\\rightarrow` mateix que el m\u00e8tode anterior, per\u00f2 accedint a la columna amb el nom que hem seleccionat a la consulta o el nom a la taula.</li> </ul>"},{"location":"UD2_Connectors/6_CRUD/#122-sentencies-variables","title":"1.2.2. Sent\u00e8ncies variables","text":"<p>Imagina que vols recuperar noms que continguen la cadena <code>Ma</code> dins seu.</p> SQL<pre><code>String SQL=\"Select * from Persona where nombre like '%Ma%'\";\n</code></pre> <p>En aquest cas, aquesta consulta est\u00e0 codificada directament, i si vols canviar la part del text, has de modificar el teu codi. Per evitar la codificaci\u00f3 directa, podem escriure:</p> Java<pre><code>ConnexioDB conDB=new ConnexioDB(\"Instituto\");\n\nConnection con=conDB.getConnexio();\n\n// hardcoded String\n// String SQL=\"Select * from Persona where nombre like '%Ma%'\";\n\nString nombre=Utilitats.leerTextoC(\"Give me part of the name: \");\n// The query\nString SQL=\"Select * from Persona where nombre like '%\" + nombre + \"%'\";\n// The statement\nStatement st=con.createStatement();\n// The execution\nResultSet rst=st.executeQuery(SQL);\n\n// processing\nwhile(rst.next()){\n    System.out.print(ConsoleColors.BLUE_BRIGHT+ \"People with \" +nombre+\": \"+ ConsoleColors.RESET);\n    System.out.println(\n            rst.getString(\"apellidos\")+ \", \"+\n            rst.getString(\"nombre\")+ \" \"+\n            rst.getInt(\"edad\"));\n}\n\nrst.close();\n</code></pre> <p>Com podem veure, les dades ara estan en variables, per\u00f2 la construcci\u00f3 de l'SQL \u00e9s m\u00e9s complexa. Cal tenir en compte que els textos han d'estar entre cometes i els n\u00fameros no, el que facilita cometre errors. Per\u00f2 pot ser pitjor, aquest tipus de codi pot inc\u00f3rrer en problemes d'injecci\u00f3 SQL, com veiem a l'exemple seg\u00fcent:</p> Java<pre><code>String idPersona=Read.readText(\"Tell me the id to consult: \");\nString SQL = \"Select * from Person where idPersona=\"+idPersona;\n</code></pre> <ul> <li>Si l'usuari introdueix <code>4</code> \\(\\rightarrow\\) Es mostrar\u00e0 la persona amb ID igual a 4</li> <li>Si l'usuari introdueix <code>4 o 1=1</code> \\(\\rightarrow\\) Es mostraran totes les persones</li> </ul> <p>Cal evitar aquest tipus de consultes en les declaracions de validaci\u00f3 d'usuari, per a les quals farem servir les sent\u00e8ncies preparades i, \u00f2bviament, ser molt cautelosos en la verificaci\u00f3 de les entrades.</p>"},{"location":"UD2_Connectors/6_CRUD/#123-sentencies-preparades","title":"1.2.3. Sent\u00e8ncies preparades","text":"<p>Per evitar el problema de l'injecci\u00f3 SQL, sempre que tinguem par\u00e0metres a la nostra consulta, farem servir sent\u00e8ncies preparades. En les sent\u00e8ncies preparades, on hem de fer servir un marcador, en lloc de compondre-la amb concatenacions dins de la cadena, l'indicarem amb un interrogant (<code>?</code>), un car\u00e0cter anomenat placeholder.</p> <p>A continuaci\u00f3, haurem d'assignar valors a aquests placeholders, utilitzant els m\u00e8todes <code>setType(int pos)</code> on <code>Type</code> \u00e9s el tipus de dades que assignarem i <code>pos</code> \u00e9s la posici\u00f3 del placeholder, comen\u00e7ant per <code>1</code>. Veurem l'exemple:</p> Java<pre><code>ConnexioDB conDB=new ConnexioDB(\"Instituto\");\n\nConnection con=conDB.getConnexio();\n\nString ID=Utilitats.leerTextoC(\"Give me an id: \");\n// The query\nString SQL=\"Select * from Persona where idPersona = ?\" ;\n// The statement\nPreparedStatement pst=con.prepareStatement(SQL);\n// fill placeholders\n\npst.setString(1, ID);\n\n// The execution\nResultSet rst=pst.executeQuery();\n\n// processing\nwhile(rst.next()){\n    System.out.print(ConsoleColors.BLUE_BRIGHT+ \"People with \" +ID+\": \"+ ConsoleColors.RESET);\n    System.out.println(\n            rst.getString(\"apellidos\")+ \", \"+\n            rst.getString(\"nombre\")+ \" \"+\n            rst.getInt(\"edad\"));\n}\n\nrst.close();\n</code></pre> <p>Consell</p> Text Only<pre><code>Pots combinar ResultSet amb ResultSetMetaData per obtenir els noms de les columnes i els tipus de dades emmagatzemats a la base de dades. Trobar\u00e0s un exemple a la plataforma.\n</code></pre>"},{"location":"UD2_Connectors/6_CRUD/#13-actualitzacio-update-i-esborrat-delete","title":"1.3. Actualitzaci\u00f3 (Update) i Esborrat (Delete)","text":"<p>L'actualitzaci\u00f3 i l'esborrat d'una fila es consideren com a actualitzacions de la base de dades, ja que modifiquen l'estat de la base de dades. De fet, tamb\u00e9 considerem la inserci\u00f3 com una actualitzaci\u00f3 de la base de dades. Totes dues tasques s'incloent en el m\u00e8tode <code>executeUpdate()</code>. Anem a estudiar-ho a trav\u00e9s d'exemples:</p>"},{"location":"UD2_Connectors/6_CRUD/#131-exemple-desborrat","title":"1.3.1. Exemple d'esborrat","text":"<p>Anem a esborrar files d'una taula de persones entre les edats donades:</p> Java<pre><code>ConnexioDB conDB = new ConnexioDB(\"Instituto\");\nConnection con = conDB.getConnexio();\n\n// give the age's bounds\nint minAge = Utilitats.leerEnteroC(\"Give me minimal age: \");\nint maxAge = Utilitats.leerEnteroC(\"Give me maximun age: \");\n\n// The query\nString SQL = \"Delete from Persona where edad between ? and ?\";\n\n// The statement\nPreparedStatement pst = con.prepareStatement(SQL);\n\n// fill placeholders            \npst.setInt(1, minAge);\npst.setInt(2, maxAge);\n\n// show the query after resolve placeholders\nSystem.out.println(pst);\n\n// The execution\nint deletedtedRows = pst.executeUpdate();\n\n// how many roas affecte\nSystem.out.println(deletedtedRows + \" has been deleted.\");\n</code></pre> <p>Perill</p> <p>Eliminar dades \u00e9s una operaci\u00f3 molt delicada. Tingues cura de:</p> <ul> <li>No oblidis la cl\u00e0usula <code>WHERE</code> quan elimines, ja que eliminar\u00e0s totes les dades de la taula.</li> <li>Si vols eliminar tota la taula, incloent l'estructura (definici\u00f3 + taula), has d'utilitzar <code>DROP TABLE</code> en compte de <code>DELETE</code>.</li> <li>Si intentes eliminar una fila que est\u00e0 referenciada per una clau externa, obtindr\u00e0s l'excepci\u00f3 <code>SQLIntegrityConstraintViolationException</code> i un missatge com No es pot eliminar o actualitzar una fila pare: falla una restricci\u00f3 de clau externa.</li> </ul>"},{"location":"UD2_Connectors/6_CRUD/#132-exemple-dactualitzacio","title":"1.3.2. Exemple d'Actualitzaci\u00f3","text":"<p>Anem a afegir anys a les persones amb l'ID donat:</p> Java<pre><code>ConnexioDB conDB = new ConnexioDB(\"Instituto\");\n\nConnection con = conDB.getConnexio();\n\n// give the age's bounds\nint difAge = Utilitats.leerEnteroC(\"Give me number oy years: \");\nint idMin = Utilitats.leerEnteroC(\"Give me minimum id: \");\n\n// The query\nString SQL = \"Update Persona set edad=edad+ ? where idPersona &gt; ?\";\n\n// The statement\nPreparedStatement pst = con.prepareStatement(SQL);\n\n// fill placeholders            \npst.setInt(1, difAge);\npst.setInt(2, idMin);\n\nSystem.out.println(pst);\n// The execution\nint updatedRows = pst.executeUpdate();\n\nSystem.out.println(updatedRows + \" has been updated.\");\n</code></pre> <p>Warning</p> <p>Recorda que:</p> <ul> <li>La cl\u00e0usula <code>UPDATE</code> no necessita <code>FROM</code> perqu\u00e8 indiquem directament el nom de la taula.</li> <li>Apareix la cl\u00e0usula <code>SET</code>, amb parells <code>camp=valor_actualitzat</code>, per assignar el nou valor als camps seleccionats.</li> <li>Si oblidem la cl\u00e0usula <code>FROM</code>, s'actualitzaran totes les files.</li> </ul>"},{"location":"UD2_Connectors/6_CRUD/#14-scripts","title":"1.4. Scripts","text":"<p>Un script, que normalment s'ha creat en un fitxer extern, \u00e9s un conjunt d'instruccions SQL executades en ordre de dalt a baix. Podem prendre com a estrat\u00e8gia llegir el fitxer l\u00ednia per l\u00ednia i executar-lo una per una, per\u00f2 JDBC permet executar un conjunt d'instruccions en bloc. Per fer aix\u00f2, el primer que hem de fer \u00e9s habilitar m\u00faltiples execucions afegint un par\u00e0metre a la connexi\u00f3, que \u00e9s <code>allowMultiQueries=true</code>.</p> <p>A continuaci\u00f3, hem de carregar el fitxer i compondre una cadena amb tot el script. Per normalitzar-lo i fer-lo totalment port\u00e0til, hem de tenir cura amb els salts de l\u00ednia, ja que depenent del sistema \u00e9s una combinaci\u00f3 <code>\\n</code> o <code>\\r\\n</code>. Podem llegir l\u00ednia per l\u00ednia i guardar-ho en un <code>StringBuilder</code>, afegint <code>System.getProperty(\"line.separator\")</code> com a separadors.</p> <p>Despr\u00e9s nom\u00e9s necessitarem crear una declaraci\u00f3 amb aquesta cadena i executar-la amb <code>executeUpdate()</code>. Ho veurem a continuaci\u00f3:</p> Java<pre><code>ConnexioDB conDB = new ConnexioDB(\"Instituto\");\n\nConnection con = conDB.getConnexio();\n\nFile script = new File(\"sql/EsquemaCine.sql\");\n\nBufferedReader bfr = bfr = new BufferedReader(new FileReader(script));\n\nString line = null;\nStringBuilder sb = new StringBuilder();\n\n// Obtenemos el salto de linea del sistema subyacente\nString breakLine = System.getProperty(\"line.separator\");\n\nwhile ((line = bfr.readLine()) != null) {\n    sb.append(line);\n    sb.append(breakLine);\n}\n\nString query = sb.toString();   // generemos el Script en un String\nStatement stm = con.createStatement();\nint result = stm.executeUpdate(query);\nSystem.out.println(\"Script ejecutado con salida \" + result);\n</code></pre> <p>Consell</p> <p>Recordes les classes <code>Files</code> i <code>Paths</code>? Reescriu l'\u00faltim exemple per obtenir un codi m\u00e9s net.</p>"},{"location":"UD2_Connectors/6_CRUD/#15-transaccions","title":"1.5. Transaccions","text":"<p>Si volem protegir la integritat de les dades, aix\u00ed com evitar situacions de bloqueig inesperades en aplicacions multithread, hem de protegir les nostres operacions, especialment aquelles que modifiquen les dades mitjan\u00e7ant l'\u00fas de transaccions.</p> <p>Una transacci\u00f3 defineix un entorn d'execuci\u00f3 en qu\u00e8 les operacions de desament es mantenen emmagatzemades a la mem\u00f2ria fins que la transacci\u00f3 es completi. Si en un moment determinat alguna cosa falla, l'estat es torna al punt inicial de la mateixa (punt inicial) o a algun punt de marca intermedi. Per defecte, obrir una connexi\u00f3 inicia una transacci\u00f3:</p> <ul> <li>Cada execuci\u00f3 a la connexi\u00f3 genera una transacci\u00f3 per si mateixa.</li> <li>Si volem desactivar aquesta opci\u00f3 perqu\u00e8 la transacci\u00f3 abasti diverses execucions, hem de marcar-ho mitjan\u00e7ant <code>Connection.setAutoCommit(false);</code>.</li> <li>Per acceptar definitivament la transacci\u00f3 ho farem mitjan\u00e7ant <code>Connection.commit();</code></li> <li>Per cancel\u00b7lar la transacci\u00f3 <code>Connection.rollback();</code></li> </ul>"},{"location":"UD2_Connectors/6_CRUD/#16-resultsets-actualitzables","title":"1.6. ResultSets actualitzables","text":"<p>Els m\u00e8todes de treball revisats a les seccions anteriors, especialment quan s'actualitzen o esborren files, funcionen directament a la base de dades. Aix\u00f2 significa que esborreu o actualitzeu una fila sense carregar-la pr\u00e8viament a la mem\u00f2ria. Qu\u00e8 passa si voleu mostrar les dades a l'usuari i despr\u00e9s l'usuari decideix esborrar o actualitzar la fila? En aquest cas, \u00e9s millor utilitzar ResultSets actualitzables.</p> <p>Hem estudiat ResultSet com una col\u00b7lecci\u00f3 de files i l'hem utilitzat nom\u00e9s per a la lectura. Tamb\u00e9 podem utilitzar-lo per editar i esborrar dades. Per fer-ho, hem de obrir el ResultSet d'una manera diferent de la que hem vist fins ara. I, per \u00faltim, per\u00f2 no menys important, dependr\u00e0 de la base de dades la disponibilitat de crear aquest tipus de ResultSets.</p> <p>Per aconseguir-ho, no dep\u00e8n del ResultSet ni de com es va crear l'Statement. Hem d'utilitzar aquest constructor:</p> Java<pre><code>public abstract Statement createStatement(\n    int arg0,   // resultSetType           \n    int arg1,   // resultSetConcurrency\n    int arg2)   // resultSetHoldability\n    throws SQLException\n</code></pre> <p>Com podeu veure, hi ha 3 arguments per indicar quin tipus de ResultSet donem al final. Aquests tres arguments poden ser:</p> <ul> <li><code>resultSetType</code> \\(\\rightarrow\\) aquestes s\u00f3n opcions sobre com moure's i passar per les files del ResultSet:<ul> <li><code>TYPE_FORWARD_ONLY</code> \\(\\rightarrow\\) opci\u00f3 per defecte. El ResultSet nom\u00e9s es pot passar una vegada.</li> <li><code>TYPE_SCROLL_INSENSITIVE</code> \\(\\rightarrow\\) Permet rebobinar i saltar a una posici\u00f3 absoluta o relativa.</li> <li><code>TYPE_SCROLL_SENSITIVE</code> \\(\\rightarrow\\) Igual que abans, per\u00f2 permet veure els canvis realitzats a la base de dades.</li> </ul> </li> <li><code>ResultSetConcurrency</code> \\(\\rightarrow\\) aquestes s\u00f3n opcions sobre si es pot actualitzar el ResultSet o no:<ul> <li><code>CONCUR_READ_ONLY</code> \\(\\rightarrow\\) opci\u00f3 per defecte. Nom\u00e9s lectura. Si volem actualitzar alguna cosa, nom\u00e9s podem utilitzar les cl\u00e0usules <code>DELETE</code> o <code>UPDATE</code>.</li> <li><code>CONCUR_UPDATABLE</code> \\(\\rightarrow\\) Les files del ResultSet es poden actualitzar o esborrar.</li> </ul> </li> <li><code>ResultSetHoldability</code> aquestes opcions s\u00f3n sobre el comportament en tancar el ResultSet:<ul> <li><code>HOLD_CURSORS_OVER_COMMIT</code> \\(\\rightarrow\\) El ResultSet es mant\u00e9 obert despr\u00e9s de confirmar la transacci\u00f3.</li> <li><code>CLOSE_CURSORS_AT_COMMIT</code> \\(\\rightarrow\\) El ResultSet es tanca despr\u00e9s de confirmar la transacci\u00f3. Millora el rendiment.</li> </ul> </li> </ul> <p>En el seg\u00fcent exemple, podem preguntar al nostre DBMS si aquests tipus de ResultSet estan suportats:</p> Java<pre><code>ConnexioDB conDB = new ConnexioDB(\"Instituto\");\nConnection con = conDB.getConnexio();\nDatabaseMetaData dbmd = con.getMetaData();\n\nSystem.out.println(\"TYPE_FORWARD_ONLY: \" + dbmd.supportsResultSetType(ResultSet.TYPE_FORWARD_ONLY));\nSystem.out.println(\"TYPE_SCROLL_INSENSITIVE: \" + dbmd.supportsResultSetType(ResultSet.TYPE_SCROLL_INSENSITIVE));\nSystem.out.println(\"TYPE_SCROLL_SENSITIVE: \" + dbmd.supportsResultSetType(ResultSet.TYPE_SCROLL_SENSITIVE));\nSystem.out.println(\"CONCUR_READ_ONLY: \" + dbmd.supportsResultSetConcurrency(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY));\nSystem.out.println(\"CONCUR_UPDATABLE: \" + dbmd.supportsResultSetConcurrency(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE));\n</code></pre>"},{"location":"UD2_Connectors/6_CRUD/#161-moviment-del-resultset","title":"1.6.1. Moviment del ResultSet","text":"<p>Com podem veure, no nom\u00e9s podem moure el cursor cap endavant:</p> <ul> <li><code>next</code>, <code>previous</code>, <code>first</code> i <code>last</code> \\(\\rightarrow\\) com el seu nom indica, es mouen cap endavant, cap enrere, al principi i a l'\u00faltima fila. Retorna true si el cursor apunta a una fila i false en cas contrari.</li> <li><code>beforeFirst</code> i <code>afterLast</code> \\(\\rightarrow\\) el cursor apuntar\u00e0 fora de les files, abans de la primera o despr\u00e9s de l'\u00faltima fila.</li> <li><code>relative(int n)</code> \\(\\rightarrow\\) el cursor es mou n files (cap endavant o cap enrere, depenent del signe).</li> <li><code>absolute(int n)</code> \\(\\rightarrow\\) el cursor apunta a la fila n.</li> </ul>"},{"location":"UD2_Connectors/6_CRUD/#162-eliminacio-de-files-en-un-resultset","title":"1.6.2. Eliminaci\u00f3 de files en un ResultSet","text":"<p>Despr\u00e9s de col\u00b7locar el cursor a la fila que es vol eliminar, es pot eliminar del ResultSet (i de la base de dades) amb el m\u00e8tode <code>deleteRow()</code>. Quan s'elimina una fila, el cursor apuntar\u00e0 a la fila anterior a la que s'ha eliminat.</p>"},{"location":"UD2_Connectors/6_CRUD/#163-actualitzacio-de-files-en-un-resultset","title":"1.6.3. Actualitzaci\u00f3 de files en un ResultSet","text":"<p>Despr\u00e9s de col\u00b7locar el cursor a la fila desitjada, s'ha de:</p> <ol> <li>Actualitzar les columnes desitjades, utilitzant el m\u00e8tode <code>updateType(int column, type newValue)</code>, on la columna i-\u00e8ssima (o amb el seu nom) s'assigna el nou valor del tipus donat.</li> <li>Un cop s'hagin modificat totes les columnes desitjades, es guarden els canvis amb <code>updateRow()</code>.</li> </ol> <p>Consell</p> <p>No podem actualitzar una fila sencera, hem de actualitzar columna per columna i despr\u00e9s actualitzar la fila.</p>"},{"location":"UD2_Connectors/6_CRUD/#164-insercio-de-files-en-un-resultset","title":"1.6.4. Inserci\u00f3 de files en un ResultSet","text":"<p>Si volem inserir una nova fila en un ResultSet, hem de:</p> <ol> <li>Generar una nova fila buida, i aix\u00f2 s'aconsegueix amb el m\u00e8tode <code>moveToInsertRow()</code>.</li> <li>En aquesta fila, apliquem el m\u00e8tode <code>updateType(int column, type newValue)</code> a totes les columnes a les quals volem assignar un valor, i finalment</li> <li>Procedim a inserir la nova fila amb <code>insertRow()</code>.</li> </ol> <p>Important</p> <ul> <li>Aquestes operacions d'actualitzaci\u00f3, eliminaci\u00f3 i inserci\u00f3 nom\u00e9s es poden realitzar en consultes que provenen d'una taula sense agrupacions.</li> <li>Per evitar complexitat en els nostres programes, val la pena avaluar la conveni\u00e8ncia de traduir les actualitzacions del ResultSet a SQL pur i executar-les directament a les bases de dades mitjan\u00e7ant noves sent\u00e8ncies.</li> </ul>"},{"location":"UD2_Connectors/7_Row_to_Object/","title":"1. De files a Objectes","text":"<p>Finalment, per tancar la unitat, treballarem de manera natural: recuperarem dades de la base de dades, crearem objectes a partir del <code>ResultSet</code> i guardarem les dades a la base de dades.</p> <p>Estudiarem una nova manera de crear els nostres POJO (i BEAN), utilitzant una llibreria moderna anomenada Lombok.</p>"},{"location":"UD2_Connectors/7_Row_to_Object/#11-pojo-bean-i-projecte-lombok","title":"1.1. POJO, BEAN i Projecte Lombok","text":"<p>Hem de crear classes segons el nostre model orientat a objectes. Depenent de com haguem fet les classes, poden ser POJO o BEAN o un altre tipus de classes. Anem a entendre-ho (extret d'aqu\u00ed: enlla\u00e7).</p>"},{"location":"UD2_Connectors/7_Row_to_Object/#111-pojo","title":"1.1.1. POJO","text":"<p>Aix\u00f2 significa Plain Old Java Object. \u00c9s una classe que:</p> <ul> <li>No ha d'estendre cap classe.</li> <li>No ha d'implementar cap interf\u00edcie.</li> <li>No ha de contenir anotacions espec\u00edfiques.</li> </ul> <p>No hi ha restriccions en els modificadors d'acc\u00e9s dels camps. Poden ser privats, per defecte, protegits o p\u00fablics. Tampoc \u00e9s necessari incloure cap constructor en aquest.</p> <p>Un exemple de POJO seria, per exemple:</p> Java<pre><code>// AS POJO\npublic class Modul {\n  // attributes\n  String nom;\n  int hores;\n  double nota;\n  // constructor\n  public Modul(String nom, int hores, double nota) {\n      this.nom = nom;\n      this.hores = hores;\n      this.nota = nota;\n  }\n  // getters\n  public String getModul(){return this.nom;}\n  public int getHores() {return this.hores;}\n  public double getNota() {return this.nota;}\n\n  @Override\n  public String toString() {\n      return \"Modul{\" + \"nom=\" + nom + \", hores=\" + hores + \", nota=\" + nota + '}';\n  } \n}\n</code></pre> <p>Com podeu veure, un POJO \u00e9s la m\u00ednima classe que podem fer.</p>"},{"location":"UD2_Connectors/7_Row_to_Object/#112-bean","title":"1.1.2. BEAN","text":"<p>Els Beans s\u00f3n un tipus especial de POJO. Hi ha algunes restriccions perqu\u00e8 un POJO sigui un Bean.</p> <ul> <li>Tots els JavaBeans s\u00f3n POJOs, per\u00f2 no tots els POJOs s\u00f3n JavaBeans.</li> <li><code>Serializable</code>, han d'implementar la interf\u00edcie Serializable. No obstant aix\u00f2, alguns POJOs que no implementen la interf\u00edcie Serializable es diuen POJOs perqu\u00e8 Serializable \u00e9s una interf\u00edcie marcadora i, per tant, no suposa una c\u00e0rrega excessiva.</li> <li>Els camps han de ser privats. Aix\u00f2 proporciona un control complet sobre els camps.</li> <li>Els camps han de tenir getters o setters o tots dos.</li> <li>Ha d'haver-hi un constructor sense arguments en un Bean.</li> <li>Els camps nom\u00e9s s'accedeixen mitjan\u00e7ant el constructor o els getters i setters.</li> </ul> Java<pre><code>// AS POJO\npublic class Modul {\n  // attributes\n  private String nom;\n  private int hores;\n  private double nota;\n  // constructor\n  public Modul() { }\n  // getters\n  public String getModul(){return this.nom;}\n  public int getHores() {return this.hores;}\n  public double getNota() {return this.nota;}\n// setters\n  public void getModul(){return this.nom;}\n  public void getHores() {return this.hores;}\n  public void getNota() {return this.nota;}\n\n  @Override\n  public String toString() {\n      return \"Modul{\" + \"nom=\" + nom + \", hores=\" + hores + \", nota=\" + nota + '}';\n  } \n}\n</code></pre> <p>Per resumir, les classes POJO i Beans s'utilitzen per definir objectes Java per augmentar la seva llegibilitat i reutilitzaci\u00f3. Els POJOs no tenen altres restriccions mentre que els beans s\u00f3n POJOs especials amb algunes restriccions.</p>"},{"location":"UD2_Connectors/7_Row_to_Object/#113-lombok","title":"1.1.3. Lombok","text":"<p>Independentment de si utilitzem POJO o BEAN, hi ha algunes tasques repetitives que hem de fer per crear les nostres classes. La majoria d'aquestes tasques s\u00f3n implementades pels IDE, com ara crear getters, setters, encapsular camps, crear constructors, etc. Project Lombok \u00e9s una llibreria que evita fer aquestes tasques repetitives, i diem el que volem i la llibreria i el compilador fan la resta.</p> <p>En aquest enlla\u00e7 configuraci\u00f3 de Lombok trobar\u00e0s com configurar la llibreria en cada gestor de projectes (gradle, maven, etc.) i en cada IDE (Netbeans, Eclipse, IntelliJ, etc.).</p> <p>Un cop instal\u00b7lada, nom\u00e9s cal dir mitjan\u00e7ant anotacions el que vols:</p> <ul> <li><code>@Getter</code> \\(\\rightarrow\\) generar\u00e0 tots els getters.</li> <li><code>@Setter</code> \\(\\rightarrow\\) generar\u00e0 tots els setters.</li> <li><code>@Data</code> \\(\\rightarrow\\) tots els m\u00e8todes que necessiten un POJO, incloent <code>ToString</code>.</li> <li><code>@AllArgsConstructor</code> o <code>@NoArgsConstructor</code> \\(\\rightarrow\\) generar\u00e0 el constructor que vulguis.</li> </ul> <p>Al seg\u00fcent v\u00eddeo s'explica com afegir la depend\u00e8ncia de Gradle i utilitzar Lombok.</p>"},{"location":"UD2_Connectors/7_Row_to_Object/#12-carregant-objectes","title":"1.2. Carregant objectes","text":"<p>Anem a finalitzar amb un exemple:</p>"},{"location":"UD2_Connectors/7_Row_to_Object/#121-classe-persona","title":"1.2.1. Classe Persona","text":"<p>Aquesta classe \u00e9s el POJO d'una persona. Crear\u00e0 getters, setters, toString i els m\u00e8todes principals amb nom\u00e9s unes poques l\u00ednies i algunes anotacions.</p> Java<pre><code>@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class Persona {\n    private int idPersona;\n    private String nombre;\n    private String apellidos;\n    private int edad;\n}\n</code></pre> <p>Cal tenir en compte que amb Lombok la feina es fa f\u00e0cil.</p>"},{"location":"UD2_Connectors/7_Row_to_Object/#122-omplint-un-array","title":"1.2.2. Omplint un Array","text":"<p>Per omplir una estructura de dades des de la base de dades, primer cal obtenir les dades. Cal crear l'objecte <code>Statement</code> o <code>PreparedStatement</code> i executar la consulta.</p> <p>La tasca principal \u00e9s transformar el <code>ResultSet</code> en una llista, per\u00f2 \u00e9s una tasca senzilla:</p> <ul> <li>Recorre el ResultSet (amb next), i per a cada fila:<ul> <li>Crea un objecte amb els valors emmagatzemats a les columnes</li> <li>Afegeix aquest objecte a la llista</li> </ul> </li> </ul> Java<pre><code>ArrayList&lt;Persona&gt; lasPersonas= new ArrayList();\n\nConnexioDB conDB=new ConnexioDB(\"Instituto\");\n\nConnection con=conDB.getConnexio();\n\nString SQL=\"Select * from Persona\" ;\n// The statement\nStatement st=con.createStatement(\n        ResultSet.TYPE_SCROLL_INSENSITIVE,\n        ResultSet.CONCUR_READ_ONLY);\n\n// The execution\nResultSet rst=st.executeQuery(SQL);\n\nif (!rst.next()){\n    System.out.println(\"No people in DB\");\n}\nelse{\n    rst.beforeFirst();\n    while(rst.next()){\n        Persona p= new Persona(\n                rst.getInt(1),\n                rst.getString(2),\n                rst.getString(3),\n                rst.getInt(4));\n        System.out.println(\"Adding \" +p);\n        lasPersonas.add(p);\n    }\n}\n\nSystem.out.println(\"Added \" + lasPersonas.size() + \" people\");\nrst.close();\n</code></pre> <p>Ara podr\u00e0s canviar la informaci\u00f3 en els objectes i, finalment, si s'ha fet alguna modificaci\u00f3, haur\u00e0s de guardar-la a la base de dades. Les preguntes s\u00f3n:</p> <ul> <li>Com puc saber si s'ha actualitzat un objecte?</li> <li>Com puc saber quin camp s'ha de desar?</li> </ul> <p>Com pots veure, hi ha diverses tasques que requereixen un control de la modificaci\u00f3 de les dades i com desar-les. Aquesta tasca ser\u00e0 f\u00e0cil amb ORM i l'estudiarem.</p> <p> Versi\u00f3 Autor Data 0 Joan Gerard Camarena Juliol de 2021 1 Joan Gerard Camarena Octubre de 2022 2 Joan Gerard Camarena Setembre de 2024 <p></p>"},{"location":"UD3_Hibernate/1_Mapping/","title":"1. Mapeig d'objectes","text":""},{"location":"UD3_Hibernate/1_Mapping/#1-introduccio-tecniques-de-mapeig","title":"1. Introducci\u00f3. T\u00e8cniques de mapeig.","text":"<p>En unitats anteriors hem estudiat l'acc\u00e9s dels nostres programes als fitxers i a les bases de dades relacionals. Com hem vist, el gran problema \u00e9s que els nostres programes manipulen objectes, mentre que les bases de dades manipulen taules, la qual cosa provoca l'\u00fas de models diferents i acaba en el ja esmentat buit objecte-relacional.</p> <p>El mapeig objecte-relacional ve a omplir el buit entre aquests dos models, evitant que gastem temps en el nostre codi convertint entre els resultats de les operacions i els nostres objectes. Amb l'\u00fas d'un ORM (Object Relational Mapping), un cop s'ha establert la correspond\u00e8ncia entre els models, en els nostres programes nom\u00e9s treballarem amb un model, el model orientat a objectes. D'aquesta manera aconseguim evitar que els nostres programes caiguin en aquest buit, centrant-nos en la l\u00f2gica de negoci.</p> <p>Les t\u00e8cniques ORM (Object-Relational Mapping Tools) s\u00f3n les encarregades, mitjan\u00e7ant un conjunt de descripcions i metadades (dades que descriuen les dades), de fer una correspond\u00e8ncia entre les dades primitives d'ambd\u00f3s models i les seves estructures: entre taules i objectes, camps i atributs, els seus identificadors i les seves claus prim\u00e0ries. Aquesta correspond\u00e8ncia no sempre ser\u00e0 senzilla i hauran d'estar disponibles metadades que puguin expressar una major complexitat.</p> <p>Per exemple:</p> <ul> <li>Potser trobarem que a vegades pot ser interessant emmagatzemar una propietat en m\u00e9s d'una columna, o diverses propietats en una sola columna.</li> <li>En altres ocasions, pot haver-hi propietats que no s'emmagatzemin, o camps de la base de dades que no apareguin en els objectes.</li> <li>Utilitzeu atributs amb tipus de dades no primitius que necessiten ser convertits en altres taules, i decidiu quins camps seran claus externes que apuntin a les noves taules.</li> </ul> <p>De la mateixa manera que la definici\u00f3 de les dades, necessitarem un mecanisme de persist\u00e8ncia d'objectes, de manera que els objectes puguin ser \"rastrejats\" a la mem\u00f2ria i quan es reflecteixin canvis en ells, es reflecteixin directament a la base de dades.</p>"},{"location":"UD3_Hibernate/1_Mapping/#2-mapeig","title":"2. Mapeig","text":"<p>Amb aquestes eines de mapeig aconseguirem:</p> <ul> <li>Reduir el temps de desenvolupament</li> <li>Oblidar-nos del nostre SGBD subjacent</li> <li>Treballar amb objectes, atributs i m\u00e8todes. No necessiteu saber res sobre taules i relacions.</li> </ul> <p>Totes les eines de mapeig es basen en aquestes tres bases s\u00f2lides.</p>"},{"location":"UD3_Hibernate/1_Mapping/#21-tecniques-de-mapeig","title":"2.1. T\u00e8cniques de mapeig","text":"<p>Destaquem dues t\u00e8cniques de mapeig objecte-relacional:</p> <ul> <li>Aquelles que incrusten les definicions dins del codi de les classes i estan vinculades al llenguatge, com ara macros de C++ o anotacions de PHP i Java.</li> <li>Aquelles que guarden les definicions en fitxers independents del codi, generalment en XML o JSON.</li> </ul> <p>Aquestes t\u00e8cniques no s\u00f3n exclusives, ja que totes dues estan disponibles en la majoria d'entorns i fins i tot poden coexistir en la mateixa aplicaci\u00f3.</p>"},{"location":"UD3_Hibernate/1_Mapping/#22-llenguatge-de-consulta","title":"2.2. Llenguatge de consulta","text":"<p>Com que els SGBD inclouen SQL com a llenguatge de consulta, la majoria dels ORM inclouen el seu propi llenguatge, basat en OQL (Object Query Language). Com en SQL, podem demanar informaci\u00f3, per\u00f2 basada en objectes en comptes de taules.</p>"},{"location":"UD3_Hibernate/1_Mapping/#23-sincronitzacio","title":"2.3. Sincronitzaci\u00f3","text":"<p>Els ORM inclouen diversos processos centrats en:</p> <ul> <li>Seguir i descobrir els canvis que els objectes experimenten durant el seu cicle de vida per emmagatzemar-los.</li> <li>Crear i iniciar noves inst\u00e0ncies d'objectes a partir de les dades emmagatzemades a la base de dades.</li> <li>A partir dels objectes, extreure la seva informaci\u00f3 per reflectir-la a les taules de la base de dades.</li> </ul> <p>Note</p> <p>Estudiarem el cicle de vida dels objectes quan es carreguen i es desen de la base de dades.</p>"},{"location":"UD3_Hibernate/2_Hibernate/","title":"2. Introduccio a Hibernate","text":""},{"location":"UD3_Hibernate/2_Hibernate/#1-hibernate","title":"1. Hibernate","text":"<p>Hibernate \u00e9s un framework ORM per a Java, que facilita la correspond\u00e8ncia d'atributs entre una base de dades relacional i el model d'objectes de la nostra aplicaci\u00f3 mitjan\u00e7ant fitxers XML o anotacions en els beans d'entitat. \u00c9s un programari lliure distribu\u00eft sota la llic\u00e8ncia GPL 2.0, per la qual cosa es pot utilitzar en aplicacions comercials.</p> <p>La funci\u00f3 principal de Hibernate ser\u00e0 oferir a l'programador les eines per detallar el seu model de dades i les relacions entre ells, de manera que sigui l'ORM mateix el que interactu\u00ef amb la base de dades, mentre que el desenvolupador es dedica a manipular objectes.</p> <p>A m\u00e9s, ofereix un llenguatge de consulta, anomenat HQL (Hibernate Query Language), de manera que sigui l'ORM mateix el que tradueixi aquest llenguatge al de cada motor de base de dades, mantenint aix\u00ed la portabilitat a costa d'un lleuger augment en el temps d'execuci\u00f3.</p> <p></p> <p>Quan es creen objectes, aquests s\u00f3n vol\u00e0tils o temporals (es destruiran quan l'aplicaci\u00f3 finalitzi). Quan volem emmagatzemar-los amb Hibernate, s\u00f3n rastrejats amb un mecanisme anomenat <code>Session</code>. Tamb\u00e9 es rastrejen els objectes carregats des de les bases de dades. Si ho desitgem, podem finalitzar el rastreig, eliminant l'objecte quan ja no el necessitem.</p> <p>A m\u00e9s, es proporciona un llenguatge de consulta, HQL o Hibernate Query Language, basat en OQL. La part subjacent de la sessi\u00f3, com es pot veure, permet l'\u00fas de diverses tecnologies, incloent JDBC per connectar-se al SGBD necessari.</p>"},{"location":"UD3_Hibernate/2_Hibernate/#2-configuracio","title":"2. Configuraci\u00f3","text":"<p>Hibernate, com un bon framework, no necessita una instal\u00b7laci\u00f3, ja que est\u00e0 integrat en el nostre projecte com a llibreries. Podr\u00edem optar per instal\u00b7lar moltes llibreries jar, per\u00f2 \u00e9s molt millor utilitzar un gestor de paquets per automatitzar aquesta tasca. El proc\u00e9s de construcci\u00f3 del projecte ser\u00e0 m\u00e9s f\u00e0cil al final.</p> <p>Utilitzarem Maven com a gestor de paquets.</p>"},{"location":"UD3_Hibernate/2_Hibernate/#3-dependencies","title":"3. Dependencies.","text":"<p>En els nostres projectes s'utilitzaran dues eines b\u00e0siques: Hibernate i un controlador per connectar-se a la base de dades seleccionada. \u00d2bviament, cal afegir les depend\u00e8ncies al gestor de paquets. En Maven, les depend\u00e8ncies s'inclouen al fitxer <code>Pom.xml</code>, a la carpeta arrel del nostre projecte. Dins de l'etiqueta <code>&lt;dependencies&gt;</code> cal afegir:</p> XML<pre><code>&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;mysql&lt;/groupId&gt;\n    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n    &lt;version&gt;8.0.27&lt;/version&gt;\n&lt;/dependency&gt;\n\n&lt;!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-core --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;\n    &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;\n    &lt;version&gt;5.6.3.Final&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Si has triat Gradle com a gestor de paquets, el teu <code>build.gradle</code> hauria de ser el seg\u00fcent:</p> Bash<pre><code>dependencies {\n    // https://mvnrepository.com/artifact/mysql/mysql-connector-java\n    implementation group: 'mysql', name: 'mysql-connector-java', version: '8.0.27'\n\n    // https://mvnrepository.com/artifact/org.hibernate/hibernate-core\n    implementation group: 'org.hibernate', name: 'hibernate-core', version: '5.6.3.Final'\n}\n</code></pre> <p>Recorda...</p> <p>Recorda que pots trobar els paquets a https://mvnrepository.com/repos/central</p>"},{"location":"UD3_Hibernate/2_Hibernate/#4-estructura-del-projecte","title":"4. Estructura del projecte","text":"<p>Un cop hem afegit les depend\u00e8ncies, hem de crear una estructura de projecte per organitzar les nostres classes, amb l'objectiu de separar la l\u00f2gica del programa. A continuaci\u00f3, mostrarem una breu descripci\u00f3, aprofundint en cada punt m\u00e9s endavant.</p>"},{"location":"UD3_Hibernate/2_Hibernate/#41-beans","title":"4.1. Beans","text":"<p>Els Beans s\u00f3n l'evoluci\u00f3 dels POJOs que hem estudiat en unitats anteriors. Recorda que aquestes classes s\u00f3n objectes comuns, sense pert\u00e0nyer a cap arbre d'her\u00e8ncia i sense implementar cap interf\u00edcie. S'utilitzen per emmagatzemar informaci\u00f3 sobre un concepte concret (si necessito un cotxe...crea un cotxe).</p> <p>Com a extensi\u00f3 dels POJOs, apareixen els Beans, sense restriccions en els atributs, constructors i her\u00e8ncia. Tenen algunes restriccions:</p> <ul> <li>Els seus atributs han de ser <code>private</code> (encapsulaci\u00f3).</li> <li>Han de implementar la interf\u00edcie <code>Serializable</code>.</li> <li>Han de tenir getters i setters p\u00fablics.</li> <li>Han de tenir un constructor gen\u00e8ric (sense arguments).</li> </ul> <p>Recorda</p> <p>La serialitzaci\u00f3 en temps d'execuci\u00f3 associa a cada classe serialitzable un n\u00famero de versi\u00f3, anomenat <code>serialVersionUID</code>, que s'utilitza durant la deserialitzaci\u00f3 per verificar que l'emissor i el receptor d'un objecte serialitzat han carregat classes per a aquest objecte que s\u00f3n compatibles en relaci\u00f3 a la serialitzaci\u00f3.</p> <p>Si el receptor ha carregat una classe per a l'objecte que t\u00e9 un <code>serialVersionUID</code> diferent del de la classe de l'emissor corresponent, llavors la deserialitzaci\u00f3 donar\u00e0 lloc a una <code>InvalidClassException</code>. Una classe serialitzable pot declarar el seu propi <code>serialVersionUID</code> expl\u00edcitament mitjan\u00e7ant la declaraci\u00f3 d'un camp anomenat <code>serialVersionUID</code> que ha de ser est\u00e0tic, final i de tipus long:</p> Java<pre><code>static final long serialVersionUID = 137L;\n</code></pre> <p>Aix\u00ed, els Beans s\u00f3n components d'acc\u00e9s a dades i representen entitats a la nostra aplicaci\u00f3. \u00c9s una bona idea crear els nostres Beans a la mateixa carpeta, normalment anomenada <code>Model</code>.</p> <p>Recorda</p> <p>Recordes la llibreria <code>Lombok</code>? \u00c9s molt \u00fatil per crear els nostres beans amb nom\u00e9s unes poques l\u00ednies de codi.</p>"},{"location":"UD3_Hibernate/2_Hibernate/#42-fitxers-de-mapeig","title":"4.2. Fitxers de mapeig","text":"<p>Un cop s'hagin creat les entitats, cal mapejar cada entitat. Cada mapeig estableix les refer\u00e8ncies entre els beans i les taules, els atributs i les columnes, per establir una coincid\u00e8ncia perfecta entre ells.</p> <p>La primera opci\u00f3 ser\u00e0 crear fitxers de mapeig, amb la sintaxi (en XML) entre les classes i les taules. Si el bean es diu <code>Car</code>, el fitxer de mapeig hauria de ser <code>Car.hbm.xml</code>:</p> <ul> <li><code>hbm</code> \u00e9s per a mapeig d'hibernate</li> <li><code>xml</code> perqu\u00e8 la sintaxi est\u00e0 en l'especificaci\u00f3 XML.</li> </ul> <p>Estudiarem els fitxers de mapeig en les seg\u00fcents seccions.</p>"},{"location":"UD3_Hibernate/2_Hibernate/#43-altres-fitxers","title":"4.3. Altres fitxers","text":"<p>Finalment, tindrem la resta de classes del programa, aix\u00ed com l'aplicaci\u00f3 o classe principal. Si esteu dissenyant una aplicaci\u00f3 amb un entorn gr\u00e0fic, hi hauria classes de representaci\u00f3 de dades o vistes. De manera similar, en cas d'una aplicaci\u00f3 web, faltarien els controladors i els serveis.</p>"},{"location":"UD3_Hibernate/2_Hibernate/#5-configuracio-del-projecte","title":"5. Configuraci\u00f3 del projecte","text":"<p>Anem a examinar m\u00e9s detingudament el fitxer de configuraci\u00f3 d'Hibernate. En el fitxer de configuraci\u00f3 d'Hibernate podem establir les opcions de manera desordenada, per\u00f2 es recomana agrupar els blocs d'opcions per aclarir i mantenir el codi, aix\u00ed com indicar mitjan\u00e7ant comentaris qu\u00e8 estem fent en cada moment. Ho veurem amb un exemple complet, que detallarem pas a pas en les seccions seg\u00fcents.</p>"},{"location":"UD3_Hibernate/2_Hibernate/#51-hibernatecfgxml","title":"5.1. Hibernate.cfg.xml","text":"XML<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n  &lt;!DOCTYPE hibernate-configuration PUBLIC \n    \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\" \n    \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\"&gt;\n\n &lt;hibernate-configuration&gt;\n    &lt;session-factory&gt;\n      &lt;!-- Connection properties --&gt;\n      &lt;!-- Driver JDBC --&gt;\n        &lt;property name=\"connection.driver_class\"&gt;\n          com.mysql.cj.jdbc.Driver\n        &lt;/property&gt;\n\n      &lt;!-- Add ?createDatabaseIfNotExist=true to create database  --&gt;\n      &lt;property name=\"connection.url\"&gt;\n        jdbc:mysql://localhost:3308/DBName\n      &lt;/property&gt;\n\n      &lt;!--user and pass --&gt;\n      &lt;property name=\"connection.username\"&gt;root&lt;/property&gt;\n      &lt;property name=\"connection.password\"&gt;root&lt;/property&gt;\n\n      &lt;!-- extra conf --&gt;\n\n      &lt;!-- JDBC connection pool for concurrent connections --&gt;\n      &lt;property name=\"connection.pool_size\"&gt;5&lt;/property&gt;\n\n      &lt;!--  dialect connector. Useful for Foreing Keys--&gt;\n      &lt;property name=\"dialect\"&gt;\n        org.hibernate.dialect.MySQL5InnoDBDialect\n      &lt;/property&gt;\n\n      &lt;!-- one thread one session --&gt;\n      &lt;property name=\"current_session_context_class\"&gt;thread&lt;/property&gt;\n\n      &lt;!-- show \"reals\" SQL ops. only for development--&gt;\n      &lt;property name=\"show_sql\"&gt;true&lt;/property&gt;\n\n      &lt;!-- DB maintenance --&gt;\n      &lt;property name=\"hbm2ddl.auto\"&gt;update&lt;/property&gt;\n\n      &lt;!-- options hbm2dll:\n        create : \n          create always DB when session factory is loaded. Data will be lost.\n        update : \n          Data will be safe, but database structure will be update. \n          Useful in production.\n        create-drop : \n          like create and dropping the database.\n        validate:   \n          check the mapping between database and beans.\n      --&gt;\n\n      &lt;!-- Mapping files. Can be combined--&gt;\n\n      &lt;!-- mapping classes --&gt;\n      &lt;mapping class=\"package.class1\" /&gt;\n      &lt;mapping class=\"package.class2\" /&gt;\n\n      &lt;!-- Maping files--&gt;\n      &lt;mapping resource=\"class3.hbm.xml\" /&gt;\n      &lt;mapping resource=\"class4.hbm.xml\" /&gt;\n    &lt;/session-factory&gt;\n&lt;/hibernate-configuration&gt;\n</code></pre> <p>Cal tenir en compte que:</p> <ul> <li>\u00c9s molt recomanable tenir l'opci\u00f3 de mostrar les consultes SQL establerta a <code>true</code>, almenys en els primers projectes, per veure com es realitza la correspond\u00e8ncia dels objectes amb les consultes SQL.</li> <li>L'opci\u00f3 <code>hbm2ddl</code> \u00e9s molt potent, ja que si nom\u00e9s partim del model orientat a objectes, Hibernate crear\u00e0 la base de dades per a nosaltres (obviament buida de dades). M\u00e9s endavant veurem en una pr\u00e0ctica posterior una altra opci\u00f3 molt interessant, <code>hbm2java</code>, que mitjan\u00e7ant l'enginyeria inversa ens permetr\u00e0 crear els nostres Beans a partir del disseny relacional.</li> <li>Els fitxers de mapeig XML () han d'estar junts amb les classes Java, en el mateix paquet. <li>Els mapejos dins de les classes () fan refer\u00e8ncia als propis Beans, com veurem a la seg\u00fcent secci\u00f3."},{"location":"UD3_Hibernate/2_Hibernate/#52-carrega-de-scripts","title":"5.2. C\u00e0rrega de scripts","text":"<p>Si voleu inserir dades a la vostra base de dades en aplicacions de prova, \u00e9s una bona idea tenir un script SQL i carregar-lo autom\u00e0ticament quan es carregui la configuraci\u00f3 d'Hibernate. Podeu afegir un fitxer sota <code>src/main/resources</code> anomenat <code>import.sql</code>, i, despr\u00e9s de la creaci\u00f3 de taules, si existeix, aquest script s'executar\u00e0. Aquesta \u00e9s la manera de comen\u00e7ar un projecte amb dades de prova existents a les nostres bases de dades.</p> <p>A m\u00e9s, si voleu executar m\u00e9s scripts, podeu afegir fitxers espec\u00edfics a <code>hibernate.cfg.xml</code>, de la seg\u00fcent manera:</p> XML<pre><code>&lt;property name=\"hibernate.hbm2ddl.import_files\"&gt;\n  /import1.sql, /import2.sql\n&lt;/property&gt;\n</code></pre>"},{"location":"UD3_Hibernate/2_Hibernate/#6-carregant-la-configuracio-i-les-sessions","title":"6. Carregant la configuraci\u00f3 i les sessions","text":"<p>Per tal de carregar el fitxer de configuraci\u00f3 anterior, hem de crear un objecte <code>SessionFactory</code> a trav\u00e9s del qual podem crear inst\u00e0ncies de <code>Session</code> per connectar-nos a la nostra base de dades. L'estructura d'aquesta classe ser\u00e0 sempre la mateixa: carregar el fitxer de configuraci\u00f3 XML i despr\u00e9s crear la <code>SessionFactory</code>.</p> Java<pre><code>public class HibernateUtil {\n\n    private static final SessionFactory sessionFactory;\n\n    // C\u00f3digo est\u00e1tico. S\u00f3lo se ejecuta una vez, como un Singleton\n    static {\n        try {\n            // Creamos es SessionFactory desde el fichero hibernate.cfg.xml \n            sessionFactory = new Configuration()\n                .configure(new File(\"hibernate.cfg.xml\")).buildSessionFactory();    \n        } catch (Throwable ex) {\n            System.err.println(\"Error en la inicializaci\u00f3n.  \" + ex);\n            throw new ExceptionInInitializerError(ex);\n        }\n    }\n\n    public static SessionFactory getSessionFactory() {\n        return sessionFactory;\n    }\n}\n</code></pre> <p>Atenci\u00f3</p> <p>Aquesta implementaci\u00f3 s'ha realitzat amb el patr\u00f3 de disseny Singleton, per tal de tenir una \u00fanica inst\u00e0ncia de SessionFactory.</p>"},{"location":"UD3_Hibernate/3_Entities_Beans/","title":"3. Entitats","text":""},{"location":"UD3_Hibernate/3_Entities_Beans/#1-mapeig-dentitas-beans","title":"1. Mapeig d'Entitas. Beans","text":"<p>Un cop estudiat la configuraci\u00f3 inicial, \u00e9s el moment de mapejar les nostres entitats i relacions. Partint del model relacional, anem a fer servir aquesta entitat  <code>Peli</code>:</p> SQL<pre><code>CREATE dTABLE `Peli` (\n  `idPeli` int(11) NOT NULL AUTO_INCREMENT,\n  `titulo` varchar(45) NOT NULL,\n  `anyo` varchar(45) NOT NULL,\n  `director` varchar(45) NOT NULL,\n  PRIMARY KEY (`idPeli`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8\n</code></pre> <p>Ac\u00ed tens un script DBCine.sql per a treballar. La classe que encapsula la pel\u00b7l\u00edcula ser\u00e0 alguna cosa semblant a:</p> Java<pre><code>package Model;\n\nimport java.io.Serializable;\n\n/**\n *\n * @author joange\n */\npublic class Peli implements Serializable{\n\n    private Long idPeli;\n    private String titulo;\n    private int anyo;\n    private String elDirector;\n\n    public Peli() {\n    }\n\n    public Peli(String titulo, int anyo, String elDirector) {\n        this.titulo = titulo;\n        this.anyo = anyo;\n        this.elDirector = elDirector;\n    }\n  // more to come\n}\n</code></pre> <p>Recordatori</p> <p>Recorda que pots utilitzar la llibreria <code>Lombok</code> per crear beans de manera m\u00e9s r\u00e0pida.</p>"},{"location":"UD3_Hibernate/3_Entities_Beans/#2-arxius-de-mapeix","title":"2. Arxius de Mapeix","text":"<p>El bean creat a la \u00faltima secci\u00f3 encara no es pot persistir. Per fer-ho, hem de crear un fitxer extern a la classe, amb l'extensi\u00f3 <code>hbm.xml</code> i amb el mateix nom que la classe (Hibernate Mapping). La ubicaci\u00f3 del fitxer no importa, per\u00f2 \u00e9s una bona idea guardar les classes del model en un lloc i els fitxers de mapeig en un altre.</p> <p>Aix\u00ed que crearem un paquet <code>orm</code> i dins d'aquest, crearem el fitxer <code>Peli.hbm.xml</code>. Anem a explicar-ho amb un exemple, ja que la sintaxi \u00e9s bastant extensa.</p> XML<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\" \n  \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"&gt;\n&lt;hibernate-mapping&gt;\n    &lt;class name=\"Model.Peli\" table=\"Peli\" &gt;\n        &lt;id column=\"idPeli\" name=\"idPeli\" type=\"int\"&gt;\n            &lt;generator class=\"native\"/&gt;\n        &lt;/id&gt;\n        &lt;property name=\"titulo\" type=\"string\"/&gt;\n        &lt;property name=\"anyo\" /&gt;\n        &lt;property column=\"director\" name=\"elDirector\" /&gt;\n    &lt;/class&gt;\n&lt;/hibernate-mapping&gt;\n</code></pre> <p>Fixar-se en els conceptes b\u00e0sics:</p> <ul> <li>Les l\u00ednies 1-3 s\u00f3n la cap\u00e7alera XML, que apunta al fitxer DTD amb la gram\u00e0tica per comprovar que el fitxer est\u00e0 ben format.</li> <li><code>&lt;hibernate-mapping&gt;</code> \\(\\rightarrow\\) indica que aquest fitxer \u00e9s un mapeig.</li> <li><code>&lt;class&gt;</code> \\(\\rightarrow\\) \u00e9s l'etiqueta per especificar quina classe estem mapejant i t\u00e9 dos atributs:<ul> <li><code>name=\"Model.Peli\"</code> \\(\\rightarrow\\) apunta a la classe (fitxer Java), sense extensi\u00f3.</li> <li><code>table=\"Peli\"</code> \\(\\rightarrow\\) aqu\u00ed escrivim el nom de la taula a la base de dades que contindr\u00e0 les dades.</li> </ul> </li> <li>Cal especificar els camps de la classe i les seves respectives columnes. Distingim entre:<ul> <li><code>&lt;property&gt;</code> \\(\\rightarrow\\) per als camps normals. Pot tenir diversos atributs:<ul> <li><code>name</code> \\(\\rightarrow\\) (obligatori) \u00e9s el nom del camp dins de la classe.</li> <li><code>column</code> \\(\\rightarrow\\) \u00e9s el nom de la columna corresponent a la taula. Si no s'especifica <code>column</code>, Hibernate assumir\u00e0 que \u00e9s el mateix que l'atribut <code>name</code>.</li> <li><code>type</code> \\(\\rightarrow\\) \u00e9s el tipus de dades de Java de la columna. Per defecte, Hibernate utilitzar\u00e0 el mateix que el especificat per la classe, per\u00f2 cal indicar-ho per resoldre camps ambigus (mira la figura seg\u00fcent, especialment en els formats de data i hora).</li> </ul> </li> <li><code>&lt;id&gt;</code> \\(\\rightarrow\\) (obligatori) \u00e9s el camp que s'utilitzar\u00e0 com a clau prim\u00e0ria i tamb\u00e9 pot tenir els atributs name, column i type. Existeix la possibilitat que la clau prim\u00e0ria sigui generada pel sistema de gesti\u00f3 de bases de dades (DBMS), i ho indicarem amb:<ul> <li><code>&lt;generator&gt;</code> \\(\\rightarrow\\) estableix el motor per generar la clau prim\u00e0ria, que pot ser especificat de diverses maneres. Amb <code>native</code> utilitzem el mateix m\u00e8tode de la base de dades subjacent. En aquest tutorial pots trobar exemples complets enlla\u00e7</li> </ul> </li> </ul> </li> </ul> <p>Atenci\u00f3</p> <ul> <li>Has de desar aquest fitxer perqu\u00e8 sigui accessible en el nostre projecte. Una bona opci\u00f3 \u00e9s crear una carpeta <code>resources</code> dins de <code>src/main</code> i desar aquests fitxers a l'interior.</li> <li>Hibernate necessita m\u00e8todes get/set per accedir als camps dels nostres objectes. No obstant aix\u00f2, potser no vols crear cap m\u00e8tode, per\u00f2 Hibernate ho necessita. La soluci\u00f3 \u00e9s afegir un nou atribut <code>access=field</code> que permet a Hibernate accedir als camps sense getters i setters.</li> </ul> <p></p> <p>Atenci\u00f3</p> <p>Estudiarem m\u00e9s opcions com les claus externes en les pr\u00f2ximes seccions.</p> <p>Ara estudiarem un xicotet programa:</p> Java<pre><code>// get a Session and start a transaction\nSession laSesion=HibernateUtil.getSessionFactory().getCurrentSession();\nlaSesion.getTransaction().begin();\n\n// Create new object\nPeli p=new Peli(\"Piratas del caribe\", 2003, \"Gore Verbinsky\");\nSystem.out.println(\"Unsaved: \"+ p);\n\n// save in the database\nLong idNueva=(Long)laSesion.save(p);\n\n// Get the saved object (with another varaible)\nPeli q=laSesion.get(Peli.class, idNueva);\n\nSystem.out.println(\"Saved: \" + q);\n\n//close all\nlaSesion.getTransaction().commit();\nlaSesion.close();\n</code></pre> <p>Comentaris:</p> <ul> <li>Cal tenir en compte que per desar un objecte (per exemple, inserir una fila a la base de dades), nom\u00e9s cal executar <code>Session.save(Object)</code>.</li> <li>Per obtenir un objecte de la base de dades, hi ha una manera senzilla, coneixent la classe i la clau prim\u00e0ria de l'objecte. El m\u00e8tode \u00e9s <code>Session.get(class,ID)</code>, i obtenim un objecte d'aquesta classe amb aquesta ID.</li> <li>Cal tenir en compte que quan creem un objecte nou, no t\u00e9 una ID (recorda que \u00e9s generada autom\u00e0ticament), per\u00f2 quan el desem, se li assigna una nova ID.</li> </ul> <p>Recorda</p> <p>Si triem <code>create</code> a la propietat <code>hbm2ddl.auto</code>, com ja suposar\u00e0s, la base de dades estar\u00e0 buida. \u00c9s una bona idea crear un fitxer anomenat <code>imports.sql</code> amb algunes dades necess\u00e0ries per provar els nostres programes.</p>"},{"location":"UD3_Hibernate/3_Entities_Beans/#3-mapejant-classes-anotacions","title":"3. Mapejant classes. Anotacions.","text":"<p>Abans de comen\u00e7ar a anotar classes, deixem que us mostri aix\u00f2:</p> <ul> <li> <p>JDO (Java Data Objects) \u00e9s un est\u00e0ndard de persist\u00e8ncia desenvolupat per Apache, que inclou un marc de treball de persist\u00e8ncia basat en post-compilaci\u00f3. Tot i intentar aconseguir una t\u00e8cnica m\u00e9s eficient, hi ha poques iniciatives comercials que segueixen aquest est\u00e0ndard.</p> </li> <li> <p>L'alternativa \u00e9s JPA (Java Persistance API), un est\u00e0ndard de persist\u00e8ncia incorporat a JDK 5, amb diverses llibreries que el suporten, i basat en el principi de la reflexi\u00f3, que utilitza metadades aix\u00ed com informaci\u00f3 sobre les classes i l'estructura perqu\u00e8 la m\u00e0quina virtual pugui accedir a la informaci\u00f3 recopilada dels objectes per invocar els seus m\u00e8todes i construir noves inst\u00e0ncies. Les dues ORM m\u00e9s implementades en Java: Hibernate i EJB utilitzen aquest est\u00e0ndard.</p> </li> </ul> <p>Mapejar classes \u00e9s f\u00e0cil, i nom\u00e9s cal emparellar cada camp amb cada columna. L'inconvenient \u00e9s que necessitem mantenir dos fitxers: classes i fitxers de mapeig. Per aquest motiu, podem unir tots dos elements, afegint dins de les classes les anotacions espec\u00edfiques per fer l'emparellament. La interf\u00edcie JPA ens permet fer aquesta tasca.</p> <p>Anem a mostrar una classe amb anotacions i comparar-la amb els fitxers de mapeig. A m\u00e9s, farem servir Lombok per crear la classe, que tamb\u00e9 utilitza anotacions ;).</p> Java<pre><code>@Data\n@NoArgsConstructor\n@Entity\n@Table(name = \"Car\")\npublic class Car implements Serializable {\n\npublic Car(String plate, String brand, int year) {\n    this.plate = plate;\n    this.brand = brand;\n    this.year = year;\n}\n\nstatic final long serialVersionUID = 137L;\n\n@Id\n@GeneratedValue(strategy = GenerationType.IDENTITY)\nprivate long idCar;\n\n@Column\nprivate String plate;\n\n@Column(name = \"marca\")\nprivate String brand;\n\n@Column\nprivate int year;\n}\n</code></pre> <p>Informaci\u00f3</p> <p>Hibernate primer cre\u00e0 les anotacions del paquet <code>org.hibenate.annotations</code>, per\u00f2 des de la versi\u00f3 4 est\u00e0 depreciat, i s'ha d'importar des de <code>javax.persistence</code></p> <p>Anem a veure les principals anotacions, tot i que en tindr\u00e0s moltes m\u00e9s a la documentaci\u00f3 de JPA:</p> <ul> <li><code>@Entity</code> per indicar que aquesta classe representa una entitat a la nostra base de dades. A m\u00e9s, hem d'associar aquesta entitat a una <code>@Table</code> amb el nom correcte.</li> <li>Per definir els camps de la base de dades, hem d'utilitzar <code>@Column</code>. Pots especificar m\u00e9s opcions, especialment si el nom de la columna \u00e9s diferent del nom del camp. Consulta la seg\u00fcent imatge per a m\u00e9s opcions. Una opci\u00f3 interessant \u00e9s establir un valor generat autom\u00e0ticament amb <code>@GeneratedValue</code>. Si no especifiques l'opci\u00f3 <code>name</code>, es suposa que \u00e9s el mateix.</li> <li>Per marcar un camp com a clau prim\u00e0ria, necessites <code>@Id</code>. En aquest cas, no cal que ho especifiquis amb <code>@Column</code>.</li> </ul>"},{"location":"UD3_Hibernate/3_Entities_Beans/#4-components","title":"4. Components","text":"<p>Anem a revisar un patr\u00f3 de disseny especial, que \u00e9s l'agregaci\u00f3. Aquest patr\u00f3 s'utilitza quan necessitem una entitat que nom\u00e9s t\u00e9 sentit dins d'una altra entitat, per exemple, una roda no t\u00e9 sentit fora d'un cotxe. Si l'entitat pot existir per si sola, \u00e9s quan utilitzem una relaci\u00f3, i ho estudiarem a la seg\u00fcent secci\u00f3.</p> <p>La classe agregada tamb\u00e9 es coneix com a component.</p> <p>Compte</p> <p>Aquests components tamb\u00e9 es poden substituir per una relaci\u00f3 1:1 amb una restricci\u00f3 d'exist\u00e8ncia, quan en el proc\u00e9s de normalitzaci\u00f3 es junten a la mateixa taula.</p> <p>Per crear un component, la classe agregada s'ha de definir amb <code>@Embeddable</code> (i, \u00f2bviament, sense <code>@Entity</code>). Aquesta anotaci\u00f3 indica a Hibernate que l'exist\u00e8ncia d'aquests objectes ha d'estar dins d'altres objectes. Dins d'aquests objectes, com a camps, els objectes s'han de marcar amb <code>@Embedded</code>. Anem a veure un exemple:</p> <p>Un component <code>Roda</code> (Wheel</p> Java<pre><code>@Embeddable\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class Wheel {\n\n    @Column\n    int diameter;\n    @Column\n    char speedCode;\n}\n</code></pre> <p>An aggregation <code>CarWheel</code></p> Java<pre><code>@Data\n@NoArgsConstructor\n@Entity\n@Table(name = \"Car\")\npublic class CarWheel implements Serializable {\n\n    public CarWheel(String plate, String brand, int year, Wheel wheel) {\n        this.plate = plate;\n        this.brand = brand;\n        this.year = year;\n        this.wheel = wheel;\n    }\n\n    static final long serialVersionUID = 137L;\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private long idCar;\n\n    @Column\n    private String plate;\n\n    @Column(name = \"marca\")\n    private String brand;\n\n    @Column\n    private int year;\n\n    @Embedded\n    private Wheel wheel;\n\n}\n}\n</code></pre> <p>Quan Hibernate crea la taula, cal tenir en compte que no es crear\u00e0 cap taula <code>Wheel</code>. En canvi, tots els camps estan dins de <code>CarWheel</code>. Els dos \u00faltims camps s\u00f3n propietats de la classe <code>Wheel</code>.</p> SQL<pre><code>Hibernate: \ncreate table Car (\n    idCar bigint not null auto_increment, \n    marca varchar(255), \n    plate varchar(255), \n    year integer, \n    diameter integer, \n    speedCode char(1), \n  primary key (idCar)) engine=InnoDB\n</code></pre> <p>Atenci\u00f3 Pot apar\u00e8ixer un problema quan intentes desar dos components incrustats, per exemple dues adreces d'un empleat, ja que Hibernate crea camps a partir de la classe del component i els noms dels camps es duplicaran. Per evitar aquest inconvenient, la soluci\u00f3 \u00e9s canviar el nom dels camps de la classe del component, com es mostra a continuaci\u00f3 (dins de la classe agregada):</p> Java<pre><code>@Embedded\nprivate Wheel wheel1;\n\n@Embedded\n@AttributeOverrides({\n        @AttributeOverride(name=\"diameter\", column = @Column(name=\"diameter2\") ),\n        @AttributeOverride(name=\"speedCode\", column = @Column(name=\"speedCode2\") )\n})\nprivate Wheel wheel2;\n</code></pre> <p>Fixa't que:</p> <ul> <li>El primer camp incrustat no necessita res especial.</li> <li>En el segon, hem de sobreescriure els noms dels atributs, comen\u00e7ant amb <code>@AttributeOverrides</code> amb diversos <code>@AttributeOverride</code>, indicant el nom antic i el nou nom de la columna.</li> </ul> <p>Per\u00f2...</p> <p>Aquesta situaci\u00f3 no \u00e9s habitual, per\u00f2 \u00e9s important resoldre-la quan sigui necessari.</p>"},{"location":"UD3_Hibernate/3_Entities_Beans/#5-exercici","title":"5. Exercici","text":"<p>Realitza la seg\u00fcent tasca:</p> <ul> <li>Crea un projecte Maven i afegeix totes les depend\u00e8ncies que necessitis.</li> <li>Crea dues classes per tu mateix, per\u00f2 pensant que estaran relacionades en un futur. Per exemple, Professor i Tema, o Conductor i Cotxe, o Mascota i Veterinari. En aquest moment no cal que cre\u00efs cap relaci\u00f3.</li> <li>Cada classe ha de tenir una ID i almenys 4 camps, amb diversos tipus de dades (no cal que tots siguin camps de tipus String).</li> <li>Mapeja les dues classes:<ul> <li>Una amb un fitxer XML extern.</li> <li>L'altra amb anotacions JPA.</li> </ul> </li> <li>Crea una aplicaci\u00f3 principal on demanis a l'usuari les dades i les emmagatzemis (i les desis) a la mateixa base de dades.</li> </ul>"},{"location":"UD3_Hibernate/4_Relationships/","title":"4. Relacions","text":""},{"location":"UD3_Hibernate/4_Relationships/#1-mapejant-relacions","title":"1. Mapejant Relacions","text":"<p>Com vam esmentar a la introducci\u00f3, analitzarem com mapejar els diferents tipus de relacions. Abans de comen\u00e7ar a discutir la cardinalitat de les relacions, hem de considerar el significat d'aquestes relacions, i revisarem el concepte de direccionalitat de les relacions.</p> <ul> <li>Unidireccional \u2192 Direm que una relaci\u00f3 \u00e9s unidireccional quan accedim a l'objecte relacionat (component) des d'un altre objecte (propietari). Per exemple, si muntem un motor en un cotxe, el l\u00f2gic \u00e9s que el propietari sigui el cotxe, i des d'aquest obtindrem el motor. En aquest cas, dins de l'objecte Cotxe apareixer\u00e0 un objecte Motor, i el Motor no tindr\u00e0 una exist\u00e8ncia pr\u00f2pia.</li> <li>Bidireccional \u2192 S\u00f3n relacions en les quals els elements relacionats solen tenir el mateix pes o entitat. Per exemple, un Grup d'un institut i un Tutor. Des d'un grup t\u00e9 sentit con\u00e8ixer el tutor, i tamb\u00e9 podem des d'un professor (el tutor), accedir al grup que tutoritza. En aquest cas, dins de l'objecte Grup tenim una refer\u00e8ncia a l'objecte Tutor i viceversa.</li> </ul> <p>Av\u00eds</p> <p>En aquest tipus de refer\u00e8ncies, com es pot deduir, hi ha una recursi\u00f3 intr\u00ednseca. Per tant, quan gestionem aquest tipus de relacions bidireccionals, tingueu molta cura de no causar bucles, ja que fins i tot una cosa tan senzilla com imprimir pot fer que el nostre programa es bloquegi i aparegui la coneguda <code>StackOverflowException</code>.</p> <p>A partir d'ara, podr\u00edem estudiar totes les representacions amb JPA.</p>"},{"location":"UD3_Hibernate/4_Relationships/#2-relacions-un-a-un","title":"2. Relacions Un a Un","text":"<p>Per a l'explicaci\u00f3 dels exemples, veurem el disseny i la implementaci\u00f3 a la base de dades de cada cas i com es veu a Hibernate. Per a aquest exemple representarem una relaci\u00f3 1:1 entre Grup i Professor, on es pot veure que un Grup t\u00e9 un Tutor, i un Tutor nom\u00e9s pot tutoritzar un Grup.</p> <p></p> <p>Primerament, la classe que \u00e9s apuntada per la clau forana. Molt f\u00e0cil, perqu\u00e8 no necessitem fer res.</p> Java<pre><code>@Data\n@NoArgsConstructor\n@Entity\n@Table(name=\"Profesor\")\npublic class Profesor {\n\n  static final long serialVersionUID = 1L;\n\n  @Id\n  @GeneratedValue(strategy=GenerationType.IDENTITY)\n  private int idTeacher;\n\n  @Column\n  private String name;\n\n  public Profesor(String name) {\n      this.name = name;\n  }   \n}\n</code></pre> <p>I ara, la classe que cont\u00e9 la clau aliena. Aqu\u00ed hem de marcar que un <code>Grup</code> necessita un <code>Professor</code> com a tutor. Vegem-ho:</p> <p>Java<pre><code>@Data\n@NoArgsConstructor\n@Entity\n@Table(name = \"Grupo\")\npublic class Grupo implements Serializable {\n\n  static final long serialVersionUID = 137L;\n\n  @Id\n  @GeneratedValue(strategy = GenerationType.IDENTITY)\n  private long idGroup;\n\n  @Column\n  private String level;\n\n  @Column\n  private String course;\n\n  @Column\n  private int year;\n\n  @OneToOne(cascade = CascadeType.ALL)\n  @JoinColumn(\n      name=\"id_tutor\",\n      referencedColumnName = \"idTeacher\",\n      unique=true,\n      foreignKey = @ForeignKey(name = \"FK_GRP_TEACH\"))\n  private Profesor tutor;\n\n  public Grupo(String level, String course, int year) {\n      this.level = level;\n      this.course = course;\n      this.year = year;\n  }  \n\n}\n</code></pre> Tingueu en compte que la classe <code>Grupo</code> cont\u00e9 un camp anomenat <code>tutor</code> de la classe <code>Profesor</code>, i:</p> <ul> <li><code>@OneToOne(cascade = CascadeType.ALL)</code> marquem aquesta relaci\u00f3 com a 1:1. A m\u00e9s, especifiquem l'atribut <code>cascade</code>, que \u00e9s el m\u00e9s important. El cascading \u00e9s la manera de dir que quan realitzem alguna acci\u00f3 sobre l'entitat objectiu (<code>Grupo</code>), la mateixa acci\u00f3 s'aplicar\u00e0 a l'entitat associada (<code>Profesor</code>). Revisem les opcions m\u00e9s rellevants:</li> <li><code>CascadeType.ALL</code> propaga totes les operacions. La mateixa operaci\u00f3 que fem en l'objectiu es far\u00e0 en l'associat.</li> <li><code>CascadeType.PERSIST</code> propaga nom\u00e9s l'operaci\u00f3 de persist\u00e8ncia a la base de dades (guardar).</li> <li><code>CascadeType.SAVE_UPDATE</code> \u00e9s de Hibernate, no de JPA, i propaga el m\u00e8tode <code>saveOrUpdate()</code>. \u00c9s molt similar a persist.</li> <li><code>CascadeType.REMOVE</code> o <code>CascadeType.DELETE</code> propaga l'eliminaci\u00f3 d'entitats. Tingueu molta cura amb aquesta opci\u00f3 per evitar perdre dades.</li> <li>En el <code>@JoinColumn</code> establim:</li> <li>el nom de la columna a la nostra base de dades</li> <li>el nom de la columna referenciada en l'entitat objectiu <code>Profesor</code></li> <li><code>unique=true</code> per assegurar que la relaci\u00f3 \u00e9s 1:1 (un professor no pot estar relacionat amb cap altre grup)</li> <li>[opcional] per establir el nom de la restricci\u00f3 de clau forana, en cas que vulgueu canviar-lo o eliminar-lo en operacions futures.</li> </ul> <p>M\u00e9s informaci\u00f3 a la seg\u00fcent webbaeldung</p>"},{"location":"UD3_Hibernate/4_Relationships/#21-un-a-un-bidireccional","title":"2.1. Un a Un bidireccional","text":"<p>Si volem emmagatzemar en Professor els grups que est\u00e0 tutoritzant, necessitem afegir una refer\u00e8ncia al Grup. Com que hem fet la clau forana en Grup, ser\u00e0 molt f\u00e0cil:</p> Java<pre><code>@OneToOne(mappedBy= \"tutor\") \nprivate Grupo elGrupo;\n</code></pre> <p>Amb <code>mappedBy=\"tutor\"</code> estem dient que a la classe <code>Grupo</code> existeix un camp anomenat <code>tutor</code> amb tota la informaci\u00f3 sobre la relaci\u00f3. Tingueu en compte que no s'afegiran camps addicionals a <code>Profesor</code>, perqu\u00e8 la informaci\u00f3 sobre la relaci\u00f3 es troba a la taula <code>Grupo</code>.</p>"},{"location":"UD3_Hibernate/4_Relationships/#3-un-a-molts","title":"3. Un a Molts","text":"<p>Per a aquesta explicaci\u00f3 comen\u00e7arem amb el seg\u00fcent model, en el qual un Llibre t\u00e9 un Autor que l'ha escrit, i un Autor pot haver escrit diversos Llibres. En l'esquema relacional, la relaci\u00f3 \u00e9s des de <code>idAutor</code> en Llibres, que \u00e9s clau forana a la taula Autor (ID).</p> <p></p> <p>Primer, podem decidir qui \u00e9s el propietari de la relaci\u00f3. Realment no importa, per\u00f2 en diversos dissenys \u00e9s molt clar, per exemple entre <code>Estudiant</code> i <code>Email</code>, on \u00f2bviament el propietari \u00e9s <code>Estudiant</code>. Normalment hauria de ser la classe amb cardinalitat molts el propietari. Vegem l'exemple.</p> <p>Java<pre><code>@Entity\n@Table(name=\"Libro\")\npublic class Libro implements Serializable {\n\n    @Id\n    @GeneratedValue(strategy=GenerationType.IDENTITY)\n    private Long idLibro;\n\n    @Column\n    private String titol;\n\n    @Column\n    private String tipus;\n\n    @ManyToOne(cascade=CascadeType.PERSIST)\n    @JoinColumn(name=\"idAutor\",\n                foreignKey = @ForeignKey(name = \"FK_LIB_AUT\" ))\n    private Autor elAutor;\n</code></pre> En aquest exemple, un <code>Llibre</code> t\u00e9 un autor (\u00fanic). Ho implementem emmagatzemant una refer\u00e8ncia a un objecte Autor, anomenat <code>elAutor</code> dins del nostre Llibre. Hem d'escriure la informaci\u00f3 de la relaci\u00f3 en aquest camp:</p> <ul> <li>Hem de marcar aquest camp com <code>@ManyToOne</code>, perqu\u00e8 Llibre est\u00e0 al costat dels molts de la relaci\u00f3 (recordeu que un Autor pot escriure diversos Llibres)</li> <li>La clau forana ser\u00e0 anotada amb l'etiqueta <code>@JoinColumn</code>, amb diversos atributs:</li> <li>Com que <code>elAutor</code> \u00e9s el punt inicial de la clau forana, que apunta a la taula <code>Author</code>, necessitem dir el nom de la clau prim\u00e0ria en aquesta classe. Aquest atribut \u00e9s opcional, per\u00f2 \u00e9s una bona opci\u00f3 per millorar el nostre codi.</li> <li>Opcionalment, podem anomenar la restricci\u00f3 de la clau forana, amb un nom ben estructurat, amb l'atribut <code>foreignKey</code></li> </ul> Java<pre><code>@Entity\n@Table(name=\"Libro\")\npublic class Autor implements Serializable{\n\n    static final long serialVersionUID = 137L;\n\n    @Id\n    @GeneratedValue(strategy=GenerationType.IDENTITY)\n    private Long idAutor;\n\n    @Column\n    private String nom;\n\n    @Column\n    private String nacionalitat;\n\n    @OneToMany(mappedBy=\"elAutor\",\n            cascade=CascadeType.PERSIST,\n            fetch = FetchType.LAZY)\n    private Set&lt;Libro&gt; elsLlibres;\n\n    // rest of the class\n</code></pre> <p>La classe <code>Autor</code> est\u00e0 en el costat un, i aix\u00f2 significa que pot escriure molts <code>Llibres</code>. Per aquesta ra\u00f3, emmagatzemem tots els llibres que ha escrit en un <code>Set</code> de llibres. Les anotacions seran:</p> <ul> <li>Com que un Autor pot escriure molts llibres, marquem el Set de llibres com <code>@OneToMany</code>. Com que hem escrit l'especificaci\u00f3 de la relaci\u00f3 en Llibre, podr\u00edem dir que la relaci\u00f3 est\u00e0 mapejada en el camp <code>elAutor</code> dins de la classe <code>Llibre</code>, amb <code>mappedBy=\"elAutor\"</code> f\u00e0cilment.</li> </ul> <p>Decisi\u00f3</p> <p>En lloc d'emmagatzemar llibres en un Set, es poden emmagatzemar en una Llista. La principal difer\u00e8ncia \u00e9s respondre a aquesta pregunta: \u00e9s important l'ordre?. Si respons s\u00ed, has d'utilitzar una Llista. Si la resposta \u00e9s no, has d'utilitzar un Set.</p> <p>Espai</p> <p>La relaci\u00f3 <code>1:N</code> que hem explicat \u00e9s bidireccional. Aix\u00f2 vol dir que des d'un Autor podem obtenir tots els Llibres que ha escrit, i des d'un Llibre podem obtenir l'Autor.</p> <p></p> <p>Podeu trobar diverses p\u00e0gines i llibres que expliquen les relacions unidireccionals <code>1:N</code>. Aix\u00f2 vol dir que amb aquest tipus d'implementaci\u00f3 nom\u00e9s podem viatjar en una direcci\u00f3. En aquest cas, hem d'emmagatzemar nom\u00e9s dins d'un Llibre qui \u00e9s l'autor, perqu\u00e8 el Llibre \u00e9s el propietari. Hem d'eliminar el conjunt de llibres en l'autor per obtenir una relaci\u00f3 unidireccional.</p>"},{"location":"UD3_Hibernate/4_Relationships/#31-tipus-de-carrega-fetch","title":"3.1. Tipus de C\u00e0rrega Fetch","text":"<p>Aquest atribut sol apar\u00e8ixer quan tenim una relaci\u00f3 <code>1:N</code> o <code>N:M</code> en una classe que t\u00e9 una col\u00b7lecci\u00f3 de classes relacionades (tamb\u00e9 es pot especificar amb un <code>1:1</code> per\u00f2 \u00e9s menys com\u00fa). Quan Hibernate carrega un objecte, carregar\u00e0 els seus atributs generals (nom, nacionalitat, etc...), per\u00f2 qu\u00e8 passa amb els Llibres que ha escrit, els carrega o no?</p> <ul> <li><code>DateType.EAGER</code> \u2192 Literalment tradu\u00eft com ansi\u00f3s. No podem esperar, i quan es carrega l'Autor, Hibernate resoldr\u00e0 la relaci\u00f3 i carregar\u00e0 tots els llibres amb totes les dades internes de cada llibre. Tenim totes les dades en el moment.</li> <li><code>DateType.LAZY</code> \u2192 Literalment com mandr\u00f3s (vago), per\u00f2 m\u00e9s representatiu com c\u00e0rrega mandrosa. Si carreguem l'Autor, Hibernate nom\u00e9s carrega els atributs propis de l'Autor, sense carregar els seus Llibres. Quan intentem accedir als seus llibres des del nostre programa, Hibernate s'activa i els carrega. \u00c9s a dir, en mode LAZY, les dades es carreguen quan es necessiten.</li> </ul> <p>Qu\u00e8 farem?*</p> <p>Qu\u00e8 \u00e9s millor o pitjor? La resposta no \u00e9s senzilla, ja que ambd\u00f3s tenen pros i contres:</p> <ul> <li>En <code>EAGER</code> nom\u00e9s es fa un acc\u00e9s, mentre que en <code>LAZY</code> dos accessos o m\u00e9s.</li> <li>En <code>EAGER</code> es carreguen totes les dades, fins i tot si no s\u00f3n necess\u00e0ries, en <code>LAZY</code> nom\u00e9s es carrega el que \u00e9s necessari.</li> </ul> <p>El programador ha de valorar i equilibrar la quantitat d'informaci\u00f3 requerida en un moment donat i el cost d'acc\u00e9s a la base de dades.</p>"},{"location":"UD3_Hibernate/4_Relationships/#4-molts-a-molts","title":"4. Molts a Molts","text":"<p>En aquesta secci\u00f3 acabarem amb l'\u00faltim tipus de relacions que podem trobar en el model E/R, que s\u00f3n les relacions molts a molts. Poden apar\u00e8ixer altres relacions amb cardinalitats m\u00e9s altes, com les relacions tern\u00e0ries, per\u00f2 com es va estudiar en el primer any, totes elles es poden modelar amb transformacions bin\u00e0ries.</p> <p>Dins de les relacions bin\u00e0ries, podem trobar dues possibilitats:</p> <ul> <li>Relacions que simplement indiquen la relaci\u00f3 (per exemple, que un personatge pot o no portar un cert tipus d'arma en un joc de rol) o</li> <li>Relacions que, a m\u00e9s d'indicar-ho, afegeixen nous atributs. Per exemple, un actor participa en una pel\u00b7l\u00edcula en un tipus de paper: principal, secundari, etc.</li> </ul> <p>En el model relacional, ambd\u00f3s casos acaben sent modelats com una nova taula (amb o sense l'atribut). Si ens trobem en el segon cas, una nova taula amb els atributs que posseeix ha de ser modelada amb una classe, aix\u00ed que la relaci\u00f3 <code>N:M</code> entre dues taules es convertir\u00e0 en <code>dues relacions un a molts 1:N i N:1</code> (actor-actuaci\u00f3 i actuaci\u00f3-pel\u00b7l\u00edcula). Ens centrarem en el primer cas, ja que ja estem preparats per resoldre el segon.</p> <p>Millora</p> <p>Per a la segona part, aquest tutorial explica com fer-ho N_M amb atributs. \u00c9s molt recomanable implementar-ne un exemple.</p> <p>Anem a modelar el cas t\u00edpic d'un Professor que imparteix diversos M\u00f2duls, els quals poden ser impartits per diversos professors. L'esquema \u00e9s el seg\u00fcent:</p> <p></p> <p>Com podem veure, la t\u00edpica taula central de la relaci\u00f3 <code>N:M</code> es mant\u00e9. Com es va esmentar anteriorment, la taula Doc\u00e8ncia no existir\u00e0 en el model OO, ja que nom\u00e9s serveix per relacionar els elements.</p> <p>Les classes M\u00f2dul i Professor s\u00f3n les seg\u00fcents (nom\u00e9s es mostra la part relacionada amb la relaci\u00f3) triant en aquest cas Professor com el propietari de la relaci\u00f3:</p> Java<pre><code>// in Professor, a set of Modulo\n@ManyToMany(cascade=CascadeType.PERSIST,\n            fetch=FetchType.LAZY)\n@JoinTable(name=\"Docencia\",\n          joinColumns = {@JoinColumn(\n            name=\"idProfesor\",\n            foreignKey = @ForeignKey(name = \"FK_DOC_PROF\" ))},\n          inverseJoinColumns = {@JoinColumn(\n            name=\"idModulo\",\n            foreignKey = @ForeignKey(name = \"FK_DOC_MOD\" ))})\nprivate Set&lt;Modulo&gt; losModulos=new HashSet&lt;&gt;();\n</code></pre> Java<pre><code>// in Modulo.. a set of Professor\n@ManyToMany(cascade = CascadeType.PERSIST,\n            fetch = FetchType.LAZY,\n            mappedBy = \"losModulos\")\nprivate Set&lt;Profesor&gt; losProfesores=new HashSet&lt;&gt;();;\n</code></pre> <p>Aquesta \u00e9s l'especificaci\u00f3 m\u00e9s complicada, anem-hi:</p> <ul> <li>En ambdues classes el mapeig \u00e9s <code>@ManyToMany</code></li> <li>En ambd\u00f3s casos indiquem com gestionem les operacions en cascada (<code>cascade</code>) i la c\u00e0rrega dels objectes relacionats de l'altra classe (<code>fetch</code>)</li> <li>A la classe propiet\u00e0ria (<code>Professor</code>) es mapar\u00e0 un <code>Set&lt;Module&gt;</code> amb la relaci\u00f3 que comen\u00e7ar\u00e0 des de la meva classe actual <code>Professor</code> \\(\\rightarrow\\) doc\u00e8ncia \\(\\rightarrow\\) <code>Modulo</code> (el tipus base del Set)</li> <li>Amb <code>@JoinTable</code> s'indica que la relaci\u00f3 enlla\u00e7a amb una taula amb nom <code>Docencia</code>, on:</li> <li>S'enlla\u00e7ar\u00e0 (<code>joincolumns</code>), i l'enlla\u00e7 \u00e9s amb <code>@JoinColumn</code>:<ul> <li>Comen\u00e7ant des del camp <code>idProfesor</code> dins de la taula <code>Docencia</code></li> <li>Acabant a la clau prim\u00e0ria de <code>Profesor</code>,</li> <li>La FK es nomena <code>foreignKey = @ForeignKey(name = \"FK_DOC_PROF\" )</code>.</li> </ul> </li> <li>Tingueu en compte que els noms dins de @JoinTable s\u00f3n noms a la taula Docencia (existent nom\u00e9s a la base de dades).</li> <li>Es mapeja des de la taula <code>Docencia</code> a l'entitat font <code>Modulo</code> inversament (des del punt fins a l'origen de la fletxa):   </li> <li>Aix\u00f2 s'aconsegueix amb <code>inverseJoinColumns</code>:<ul> <li>Enlla\u00e7ant des del camp <code>idModule</code> (<code>@JoinColumn</code>).</li> <li>Tamb\u00e9 nomenem la FK.</li> </ul> </li> <li>A la classe relacionada (<code>Modulo</code>), que no \u00e9s la propiet\u00e0ria, simplement indiquem que la propiet\u00e0ria \u00e9s <code>Professor</code>, mitjan\u00e7ant <code>mappedBy=\"losModulos\"</code>.</li> </ul> <p>Un codi d'exemple seria aix\u00ed:</p> Java<pre><code>Profesor p1 = new Profesor(\"Mario Bened\u00e9\");\nProfesor p2 = new Profesor(\"Jose Fernandez\");\n\nModulo m1 = new Modulo(\"Acceso a Datos\");\nModulo m2 = new Modulo(\"Bases de Datos\");\nModulo m3 = new Modulo(\"Programaci\u00f3n\");\nModulo m4 = new Modulo(\"Dise\u00f1o de Interfaces\");\n\n// a\u00f1adimos modulos a p1\np1.addModulo(m3);\np1.addModulo(m1);\n\n// a\u00f1adimos modulos a p2\np2.addModulo(m2);\np2.addModulo(m3);\np2.addModulo(m4);\n\n// guardamos\nlaSesion.persist(p1);\nlaSesion.persist(p2);\n</code></pre> <p>i la sortida de Hibernate ser\u00e0 semblant a:</p> Bash<pre><code>Hibernate: drop table if exists Modulo\nHibernate: drop table if exists Profesor\nHibernate: create table Docencia (\n    idProfesor bigint not null, \n    idModulo bigint not null, \n    primary key (idProfesor, idModulo)) engine=InnoDB\nHibernate: create table Modulo (\n    idModulo bigint not null auto_increment, \n    nombre varchar(255), \n    primary key (idModulo)) engine=InnoDB\nHibernate: create table Profesor (\n    idProfe bigint not null auto_increment, \n    nomProfe varchar(255), \n    primary key (idProfe)) engine=InnoDB\nHibernate: alter table Docencia add constraint FK_DOC_MOD \n    foreign key (idModulo) references Modulo (idModulo)\nHibernate: alter table Docencia add constraint FK_DOC_PROF \n    foreign key (idProfesor) references Profesor (idProfe)\nHibernate: insert into Profesor (nomProfe) values (?)\nHibernate: insert into Modulo (nombre) values (?)\nHibernate: insert into Modulo (nombre) values (?)\nHibernate: insert into Profesor (nomProfe) values (?)\nHibernate: insert into Modulo (nombre) values (?)\nHibernate: insert into Modulo (nombre) values (?)\nHibernate: insert into Docencia (idProfesor, idModulo) values (?, ?)\nHibernate: insert into Docencia (idProfesor, idModulo) values (?, ?)\nHibernate: insert into Docencia (idProfesor, idModulo) values (?, ?)\nHibernate: insert into Docencia (idProfesor, idModulo) values (?, ?)\nHibernate: insert into Docencia (idProfesor, idModulo) values (?, ?)\n</code></pre> <p>Despres de crear les taules, Hibernate crear\u00e0 les claus alienes, i llavors inserir\u00e0 els registres. Primer <code>Professor</code> i <code>M\u00f2dul</code> i seguidament la relaci\u00f3 entre ells de <code>Doc\u00e8ncia</code></p>"},{"location":"UD3_Hibernate/5_HQL/","title":"5. Consultes","text":""},{"location":"UD3_Hibernate/5_HQL/#1-hibernate-query-language","title":"1. Hibernate Query Language","text":"<p>La documentaci\u00f3 completa es pot trobar aqu\u00ed:</p> <ul> <li>In spanish</li> <li>In english</li> </ul> <p>El llenguatge HQL (Hibernate Query Language) va n\u00e9ixer amb l'objectiu de preservar el model relacional, ja que \u00e9s un superset de SQL (extensi\u00f3 de SQL que inclou SQL). La primera consideraci\u00f3 \u00e9s que, per defecte, la seva funcionalitat \u00e9s recuperar objectes de la base de dades, no taules com f\u00e8iem en el llenguatge SQL a trav\u00e9s de <code>ResultSet</code>. Les consultes amb HQL es faran des d'una interf\u00edcie Query, que ser\u00e0 el lloc on especificarem qu\u00e8 volem obtenir. Opcionalment, podem afegir a la consulta els par\u00e0metres necessaris per a la seva execuci\u00f3, per evitar consultes amb codi dur.</p> <p>En primer lloc, la consulta ser\u00e0 preparada. En crear-la, hem de tenir en compte dues opcions, amb quatre combinacions possibles:</p> <ul> <li>Retornar\u00e0 un resultat o m\u00e9s d'un i,</li> <li>Retornar\u00e0 el resultat encapsulat en objectes o de manera composta.</li> </ul> <p>Depenent de la resposta obtinguda, en el segon pas triarem una de les quatre opcions vistes a continuaci\u00f3.</p> Java<pre><code>1 Query q=session.createQuery(\"HQL statement\");\n\n2.1 List&lt;Object&gt; resultsObjects=q.list();\n\n2.2 List&lt;Object []&gt;mixedresults=q.list();\n\n2.3 Object result=q.uniqueResult();\n\n2.4 Object[] result=q.uniqueResult();\n\n1. // process information obtained\n</code></pre> <ol> <li>In first option the query returns a collection of objects (several rows, on object in a row).</li> <li>This option return a collection with a composite of objects and another types: for example a Student a number of topics and number of teachers.</li> <li>Both last options is when, instead of a collection, the query returns a unique object/composite.</li> </ol> <p>Apunt...</p> <ul> <li><code>session.createQuery</code> \u2192 permet escriure una consulta HQL, amb o sense par\u00e0metres.</li> <li> <p><code>Query.list()</code> \u2192 obt\u00e9 tots els objectes (com una Llista) de la base de dades que satisfan la consulta.</p> </li> <li> <p><code>Query.uniqueResult()</code> \u2192 obt\u00e9 un \u00fanic objecte de la base de dades.</p> </li> </ul> <p>Abans dels detalls, aqu\u00ed trobar\u00e0s algunes idees generals:</p> <ul> <li>Podem eliminar el <code>Select *</code>, per indicar que volem tots els atributs.</li> <li>Hi ha una sensibilitat mitjana a les maj\u00fascules i min\u00fascules: les paraules reservades de HQL no distingeixen entre maj\u00fascules i min\u00fascules, per\u00f2 les refer\u00e8ncies als objectes (els seus noms) s\u00ed que ho fan: no importa posar <code>From</code> o <code>fROm</code>, per\u00f2 un <code>Student</code> no \u00e9s el mateix que un <code>student</code>. Es recomana escriure les sent\u00e8ncies en min\u00fascules, per tal de distingir-les de les classes.</li> <li>Despr\u00e9s de <code>from</code>, apareix el nom d'una classe (o classes), no de taules.</li> <li>Assignar \u00e0lies \u00e9s altament recomanable. Podem utilitzar joins de manera similar a SQL.</li> <li>Despr\u00e9s pot apar\u00e8ixer el <code>where</code>, amb les seves condicions similars a SQL.</li> <li>Les constants de text es tanquen entre cometes simples.</li> <li>Podem consultar col\u00b7leccions que apareixen dins dels objectes (per exemple, el conjunt d'estudiants d'un professor).</li> <li>No hi ha operador <code>limit</code>.</li> <li><code>order by</code> s'utilitza de manera similar a SQL.</li> <li><code>group by</code> est\u00e0 perm\u00e8s, i les funcions agregades s\u00f3n: COUNT, AVG, SUM, MIN i MAX.</li> </ul>"},{"location":"UD3_Hibernate/5_HQL/#2-recuperant-objectes","title":"2. Recuperant objectes","text":"<p>A partir d'ara, els exemples es basen en aquest esquema Docencia</p> <p></p> <p>Consell</p> <p>Ara \u00e9s un bon moment per intentar fer un enfocament d'enginyeria inversa per construir el teu projecte a partir de la base de dades.</p>"},{"location":"UD3_Hibernate/5_HQL/#3-consultes","title":"3. Consultes","text":""},{"location":"UD3_Hibernate/5_HQL/#31-obtenint-objectes-simples","title":"3.1. Obtenint objectes simples","text":"<p>Aquestes consultes s\u00f3n les que volem recuperar un objecte o una col\u00b7lecci\u00f3 d'aquests de la base de dades (una o m\u00e9s files, en comparaci\u00f3 amb ResultSet). Cada resultat \u00e9s un \u00fanic objecte d'una taula de la base de dades. Es caracteritzaran perqu\u00e8 la paraula Select pot no apar\u00e8ixer o simplement indicar l'\u00e0lies de la classe que tenim. Vegem els exemples.</p> <p>El seg\u00fcent exemple mostra tots els estudiants:</p> Java<pre><code>// complete and polite\nQuery&lt;Alumno&gt; q=laSesion.createQuery(\"Select a from Alumno a\");\n\n// OR\n\n// in a quick way\nQuery&lt;Alumno&gt; q=laSesion.createQuery(\"from Alumno\");\n\n// quickest (without type)\nQuery q=laSesion.createQuery(\"from Alumno\");\n\nList&lt;Student&gt; losAlumnos=q.list();\n\nfor (Alumno alumno : losAlumnos) {\n            System.out.println(alumno);\n        }\n</code></pre> <p>Si volem filtrar o cercar qualsevol estudiant, necessitem utilitzar la cl\u00e0usula <code>where</code>, com en una consulta SQL normal. Les expressions poden ser:</p> <p></p> <p>Quan el filtre <code>where</code> nom\u00e9s retorna un objecte, podr\u00edem emmagatzemar-lo en una llista i despr\u00e9s accedir-hi, per\u00f2 \u00e9s millor obtenir l'objecte directament, com segueix:</p> <p>Java<pre><code>Query&lt;Alumno&gt; q = laSesion.createQuery(\"Select a from Alumno a where a.idAlumno=1\");\nAlumno alumno = q.uniqueResult();\nSystem.out.println(alumno);\n</code></pre> tingues en compte que creem la nostra consulta amb l'operador diamant, indicant que retornar\u00e0 un estudiant. Aleshores, la consulta retorna \u00f2bviament l'estudiant. L'alternativa \u00e9s fer un c\u00e0sting de l'objecte retornat de <code>uniqueResult</code>:</p> Java<pre><code>Query q = laSesion.createQuery(\"Select a from Alumno a where a.idAlumno=1\");\nAlumno alumno = (Alumno)q.uniqueResult();\nSystem.out.println(alumno);\n</code></pre> <p>Atenci\u00f3</p> <p>Tingueu cura quan recupereu un objecte \u00fanic i la consulta en retorna diversos.</p> Java<pre><code>Query q=laSesion.createQuery(\"Select a from Student a where a.age=24\");\nAlumno a=(Student) q.uniqueResult();\n// org.hibernate.NonUniqueResultException: query did not return a unique result: 2\n</code></pre> <p>Quan tenim molts resultats, no \u00e9s convenient recuperar-los tots alhora, sin\u00f3 accedir-hi de 10 en 10 o similar, igual que les p\u00e0gines de cerca de Google o Amazon. Podem aconseguir-ho llan\u00e7ant consultes m\u00e9s petites repetidament, aplicant a la consulta:</p> <ul> <li><code>Q.setFirstResult(int start)</code> \u2192 indica el primer objecte (fila) a retornar.</li> <li><code>Q.setMaxResult(int howMany)</code> \u2192 indica quantes files retornar\u00e0.</li> </ul> <p>Amb un algorisme dissenyat adequadament, podem fer un bucle, despla\u00e7ant l'inici en cada iteraci\u00f3, incrementant-lo pel nombre de files recuperades en l'iteraci\u00f3 anterior. Aix\u00f2 implicaria moltes consultes petites en lloc d'una de gran.</p>"},{"location":"UD3_Hibernate/5_HQL/#32-obtenint-objectes-compostos","title":"3.2. Obtenint objectes compostos","text":"<p>Si necessitem obtenir m\u00e9s (o menys) dades que un objecte sencer, ho hem de fer a la part <code>select</code> de la cl\u00e0usula, per\u00f2 quan obtenim les dades no les podem emmagatzemar en un Object. Per aquesta ra\u00f3, i utilitzant la propietat de polimorfisme de Java, obtenim els resultats en un array gen\u00e8ric d'objectes. Per tant, hem de ser molt curosos amb el tipus de cada cel\u00b7la, aix\u00ed com la mida d'aquest array, ja que estar\u00e0 fortament lligat a la consulta en si. Vegem la seg\u00fcent consulta: Mostra el nom i l'edat dels estudiants:</p> Java<pre><code>Query q = laSesion.createQuery(\"Select a.nombre,a.edad from Alumno a\");\n\nList&lt;Object[]&gt; result = q.list();\n\nfor (Object[] objects : result) {\n  System.out.print(\"Alumno: \");\n  for (int i = 0; i &lt; objects.length; i++) {\n    System.out.print(objects[i] + \" \");\n  }\n  System.out.println();\n}\n</code></pre> <p>Tingues en compte que si nom\u00e9s vols imprimir la informaci\u00f3, no cal fer cap treball extra, ja que (gaireb\u00e9) tots els objectes es poden convertir a String. Si vols utilitzar-los d'una altra manera, tin molt de compte en convertir-los al tipus de dada adequat.</p> <p>Col\u00b7leccions</p> <p>Anem a comprovar el nom dels estudiants i quants ex\u00e0mens han fet. Aquesta informaci\u00f3 es troba al conjunt d'Ex\u00e0mens, aix\u00ed que necessitarem manipular aquesta col\u00b7lecci\u00f3:</p> Java<pre><code>Query q = laSesion.createQuery(\"Select a.nombre,size(a.examens) from Alumno a\");\nList&lt;Object[]&gt; result = q.list();\n\nfor (Object[] alu : result) {\n  System.out.println(\"Alumno: \" + alu[0] + \" has done \" + alu[1] + \" exams.\");\n}\n</code></pre> <p>Com podeu veure, hem aplicat la funci\u00f3 <code>size()</code> a la col\u00b7lecci\u00f3 per veure la seva mida. Per tant, podem aplicar:</p> <ul> <li><code>size(collection)</code> \u2192 recuperar la mida de la col\u00b7lecci\u00f3.</li> <li><code>collection is empty</code> | <code>collection is not empty</code> \u2192 per determinar si est\u00e0 buida. \u00c9s equivalent a comparar la mida amb 0.</li> <li>Els operadors <code>in</code>, <code>all</code> es poden combinar utilitzant l'operador <code>elements(collection)</code>.</li> </ul> <p>Com a consulta avan\u00e7ada, podeu utilitzar <code>exists</code> i <code>not exists</code> en les vostres consultes.</p>"},{"location":"UD3_Hibernate/5_HQL/#4-parametres-i-consultes-nominals-amb-nom","title":"4. Par\u00e0metres i Consultes Nominals (amb nom)","text":"<p>Normalment, la majoria de consultes necessitaran alguns par\u00e0metres, generalment per al filtratge d'objectes en la cl\u00e0usula where. Els beneficis de parametritzar les consultes per evitar la injecci\u00f3 de SQL o problemes similars ja es van discutir en la unitat anterior.</p> <p>La gesti\u00f3 dels par\u00e0metres es realitza de la mateixa manera que amb les sent\u00e8ncies preparades (<code>preparedStatements</code>), i es pot fer mitjan\u00e7ant par\u00e0metres posicionals o nominals. Vegem alguns exemples:</p>"},{"location":"UD3_Hibernate/5_HQL/#41-parametres-posicionals","title":"4.1. Par\u00e0metres posicionals","text":"<p>Hem d'afegir espais reservats dins de la nostra consulta, per\u00f2 en lloc de <code>?</code> afegim un n\u00famero despr\u00e9s del signe d'interrogaci\u00f3. Despr\u00e9s hem de configurar el par\u00e0metre segons el n\u00famero d'espai reservat que hem establert abans, de la seg\u00fcent manera:</p> Java<pre><code>Query&lt;Alumno&gt; q = laSesion.createQuery(\"Select a from Alumno a where a.edad=?1\");\nq.setParameter(1, 24);\nList&lt;Alumno&gt; losAlumnos = q.list();\n\nfor (Alumno alumno : losAlumnos) {\n  System.out.println(alumno);\n}\n</code></pre> <p>Consell</p> <p>Tingues en compte que el m\u00e8tode <code>setParameter</code> est\u00e0 sobrecarregat per establir tot tipus de dades.</p>"},{"location":"UD3_Hibernate/5_HQL/#42-parametres-nominals","title":"4.2. Par\u00e0metres nominals","text":"<p>Les posicions estan b\u00e9, per\u00f2 si podem indicar els par\u00e0metres de manera nominal, el programa ser\u00e0 molt m\u00e9s llegible. Els par\u00e0metres s'indiquen amb <code>:nomDelParametre</code> i s'assignaran amb el m\u00e8tode <code>setParameter(nomDelParametre, valor)</code>, indicant el nom del par\u00e0metre (sense els dos punts):</p>"},{"location":"UD3_Hibernate/5_HQL/#43-consultes-amb-nom","title":"4.3. Consultes amb nom","text":"<p>Podem escriure consultes en els nostres m\u00e8todes segons les necessitem. No obstant aix\u00f2, \u00e9s una bona pr\u00e0ctica crear les consultes m\u00e9s importants o que preveiem que seran les m\u00e9s utilitzades juntament amb la mateixa classe, a trav\u00e9s del mecanisme que es presenta a continuaci\u00f3. En aquesta secci\u00f3 creem i etiquetem les nostres consultes, dins d'una col\u00b7lecci\u00f3 de consultes, i despr\u00e9s les podem cridar. \u00c9s com si cre\u00e9ssim una biblioteca de consultes.</p> <p>Fora de la definici\u00f3 de la classe, es crear\u00e0 una col\u00b7lecci\u00f3 <code>@NamedQueries</code>, que contindr\u00e0 un array (indicat per claus) d'elements <code>@NamedQuery</code>, cadascun d'ells amb un nom i una definici\u00f3 de consulta.</p> <p>Per invocar-les, en lloc de crear un objecte <code>Query</code>, el crearem a trav\u00e9s d'una <code>NamedQuery</code>, indicant el seu nom i assignant par\u00e0metres, si n'hi ha.</p> <p>A la classe Alumno:</p> Java<pre><code>@Entity\n@Table(name = \"Alumno\", catalog = \"DocenciaConsultas\")\n@NamedQueries({\n    @NamedQuery(name=\"Repetidores\",\n            query=\"select a from Student a where a.repeater=true \"),\n    @NamedQuery(name=\"AlumnosEntre\",\n            query=\"select a from Student a where a.age between :min and :max\"),\n    @NamedQuery(name=\"AlumnosDescAge\",\n            query=\"select a from Student a order by a.age desc\")\n})\npublic class Alumno implements java.io.Serializable {\n    static final long serialVersionUID=13L;\n  ...\n</code></pre> <p>Quan volem utilitzar-lo, en lloc de crear una <code>Query</code> hem de crear una <code>NamedQuery</code>, de la seg\u00fcent manera:</p> Java<pre><code>Query&lt;Alumno&gt; q = laSesion.createNamedQuery(\"Repetidores\", Alumno.class);\nSystem.out.println(\"Alumnos repetidores: \");\nList&lt;Alumno&gt; losAlumnos = q.list();\n\nq = laSesion.createNamedQuery(\"AlumnosEntre\", Alumno.class);\nq.setParameter(\"min\", 23);\nq.setParameter(\"max\", 28);\n\nq = laSesion.createNamedQuery(\"AlumnosDescAge\", Alumno.class);\nSystem.out.println(\"Alumnos de mayor a menor: \");\n</code></pre>"},{"location":"UD3_Hibernate/5_HQL/#5-crud","title":"5. CRUD","text":"<p>Finalment, analitzarem la resta de les operacions CRUD. Cal destacar que aquestes operacions es poden realitzar directament sobre els objectes, per aix\u00f2 s'expliquen com a complement\u00e0ries m\u00e9s que principals.</p>"},{"location":"UD3_Hibernate/5_HQL/#51-crear-create-insert","title":"5.1. Crear (Create - Insert)","text":"<p>Si volem inserir un nou objecte a la base de dades, \u00e9s molt f\u00e0cil, com podem recordar en les primeres seccions d'aquesta unitat.</p> Java<pre><code>Alumno a=new Alumno();\na.setApellidos(\"Hamilton\");\na.setNombre(\"Lewis\");\na.setEdad(42);\na.setRepetidor(false);\n\nlaSesion.persist(a);\n</code></pre> <p>Simplement creem un nou objecte, establim els seus valors, mitjan\u00e7ant setters o el constructor amb tots els arguments, i finalment l'emmagatzemem a la base de dades amb el m\u00e8tode <code>persist</code>. Podeu utilitzar <code>save</code> o <code>saveOrUpdate</code> indistintament. Podeu veure algunes difer\u00e8ncies entre ells aqu\u00ed. Tots dos executen una instrucci\u00f3 <code>insert sql</code>.</p> <p>De la mateixa manera que SQL, podr\u00edem inserir en una taula amb el resultat d'una consulta, com segueix:</p> SQL<pre><code>insert into class(properties) select_hql;\n</code></pre>"},{"location":"UD3_Hibernate/5_HQL/#52-actualitzacio-update","title":"5.2. Actualitzaci\u00f3 (Update)","text":"<p>Per canviar el valor d'una o m\u00e9s propietats d'un objecte, podem carregar l'objecte de la base de dades, canviar els valors mitjan\u00e7ant els m\u00e8todes getters i despr\u00e9s desar els canvis.</p> Java<pre><code>Alumno a=laSesion.get(Alumno.class, 7L);\na.setEdad(44);\na.setRepetidor(true);\n\nlaSesion.update(a);\nSystem.out.println(a);\n</code></pre> <p>Si volem establir una actualitzaci\u00f3 massiva, que afecti diversos registres a la base de dades, podr\u00edem utilitzar-ho de la mateixa manera que en SQL:</p> Java<pre><code>Query q=laSesion.createQuery(\"Update from Alumno a set a.edad=a.edad+1 where a.repetidor=true\");\nint howMany=q.executeUpdate();\n\nSystem.out.println(howMany + \" alumnos actualizados\");\n</code></pre>"},{"location":"UD3_Hibernate/5_HQL/#53-eliminacio-delete","title":"5.3. Eliminaci\u00f3 (Delete)","text":"<p>Com en les seccions anteriors, podr\u00edem eliminar un \u00fanic objecte o un conjunt de registres que compleixin una condici\u00f3. En el cas d'un \u00fanic objecte, necessitem carregar-lo i despr\u00e9s eliminar-lo:</p> Java<pre><code>Alumno a=laSesion.get(Alumno.class, 7L);\nlaSesion.delete(a);\n\nSystem.out.println(a);\n</code></pre> <p>Tingues en compte que l'objecte roman en mem\u00f2ria o fins al final del m\u00e8tode, per\u00f2 quan la sessi\u00f3 es confirma, l'objecte passar\u00e0 a estar <code>detached</code>. L'estat <code>detached</code> significa que aquest objecte est\u00e0 fora de qualsevol tipus de seguiment. No tenim la possibilitat de desar o actualitzar aquest objecte de nou.</p> <p>Per fer una eliminaci\u00f3 massiva, de la mateixa manera que SQL:</p> Java<pre><code>Query q=laSesion.createQuery(\"delete from Alumno a where a.repetidor=true\");\nint howMany=q.executeUpdate();\n\nSystem.out.println(howMany + \" alumnos borrados\");\n</code></pre> <p>Consell</p> <p>Recorda aquests consell generals:</p> <ul> <li>Aquestes sent\u00e8ncies poden contenir par\u00e0metres (en sent\u00e8ncies que contenen la cl\u00e0usula <code>where</code>).</li> <li>El <code>where</code> \u00e9s opcional, per\u00f2 eliminar\u00e0 o actualitzar\u00e0 tot si falta.</li> <li>Aquestes consultes s'executen totes utilitzant <code>executeUpdate()</code>, perqu\u00e8 canvien l'estat de la base de dades, i retornar\u00e0 un enter amb el nombre de files afectades.</li> </ul> <p>Has de prestar atenci\u00f3 a les eliminacions, ja que depenent de com hem definit les relacions (eliminacions en cascada, deixant files orfes, etc.) poden o no oc\u00f3rrer, i llan\u00e7ar <code>java.sql.SQLIntegrityConstraintViolationException</code>.</p> <p>Com a comentari final en aquesta secci\u00f3, recorda el que s'ha dit anteriorment: en la manipulaci\u00f3 d'objectes (eliminacions, modificacions, etc.) tenim prou eines per fer-ho sense consultes HQL. Aquestes consultes s\u00f3n m\u00e9s adequades per processar grans volums d'informaci\u00f3 sense carregar aquesta informaci\u00f3 al nostre programa per processar-la.</p>"},{"location":"UD3_Hibernate/5_HQL/#6-apendix-estat-dels-objectes","title":"6. Ap\u00e8ndix, Estat dels objectes","text":"<p>Com hem dit al llarg d'aquesta unitat, els objectes es carreguen i es controlen pel gestor de sessions. Cada objecte podria tenir un estat dins de la sessi\u00f3, i \u00e9s interessant con\u00e8ixer totes les possibilitats. En aquesta imatge, podeu veure tots els diferents estats i el m\u00e8tode per canviar l'estat de l'objecte.</p> <p></p> <ul> <li>transient \u2192 L'objecte t\u00e9 identitat (existeix en mem\u00f2ria), per\u00f2 no t\u00e9 una identitat persistent, o clau prim\u00e0ria.</li> <li>persistent \u2192 L'objecte ha estat marcat per ser desat (persistit), i la identitat en mem\u00f2ria est\u00e0 relacionada amb la identitat de la base de dades. Quan carreguem un objecte de la base de dades, aquest \u00e9s l'estat inicial.</li> <li>detached \u2192 L'objecte ha estat persistit recentment, per\u00f2 aquest context est\u00e0 tancat, amb el m\u00e8tode <code>detach()</code>. Les operacions quan est\u00e0 desconnectat no es reflectiran a la base de dades.</li> <li>removed \u2192 L'objecte ha estat marcat per ser eliminat (per\u00f2 encara no s'ha efectuat). Quan la sessi\u00f3 es tanqui, ser\u00e0 eliminat efectivament, per\u00f2 podem tornar-lo a carregar i posar-lo en un context persistent.</li> </ul> <p>Podeu obtenir m\u00e9s informaci\u00f3 aqu\u00ed.</p>"},{"location":"UD4_BDOO/1_Introduction/","title":"1. Introduccio a les bases de dades OO","text":""},{"location":"UD4_BDOO/1_Introduction/#1-introduccio","title":"1. Introducci\u00f3","text":"<p>Les bases de dades relacionals sorgeixen del model relacional com un sistema que representa fidelment la realitat, amb gran solidesa degut a la l\u00f2gica relacional subjacent. Aquest model representa la perspectiva est\u00e0tica de la modelitzaci\u00f3 de l'aplicaci\u00f3, i en ell totes les dades es desglossen a nivells at\u00f2mics, ja que, com recordem, no es permeten valors multivaluats ni compostos.</p> <p>Aquest model ha patit la bretxa objecte-relacional, en la qual els llenguatges de programaci\u00f3 han evolucionat les estructures adoptant la metodologia orientada a objectes. Aix\u00f2 ens porta a dissenyar la base de dades d'una banda, seguint el model relacional, i tamb\u00e9 necessitem dissenyar les classes de l'aplicaci\u00f3 d'altra banda. Aquests dissenys, que no solen coincidir, es poden ajustar amb les eines ORM estudiades en la unitat anterior per mitigar la desconnexi\u00f3 objecte-relacional.</p> <p>D'aquesta bretxa sorgeix la necessitat d'afegir un disseny m\u00e9s orientat a objectes dins de la pr\u00f2pia base de dades. Si analitzem un esquema orientat a objectes i intentem aplicar la teoria de la normalitzaci\u00f3, trobarem que els objectes es descomponen en diverses entitats, cosa que provoca l'aparici\u00f3 de moltes taules.</p> <p>Aquest alt nombre de taules provoca, com a conseq\u00fc\u00e8ncia, un augment de les refer\u00e8ncies entre elles, augmentant considerablement les relacions entre elles i, per tant, un major nombre de restriccions que cal controlar (<code>FOREIGN KEY</code>), cosa que suposa un augment del nombre de comprovacions que ha de realitzar el SGBD.</p> <p>Aix\u00ed, en la BD OO (Base de Dades Orientada a Objectes) es permet una definici\u00f3 de tipus de dades complexos en comparaci\u00f3 amb els simples que incorpora el SGBD relacional, permetent la definici\u00f3 de tipus estructurats i fins i tot multivaluats. Amb tot aix\u00f2, la BD OO hauria de permetre simplement el disseny a trav\u00e9s d'objectes (similar a l'UML) indicant els objectes que hi participen, indicant els seus atributs i m\u00e8todes, i les relacions que els afecten, i \u00f2bviament, les her\u00e8ncies.</p> <p>Aquestes BD OO encara no han despegat, i algunes solucions que implementen solucions comercials \u00e9s proporcionar al sistema de bases de dades relacionals les capacitats sem\u00e0ntiques de l'orientaci\u00f3 a objectes, apareixent aix\u00ed les BDOR (Bases de Dades Objecte-Relacional).</p>"},{"location":"UD4_BDOO/1_Introduction/#2-bases-de-dades-objecte-relacional","title":"2. Bases de Dades Objecte-Relacional","text":"<p>L'est\u00e0ndard ANSI SQL1999 (SQL99 i posteriorment SQL2003), com a continuaci\u00f3 de SQL92 en qu\u00e8 s'adapten les caracter\u00edstiques del model relacional, permet afegir caracter\u00edstiques orientades a objectes a les bases de dades relacionals. Aix\u00f2 permet que els SGBD robustos hagin adoptat i implementat aquelles caracter\u00edstiques requerides. Entre aquestes caracter\u00edstiques es troben:</p> <ul> <li>Definici\u00f3 de nous tipus de dades per part de l'usuari.</li> <li>Adaptaci\u00f3 per acomodar grans tipus de dades bin\u00e0ries com imatges i documents.</li> <li>Capacitat per emmagatzemar elements compostos com arrays.</li> <li>Emmagatzemar directament refer\u00e8ncies a altres taules.</li> <li>Definici\u00f3 d'objectes i her\u00e8ncia.</li> <li>Definici\u00f3 de funcions que gestionen les estructures definides pr\u00e8viament.</li> </ul>"},{"location":"UD4_BDOO/2_ORDB/","title":"2. Bases de dades Objecte-Relacionals","text":""},{"location":"UD4_BDOO/2_ORDB/#1-base-de-dades-objecte-relacional","title":"1. Base de dades Objecte-Relacional","text":"<p>En aquesta secci\u00f3 treballarem amb la base de dades PostgreSQL. Com el sistema de gesti\u00f3 de bases de dades objecte-relacional de codi obert, que ha tingut el major impacte, sent un rival directe del gran Oracle.</p> <p>Ens centrarem en les novetats que ofereix Postgres enfront de MySQL, com una extensi\u00f3 dels conceptes del primer any.</p> <p>Important</p> <p>Ser\u00e0 interessant:</p> <ul> <li>Instal\u00b7lar el teu propi servidor PostgreSQL. Es recomana utilitzar-lo mitjan\u00e7ant un contenidor Docker.</li> <li>Instal\u00b7lar un client per mostrar la teva base de dades. Recomanem DBeaver.</li> </ul> <p>Treballarem amb aquest conegut exemple:</p> <p></p>"},{"location":"UD4_BDOO/2_ORDB/#2-definicio-de-tipus","title":"2. Definici\u00f3 de tipus","text":"<p>En PostgreSQL existeixen els tipus habituals que es troben en els SGBD moderns. A m\u00e9s, destaquen tipus especials per emmagatzemar adreces d'Internet (Tipus d'Adre\u00e7a de Xarxa), XML i JSON per guardar i processar aquests formats, tipus propis i col\u00b7leccions. Amb aix\u00f2, podem observar els grans avan\u00e7os de PostgreSQL, que d'una manera relaxada podr\u00edem considerar com Objecte-Relacional i Documental.</p>"},{"location":"UD4_BDOO/2_ORDB/#21-enumeracio","title":"2.1. Enumeraci\u00f3","text":"<p>Els tipus enumerats s\u00f3n tipus que nom\u00e9s permeten valors espec\u00edfics, generalment tamb\u00e9 coneguts com a dominis. En PostgreSQL els podem crear de la seg\u00fcent manera:</p> SQL<pre><code>CREATE TYPE enum_name AS ENUM\n    ( [ 'valor' [, ... ] ] );\n</code></pre> <p>per exemple:</p> SQL<pre><code>create type basic_colors as enum('#FF0000','#00FF00','#0000FF');\ncreate type street_kind as enum ('Calle','Avenida','Partida');\n</code></pre> <p>Aquesta manera de definir aquest tipus evitar\u00e0 les comprovacions de valors (cl\u00e0usules CHECK) existents en alguns SGBD relacionals.</p>"},{"location":"UD4_BDOO/2_ORDB/#22-tipus-estructurats","title":"2.2. Tipus estructurats","text":"<p>Els tipus estructurats s\u00f3n els precursors dels objectes en si. Si recordem, en la programaci\u00f3 estructurada, a partir dels tipus b\u00e0sics, pod\u00edem crear estructures de dades:</p> <ul> <li>On tots els elements s\u00f3n iguals (vectors, arrays i col\u00b7leccions)</li> <li>On els seus elements podrien ser de diferents tipus. Aquestes estructures van evolucionar cap als objectes actuals afegint comportament i altres caracter\u00edstiques.</li> </ul> <p>En el model relacional, com que hem de respectar l'atomicitat de les dades, no pod\u00edem generar aquestes estructures. En Postgres podem crear aquests nous tipus de dades estructurats amb la seg\u00fcent sintaxi, molt semblant a la creaci\u00f3 d'una taula:</p> SQL<pre><code>CREATE TYPE type_name AS(\n  attribute_name data_type\n  [, ... ]-- one or more\n);\n</code></pre> <p>per exemple:</p> SQL<pre><code>create type Punto as(\n    x integer,\n    Y integer \n);\n</code></pre> <p>o, fent servir un una enumeraci\u00f3, de les vistes abans:</p> SQL<pre><code>create type Address as(\n    Type street_kind,\n    street varchar,\n    number int\n);\n</code></pre> <p>i finalment creariem la seg\u00fcent taula:</p> SQL<pre><code>create table person(\n    idPerson serial primary key,\n    name varchar,\n    direction Address\n);\n\ninsert into person(name) values ('joange');\ninsert into person(name,address) values('joange',null);\ninsert into person(name,address) values('joange',('Street','Calvary',1));\n\nselect direction from person;\nselect (address).street from person;\n</code></pre> <p>Recordatori</p> <ul> <li>No es poden aplicar restriccions NOT NULL, DEFAULT o CHECK als camps que pertanyen als tipus creats.</li> <li>La tipificaci\u00f3 t\u00e9 sentit en dades que no existeixen per si mateixes, que necessiten ser incrustades en altres estructures o taules.</li> <li>Quan s'utilitza dins d'una taula i es manipula la inserci\u00f3, es far\u00e0 en un bloc, entre par\u00e8ntesis, ja que determina una estructura.</li> <li>Per seleccionar un subtipus, hem d'envoltar el tipus general entre par\u00e8ntesis, en cas contrari Postgres el confon amb una taula i genera un error.</li> </ul>"},{"location":"UD4_BDOO/2_ORDB/#3-classes-o-realment-taules","title":"3. Classes (o realment taules?)","text":"<p>Anem a crear una classe <code>Figura</code>, que ser\u00e0 el punt de partida d'una her\u00e8ncia del model presentat a l'inici de la unitat. Vegem qu\u00e8 incorpora respecte a les implementacions del model relacional. <code>Figura</code> cont\u00e9 una clau prim\u00e0ria, i contindr\u00e0 un <code>Punto</code> per localitzar-la en el pla. A m\u00e9s, cont\u00e9 una col\u00b7lecci\u00f3 de colors, per fer possibles degradats, guardats com un array. Guardar col\u00b7leccions \u00e9s tamb\u00e9 una capacitat afegida que no suporta el model relacional, donada l'abs\u00e8ncia de valors multivaluats.</p> <p>Es crea una classe amb la mateixa sintaxi que una taula, ja que, a efectes pr\u00e0ctics, des d'un punt de vista estructural \u00e9s el mateix. Posteriorment, l'her\u00e8ncia distingeix que una taula \"hereta\" d'una altra.</p> SQL<pre><code>create table Figura (\n    fID serial primary key, -- identifier\n    Punto position,  -- position he occupies\n    color TEXT[ ]    -- color(s) of the figure\n);\n</code></pre> <p>Per inserir nous registres, tingues en compte que:</p> <ul> <li>Els elements de tipus <code>Punto</code> s'han d'emmagatzemar utilitzant un constructor que crea una <code>fila</code> abstracta, anomenada <code>ROW</code> o entre par\u00e8ntesis.</li> <li>Per als arrays, tamb\u00e9 necessitem un constructor anomenat <code>ARRAY</code>, amb una llista d'elements.</li> </ul> SQL<pre><code>insert into Figura(position,color)\n  values(ROW(0,0),ARRAY['#FFFFFF','#00CC00']);\n</code></pre> <p>A partir d'aqu\u00ed, crearem noves classes per representar els cercles, quadrats i rectangles de <code>Figura</code> utilitzant l'her\u00e8ncia. La sintaxi \u00e9s la seg\u00fcent:</p> SQL<pre><code>create table sub_table(\n -- definition of table attributes\n) inherits (super_table);\n</code></pre> <p>Com podem veure, simplement afegim <code>inherits</code> per crear la relaci\u00f3 d'her\u00e8ncia. Pel disseny que ten\u00edem anteriorment:</p> SQL<pre><code>create table Rectangle(\n    height int,\n    width int \n) inherits (Figure);\n\ncreate table Quadrat(\n    side int\n) inherits (Figure);\n\ncreate table Cercle(\n    radio int\n) inherits (Figure);\n</code></pre> <p>Inserim algunes files, tenint en compte que tamb\u00e9 hem d'incloure els atributs de la superclasse.</p> SQL<pre><code>insert into Quadrat(position,color,side) values (ROW(10,10),ARRAY['#00BBCC','#BBCC00'],40);\ninsert into Quadrat(position,color,side) values(ROW(10,fifteen),ARRAY['#AA6633','#CCFF00'],27);\ninsert into Cercle(position,color,radius) values(ROW(30,25),ARRAY['#BBCC','#CCCC00'],20);\ninsert into Cercle(position,color,radius) values(ROW(10,-10),ARRAY['#00BBCC','#CCCC00'],20);\ninsert into Rectangle(position,color,height,width) values(ROW(10,5),ARRAY['#00BBCC','#CCCC00'],20,50);\ninsert into Rectangle(position,color,height,width) values(ROW(30,-10),ARRAY['#00BBCC','#CCCC00'],20,50);\n</code></pre> <p>Si executem diversos <code>Select * from</code>, obtenim a DBeaver:</p> <p></p> <p></p> <p></p> <p></p> <p>Com \u00e9s l\u00f2gic, \u00e9s possible pensar que quan seleccionem dades de la taula general (<code>Select * from Figura</code>) apareixeran tots els elements de les subclasses. Si volgu\u00e9ssim seleccionar nom\u00e9s aquells que s\u00f3n Figura, podr\u00edem fer-ho amb (<code>Select * from ONLY Figura</code>).</p> <p>Anem a completar l'exemple creant un dibuix amb totes les figures que hem emmagatzemat. Guardarem el dibuix en una nova classe que cont\u00e9 la identificaci\u00f3 del dibuix, i guardarem una col\u00b7lecci\u00f3 amb els identificadors de les figures que componen el dibuix.</p> SQL<pre><code>create table Dibujo(\n    drawingid serial primary key,\n    items int[]\n);\n\ninsert into Drawing (elements) values(ARRAY[2,4,5,6]);\ninsert into Drawing (elements) values(ARRAY(select fid from Figura));\n</code></pre> <p>Comentar que la selecci\u00f3 dels identificadors de <code>Figura</code> pot ser directa, o seleccionant aquells que volem, mitjan\u00e7ant una consulta incrustada dins del constructor ARRAY. Aix\u00f2 es pot fer quan el select retorna una sola columna.</p> <p>Obtenim els dibuixos que tenim, aquesta col\u00b7lecci\u00f3 de figures es mostra. Per\u00f2 si volem descompondre el vector, per accedir a cadascuna de les figures que hi ha, ho podem fer amb la funci\u00f3 <code>unnest</code>.</p>"},{"location":"UD4_BDOO/3_OODB/","title":"3. Bases de dades Orientades a Objectes","text":""},{"location":"UD4_BDOO/3_OODB/#1-base-de-dades-orientades-a-objectes-objectdb","title":"1. Base de dades Orientades a Objectes. ObjectDB","text":"<p>En aquesta secci\u00f3, com a SGBD, s'ha escollit ObjectDB, ja que \u00e9s molt vers\u00e0til, gratu\u00eft i fins i tot permet incrustar-lo dins dels nostres projectes Java, cosa que permet una gran simplicitat per al desenvolupament de petites aplicacions, gr\u00e0cies a l'eliminaci\u00f3 d'un servidor.</p>"},{"location":"UD4_BDOO/3_OODB/#2-installacio","title":"2. Instal\u00b7laci\u00f3","text":"<p>ObjectDB no requereix instal\u00b7laci\u00f3 com a tal, ja que tot el seu codi est\u00e0 integrat en una API per accedir a la base de dades empaquetada en un fitxer jar. Des del lloc web oficial podem descarregar el Kit de Desenvolupament d'ObjectDB. En el moment d'escriure aquest llibre, la versi\u00f3 \u00e9s la 2.9.0. Aquest kit cont\u00e9, entre altres:</p> <ul> <li>Depend\u00e8ncies per a projectes Java</li> <li>Utilitats per visualitzar i consultar la base de dades</li> <li>Servidor per a aplicacions distribu\u00efdes</li> <li>Documentaci\u00f3</li> </ul> <p>Un cop descomprimit, nom\u00e9s necessitarem la m\u00e0quina virtual Java instal\u00b7lada al nostre sistema per executar tots els elements. Per utilitzar ObjectDB en el nostre projecte hem d'afegir el fitxer <code>objectdb.jar</code> a les depend\u00e8ncies del nostre projecte o fer-ho utilitzant el gestor de depend\u00e8ncies maven o gradle.</p> <p>En aquest moment podem connectar-nos a la base de dades, la centralitzaci\u00f3 de la connexi\u00f3 a la base de dades es fa a trav\u00e9s d'una inst\u00e0ncia d'un objecte <code>EntityManagerFactory</code>, del qual podem obtenir diverses inst\u00e0ncies d'un <code>EntityManager</code>.</p> <p>Des de l'<code>EntityManager</code> podrem dur a terme les operacions t\u00edpiques de CRUD, tenint en compte que sempre que hi hagi modificacions en ell. Hem de dur a terme l'operaci\u00f3 dins d'una transacci\u00f3 per evitar situacions inconsistents en ella. Aqu\u00ed veiem una possible classe amb l'establiment de la connexi\u00f3 i l'obtenci\u00f3 d'un <code>EntityManager</code>. Aquest codi es pot veure en el fitxer adjunt <code>ConexionOBD.java</code>. Tingueu en compte que les importacions s\u00f3n de <code>javax.persistence</code>:</p> Java<pre><code>import javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.PersistenceException;\n\npublic class ConexionOBD {\n\n    private EntityManagerFactory emf;\n    private EntityManager em;\n    private String nombreBD;\n\n    /**\n     * Crea una objeto a la BBDD indicada\n     */\n    public ConexionOBD(String nombre){\n        this.emf=null;\n        this.em=null;\n        this.nombreBD=nombre;\n    }\n\n    /**\n     * M\u00e9todo que realiza la conexi\u00f3n\n     */\n    private void conectar(){  \n        emf = Persistence.createEntityManagerFactory(nombreBD);\n        try{\n            em = emf.createEntityManager();\n        }\n        catch(PersistenceException ex){\n            System.out.println(ex.getMessage());\n        }\n    }\n\n    /**\n     * Metodo que desconecta\n     */\n    public void desconectar(){  \n        this.em.close();\n        this.emf.close();\n        this.em=null;\n        this.emf=null;\n    }\n\n    /**\n     * \n     * @return El EntityManager sobre el que operar\n     */\n    public EntityManager getEM(){\n        if (em==null)\n            conectar();\n        return em;\n    }\n}\n</code></pre>"},{"location":"UD4_BDOO/3_OODB/#3-persistencia-de-classes","title":"3. Persist\u00e8ncia de classes","text":"<p>Per persistir un objecte, necessitarem (semblant a Hibernate):</p> <ul> <li>Anotar la teva classe i marcar-la com a <code>@Entity</code></li> <li>Definir un camp com a <code>@Id</code> i opcionalment auto-incrementar amb <code>@GeneratedValue</code>.</li> <li>La resta dels atributs de l'entitat, per defecte, es persisteixen autom\u00e0ticament sense cap tipus d'anotaci\u00f3. En cas de no voler persistir-ne, podem indicar-ho amb <code>@Transient</code>.</li> </ul> Java<pre><code>@Entity\npublic classes Alumno{ \n  @Id @GeneratedValue\n  private Long idAlumno;\n  private String Name;\n}\n</code></pre> <p>Per emmagatzemar un Alumne, n'hi haur\u00e0 prou amb crear un Alumne i persistir-lo a la base de dades, com es veu a continuaci\u00f3, assumint l'objecte de tipus conexionDB vist en el fitxer adjunt:</p> Java<pre><code>ConexionOBD con= new ConexionOBD(\"Alumnos.odb\");\nEntityManager em=con.getEM();\nem.getTransaction().begin();\nAlumno alu=new Alumno(\"Antonio Ramos\");\nem.persist(alu);\nem.getTransaction().commit();\n</code></pre> <p>Classes incrustades o Components</p> <p>En Java, de vegades hi ha classes que no tenen exist\u00e8ncia pr\u00f2pia, tret que existeixin dins d'una altra classe, com ara una classe Adre\u00e7a. No t\u00e9 sentit crear un objecte Adre\u00e7a ad-hoc, en canvi, s\u00ed que t\u00e9 sentit crear-lo perqu\u00e8 una Adre\u00e7a existeixi, per exemple, dins d'un Estudiant.</p> <p>Per a aquests casos (febles) que existeixen incrustats dins d'altres classes, hem de declarar-los com a incrustables utilitzant l'anotaci\u00f3 <code>@Embeddable</code> i marcar-los com a incrustats (<code>@Embedded</code>) dins de la classe en qu\u00e8 existeixen.</p> Java<pre><code>@Embeddable\npublic class Direccion{\n    ...\n}\n\n@Entity\npublic classes Alumno{\n  ...\n  @Embedded\n  private Direccion direction;\n}\n\n// in main\nAlumno alu= new Alumno(\"Joan Gerard\");\nDireccion d= new Direccion(\"calvary street\");\nalu.setDireccion(d);\nem.persist(alu);\n</code></pre> <p>Una entitat <code>Alumno</code> es guardar\u00e0 a la base de dades, per\u00f2 la <code>Direccion</code> no existeix com a objecte per si mateix.</p>"},{"location":"UD4_BDOO/3_OODB/#4-relacions","title":"4. Relacions","text":""},{"location":"UD4_BDOO/3_OODB/#41-relacio-un-a-un","title":"4.1. Relaci\u00f3 un a un","text":"<p>La relaci\u00f3 m\u00e9s senzilla \u00e9s un a un, en la qual un objecte cont\u00e9 un altre objecte. La marcarem com ja ho vam fer en Hibernate amb el modificador <code>@OneToOne</code> indicant que el desament \u00e9s en cascada (<code>cascade=CascadeType.PERSIST</code>).</p> <p>A partir d'ara, quan desis una inst\u00e0ncia d'un objecte, la teva pr\u00f2pia inst\u00e0ncia de l'objecte relacionat es desar\u00e0 i s'enlla\u00e7ar\u00e0. L'objecte enlla\u00e7at tindr\u00e0 exist\u00e8ncia per si mateix (si est\u00e0 marcat com a <code>@Entity</code>). Un exemple b\u00e0sic en qu\u00e8 una classe t\u00e9 un \u00fanic <code>Tutor</code>:</p> <p>Basat en un exemple en qu\u00e8 una <code>Clase</code> (d'un institut) t\u00e9 un <code>Tutor</code> associat, l'exemple ser\u00e0 el seg\u00fcent:</p> Java<pre><code>@Entity\npublic classes Professor{\n  ...\n}\n\n@Entity\npublic class Clase{\n  ...\n  @OneToOne(cascade=CascadeType.PERSIST)\n  private Professor tutor;\n}\n\n\nProfessor p=new Professor(\"Pepe\");\nClase c= new Clase(\"2DAM\");\nc.setTutor(p);\num.persist(c); // when saving the class the tutor is saved\n</code></pre> <p>Atenci\u00f3</p> <p>Recorda que, de la mateixa manera que en Hibernate, aquesta relaci\u00f3 \u00e9s unidireccional, per\u00f2 es pot fer bidireccional.</p>"},{"location":"UD4_BDOO/3_OODB/#42-relacio-una-a-molts","title":"4.2. Relaci\u00f3 Una a molts","text":"<p>Ara ens referirem a una relaci\u00f3 cl\u00e0ssica en la qual un <code>Professor</code> \u00e9s el tutor de diversos <code>Alumne</code>. Aquestes relacions poden ser unidireccionals o bidireccionals. En aquest exemple ho veurem de manera bidireccional, de tal manera que donat un alumne podem saber qui \u00e9s el seu tutor i donat un professor podem obtenir els alumnes que tutoritza.</p> Java<pre><code>@Entity\npublic class Alumno{\n  ...\n  @ManyToOne(cascade=CascadeType.PERSIST)\n  private Profesor tutor;\n\n}\n\n@Entity\npublic class Profesor{\n  ...\n  @OneToMany(cascade=CascadeType.PERSIST,\n             fetch=FetchType.EAGER)\n  private List&lt;Alumno&gt; theStudents;\n}\n</code></pre> <p>Atenci\u00f3</p> <p>Recorda que, de la mateixa manera que en Hibernate, la c\u00e0rrega de les col\u00b7leccions es pot fer immediatament, amb una mode <code>EAGER</code> o quan sigui necessari en mode <code>LAZY</code>.</p>"},{"location":"UD4_BDOO/3_OODB/#43-molts-a-molts","title":"4.3. Molts a molts","text":"<p>En les relacions de molts a molts, podem abordar-les de diverses maneres. Donem l'exemple de l'ensenyament entre Professor i Alumne. Si simplement volem indicar qui ensenya a qui, seria suficient emmagatzemar una col\u00b7lecci\u00f3 de professors en cada alumne (els professors que ensenyen a aquest alumne), i sim\u00e8tricament, en cada professor una col\u00b7lecci\u00f3 d'alumnes (els alumnes a qui ensenyen). En aquest cas, seria bidireccional, ja que des d'una classe podem navegar a l'altra, quedant aix\u00ed:</p> Java<pre><code>@Entity\npublic classes Alumno{\n  ...\n  @ManyToMany(cascade=CascadeType.PERSIST, fetch=FetchType.LAZY)\n  private Set&lt;Profesor&gt; teachers=new Hash Set&lt;&gt;();\n}\n\n@Entity\npublic classes Profesor{\n  ...\n  @ManyToMany(cascade=CascadeType.PERSIST, fetch=FetchType.LAZY)\n  private Set&lt;Alumno&gt; students=new Hash Set&lt;&gt;();;\n}\n</code></pre> <p>Atenci\u00f3</p> <p>Si necessitem desar qualsevol informaci\u00f3 dins d'aquesta relaci\u00f3, com ara la nota que s'ha rebut, l'estudiant, o els incidents publicats, etc., llavors hem de crear una nova classe, que incorporar\u00e0 els atributs de la relaci\u00f3, i establir relacions un a molts des de cada entitat (Estudiant/Professor) fins a la nova entitat (Ensenyament). Aquesta suposici\u00f3 \u00e9s la famosa Les relacions N-M generen una taula amb els atributs que posseeixen del model relacional.</p>"},{"location":"UD4_BDOO/3_OODB/#5-consultes","title":"5. Consultes","text":"<p>Revisarem com podem carregar les dades que hem desat pr\u00e8viament a la base de dades. Suposem que tenim una classe Estudiant, mapada amb una entitat i amb un identificador (idStudent). La manera m\u00e9s senzilla de carregar un Estudiant, coneixent el seu id, \u00e9s el m\u00e8tode <code>find(class,id)</code>, com vam fer a Hibernate:</p> Java<pre><code>Student a=em.find(Student.classes,2);\n</code></pre> <p>La resta de les c\u00e0rregues s'han de dur a terme mitjan\u00e7ant consultes, en un llenguatge JPQL (Java Persistence Query Language), novament similar a l'HQL de Hibernate.</p> <p>Hi ha dues classes: <code>Query</code> i <code>TypedQuery</code> (la segona hereta de la primera), que s'utilitzen normalment en el primer cas quan no coneixem el resultat de la consulta, i en el segon quan coneixem el resultat.</p> <p>La primera \u00e9s polim\u00f2rfica, de manera que enlla\u00e7ar\u00e0 din\u00e0micament els resultats, i la segona verifica el resultat amb la classe actual. La documentaci\u00f3 oficial recomana l'\u00fas de la segona, <code>TypedQuery</code> per a consultes i <code>Query</code> per a actualitzacions i eliminacions.</p> Java<pre><code>// creation of Query (q) or TypedQuery (tq)\n\n// unique result\n\n//return a generic object, and we must cast it.\nObject q.getSingleResult();   \n\n// return an specified Object\nT tq.getSingleResult();\n\n// a result set\n\n//return a List of generic object, and we must cast it.\nList q.getResultList(); \n\n// return a list of specified Object\nList&lt;T&gt; tq.getResultList();\n\n// to update or delete\nq.executeUpdate();\n</code></pre> <p>De manera similar a Hibernate, podem consultar la base de dades de la seg\u00fcent manera:</p> Java<pre><code>TypedQuery&lt;Alumno&gt; tq=em.createQuery(\"Select a from Alumno a where a.ampa=true\", Alumno.class);\nList&lt;Alumno&gt; alumnosAmpa=tq.getResultList();\n</code></pre> <p>o amb par\u00e0metres:</p> Java<pre><code>TypedQuery&lt;Alumno&gt; tq=em.createQuery(\"Select a from Alumno a where a.ampa= :ampa\", Alumno.class);\ntq.setParameter(\"ampa\", true);\nList&lt;Alumno&gt; alumnosAmpa=tq.getResultList();\n</code></pre> <p>o crear consultes amb nom espec\u00edfiques:</p> Java<pre><code>// on the class\n@NamedQueries({\n    @NamedQuery(query = \"Select a from Alumno a where a.nombre = :name\", name = \"find alu by name\"),\n    @NamedQuery(query = \"Select a from Alumno a\", name = \"get all alu\")\n})\n\n// on main or whatever\nTypedQuery&lt;Alumno&gt; tq=em.createNamedQuery(\"get all alu\",Alumno.class);\nList&lt;Alumno&gt; alumnosAmpa=tq.getResultList();\n</code></pre>"},{"location":"UD4_BDOO/3_OODB/#51-esborrats-i-actualitzacions","title":"5.1. Esborrats i Actualitzacions","text":"<p>Finalment, revisarem les \u00faltimes operacions CRUD que ens queden. Les actualitzacions s\u00f3n totalment transparents per a l'usuari, ja que qualsevol modificaci\u00f3 que es faci dins del context d'una transacci\u00f3 es desar\u00e0 autom\u00e0ticament quan es tanqui amb un <code>commit()</code>. Alternativament, es poden realitzar consultes d'actualitzaci\u00f3.</p> <p>Per a les eliminacions, si l'objecte s'ha recuperat de la base de dades, i per tant est\u00e0 en la transacci\u00f3 actual, es pot eliminar amb <code>em.remove(object)</code>. Es eliminar\u00e0 de la base de dades quan es faci el commit.</p>"},{"location":"UD5_Spring/1_Data_Access_Services/","title":"1. Serveis d'Acces a Dades","text":"Versi\u00f3 Data Notes Versi\u00f3 1.0 Desembre 2022 Versi\u00f3 inicial Versi\u00f3 2.0 Setembre 2023 Haetoas Versi\u00f3 1.0 Octubre 2024 Traduccions <p>\u00a9 Joan Gerard Camarena Estruch</p> <ul> <li>Aquests materials es basen en apunts d'anys anteriors creats per Joan Gerard Camarena i Jose Alfredo Murcia.</li> <li>Agra\u00efments especials a Loren Diaz de Haro per compartir el seu material i exemples de codi.</li> </ul>"},{"location":"UD5_Spring/1_Data_Access_Services/#1-introduccio-serveis-dacces-a-dades","title":"1. Introducci\u00f3. Serveis d'Acc\u00e9s a Dades","text":"<p>Un servlet \u00e9s una aplicaci\u00f3 que s'executa en un servidor, preparada per respondre a sol\u00b7licituds http. M\u00e9s tard tenim JSP (Java Server Pages), que permeten combinar elements HTML/XML amb fragments de codi Java per generar contingut din\u00e0micament. Hem de llan\u00e7ar un servidor d'aplicacions i afegir l'aplicaci\u00f3 per executar-la i servir-la com una altra p\u00e0gina.</p> <p>Podem utilitzar Servlets per escriure una aplicaci\u00f3 web, per\u00f2 hi ha molts detalls intr\u00ednsecs a controlar: validaci\u00f3, REST, cos de la sol\u00b7licitud/resposta per a JSON, vinculaci\u00f3 de formularis, etc. Aix\u00f2 implica que gran part del nostre codi es dedica a controlar les capes inferiors de comunicaci\u00f3.</p> <p>Amb el framework Spring, realment utilitzem servlets, per\u00f2 allibera el programador d'aquesta tasca pesada, gestionant-la autom\u00e0ticament. Aix\u00f2 permet al programador centrar-se en la l\u00f2gica de l'aplicaci\u00f3, sense haver de gestionar els nivells inferiors de comunicacions. A m\u00e9s, Spring Boot es defineix com un accelerador de Spring, permetent-nos indicar una s\u00e8rie de convencions (comportaments) que realitzen tasques pesades de configuraci\u00f3 d'arxius per a nosaltres. Finalment, Spring Boot incorpora un servidor web integrat (normalment <code>Tomcat</code>).</p> <p>El terme framework o si intentem for\u00e7ar la seva traducci\u00f3 al catal\u00e0 Marc de treball ens proporciona un conjunt de regles i eines dissenyades per augmentar la velocitat de desenvolupament d'aplicacions.</p>"},{"location":"UD5_Spring/1_Data_Access_Services/#2-mvc","title":"2. MVC","text":"<p>El Model Vista Controlador (MVC) \u00e9s una arquitectura per al desenvolupament d'aplicacions que separa les dades, la interf\u00edcie i la l\u00f2gica de control en capes.</p> <p></p> <p>El funcionament \u00e9s el seg\u00fcent:</p> <ol> <li>L'usuari est\u00e0 utilitzant l'aplicaci\u00f3 client (normalment un navegador o client), i fa una sol\u00b7licitud a trav\u00e9s del protocol http, tamb\u00e9 coneguda com una HTTP_REQUEST. Aquestes sol\u00b7licituds s\u00f3n rebudes pel m\u00f2dul controlador. El controlador gestiona una llista d'operacions o esdeveniments que pot processar, determinats pel seu propi protocol.</li> <li>En el cas d'una sol\u00b7licitud que demana una consulta o modificaci\u00f3 de les dades, passem els par\u00e0metres proporcionats en la sol\u00b7licitud a la capa del model. Aquesta capa accedeix a les dades, realitzant els passos 3 i 4 a trav\u00e9s d'operacions del SGBD. El Model ara est\u00e0 en condicions de donar una resposta.</li> <li>Consultar la base de dades.</li> <li>Recuperaci\u00f3 de la consulta de la base de dades.</li> <li>El model transfereix el conjunt de resultats obtinguts a la vista.</li> <li>La vista \u00e9s responsable de rebre les dades i presentar-les o formatar-les adequadament.</li> <li>El controlador retorna la presentaci\u00f3 generada per la vista (que normalment ser\u00e0 HTML din\u00e0mic) a l'aplicaci\u00f3 client, a trav\u00e9s de la sol\u00b7licitud HTTP_RESPONSE.</li> </ol>"},{"location":"UD5_Spring/1_Data_Access_Services/#3-rest","title":"3. REST","text":"<p>El model REST (Representational State Transfer) ens permet proporcionar al nostre servidor un servei per recuperar i manipular dades f\u00e0cilment al servidor. En aquest model, la part de la vista es delega al client, deixant el controlador i el model al servidor. En aquest model, destacarem entre altres:</p> <ul> <li>El protocol segueix el model client/servidor sense estat, igual que http, una sol\u00b7licitud nom\u00e9s respondr\u00e0 segons la informaci\u00f3 rebuda en la mateixa sol\u00b7licitud, sense tenir en compte totes les anteriors.</li> <li>Suport d'operacions CRUD, a trav\u00e9s de les especificacions http equivalents: GET (consulta), POST (crear), PUT (modificar) i DELETE (eliminar).</li> <li>Disposici\u00f3 del model HATEOAS (Hypermedia As Engine Of The Application State). Aquest principi permet incloure hipervincles com a recursos en les respostes.</li> </ul> <p>En MVC, i de manera simplificada, seria eliminar la capa de la vista i retornar les dades processades pel model. Normalment els servidors REST retornen dades en format JSON.</p>"},{"location":"UD5_Spring/2_Spring_SpringBoot/","title":"2. Introducci\u00f3 a Spring","text":""},{"location":"UD5_Spring/2_Spring_SpringBoot/#1-spring-and-spring-boot","title":"1. Spring and Spring Boot","text":"<p>El Spring Framework simplifica el desenvolupament d'aplicacions Java, independentment de si s\u00f3n aplicacions web ordin\u00e0ries o aplicacions web fora de l\u00ednia. Els seus majors avantatges s\u00f3n un codi font m\u00e9s simplificat i menys dificultat en els ajustos. Per oferir aquestes comoditats al programador, el framework es basa en els seg\u00fcents principis:</p> <ul> <li> <p>Injecci\u00f3 de depend\u00e8ncies (DI): t\u00e8cnica o patr\u00f3 de disseny utilitzat com una de les formes d'inversi\u00f3 de control (IOC) per promoure un acoblament feble. \u00c9s a dir, quan una classe necessita una altra classe (depend\u00e8ncia), en lloc de crear l'objecte dins de la classe mateixa, Spring el subministra o l'injecta. Aquesta forma d'IOC segueix el principi de Hollywood (no ens truquis, ja et trucarem) en qu\u00e8 l'aplicaci\u00f3 pren el control en lloc del codi, proporcionant els seg\u00fcents beneficis:</p> <ul> <li>Proporciona modularitat.</li> <li>Escalabilitat de l'aplicaci\u00f3 sense necessitat de modificar les classes.</li> <li>Evita la depend\u00e8ncia entre classes.</li> </ul> </li> <li> <p>Desenvolupament senzill amb POJOs (Plain Old Java Objects).</p> </li> <li>Minimitza el codi boilerplate.</li> <li>Simplifica l'acc\u00e9s a les dades gr\u00e0cies a l'ORM (Object Relational Mapping).</li> <li>Programaci\u00f3 Orientada a Aspectes (AOP): Permet una modularitzaci\u00f3 molt m\u00e9s alta per fer una separaci\u00f3 molt clara de les diferents tasques que cada classe ha de realitzar a la nostra aplicaci\u00f3.</li> </ul>"},{"location":"UD5_Spring/2_Spring_SpringBoot/#11-moduls-principals-del-spring-framework","title":"1.1. M\u00f2duls principals del Spring Framework","text":"<p>Gr\u00e0cies a la seva estructura modular per al desenvolupament de les aplicacions m\u00e9s diverses en Java, Spring \u00e9s l'elecci\u00f3 perfecta, ja que pots triar lliurement quins dels components necessites utilitzar per a les teves aplicacions i quins no. En l'arquitectura est\u00e0ndard, els diferents m\u00f2duls es divideixen en sis categories principals:</p> <p></p> <ul> <li> <p>Core Container: El contenidor principal proporciona els m\u00f2duls b\u00e0sics:</p> <ul> <li>Core i Beans formen l'esquelet del framework, contenint la funci\u00f3 d'injecci\u00f3 de depend\u00e8ncies i donant suport als objectes POJO. Cal aclarir que un Bean \u00e9s un POJO, tot i que t\u00e9 algunes caracter\u00edstiques addicionals.</li> <li>Context hereta les seves caracter\u00edstiques del m\u00f2dul Beans i es pot complementar amb funcions per a la internacionalitzaci\u00f3 o la c\u00e0rrega de recursos. A m\u00e9s, d\u00f3na suport a caracter\u00edstiques de Java Enterprise com EJB i JMX (Java Management Extensions). Context-support facilita la integraci\u00f3 de biblioteques d'altres prove\u00efdors en Spring.</li> <li>Spring-expression cont\u00e9 el Spring Expression Language (SPeL), una extensi\u00f3 del Unified Expression Language de l'especificaci\u00f3 JSP-2.1 (Java Server Pages).</li> </ul> </li> <li> <p>AOP i instrumentaci\u00f3: Per permetre la programaci\u00f3 orientada a aspectes, el Spring Framework cont\u00e9 el m\u00f2dul spring-aop. El component spring-instrument proporciona suport per a la implementaci\u00f3 de c\u00e0rrega d'objectes i classes de manipulaci\u00f3 per al seu \u00fas en alguns servidors.</p> </li> <li>Missatgeria: Per servir com a base per a aplicacions basades en missatges, el Spring Framework es basa en algunes de les funcions d'encriptaci\u00f3 del projecte Spring Integration, com Message, MessageChannel o MessageHandler. Aquest m\u00f2dul t\u00e9 el nom de spring-messaging.</li> <li> <p>Acc\u00e9s a Dades/Integraci\u00f3: Els m\u00f2duls d'aquesta categoria estan dissenyats per donar a les aplicacions Java les eines per interactuar amb altres aplicacions, aix\u00ed com controlar l'acc\u00e9s a les dades.</p> <ul> <li>spring-jdbc proporciona una capa d'abstracci\u00f3 que defineix la manera com un client accedeix a la base de dades i estalvia la codificaci\u00f3 complicada t\u00edpica de JDBC.</li> <li>spring-orm ofereix capes d'integraci\u00f3 per accedir a bases de dades relacionals en interf\u00edcies ORM populars.</li> <li>spring-tx (d\u00f3na suport a la gesti\u00f3 de transaccions program\u00e0tiques per a totes les classes i POJOs).</li> <li>spring-oxm (capa d'abstracci\u00f3 per al mapatge d'objectes o XML).</li> <li>spring-jms, un m\u00f2dul amb funcions per a la producci\u00f3 i processament de missatges.</li> </ul> </li> <li> <p>Web: en aquesta categoria es troben els m\u00f2duls espec\u00edfics per a aplicacions web: spring-web, spring-webmvc i spring-websocket. A m\u00e9s, aquesta aplicaci\u00f3 Java ha afegit funcions d'integraci\u00f3 t\u00edpiques orientades al web com una funci\u00f3 de c\u00e0rrega multipart o un client HTTP. El m\u00f2dul spring-webmvc tamb\u00e9 \u00e9s conegut com a web servlet i \u00e9s el que cont\u00e9 les implementacions de Spring per a l'execuci\u00f3 del patr\u00f3 d'arquitectura model-vista-controlador (MVC) i serveis web REST.</p> </li> <li>Test: el m\u00f2dul spring-test permet comprovar la funcionalitat dels components de la teva aplicaci\u00f3 Java. Aix\u00ed, amb l'ajuda de frameworks addicionals com JUnit o TestNG, pots realitzar proves unit\u00e0ries (centrades en un sol component) aix\u00ed com proves d'integraci\u00f3.</li> </ul>"},{"location":"UD5_Spring/2_Spring_SpringBoot/#2-spring-vs-spring-boot","title":"2. Spring vs Spring Boot","text":"<p>Spring Boot va apar\u00e8ixer fa uns anys amb la idea de complementar Spring, \u00e9s a dir, afegir a Spring, no amb la idea de substituir-lo. Com es pot interpretar a la imatge seg\u00fcent, Spring Boot realment funciona amb Spring per sota, per\u00f2 d'una manera m\u00e9s f\u00e0cil.</p> <p></p> <p>Podr\u00edem definir Spring Boot com un accelerador per a la creaci\u00f3 de projectes Spring, que es basa principalment en el concepte de convenci\u00f3 abans de la configuraci\u00f3. Una altra manera de definir Spring Boot podria ser com un accelerador de creaci\u00f3 de projectes Spring. Per tant, l'objectiu \u00e9s crear projectes Spring, per\u00f2 d'una manera m\u00e9s \u00e0gil, a trav\u00e9s d'una s\u00e8rie de convencions que prevalen sobre la configuraci\u00f3. Estalviant-nos haver de perdre temps fent configuracions pesades en fitxers.</p> <p>Cal destacar que Spring Boot no es considera un Framework com a tal, en canvi, Spring s\u00ed que t\u00e9 el privilegi de categoritzar-se com a tal. Amb Spring Boot, podem fer el mateix que amb Spring. Per\u00f2 d'una manera m\u00e9s r\u00e0pida que si desenvolupem exclusivament amb Spring nom\u00e9s. Per\u00f2 amb tots dos, podr\u00edem tenir el mateix desenvolupament, tot i que la difer\u00e8ncia entre els dos seria el temps invertit.</p> <p></p> <p>Per explicar les difer\u00e8ncies entre els dos, \u00e9s essencial introduir el concepte de convenci\u00f3 de configuraci\u00f3, que juga un paper tan important en el camp de l'enginyeria de programari.</p>"},{"location":"UD5_Spring/2_Spring_SpringBoot/#21-que-es-la-convencio-de-configuracio","title":"2.1. Qu\u00e8 \u00e9s la convenci\u00f3 de configuraci\u00f3?","text":"<p>Aquest principi especifica/detalla una s\u00e8rie de convencions (conjunt de regles) que estaran per sobre de la configuraci\u00f3, tret que s'especifiqui el contrari. \u00c9s a dir, s'aplicaran per defecte si no especifiquem el contrari.</p> <p>Un exemple d'una convenci\u00f3 abans de la configuraci\u00f3 podria ser quan creem una aplicaci\u00f3 MVC amb Spring, hem de dur a terme moltes configuracions, incloent-hi el port. D'altra banda, si creem l'aplicaci\u00f3 utilitzant Spring Boot, gr\u00e0cies a la convenci\u00f3 de configuraci\u00f3, el port per defecte de l'aplicaci\u00f3 en iniciar-la ser\u00e0 8080. Per\u00f2 si volem canviar-lo, nom\u00e9s hem de modificar un fitxer i afegir una sola instrucci\u00f3 on detallarem el port, per exemple, 8888. D'aquesta manera, realitzarem un desenvolupament m\u00e9s \u00e0gil, ja que evitarem haver de fer configuracions, excepte que vulguem modificar la configuraci\u00f3 d'alguna convenci\u00f3.</p>"},{"location":"UD5_Spring/2_Spring_SpringBoot/#3-requisits-i-installacio","title":"3. Requisits i Instal\u00b7laci\u00f3","text":"<p>Spring funciona amb moltes tecnologies integrades (a continuaci\u00f3), aix\u00ed que aconsellem tenir el seg\u00fcent per assegurar-nos que tot funcioni correctament. Els requisits s\u00f3n:</p> <ul> <li>Java instal\u00b7lat, \u00e9s aconsellable tenir la versi\u00f3 8, degut a la seva estabilitat. I que Spring no suporta algunes de les versions m\u00e9s noves de Java.</li> <li>Apache Maven instal\u00b7lat.</li> <li>Un IDE compatible (en aquest cas ser\u00e0 Spring Tool Suite).</li> </ul> <p>Spring Tool Suite 4, que \u00e9s el proporcionat des del lloc web de Pivotal (p\u00e0gina oficial dels creadors i mantenidors de Spring). Es pot descarregar des de https://spring.io/tools.</p>"},{"location":"UD5_Spring/2_Spring_SpringBoot/#4-primer-projecte-i-execucio","title":"4. Primer projecte i execuci\u00f3","text":"<p>Per crear un projecte Spring, ho podem fer de dues maneres:</p> <ul> <li>Crear un projecte des de Spring Boot Initializer, l'eina web proporcionada per Pivotal aqu\u00ed https://start.spring.io. Aquest assistent genera un fitxer zip amb l'estructura del projecte maven. Necessitem importar aquest fitxer zip al nostre IDE per comen\u00e7ar a programar.</li> <li>Crear el projecte des de l'IDE utilitzant l'eina de l\u00ednia de comandes (CLI), en el nostre cas l'IDE escollit ser\u00e0 Spring Tool Suite 4. No necessitem passos addicionals per comen\u00e7ar a programar.</li> </ul>"},{"location":"UD5_Spring/2_Spring_SpringBoot/#41-initializr","title":"4.1. Initializr","text":"<p>Visitem https://start.spring.io i omplim el formulari:</p> <p></p> <p>A la part de depend\u00e8ncies, haur\u00edem d'afegir els aspectes del nostre programa. Inicialment aplicaci\u00f3 web, per\u00f2 podr\u00edem afegir Lombok, Thymeleaf i altres aspectes.</p> <p>Aqu\u00ed trobareu diverses captures de pantalla amb el proc\u00e9s. Des de STS, creeu un nou projecte:</p> <p></p> <p>I seleccioneu un Spring starter project:</p> <p></p> <p>Seleccioneu un projecte maven, la versi\u00f3 de Java instal\u00b7lada i escriviu informaci\u00f3 sobre la versi\u00f3 de l'artifact i altres dades:</p> <p></p> <p>I finalment seleccioneu les depend\u00e8ncies. En el nostre projecte inicial, seleccioneu Spring web.</p> <p></p> <p>I quan el proc\u00e9s acabi, trobareu una estructura de projecte amb un pom.xml configurat.</p> <p></p> <p>i l'estructura:</p> <p></p>"},{"location":"UD5_Spring/2_Spring_SpringBoot/#42-primera-execucio","title":"4.2. Primera execuci\u00f3","text":"<p>Vegem quins fitxers s'han creat en el nostre projecte. Com podeu veure, nom\u00e9s una classe amb una funci\u00f3 principal:</p> Java<pre><code>import org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class HelloSpringApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(HelloSpringApplication.class, args);\n    }\n\n}\n</code></pre> <p>S'executar\u00e0 una <code>SpringApplication</code>, de la mateixa manera que s'executa un <code>Thread</code>. Aquesta classe inicialitza i llan\u00e7a l'aplicaci\u00f3 Spring, amb arguments, si n'hi ha.</p> <p>Consell</p> <p>Spring com a aplicaci\u00f3 web, no interactua amb l'usuari, i esperar\u00e0 i servir\u00e0 a molts clients. Per aquesta ra\u00f3, no \u00e9s una bona idea fer programes interactius amb usuaris.</p> <p>Per executar la nostra aplicaci\u00f3 Spring:</p> <p></p> <p>I apareixer\u00e0 a la consola un registre similar a:</p> <p></p> <p>La primera cosa important que heu de veure \u00e9s el port al qual el servidor Tomcat est\u00e0 escoltant. Per defecte \u00e9s el port 8080:</p> Bash<pre><code>... Tomcat started on port(s): 8080 (http) with context path ''\n</code></pre> <p>I quan aturem el nostre programa:</p> <p></p> <p>Consell</p> <p>Recordeu que \u00e9s molt \u00fatil llegir tots aquests missatges, especialment quan alguna cosa no funciona com s'espera</p> <p>Per mostrar que el nostre programa funciona correctament, necessitem provar el port espec\u00edfic, i despr\u00e9s, anar al nostre navegador i escriure <code>http://localhost:8080</code>. </p> <p></p> <p>El missatge d'error que obtenim <code>Whitelabel Error Page</code>, no \u00e9s un error en absolut, ja que no hem programat cap controlador, \u00e9s a dir, el servidor est\u00e0 funcionant, per\u00f2 no est\u00e0 servint res.</p>"},{"location":"UD5_Spring/2_Spring_SpringBoot/#43-el-fitxer-applicationproperties","title":"4.3. El fitxer <code>application.properties</code>","text":"<p>Aquest fitxer cont\u00e9 moltes configuracions \u00fatils que establirem al llarg del nostre cicle de desenvolupament. Les estudiarem a mesura que apareguin, per\u00f2 totes les configuracions que vam establir al fitxer <code>hibernate.cfg.xml</code> a la unitat 3 es configuraran en aquest fitxer.</p> <p></p> <p>Aquest fitxer, com tots els fitxers de propietats, t\u00e9 una estructura de parella atribut-valor. El primer valor important \u00e9s canviar el port que escolta el nostre servidor. Aquest fitxer es troba a la carpeta <code>src/main/resources</code>. Hem d'afegir, per exemple:</p> Bash<pre><code># port d'escolta\nserver.port = 8090\n</code></pre> <p>Si tornem a executar la nostra aplicaci\u00f3, hem de canviar el port al navegador per accedir al nostre servidor.</p> <p>Consell</p> <p>Podeu veure (gaireb\u00e9) totes les propietats visitant aquesta p\u00e0gina web</p> <p>Podr\u00edem afegir qualsevol valor que vulguem utilitzar, com ara constants per utilitzar en els nostres programes. Despr\u00e9s podem carregar-lo en els nostres programes. Per exemple:</p> Bash<pre><code># App name\napp.name=First spring app\n\n#Developer name\ndeveloper.name=Joan Gerard Camarena\n</code></pre> <p>per carregar-ho als nostres programes, necessitem utilitzar l'anotaci\u00f3 <code>@Value</code>:</p> Java<pre><code>@Value(\"${app.name}\")\nprivate String appName;\n\n@Value(\"${developer.name}\")\nprivate String devName;\n</code></pre>"},{"location":"UD5_Spring/2_Spring_SpringBoot/#44-anotacio-springbootapplication","title":"4.4. Anotaci\u00f3 <code>@SpringBootApplication</code>","text":"<p>A Spring Boot, \u00e9s molt com\u00fa aplicar m\u00faltiples anotacions a la classe principal. Per\u00f2 comunament, la majoria dels desenvolupadors principalment apliquen 3 anotacions.</p> <ul> <li><code>@Configuration</code>: Disponible des de la versi\u00f3 3 de Spring, ens ofereix la possibilitat de fer una anotaci\u00f3 que s'encarregar\u00e0 de definir la classe que la posseeix com una classe de configuraci\u00f3. Aquesta configuraci\u00f3 per al framework Spring es basar\u00e0 en anotacions. I no com en els seus or\u00edgens, que es basava en XML, cosa que ho feia m\u00e9s complex. Un altre prop\u00f2sit d'aquesta anotaci\u00f3 ser\u00e0 permetre la injecci\u00f3 de depend\u00e8ncies.</li> <li><code>@EnableAutoConfiguration</code>: La configuraci\u00f3 autom\u00e0tica de Spring Boot intenta configurar autom\u00e0ticament la teva aplicaci\u00f3 Spring en funci\u00f3 de qualsevol depend\u00e8ncia de jar que hagis afegit. Si, per exemple, si poses un HSQLDB (sistema de gesti\u00f3 de bases de dades) al teu classpath, i no has configurat manualment cap bean de connexi\u00f3 a la base de dades, Spring Boot configura autom\u00e0ticament una base de dades en mem\u00f2ria.</li> <li><code>@ComponentScan</code>: S'utilitza juntament amb <code>@Configuration</code> per dir a Spring on buscar els components, i ser\u00e0 dins del paquet que hem anotat. Nom\u00e9s havent d'escriure-ho una vegada, podent fer que tots els paquets siguin fills del paquet de la classe pare (la que cont\u00e9 el main). B\u00e0sicament, aix\u00f2 diu a Spring on ha de buscar tots els components.</li> </ul> <p>Per poder utilitzar aquest paquet de tres anotacions, Spring Boot ens ofereix <code>@SpringBootApplication</code> com la uni\u00f3 de les tres anotacions explicades anteriorment.</p>"},{"location":"UD5_Spring/2_Spring_SpringBoot/#5-mvc-amb-spring","title":"5. MVC amb Spring","text":""},{"location":"UD5_Spring/2_Spring_SpringBoot/#51-controladors","title":"5.1. Controladors","text":"<p>Un controlador \u00e9s responsable de respondre a esdeveniments. Normalment, aquests esdeveniments s\u00f3n accions (m\u00e9s t\u00e8cnicament conegudes com a sol\u00b7licituds) que solen ser realitzades per l'usuari, tot i que tamb\u00e9 poden ser sol\u00b7licituds m\u00e9s automatitzades com API, p\u00e0gines frontals Ajax, etc.</p> <p>En un context de la vida real, un controlador \u00e9s com un cambrer; Ell o ella est\u00e0 esperant darrere de la barra fins que arribi un client. El client demana una coca-cola, i el cambrer, si en t\u00e9, la servir\u00e0. Despr\u00e9s arriba un altre client, i demana un caf\u00e8, i llavors el cambrer el serveix. Un altre client arriba, i demana un te verd, i el cambrer diu que no el pot servir, perqu\u00e8 no en t\u00e9. Una vegada i una altra... El cambrer servir\u00e0 tot el que el client vulgui, si pot.</p> <p></p> <p>Tornant a Spring, hem d'afegir al nostre programa un m\u00f2dul que funcioni com un controlador, escoltant totes les sol\u00b7licituds dels clients, i responent (si pot) amb les dades que el client sol\u00b7licita.</p> <p></p> <p>Recordeu l'error en la primera execuci\u00f3 de Spring: l'aplicaci\u00f3 Spring funciona b\u00e9, per\u00f2 encara no tenim un controlador. Som-hi.</p>"},{"location":"UD5_Spring/2_Spring_SpringBoot/#52-paquet-controllers","title":"5.2. Paquet <code>controllers</code>","text":"<p>Anem a crear un controlador, per\u00f2 primer, hem de crear un paquet que contingui aquest controlador. Abans parl\u00e0vem de l'anotaci\u00f3 <code>@SpringBootApplication</code> que vam dir que era equivalent a tenir 3 anotacions. Una d'elles era <code>@ComponentScan</code>. Si no volem haver de dir-li que escanegi diversos paquets (que normalment \u00e9s la millor idea), normalment posem tota l'estructura de paquets dins del paquet <code>pare</code>, que ser\u00e0 el paquet on tenim el main.</p> <p>Per fer aix\u00f2, feu clic dret sobre el paquet que cont\u00e9 el main. D'aquesta manera, quan anem a posar el nom directament ens apareixer\u00e0 el com.example i nom\u00e9s haurem d'afegir un <code>.</code> i el nom del paquet fill. Si no, haur\u00edem d'escriure el nom complet del paquet. Com podeu veure, el paquet blanc ens indica que \u00e9s un paquet buit en lloc del paquet marr\u00f3.</p> <p></p> <p>Anem a crear una classe senzilla que controli l'\u00edndex de la nostra aplicaci\u00f3. Per aquesta ra\u00f3, hem de nomenar la nostra classe com <code>indexController.java</code>. Recordeu que \u00edndex es refereix al domini principal del nostre servidor/app.</p> <p>Consell</p> <p>\u00c9s una bona pr\u00e0ctica establir noms de classes seguint regles senzilles per entendre el comportament de la classe. Aix\u00ed, una classe anomenada <code>clientController</code> \u00e9s el controlador que mapatge informaci\u00f3 sobre <code>Client</code>, i <code>filmController.java</code> tracta sobre <code>Films</code>.</p> <p>Un cop la nostra classe ha estat creada, dins del paquet controlador, l'hem de configurar. Vegem un exemple de <code>indexController.java</code>:</p> Java<pre><code>@Controller\npublic class indexController {\n\n    @GetMapping(\"/\")\n    @ResponseBody\n    public String helloWorld() {\n        return \"Hello from Spring\";\n    }\n\n}\n</code></pre> <p>Mireu les nostres anotacions:</p> <ul> <li><code>@Controller</code> \u2192 diu a Spring que aquesta classe \u00e9s un controlador. \u00c9s una especialitzaci\u00f3 de <code>@Component</code>, i com que Spring explora tot el classpath, es detecta autom\u00e0ticament.</li> <li><code>@GetMapping(\"/\")</code> \u2192 \u00e9s el controlador. Definim un cam\u00ed (<code>\"/\"</code>) al nostre servidor, i escoltem el m\u00e8tode <code>GET</code>. En parlarem m\u00e9s endavant.</li> <li><code>@ResponseBody</code> \u2192 diu al controlador que serialitzi el valor de retorn (una cadena en el nostre exemple) a JSON i l'envi\u00ef a trav\u00e9s de <code>http_response</code> al client que crida el controlador.</li> </ul> <p>Ara, si intentem recarregar la p\u00e0gina al navegador, en lloc d'un missatge d'error, obtindrem el valor retornat pel controlador:</p> Abans del controladorDespr\u00e9s del controlador <p></p> <p></p> <p>Una altra manera d'obtenir el mateix resultat seria:</p> Java<pre><code>@RestController\npublic class indexController {\n\n    @GetMapping(\"/\")\n    public String helloWorld() {\n        return \"Hello from Spring\";\n    }\n\n}\n</code></pre> <p>on:</p> <ul> <li><code>@RestController</code> \u2192 indica que en aquesta classe tots els m\u00e8todes inclouen l'anotaci\u00f3 <code>@ResponseBody</code>. Tingueu cura, ja que tots els m\u00e8todes retornaran un objecte JSON, i en alguns casos (quan enviem dades a vistes en un altre format), pot ser una mala idea.</li> </ul>"},{"location":"UD5_Spring/2_Spring_SpringBoot/#53-sollicituds-i-parametres","title":"5.3. Sol\u00b7licituds i Par\u00e0metres","text":"<p>Atenci\u00f3</p> <p>Per provar la nostra sol\u00b7licitud, a partir d'ara utilitzarem POSTMAN https://www.postman.com/downloads/. Hi ha un ap\u00e8ndix sobre l'\u00fas de postman.</p> <p>Afegim una mica d'intel\u00b7lig\u00e8ncia a una ruta del controlador, donant-li una mica de dinamisme a trav\u00e9s del pas de par\u00e0metres. Aquests par\u00e0metres seran acceptats gr\u00e0cies a l'anotaci\u00f3 <code>@RequestParam</code>.</p> <p>El nombre de par\u00e0metres que rebrem ser\u00e0 igual al nombre de par\u00e0metres que hem definit dins de l'anotaci\u00f3 <code>@RequestParam</code> del m\u00e8tode de la ruta del controlador, de la seg\u00fcent manera:</p> Java<pre><code>@GetMapping(\"/hola\")\n    @ResponseBody\n    public String hola(@RequestParam String name) {\n        return \"Hola \"+ name +\" desde Spring !!!\";\n    }\n</code></pre> <p>Aix\u00f2 significa que una sol\u00b7licitud de <code>GET /hola</code> necessitar\u00e0 un par\u00e0metre (<code>name</code>) amb el seu valor. Per exemple <code>http://localhost:9090/hola?name=Joange</code>.</p> <p>Tingueu en compte que si no afegim el par\u00e0metre, la sol\u00b7licitud ser\u00e0 incorrecta. Podr\u00edem solucionar-ho, establint aquest par\u00e0metre com a no requerit i un valor per defecte, de la seg\u00fcent manera:</p> Java<pre><code>@GetMapping(\"/hola\")\n@ResponseBody\npublic String hola(@RequestParam(required = false,defaultValue = \"desconocido\") String name) {\n  return \"Hola \"+ name +\" desde Spring !!!\";\n}\n</code></pre>"},{"location":"UD5_Spring/2_Spring_SpringBoot/#54-logger","title":"5.4. Logger","text":"<p>Una bona idea tamb\u00e9 \u00e9s utilitzar <code>Logger</code> per mostrar qu\u00e8 est\u00e0 passant al nostre servidor. Podem utilitzar-lo com suggerim:</p> Java<pre><code>// set up a Logger to my app\nprivate static final Logger myLog=LoggerFactory.getLogger(HelloSpringApplication.class);\n\n// check specific situations\nif (name==null) {\n    myLog.warn(\"Name parameter does not exists\");\n}\nelse {\n    myLog.info(name + \" is here\");\n}\n</code></pre> <p><code>Logger</code> ens ofereix mostrar cada tipus de missatge:</p> <ul> <li><code>void error(String msg)</code></li> <li><code>void warn(String msg)</code></li> <li><code>void info(String msg)</code></li> </ul>"},{"location":"UD5_Spring/2_Spring_SpringBoot/#55-parametres-multiples","title":"5.5. Par\u00e0metres m\u00faltiples","text":"<p>Anem a estudiar com obtenir diversos par\u00e0metres, tot i que no es recomana m\u00e9s de tres o quatre, perqu\u00e8 els camins augmenten molt, i hi ha millors m\u00e8todes per passar dades al servidor, com objectes en la sol\u00b7licitud BODY des de formularis o dades dins dels camins. Un exemple cl\u00e0ssic \u00e9s el seg\u00fcent:</p> Java<pre><code>@Autowired\nprivate HttpServletRequest context;\n\n@GetMapping(\"/born\")\n@ResponseBody\npublic String born(\n    @RequestParam(required=true,defaultValue = \"unknown\") String name,\n    @RequestParam(required=true,defaultValue = \"1970\") int year         \n    ) {\n  int currentYear = Calendar.getInstance().get(Calendar.YEAR);\n  myLog.info(\"Request from -&gt; \"+context.getRemoteAddr() + \" Port-&gt;\" + context.getRemotePort());\n  return \"Hi \" + name + \" you have \" + (currentYear-year);\n}\n</code></pre> <p>tingues en compte que:</p> <ul> <li>Tot i que els valors per defecte podrien ser enters o reals, els hem de definir com a cadenes.</li> <li>La variable <code>HttpServletRequest</code> definida s'utilitza per obtenir informaci\u00f3 addicional sobre la sol\u00b7licitud http rebuda.</li> </ul> <p>Important</p> <p><code>@Autowired</code> \u00e9s una de les anotacions m\u00e9s utilitzades. Aquesta anotaci\u00f3 permet fer la injecci\u00f3 de depend\u00e8ncies. Aix\u00f2 significa que Spring buscar\u00e0 una classe dins del context de l'aplicaci\u00f3 que coincideixi amb el bean desitjat, crear\u00e0 una nova inst\u00e0ncia i la injectar\u00e0 dins del bean que posseeix la injecci\u00f3.</p>"},{"location":"UD5_Spring/2_Spring_SpringBoot/#56-sollicitud-post","title":"5.6. Sol\u00b7licitud POST","text":"<p>Apart de GET, podem fer sol\u00b7licituds POST, PUT, DELETE i m\u00e9s al nostre servidor. Simplement hem de substituir <code>@GetMapping</code> per <code>@PostMapping</code>, amb la corresponent importaci\u00f3. De fet, com que s\u00f3n rutes diferents, fins i tot si es diuen igual, podrien estar al mateix fitxer sense cap problema.</p> Java<pre><code>@PostMapping(\"/born\")\n@ResponseBody\npublic String post(\n    @RequestParam(required=true,defaultValue = \"unknown\") String name,\n    @RequestParam(required=true,defaultValue = \"1970\") int year         \n    ) {\n</code></pre> <p>Com que les sol\u00b7licituds POST solen ser cridades dins d'un formulari, \u00e9s una bona idea establir el par\u00e0metre a la secci\u00f3 del cos de la sol\u00b7licitud. Per fer aix\u00f2, hem de configurar la secci\u00f3 BODY de POSTMAN, seleccionar <code>www-form-urlencoded</code> i establir els par\u00e0metres.</p> <p>Si volem un nombre il\u00b7limitat de par\u00e0metres, podem crear una matriu i crear m\u00faltiples par\u00e0metres a POSTMAN amb el mateix nom:</p> Java<pre><code>@PostMapping(\"/lots\")\n@ResponseBody\npublic String lots(@RequestParam String [] params) {\n  String res=\"\";\n  myLog.info(\"POST Request from -&gt; \"+context.getRemoteAddr() + \" Port-&gt;\" + context.getRemotePort());\n  if(params==null || params.length==0)\n    res= \"A POST request without params.\";\n  else {\n    res=\"The list of params is:\\n\";\n    for (String param : params) {\n      res+=param+\"\\n\";\n    }\n    res=res.substring(0, res.length()-1);\n  }\n\n  return res;\n}\n</code></pre> <p></p>"},{"location":"UD5_Spring/2_Spring_SpringBoot/#57-variables-en-el-cami","title":"5.7. Variables en el cam\u00ed","text":"<p>Si volem obtenir un valor espec\u00edfic, en forma de valor en el cam\u00ed, per exemple <code>GET films/1</code> en lloc de <code>GET films?idFilm=1</code>, la manera \u00e9s la seg\u00fcent:</p> Java<pre><code>@GetMapping(\"/who/{idWho}\")\n@ResponseBody\npublic String who(@PathVariable String idWho) {\n  myLog.info(\"GET Request from -&gt; \"+context.getRemoteAddr() + \" Port-&gt;\" + context.getRemotePort());\n  return \"You are looking for \" + idWho;\n}\n</code></pre> <p>La petici\u00f3 respon:</p> <p></p> <p>Com podem veure:</p> <ul> <li>A l'aplicaci\u00f3 establim en el cam\u00ed el par\u00e0metre <code>idWho</code>.</li> <li>Al controlador definim el par\u00e0metre com a String per a poder accedir des del nostre m\u00e8tode.</li> <li>Al fer la petici\u00f3, el valor s'assigna des de la petici\u00f3 al par\u00e0metre de la funci\u00f3.</li> </ul>"},{"location":"UD5_Spring/3_API_Rest/","title":"3. Creaci\u00f3 de APIs REST","text":""},{"location":"UD5_Spring/3_API_Rest/#1-nivells-capes-de-spring","title":"1. Nivells (capes) de Spring","text":"<p>Estem aprenent sobre alguns patrons de disseny que utilitzarem en la nostra aplicaci\u00f3, i que s\u00f3n necessaris per definir una arquitectura correcta en una aplicaci\u00f3 Spring. Per tant, la primera cosa que farem \u00e9s definir les capes de l'estructura de la nostra aplicaci\u00f3, i un cop les definim, definirem nous patrons de disseny que integrarem a la nostra aplicaci\u00f3.</p> <p></p> <p>La idea \u00e9s crear una estructura de paquets que agrupi les classes en 6 paquets principals: paquet que cont\u00e9 la classe principal, capa web que cont\u00e9 els controladors, capa d'acc\u00e9s a dades que cont\u00e9 el repositori, capa de servei, capa de model de dades i capa dto. Tots aquests estan inclosos, b\u00e0sicament en 3: web, servei i repositori.</p> <p>L'objectiu \u00e9s que, amb una arquitectura ben definida i acoblada, sigui possible utilitzar la Injecci\u00f3 de Depend\u00e8ncies, ja que facilitar\u00e0 la comunicaci\u00f3 i l'acc\u00e9s entre les diferents capes.</p>"},{"location":"UD5_Spring/3_API_Rest/#11-classe-main","title":"1.1. Classe Main","text":"<p>Cada aplicaci\u00f3 Java ha de contenir una classe principal amb un m\u00e8tode main. Aquest m\u00e8tode, en cas d'implementar una aplicaci\u00f3 amb Spring, ha de cridar el m\u00e8tode run de la classe <code>SpringApplication</code>. Deixarem aquesta classe a l'arrel per defecte, de manera que sempre la tindrem al mateix lloc.</p>"},{"location":"UD5_Spring/3_API_Rest/#12-capa-web-capa-de-controladors","title":"1.2. Capa Web. Capa de Controladors","text":"<p>Ara definirem el comportament de l'aplicaci\u00f3 implementant la resta de les classes. Comen\u00e7arem amb la capa de m\u00e9s alt nivell, la capa de controladors, on exposarem els serveis de l'aplicaci\u00f3. En la nostra aplicaci\u00f3 es dir\u00e0 <code>Controller</code>.</p> <p>Aquesta capa b\u00e0sicament contindr\u00e0 3 parts:</p> <ul> <li>Serveis web consumits per aplicacions (servei REST o SOAP).</li> <li>Vistes implementades amb JSP, JSF, Thymeleaf, etc. Aquest \u00e9s el nostre cas principal, tot i que tamb\u00e9 crearem serveis REST.</li> <li>Vistes amb frameworks com Vaadin, Wicket, ZK, etc.</li> </ul>"},{"location":"UD5_Spring/3_API_Rest/#13-capa-de-serveis","title":"1.3. Capa de Serveis","text":"<p>Capa que s'encarrega d'implementar la l\u00f2gica de negoci, \u00e9s a dir, totes les tasques que el nostre sistema \u00e9s capa\u00e7 de realitzar. \u00c9s la el\u00b7laboraci\u00f3 del que ofereix el controlador.</p> <p>Aquesta \u00e9s una de les capes m\u00e9s importants ja que aqu\u00ed es duran a terme totes les operacions de validaci\u00f3 de dades que fan refer\u00e8ncia a la l\u00f2gica de negoci (per exemple, comprovar que un compte corrent t\u00e9 saldo en fer un pagament) i la seguretat. Es dir\u00e0 <code>service</code>.</p> <p>Normalment, accedeixen a les dades emmagatzemades a la base de dades de l'aplicaci\u00f3 a trav\u00e9s dels repositories, fan una s\u00e8rie d'operacions i envien les dades al controlador. Podem trobar els seg\u00fcents tipus de servei:</p> <ul> <li>Serveis d'Integritat de Repositoris: s'encarreguen de consumir informaci\u00f3 del repositori. S\u00f3n serveis f\u00e0cils d'implementar (per exemple, sol\u00b7licitar una llista de clients).</li> <li>Serveis d'Operabilitat de Negoci: realitzen operacions espec\u00edfiques per al flux de negoci (realitzen operacions complexes per completar una transacci\u00f3, com una venda, emmagatzemar una comanda, etc).</li> <li>Serveis de Seguretat: dedicats a realitzar operacions de seguretat.</li> <li>Serveis de Gesti\u00f3: dedicats a generar informes i/o estad\u00edstiques.</li> </ul>"},{"location":"UD5_Spring/3_API_Rest/#14-capa-de-repositori","title":"1.4. Capa de Repositori","text":"<p>Els repositoris s\u00f3n les classes encarregades de gestionar l'acc\u00e9s a les dades. Normalment contenen classes que realitzen operacions CRUD utilitzant nom\u00e9s una classe d'entitat d'un model de domini. Es dir\u00e0 <code>repository</code>. Poden contenir-ne operacions de dos models.</p>"},{"location":"UD5_Spring/3_API_Rest/#15-capa-de-model","title":"1.5. Capa de Model","text":"<p>Contindr\u00e0 els mapatges de les taules de la base de dades en classes que representen entitats. La capa es dir\u00e0 <code>model</code>.</p>"},{"location":"UD5_Spring/3_API_Rest/#16-capa-dto","title":"1.6. Capa DTO","text":"<p>Els controladors normalment gestionen <code>DTO</code> en lloc de pojos o beans, a causa de l'estructura de l'API o la representaci\u00f3 en vistes. Per tant, necessitarem implementar una conversi\u00f3 bidireccional entre un pojo i un model DTO. M\u00e9s endavant definirem, en els patrons de disseny, qu\u00e8 \u00e9s un DTO i veurem la conversi\u00f3 bidireccional, anomenada mapatge. A m\u00e9s, aquests DTO estaran en una capa separada anomenada <code>dto</code>.</p> <p></p>"},{"location":"UD5_Spring/3_API_Rest/#2-patrons-de-disseny","title":"2. Patrons de Disseny","text":"<p>Un patr\u00f3 de disseny \u00e9s una soluci\u00f3 provada que resol un tipus espec\u00edfic de problema de disseny en el desenvolupament de programari. Hi ha molts patrons de disseny que es divideixen en categories, per exemple: creaci\u00f3, estructural, comportamental, interacci\u00f3, etc.</p> <p>Per qu\u00e8 utilitzar patrons de disseny?: Permeten tenir el codi ben organitzat, llegible i mantenible, tamb\u00e9 permeten reutilitzar codi i augmenten l'escalabilitat en el teu projecte.</p> <p>En si mateixos proporcionen una terminologia est\u00e0ndard i un conjunt de bones pr\u00e0ctiques pel que fa a la soluci\u00f3 de problemes de desenvolupament de programari.</p> <p>Anem a explicar-ne diversos per comen\u00e7ar a entendre qu\u00e8 s\u00f3n els patrons de disseny.</p>"},{"location":"UD5_Spring/3_API_Rest/#21-patro-mvc","title":"2.1. Patr\u00f3 MVC.","text":"<p>Ja hem explicat aquest patr\u00f3 en el tema anterior, per\u00f2 li farem una petita revisi\u00f3.</p> <p>Permet separar una aplicaci\u00f3 en 3 capes, una manera d'organitzar i fer un projecte escalable. Les capes que podem trobar s\u00f3n:</p> <ul> <li>Model: Aquesta capa representa tot el que t\u00e9 a veure amb l'acc\u00e9s a dades: desar, actualitzar, obtenir dades, aix\u00ed com tot el codi de la l\u00f2gica de negoci, b\u00e0sicament les classes Java i part de la l\u00f2gica de negoci.</li> <li>Vista: La vista t\u00e9 a veure amb la presentaci\u00f3 de dades del model i el que l'usuari veu, normalment una vista \u00e9s la representaci\u00f3 visual d'un model (POJO o classe Java). Per exemple, el model d'usuari, que \u00e9s una classe en Java i les propietats de la qual s\u00f3n nom i cognom, ha de pert\u00e0nyer a una vista en la qual l'usuari final veu aquestes propietats.</li> <li>Controlador: El controlador s'encarrega de connectar el model amb les vistes, funciona com un pont entre la vista i el model, el controlador rep esdeveniments generats per l'usuari des de les vistes i s'encarrega de dirigir la sol\u00b7licitud respectiva al model. Per exemple, l'usuari vol veure els clients amb el cognom \u00c1lvarez, la sol\u00b7licitud va al controlador i aquest s'encarrega d'utilitzar el model adequat i retornar aquest model a la vista.</li> </ul> <p>En cap moment la vista interactuar\u00e0 directament amb el model, aix\u00f2 tamb\u00e9 mant\u00e9 la seguretat en una aplicaci\u00f3.</p> <p>L'important d'aquest patr\u00f3 \u00e9s que permet dividir-lo en parts, que s\u00f3n d'alguna manera independents, aix\u00ed que si, per exemple, es fa un canvi en el model, no afectaria la vista o si hi ha un canvi, seria m\u00ednim.</p>"},{"location":"UD5_Spring/3_API_Rest/#22-patro-dto","title":"2.2. Patr\u00f3 DTO.","text":"<p>Amb aquest patr\u00f3, es dissenya una de les capes transversals de l'arquitectura. Soluciona el problema de com permetre a un client intercanviar dades amb el servidor sense fer m\u00faltiples crides demanant cada pe\u00e7a de dada. Per exemple, si tenim una entitat anomenada Persona i una entitat anomenada Adreces, quan demanem les persones i les seves adreces hem de fer m\u00faltiples crides al servidor per demanar les persones i les adreces de cada persona, construint la vista amb aquesta informaci\u00f3.</p> <p>El DTO ho soluciona passant un objecte lleuger al client amb totes les dades necess\u00e0ries, juntes. El client pot llavors fer peticions locals a l'objecte que ha rebut.</p> <p>Per fer aix\u00f2, es creen classes Java que encapsulen les dades en un paquet que es pot transportar per la xarxa (poden implementar <code>java.io.Serializable</code>, tot i que no \u00e9s obligatori), \u00e9s a dir, amb l'exemple anterior, crear\u00edem una classe Java que portaria la persona i les seves adreces, tot junt en el mateix objecte.</p> <p>Aquests objectes s'utilitzen en totes les capes de l'aplicaci\u00f3, de manera que la informaci\u00f3 es porta per totes les capes de l'aplicaci\u00f3. Es recomana omplir sempre tots els camps del DTO per evitar errors de <code>NullPointerException</code> (una cadena buida pot ser millor), fer que els DTO siguin autodescriptius, utilitzar arrays o col\u00b7leccions de DTO quan sigui necessari, i considerar m\u00e8todes que sobreescriguin <code>equals()</code>.</p> <p>Hi ha dues variants de DTO's:</p> <ul> <li>DTOs personalitzats que representen part d'un bean o agrupen m\u00faltiples beans.</li> <li>DTOs de domini anomenats \"entitats\". Una classe de domini no \u00e9s directament accessible pel client, ja que, a causa de la separaci\u00f3 del patr\u00f3 MVC de la vista, les entitats que mapegen la base de dades (que s\u00f3n les entitats) no poden ser accedides. Per aquesta ra\u00f3, es fan c\u00f2pies DTO dels objectes de domini del servidor (entitats). Els clients poden operar sobre c\u00f2pies locals millorant el rendiment de lectura i actualitzaci\u00f3.</li> </ul> <p>Amb tot aix\u00f2, podem resumir que el DTO \u00e9s un patr\u00f3 molt efectiu per transmetre informaci\u00f3 entre un client i un servidor, ja que ens permet crear estructures de dades independents del nostre model de dades (Entitats), cosa que ens permet crear tantes \"vistes\" com sigui necessari. A partir d'un conjunt de taules o fonts de dades. A m\u00e9s, ens permet controlar el format, nom i tipus de dades amb qu\u00e8 transmetem les dades per ajustar-nos a un determinat requisit. Finalment, si per alguna ra\u00f3 el model de dades canvia (i amb ell les entitats) el client no es veur\u00e0 afectat, ja que continuar\u00e0 rebent el mateix DTO.</p> <p>A continuaci\u00f3 veurem com implementar el patr\u00f3 DTO.</p>"},{"location":"UD5_Spring/3_API_Rest/#23-patro-dao","title":"2.3. Patr\u00f3 DAO","text":"<p>El patr\u00f3 Data Access Object (DAO), que permet separar la l\u00f2gica d'acc\u00e9s a dades dels Objectes de Negoci, de tal manera que el DAO encapsula tota la l\u00f2gica d'acc\u00e9s a dades per a la resta de l'aplicaci\u00f3. Aquesta proposta proposa separar completament la l\u00f2gica de negoci de la l\u00f2gica d'acc\u00e9s a dades, d'aquesta manera, el DAO proporcionar\u00e0 els m\u00e8todes necessaris per inserir, actualitzar, eliminar i consultar la informaci\u00f3; d'altra banda, la capa de negoci nom\u00e9s es preocupa per la l\u00f2gica de negoci i utilitza el DAO per interactuar amb la font de dades. En l'exemple que dissenyarem a continuaci\u00f3, veurem com implementar el patr\u00f3 DAO.</p>"},{"location":"UD5_Spring/3_API_Rest/#24-patro-facade-facana","title":"2.4. Patr\u00f3 FACADE (fa\u00e7ana)","text":"<p>El patr\u00f3 de disseny Facade simplifica la complexitat d'un sistema mitjan\u00e7ant una interf\u00edcie m\u00e9s senzilla. Millora l'acc\u00e9s al nostre sistema permetent que altres sistemes o subsistemes utilitzin un punt d'acc\u00e9s com\u00fa que redueix la complexitat, minimitzant les interaccions i depend\u00e8ncies. \u00c9s a dir, crearem una interf\u00edcie Java que tindr\u00e0 els encap\u00e7alaments dels m\u00e8todes com a punt d'acc\u00e9s com\u00fa, mentre que hi haur\u00e0 classes Java que implementaran aquesta interf\u00edcie.</p> <p>Al llarg d'aquest exemple farem \u00fas d'aquest patr\u00f3.</p>"},{"location":"UD5_Spring/3_API_Rest/#3-creacio-del-projecte-i-configuracio-de-hibernate","title":"3. Creaci\u00f3 del projecte i configuraci\u00f3 de Hibernate","text":"<p>En aquesta secci\u00f3 crearem un programa senzill de Hibernate amb Spring, per aplicar tot el que hem estudiat en unitats anteriors amb Spring. Nom\u00e9s hem de crear un nou projecte, seleccionant les depend\u00e8ncies que normalment utilitzem:</p> <p></p> <p>Aix\u00f2 generar\u00e0 un <code>pom.xml</code> amb tot el que necessitem.</p> <p>Necessitem establir els par\u00e0metres que vam establir a <code>hibernate.cfg.xml</code> al fitxer <code>application.properties</code>:</p> Bash<pre><code># puerto de escucha\nserver.port = 8090\n\n# Conexi\u00f3n con la BBDD\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\n\n# Datos del SGBD. REVISAR !!!!\nspring.datasource.url = jdbc:mysql://localhost:3308/AD_UD5_Clientes\nspring.datasource.username = root\nspring.datasource.password = root\n\n\n# configuraci\u00f3n de hibernate (simple)\nspring.jpa.show-sql=true\nspring.jpa.properties.hibernate.format_sql=true\nspring.jpa.properties.hibernate.dialect = org.hibernate.dialect.MySQL5InnoDBDialect\n\n# hbm2DDL. values= none, validate, update, create, and create-drop\nspring.jpa.hibernate.ddl-auto=validate\n\n# import.sql file under src/main/resources/\n# or data.sql or schema.sql\n\n# respetar may\u00fasculas y min\u00fasculas\nspring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl\n</code></pre> <p>Important</p> <p>Totes les opcions d'inicialitzaci\u00f3 de la base de dades es poden trobar a inicialitzaci\u00f3 de la base de dades.</p>"},{"location":"UD5_Spring/3_API_Rest/#31-el-model","title":"3.1. El model.","text":"<p>Anem a utilitzar aquest model per a la nostra pr\u00e0ctica:</p> <p></p> <p>Advert\u00e8ncia</p> <p>Tens un script per crear la base de dades completa enlla\u00e7at ac\u00ed. En aquesta unitat no implementem sobre <code>Movimientos</code>.</p> <p>Per crear el model hem de crear els Beans que vam crear a la unitat 3. Podem utilitzar Lombok per millorar el nostre temps de desenvolupament.</p> <p>Consell</p> <p>Pots marcar un atribut amb l'anotaci\u00f3 de Lombok <code>@ToString.Exclude</code> per evitar que participi en el m\u00e8tode <code>toString</code>, per exemple, per evitar la recursi\u00f3.</p> <p><code>Cliente</code> DAO en el paquet <code>model</code>:</p> Java<pre><code>@Data\n@Entity\n@Table(name = \"clientes\")\npublic class Cliente {\n\n    @Id\n    @GeneratedValue( strategy=GenerationType.IDENTITY)\n    private Long id;\n\n    @Column(name = \"nif\")\n    private String nif;\n\n    @Column(name = \"nombre\")\n    private String nombre;\n    private String apellidos;\n\n    @Column(name = \"claveseguridad\")\n    private String claveSeguridad;\n    private String email;\n\n    @OneToOne(fetch = FetchType.LAZY, \n            cascade =  CascadeType.ALL, \n            mappedBy = \"cliente\")\n    @ToString.Exclude\n    private Recomendacion recomendacion;\n\n    @OneToMany(fetch = FetchType.LAZY, \n            cascade = CascadeType.ALL, \n            mappedBy = \"cliente\")\n    @ToString.Exclude\n    private List&lt;Cuenta&gt; listaCuentas;\n\n  @ManyToMany(fetch = FetchType.EAGER, cascade = {CascadeType.ALL})\n  @JoinTable(name=\"clientesdirecciones\", \n              joinColumns=@JoinColumn(name=\"idcliente\"),\n              inverseJoinColumns=@JoinColumn(name=\"iddireccion\"))\n  @ToString.Exclude\n  private List&lt;Direccion&gt; listaDirecciones;\n</code></pre>"},{"location":"UD5_Spring/3_API_Rest/#32-el-dto","title":"3.2. El DTO","text":"<p>Els DTO's (Data Transfer Object) serveixen per transferir dades en el nostre sistema a trav\u00e9s de transaccions realitzades per les nostres entitats d'una operaci\u00f3 a una altra sense perdre la integritat entre les dades.</p> <p>Per aquesta ra\u00f3, \u00e9s important definir que l'acc\u00e9s a les dades es fa nom\u00e9s a trav\u00e9s de DAO (Data Access Object) del nostre <code>model</code>, obtenint aix\u00ed una abstracci\u00f3 del model de dades. Les dades nom\u00e9s s'accedeixen a trav\u00e9s de m\u00e8todes definits en el <code>DAO</code>. Els DAOs inclouen un altre concepte que \u00e9s el DTO (Data Transfer Object). Els DTO's s\u00f3n una classe d'objectes que serveixen \u00fanicament per transportar dades. El DTO cont\u00e9 les propietats de l'objecte. Dades que poden originar-se a partir d'una o m\u00e9s entitats d'informaci\u00f3.</p> <p>Una altra bona pr\u00e0ctica \u00e9s marcar les classes amb el sufix DTO per recordar el seu significat, aix\u00ed la classe <code>Client</code> es convertiria en <code>ClientDTO</code>.</p> <p>Una de les caracter\u00edstiques dels DTO's \u00e9s que han de ser objectes <code>Serializable</code> per poder viatjar a trav\u00e9s de la xarxa. Necessitem indicar aquesta caracter\u00edstica en els DTO's, aix\u00ed que afegirem que implementin la interf\u00edcie Serializable, i amb aix\u00f2, la propietat <code>UID</code> que identifica la versi\u00f3 de cada objecte transportat.</p> <p>Per crear un DTO crearem una classe amb els atributs que volem que contingui el DTO. Pot ser m\u00e9s o menys que la classe DAO. Despr\u00e9s \u00e9s important crear m\u00e8todes per convertir tant de DAO a DTO com de DTO a DAO. Aquests m\u00e8todes es poden crear de manera est\u00e0tica.</p> Java<pre><code>// Convierte una entidad DAO a un objeto DTO con todos los datos\npublic static ClienteDTO convertToDTO(Cliente cliente) {\n  // Creamos el clienteDTO y asignamos los valores basicos\n  ClienteDTO clienteDTO = new ClienteDTO();\n  clienteDTO.setIdCliente(cliente.getId());\n  clienteDTO.setNif(cliente.getNif());\n  clienteDTO.setNombre(cliente.getNombre());\n  clienteDTO.setApellidos(cliente.getApellidos());\n\n// rest of attributes\n\n  return clienteDTO;\n}       \n\n    // Convierte de un objeto a un entidad\n    public static Cliente convertToEntity(ClienteDTO clientedto) {\n    Cliente  cliente = new Cliente();\n        cliente.setId(clientedto.getIdCliente());\n        cliente.setNif(clientedto.getNif());\n\n    // rest of attributes\n\n    return cliente;\n</code></pre> <p>Com hem dit, evitem accedir a les entitats des de capes superiors.</p> <p>Ampliaci\u00f3</p> <p>Pots cercar a internet informaci\u00f3 sobre <code>ModelMapper</code> per a gestionar els DTO</p>"},{"location":"UD5_Spring/3_API_Rest/#321-convertint-dto-a-json","title":"3.2.1. Convertint DTO a JSON","text":"<p>Com hem dit, aquests objectes (DTO's) es converteixen a JSON autom\u00e0ticament, per\u00f2 com? Spring utilitza Jackson object mapper per transformar objectes a objectes JSON. En aquest tutorial pots entendre millor com funciona.</p> <p>Convertir objectes a JSON pot portar-nos a un altre problema de recursi\u00f3 infinita, quan l'objecte cont\u00e9 refer\u00e8ncies creuades, com els m\u00e8todes <code>toString()</code>. Hem apr\u00e8s com evitar l'excepci\u00f3 <code>StackOverflowException</code> en els m\u00e8todes <code>toString()</code>, utilitzant l'anotaci\u00f3 <code>@ToString.Exclude</code> de Lombok, per\u00f2 com evitar-ho quan es converteix a JSON. La soluci\u00f3 s'ofereix amb noves anotacions, com segueix:</p> <ul> <li><code>@JsonIgnore</code> \u2192 aquest camp no es convertir\u00e0.</li> <li> <p><code>@JsonManagedReference</code> \u2192 indica que mostrarem la informaci\u00f3 d'aquest objecte cap endavant, per\u00f2 no cap enrere. Aquesta anotaci\u00f3 es complementar\u00e0 amb:</p> </li> <li> <p><code>@JsonBackReference</code> \u2192 mostra nom\u00e9s la informaci\u00f3 referenciada, similar a <code>@JsonIgnore</code>.</p> </li> <li><code>@JsonIgnoreProperties(\"property\")</code> \u2192 omet aquesta propietat en el camp anotat.</li> </ul> <p>Si marquem:</p> Java<pre><code>class Director{\n  // own attributes\n\n  @JsonManagedReference\n  Set&lt;Film&gt;\n}\n\nclass Film{\n  // own attributes\n\n  @JsonBackReference\n  Director;\n}\n</code></pre> <p>Mostrarem la informaci\u00f3 de la pel\u00b7l\u00edcula d'un director sense recursi\u00f3 (nom\u00e9s els atributs propis).</p> <p>Podeu trobar m\u00e9s informaci\u00f3 aqu\u00ed.</p>"},{"location":"UD5_Spring/3_API_Rest/#33-el-repositori","title":"3.3. El repositori","text":"<p>La capa de repositori \u00e9s responsable de gestionar l'acc\u00e9s a les dades. Aix\u00f2 fa possible separar la l\u00f2gica de negoci de l'acc\u00e9s a les dades, permetent, per exemple, poder modificar la base de dades del sistema sense afectar la l\u00f2gica.</p> <p>En aquesta capa hem de distingir dos tipus d'acc\u00e9s:</p> <ul> <li>Acc\u00e9s a dades del model de dades propi del sistema que es far\u00e0 a trav\u00e9s de l'acc\u00e9s DAO (Data Access Object). Per a aquest tipus d'acc\u00e9s, utilitzarem el framework JPA (Java Persistence API) a trav\u00e9s de Spring Data.</li> <li>Acc\u00e9s a sistemes externs a trav\u00e9s de connectors (webservices, APIs, etc.)</li> </ul> <p>Per aquesta ra\u00f3, crearem una interf\u00edcie en la qual tindrem les operacions que exposarem. Aquesta interf\u00edcie ser\u00e0 <code>ClientRepository.java</code> i es crear\u00e0 en el paquet <code>repository</code>.</p> <p>Amb Spring, estalviarem molta feina, ja que simplement definirem una interf\u00edcie de treball, en la qual indicarem el tipus de repositori que volem crear, la classe sobre la qual treballar\u00e0 i el tipus de dades que funciona com a identificador d'aquesta classe:</p> <p>Spring proporciona la Repository Interface, de la qual hereta <code>CrudRepository</code>, que inclou la definici\u00f3 de les operacions b\u00e0siques CRUD. D'aquest \u00faltim hereta <code>PagingAndSortingRepository</code>, que afegeix funcions de paginaci\u00f3 i ordenaci\u00f3, i finalment tenim <code>JPARepository</code>, que inclou operacions espec\u00edfiques per a JPA.</p> <p>La import\u00e0ncia de la definici\u00f3 gen\u00e8rica de <code>Repository&lt;Class,Type&gt;</code> \u00e9s que tots els objectes que recuperar\u00e0 s\u00f3n d'aquesta classe, i el tipus indica el tipus de la clau prim\u00e0ria d'aquesta classe. Seguint el nostre exemple, la definici\u00f3 del repositori seria:</p> Java<pre><code>@Repository\n@Transactional\npublic interface ClienteRepository extends JpaRepository&lt;Cliente, Long&gt; {\n\n}\n</code></pre> <p>Amb aix\u00f2, Spring ja ens permet accedir a la base de dades i realitzar operacions b\u00e0siques. Els seg\u00fcents m\u00e8todes estan implementats per defecte, i no necessitarem implementar-los, nom\u00e9s definir-los:</p> <ul> <li>Recuperar dades:</li> <li><code>findAll()</code>, <code>findById(Id)</code>, <code>findById(Iterable&lt;Id&gt;)</code>: recupera una o totes les ocurr\u00e8ncies d'un identificador o una col\u00b7lecci\u00f3 d'identificadors.</li> <li>Eliminar dades:</li> <li><code>delete(Object)</code>, <code>deleteAll()</code>, <code>deleteById(Id)</code>, <code>deleteAllById(Iterable&lt;Id&gt;)</code>: elimina per objecte, identificador o tots.</li> <li>comptar i comprovar:</li> <li><code>count()</code>, <code>existsById()</code></li> <li>guardar objectes:</li> <li><code>save(Object)</code>, <code>save(Iterable&lt;Object&gt;)</code>: guarda l'objecte(s)</li> </ul> <p>Consell</p> <p>Si necessitem un altre m\u00e8tode, l'hem de definir, i despr\u00e9s crear una nova classe per implementar aquesta interf\u00edcie i implementar el m\u00e8tode.</p>"},{"location":"UD5_Spring/3_API_Rest/#34-el-servei","title":"3.4. El servei","text":"<p>La capa de servei gestiona la l\u00f2gica de negoci de la nostra aplicaci\u00f3. Aquesta l\u00f2gica de negoci est\u00e0 separada de la l\u00f2gica web, que es troba en el controlador.</p> <p>Quan definim classes que implementen serveis per a la l\u00f2gica de negoci, s'han de seguir les seg\u00fcents regles:</p> <ol> <li>Definir una interf\u00edcie que tindr\u00e0 els encap\u00e7alaments dels m\u00e8todes que es volen publicar. D'aquesta manera fem \u00fas del patr\u00f3 Facade i exposem els m\u00e8todes del servei per a ser utilitzats.</li> <li>Definim una classe (tingueu en compte que una interf\u00edcie pot tenir diverses classes que la implementin) que implementi la interf\u00edcie, de manera que puguem implementar tots els m\u00e8todes del servei seguint la l\u00f2gica de negoci requerida.</li> <li>L'anotaci\u00f3 <code>@Service</code> indica a Spring que reconegui la classe com un servei (similar a l'anotaci\u00f3 <code>@Controller</code> que hem estudiat en la secci\u00f3 anterior).</li> <li>Utilitzarem <code>@Autowired</code> per injectar el servei en el controlador (ho veurem m\u00e9s endavant).</li> <li>Utilitzarem <code>@Autowired</code> per injectar el DAO amb el qual treballarem en el servei.</li> <li>Tingueu en compte que un m\u00e8tode de servei definir\u00e0 una operaci\u00f3 a nivell de negoci, per exemple, donar un missatge de benvinguda. Els m\u00e8todes de servei estaran compostos per altres operacions m\u00e9s petites, que es definiran en la capa de repositori.</li> </ol> <p>Amb tot aix\u00f2, comen\u00e7arem a definir la capa de servei. Aix\u00ed que comencem creant una interf\u00edcie anomenada <code>ClientService.java</code> en el paquet <code>service</code>.</p> Java<pre><code>public interface ClienteService {\n\n    void saveCliente(ClienteDTO clienteDTO);\n    ClienteDTO getClienteById(Long id);\n    List&lt;ClienteDTO&gt; listAllClientes();\n    void deleteCliente(Long id);\n\n}\n</code></pre> <p>Notem que en aquest cas definim 4 operacions b\u00e0siques amb <code>ClienteDTO</code>, ja que s\u00f3n els objectes que gestionar\u00e0 el controlador.</p> <p>Un cop tenim la interf\u00edcie, creem una nova classe anomenada <code>ClientServiceImpl.java</code>, que s'encarregar\u00e0 d'implementar els m\u00e8todes que es declaren a la interf\u00edcie. Despr\u00e9s, fem que la nova classe implemente la interf\u00edcie creada i despr\u00e9s fem que implementi tots els m\u00e8todes de la interf\u00edcie per defecte. Tamb\u00e9 indiquem l'anotaci\u00f3 <code>@Service</code> a la classe. Ser\u00e0 com segueix:</p> Java<pre><code>@Service\npublic class ClienteServiceImpl implements ClienteService{\n\n    @Autowired\n    private ClienteRepository clienteRepository;\n\n    @Override\n    public void saveCliente(ClienteDTO clienteDTO) {\n        Cliente cliente = ClienteDTO.convertToEntity(clienteDTO);\n        clienteRepository.save(cliente);\n    }\n\n    @Override\n    public ClienteDTO getClienteById(Long id) {\n        Optional&lt;Cliente&gt; cliente = clienteRepository.findById(id);\n        if(cliente.isPresent()) {\n            return ClienteDTO.convertToDTO(cliente.get());\n        }else {\n            return null;            \n        }\n    }\n\n    @Override\n    public List&lt;ClienteDTO&gt; listAllClientes() {\n        List&lt;Cliente&gt; lista = clienteRepository.findAll();\n        List&lt;ClienteDTO&gt; listaResultado = new ArrayList&lt;ClienteDTO&gt;();\n        for (int i = 0; i &lt; lista.size(); ++i) {\n            listaResultado.add(ClienteDTO.convertToDTO(lista.get(i)));\n        }\n        return listaResultado;\n    }\n\n    @Override\n    public void deleteCliente(Long id) {\n        clienteRepository.deleteById(id);\n    }\n}\n</code></pre> <p>Com podeu veure, el servei s'encarrega d'invocar els m\u00e8todes del repositori i de realitzar algunes comprovacions si \u00e9s necessari. A m\u00e9s, obtenim objectes <code>Cliente</code> i els transformem en <code>ClienteDTO</code> per utilitzar-los per retornar al controlador.</p> <p>Important</p> <p>El m\u00e8tode <code>findClienteById()</code> retorna una nova classe envoltori (wrapper &lt;&gt;) <code>Optional&lt;Cliente&gt;</code>. Aquesta classe encapsula un Objecte que existir\u00e0 o no, proporcionant m\u00e8todes per comprovar-ho i actuar en conseq\u00fc\u00e8ncia:</p> <ul> <li><code>isPresent()</code> \u2192 retorna un boole\u00e0.</li> <li><code>orElse(anotherObject)</code> \u2192 si no existeix, retorna un altre Objecte en lloc de l'Optional.</li> <li><code>get()</code> \u2192 retorna l'objecte existent.</li> </ul> <p>L'objectiu principal \u00e9s evitar la famosa <code>NullPointerException</code>. Podeu trobar m\u00e9s informaci\u00f3 aqu\u00ed</p>"},{"location":"UD5_Spring/3_API_Rest/#35-el-controlador","title":"3.5. El controlador","text":"<p>Ara definirem la capa de m\u00e9s alt nivell, la capa de controladors, on exposarem els serveis de l'aplicaci\u00f3.</p> <p>El controlador ser\u00e0 l'encarregat de respondre a les sol\u00b7licituds dels usuaris amb l'aplicaci\u00f3. Inclour\u00e0 els serveis, i en cas de crear una aplicaci\u00f3 MVC, podr\u00e0 invocar motors de plantilles, com Thymeleaf. Com hem comentat aqu\u00ed, ho implementarem en una sola classe (sense seguir el patr\u00f3 anterior).</p> <p>El controlador invocar\u00e0 el servei associat a aquesta sol\u00b7licitud i retornar\u00e0 les dades obtingudes o la resposta al mateix client. Hem de marcar la classe amb l'estereotip <code>@Controller</code>. En el cas dels serveis REST, tamb\u00e9 hem d'indicar que els retorns dels m\u00e8todes de la classe es serialitzen a JSON, i ho aconseguim amb <code>@ResponseBody</code>. Des de Spring 4, les dues anotacions s'han fusionat en una, mitjan\u00e7ant <code>@RestController</code>. Nom\u00e9s deixarem <code>@Controller</code> per a projectes on retornem una vista (HTML + CSS + JS).</p> <p>El servei que crearem tindr\u00e0 un comportament complet pel que fa al manteniment de <code>Cliente</code>, aix\u00ed com la seva recomanaci\u00f3, de manera que podrem llistar clients, veure la seva informaci\u00f3, registrar clients, actualitzar dades de clients i eliminar clients, o ser les operacions CRUD que es coneixen.</p> <p>Aix\u00ed que comen\u00e7arem creant un controlador anomenat <code>ClienteController.java</code>. Aquest controlador implementar\u00e0 les 4 operacions corresponents a CRUD: crear, llegir, actualitzar i eliminar. A part d'aquestes 4, crearem una operaci\u00f3 que mostrar\u00e0 la p\u00e0gina inicial de l'aplicaci\u00f3, amb un enlla\u00e7 al manteniment de clients.</p> Java<pre><code>@RestController\npublic class ClienteController {\n\n    @Autowired\n    private ClienteService clienteService;\n\n  // mapping the requests. One method per route/request\n</code></pre> <p>El controlador normalment defineix quatre operacions CRUD, per\u00f2 podem afegir totes les que necessitem. Vegem-ho.</p>"},{"location":"UD5_Spring/3_API_Rest/#351-index","title":"3.5.1. Index","text":"<p>Aquest m\u00e8tode mapatge l'\u00edndex arrel de la nostra aplicaci\u00f3 web. Per exemple, podem enviar el nom de l'aplicaci\u00f3 i el m\u00f2dul. Aquestes variables es poden definir en el nostre <code>application.properties</code> i es poden carregar amb l'anotaci\u00f3 <code>@Value</code> i una cadena <code>${property_name}</code> dins.</p> Java<pre><code>@Autowired\n    private HttpServletRequest context;\n\n    @Value(\"${app.name}\")\n    private String appName;\n\n    @Value(\"${developer.name}\")\n    private String devName;\n</code></pre> <p>El controlador d'\u00edndex normalment mostra informaci\u00f3 general sobre la p\u00e0gina principal, com segueix:</p> Java<pre><code>@GetMapping(\"/\")\npublic String index() {\n  String res=\"Hello from Spring\\n\";\n  res+=\"You are running \" +appName+\"\\n\";\n  res+=\"Developed by \" +devName;\n  return res;\n}\n</code></pre>"},{"location":"UD5_Spring/3_API_Rest/#4-operacions-de-lectura-get","title":"4. Operacions de lectura (GET)","text":"<p>\u00c9s hora de recuperar dades del nostre servidor, i normalment les operacions <code>GET</code> s\u00f3n els m\u00e8todes m\u00e9s demandats. Implementarem diversos m\u00e8todes que podrien retornar un o molts objectes de la classe desitjada, en les nostres notes, la classe <code>Cliente</code>.</p>"},{"location":"UD5_Spring/3_API_Rest/#41-obtenir-tots","title":"4.1. Obtenir tots","text":"<p>No es necessita cap opci\u00f3 de filtre, perqu\u00e8 volem obtenir tots els clients. Quan rebem aquesta sol\u00b7licitud get, hem de cridar al m\u00e8tode <code>listAll</code> en el nostre servei, que crida, de fet, a <code>findAll</code> en el nostre repositori.</p> Java<pre><code>@GetMapping(\"/clientes\")\n  public List&lt;ClienteDTO&gt; listClientes(){\n    myLog.info(context.getMethod() + \" from \" + context.getRemoteHost());\n    List&lt;ClienteDTO&gt; losClientes=clienteService.listAllClientes();\n    return losClientes;\n} \n</code></pre> <p>A part del missatge de registre, simplement recuperem les dades del servei i les retornem a la resposta.</p>"},{"location":"UD5_Spring/3_API_Rest/#42-obtenir-un","title":"4.2. Obtenir Un","text":"<p>Aquesta \u00e9s la versi\u00f3 m\u00e9s espec\u00edfica, i normalment en la sol\u00b7licitud busquem un objecte a partir del seu ID. Llavors, hem d'obtenir un par\u00e0metre en la nostra sol\u00b7licitud, i utilitzarem l'ID en el cam\u00ed, utilitzant l'anotaci\u00f3 <code>@PathVariable</code>.</p> Java<pre><code>@GetMapping(\"/clientes/{idCliente}\")\npublic ClienteDTO showClienteById(@PathVariable Long idCliente){\n  myLog.info(context.getMethod() + \" from \" + context.getRemoteHost());\n  ClienteDTO elCliente=clienteService.getClienteById(idCliente);\n  return elCliente;\n} \n</code></pre> <p>La sol\u00b7licitud ser\u00e0 <code>/clientes/7</code>, per exemple, i llavors, en el nostre m\u00e8tode del controlador, el par\u00e0metre <code>idCliente</code> es configurar\u00e0 amb el valor 7. Cridem <code>getClienteById(7)</code> i, \u00f2bviament, obtenim el <code>ClienteDTO</code> encapsulant el <code>Cliente</code> sol\u00b7licitat, si existeix.</p> <p>Podem millorar els m\u00e8todes per al cas que no hi hagi resultats (<code>Cliente</code> no existeix) o s'hagi produ\u00eft un error, retornant i encapsulant els resultats en un <code>ResponseEntity&lt;Cliente&gt;</code>. Aquesta classe envoltori retorna el resultat a la sol\u00b7licitud, per\u00f2 permet afegir un argument que ser\u00e0 el codi d'estat http. Aquest codi pot ser capturat a l'aplicaci\u00f3 client per al maneig d'errors. L'algoritme ser\u00e0 alguna cosa aix\u00ed:</p> Java<pre><code>public ResponseEntity&lt;results&gt;controllerMethod(){\n  // collect the data from the service/repository\n  if(!mistake) {\n    return new ResponseEntity&lt;&gt;(Results,HttpStatus.OK); // ALL GOOD\n  }\n    return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND); // SOMETHING IS WRONG\n  }\n</code></pre> <p>aplicat a la nostra aplicaci\u00f3 d'exemple, i fusionant els dos \u00faltims exemples de codi, obtindrem el seg\u00fcent:</p> Java<pre><code>@GetMapping(\"/clientes/{idCliente}\")\npublic ResponseEntity&lt;ClienteDTO&gt; showClienteById(@PathVariable Long idCliente){\n  myLog.info(context.getMethod() + context.getRequestURI() + \" from \" + context.getRemoteHost());\n  ClienteDTO elCliente=clienteService.getClienteById(idCliente);\n  if (elCliente==null)\n    return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND);\n  else\n    return new ResponseEntity&lt;&gt;(elCliente,HttpStatus.OK);\n} \n</code></pre>"},{"location":"UD5_Spring/3_API_Rest/#43-gestio-dexcepcions","title":"4.3. Gesti\u00f3 d'excepcions","text":"<p>El controlador gestiona diverses excepcions, i el programa continua executant-se tret que es produeixi un gran error. Ara presentem un m\u00e8tode que donar\u00e0 una resposta quan es produeixi una excepci\u00f3. Anotarem aquest m\u00e8tode amb <code>@ExceptionHandler</code>, passant la classe d'excepci\u00f3 que hem de capturar.</p> Java<pre><code>@ExceptionHandler(MethodArgumentTypeMismatchException.class)\npublic ResponseEntity&lt;String&gt; handleError(MethodArgumentTypeMismatchException e) {\n  myLog.warn(\"Method Argument Type Mismatch\", e);\n  String message = String.format(\"Method Argument Type Mismatch: %s\", e.getName());\n  return new ResponseEntity&lt;&gt;(message,HttpStatus.BAD_REQUEST);\n}\n</code></pre> <p>We can handle several exceptions in one unique method, marking it with a collection of exceptions, for instance as:</p> Java<pre><code>@ExceptionHandler({\n    MissingServletRequestParameterException.class,\n    MethodArgumentTypeMismatchException.class,\n    InvalidStreamDefinitionException.class\n})\npublic ResponseEntity&lt;String&gt; handleError(Exception e) {\n  // method body\n} \n\n// i aquest quan no es troba una entrada al controlador\n@ExceptionHandler(NoHandlerFoundException.class)\npublic ResponseEntity&lt;Map&lt;String, Object&gt;&gt; handleNotFoundError(NoHandlerFoundException ex) {\n    Map&lt;String, Object&gt; response = new HashMap&lt;&gt;();\n    response.put(\"error\", \"404 Not Found\");\n    response.put(\"message\", \"El recurso solicitado no existe.\");\n    response.put(\"path\", ex.getRequestURL());\n\n    return new ResponseEntity&lt;&gt;(response, HttpStatus.NOT_FOUND);\n}\n</code></pre>"},{"location":"UD5_Spring/3_API_Rest/#5-operacions-de-guardat-post","title":"5. Operacions de guardat (POST)","text":"<p>La primera operaci\u00f3 que necessitem fer \u00e9s guardar un nou <code>Cliente</code> a la nostra base de dades. Anem a explicar-ho amb un exemple. El controlador rebr\u00e0 un nou objecte DTO enviat per l'aplicaci\u00f3 client (utilitzarem Postman, com es pot veure a l'Ap\u00e8ndix 1):</p> Java<pre><code>//@PostMapping(value=\"/clientes\",consumes={\"application/json\"})\n@PostMapping(\"/clientes\")\npublic ResponseEntity&lt;ClienteDTO&gt; addDirector(@RequestBody ClienteDTO newCliente) { \n  myLog.info(context.getMethod() + context.getRequestURI()); \n  ClienteDTO elCliente= clienteService.saveCliente(newCliente);\n    if (elCliente==null)\n      return new ResponseEntity&lt;&gt;(HttpStatus.BAD_REQUEST);\n    else\n    return new ResponseEntity&lt;&gt;(elCliente,HttpStatus.OK);\n}\n</code></pre> <p>tingues en compte que:</p> <ul> <li>La sol\u00b7licitud est\u00e0 mapejada amb <code>@PostMapping</code>. Aqu\u00ed tens un comentari amb opcions addicionals.</li> <li>L'objecte rebut per l'aplicaci\u00f3 est\u00e0 dins d'un objecte JSON en el cos de la sol\u00b7licitud, marcat com <code>@RequestBody</code>. En aquesta unitat suposarem que les dades arriben ben formatejades.</li> <li>Les dades rebudes es passen al servei i es retorna un nou <code>Cliente</code> (emmagatzemat).</li> <li>Aquest client es retorna al client.</li> </ul> <p>En aquesta imatge pots veure les dades enviades a l'API i el valor retornat. Tingues en compte que <code>Cuentas</code> i <code>Direcciones</code> no estan presents en aquestes dades. Veurem m\u00e9s endavant com afegir aquestes dades addicionals.</p> <p></p> <p>Advert\u00e8ncia</p> <p>Hi ha moltes validacions a fer per verificar la integritat de les dades. Aqu\u00ed pots trobar un article sobre com validar les dades rebudes de les aplicacions client.</p>"},{"location":"UD5_Spring/3_API_Rest/#6-operacions-dactualitzacio-put","title":"6. Operacions d'actualitzaci\u00f3 (PUT)","text":"<p>Per actualitzar un objecte de la base de dades, necessitem rebre l'objecte actualitzat (i complet) en la sol\u00b7licitud. No podem guardar-lo immediatament, perqu\u00e8 podria no existir. Per aquesta ra\u00f3, hem de comprovar l'exist\u00e8ncia, i si aquesta \u00e9s positiva, llavors guardem l'objecte rebut, que actualitzar\u00e0 la versi\u00f3 anterior a la base de dades. Vegem l'exemple:</p> Java<pre><code>@PutMapping(\"/clientes\")\npublic ResponseEntity&lt;ClienteDTO&gt; updateCliente(@RequestBody ClienteDTO updCliente) {   \n  myLog.info(context.getMethod() + context.getRequestURI());\n  // busquem si existeix pr\u00e8viament\n  ClienteDTO elCliente= clienteService.getClienteById(updCliente.getIdCliente());\n    if (elCliente==null)\n      return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND);\n    else {\n    // com ja sabem que existeix, save actualitza\n    ClienteDTO elClienteUPD= clienteService.saveCliente(updCliente);\n    return new ResponseEntity&lt;&gt;(elClienteUPD,HttpStatus.OK);\n    }\n}\n</code></pre>"},{"location":"UD5_Spring/3_API_Rest/#7-operacions-deliminacio-delete","title":"7. Operacions d'eliminaci\u00f3 (DELETE)","text":"<p>Eliminar \u00e9s una operaci\u00f3 molt senzilla, perqu\u00e8 nom\u00e9s necessitem l'identificador de l'objecte que volem eliminar, i despr\u00e9s el podem obtenir del cam\u00ed, dins de la variable de cam\u00ed. Llavors, hem de cridar l'operaci\u00f3 d'eliminaci\u00f3 del servei.</p> Java<pre><code>@DeleteMapping(\"/clientes/{idCliente}\")\npublic ResponseEntity&lt;String&gt; deleteCliente(@PathVariable Long idCliente){\n  clienteService.deleteCliente(idCliente);\n  return new ResponseEntity&lt;&gt;(\"Cliente borrado satisfactoriamente\", HttpStatus.OK);\n}\n</code></pre>"},{"location":"UD5_Spring/3_API_Rest/#8-exercici-completa-el-servidor","title":"8. Exercici. Completa el servidor","text":"<p>Hem acabat de crear el nostre controlador sobre la classe <code>Cliente</code>, per\u00f2 podem millorar la nostra aplicaci\u00f3 afegint m\u00e9s serveis i configuracions al servidor. Aquests conceptes s'estudiaran en les seg\u00fcents seccions.</p> <p>Recomanem completar el controlador, serveis i repositoris de <code>Cuenta</code> i <code>Direccion</code> amb operacions per defecte.</p> <p>A m\u00e9s, pots afegir opcions per afegir una <code>Cuenta</code> a un <code>Cliente</code> o eliminar-la, i el mateix amb <code>Direccion</code>.</p>"},{"location":"UD5_Spring/4_Spring_Security/","title":"4. Seguretat","text":""},{"location":"UD5_Spring/4_Spring_Security/#1-https","title":"1. HTTPS","text":"<p>Avui en dia, necessitem afegir tot el que puguem per assegurar les nostres aplicacions. Estudiarem el concepte de tokens per autoritzar i autenticar les nostres sol\u00b7licituds, per\u00f2 necessitem una capa extra, https.</p> <p>En aquesta p\u00e0gina web https://tiptopsecurity.com/how-does-https-work-rsa-encryption-explained/ podeu trobar com funciona https.</p>"},{"location":"UD5_Spring/4_Spring_Security/#11-certificat","title":"1.1. Certificat","text":"<p>Primerament, necessitem generar certificats, o comprar-los. Utilitzarem l'eina <code>keytool</code> inclosa amb el kit de desenvolupament de Java per generar-los. Aquesta comanda genera un parell de certificats (p\u00fablic i privat).</p> Bash<pre><code>keytool -genkeypair -alias joange -keyalg RSA -keysize 2048\n-storetype PKCS12 -keystore jgce.p12 -validity 3650\n</code></pre> <p>Despr\u00e9s d'executar aquesta comanda, hem de respondre sobre qui som, de la seg\u00fcent manera:</p> <p></p>"},{"location":"UD5_Spring/4_Spring_Security/#12-configurar-spring","title":"1.2. Configurar Spring","text":"<p>Un cop finalitzat el proc\u00e9s, hem d'afegir el certificat dins del nostre projecte. Per exemple, dins de <code>/resources/keystore</code>. Finalment, hem de carregar el certificat i habilitar SSL, simplement afegint aquestes l\u00ednies a <code>application.properties</code>:</p> Bash<pre><code># The format used for the keystore.\nserver.ssl.key-store-type=PKCS12\n# The path to the keystore containing the certificate\nserver.ssl.key-store=classpath:keystore/jgce.p12\n# The password used to generate the certificate\nserver.ssl.key-store-password=joangeca\n# The alias mapped to the certificate\nserver.ssl.key-alias=joange\n\n# Use HTTPS instead of HTTP\nserver.ssl.enabled=true\n</code></pre> <p></p> <p>I aix\u00f2 \u00e9s tot, quan Spring comenci veurem que est\u00e0 funcionant amb el protocol <code>https</code>:</p> Bash<pre><code>2023-01-13 08:29:37.267  INFO 83291 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 9091 (https)\n</code></pre> <p></p> <p>i en la sol\u00b7licitud probablement els navegadors no confiaran en el nostre certificat (haurem d'afegir una excepci\u00f3 de confian\u00e7a):</p> <p></p>"},{"location":"UD5_Spring/4_Spring_Security/#2-spring-security","title":"2. Spring Security","text":"<p>Spring Security \u00e9s un projecte paraigua que agrupa tots els mecanismes referents a la seguretat. Necessitem afegir:</p> XML<pre><code>&lt;dependency&gt;\n&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n&lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; \n&lt;/dependency&gt;\n</code></pre> <p>i autom\u00e0gicament:</p> <ul> <li>La configuraci\u00f3 per defecte est\u00e0 habilitada, a trav\u00e9s d'un filtre, anomenat <code>SpringSecurityFilterChain</code>.</li> <li>Es crea un bean de tipus <code>UserDetailsService</code> amb un usuari anomenat <code>user</code> i una contrasenya aleat\u00f2ria que es mostra per la consola.</li> <li>El filtre es registra en el contenidor de servlets per a totes les sol\u00b7licituds.</li> </ul> <p>Encara que no has configurat gaire, t\u00e9 moltes conseq\u00fc\u00e8ncies:</p> <ul> <li>Requereix autenticaci\u00f3 per interactuar amb la nostra aplicaci\u00f3</li> <li>Genera un formulari de login per defecte.</li> <li>Genera un mecanisme de logout</li> <li>Protegeix l'emmagatzematge de contrasenyes amb <code>BCrypt</code>.</li> <li>Proporciona protecci\u00f3 contra atacs CSRF, Fixaci\u00f3 de Sessi\u00f3, Clickjacking...</li> </ul> <p>Podem crear una classe de configuraci\u00f3, amb aquest contingut:</p> Java<pre><code>@Configuration\npublic class SecurityConfig {\n\n}\n</code></pre> <p>Atenci\u00f3</p> <p>Tornarem a aquesta classe per afegir m\u00e9s configuracions. El m\u00e9s interessant \u00e9s el m\u00e8tode <code>configure</code> i la creaci\u00f3 de diversos Beans utilitzats per altres classes.</p>"},{"location":"UD5_Spring/4_Spring_Security/#21-dades-dusuaris-per-a-autenticacio-i-autoritzacio-models","title":"2.1. Dades d'Usuaris per a Autenticaci\u00f3 i Autoritzaci\u00f3 (Models)","text":"<p>Important</p> <p>A partir d'ara, aquest exemple es basa en una p\u00e0gina web famosa https://www.bezkoder.com. Expliquem tot el necessari de l'exemple que podeu veure aqu\u00ed.</p> <p>En aquesta secci\u00f3 prepararem la nostra aplicaci\u00f3 per identificar usuaris amb diversos rols. Amb aquests rols, podrem concedir o no acc\u00e9s a diversos recursos.</p>"},{"location":"UD5_Spring/4_Spring_Security/#22-usuaris-rols","title":"2.2. Usuaris &amp; Rols","text":"<p>Per fer aix\u00f2, necessitem crear una classe <code>User</code>, per emmagatzemar aquesta informaci\u00f3 a la nostra base de dades. Aquest usuari podria tenir una col\u00b7lecci\u00f3 de rols. Podem fer-ho amb una relaci\u00f3 de molts a molts.</p> Java<pre><code>public enum ERole {\n  ROLE_USER,\n  ROLE_MODERATOR,\n  ROLE_ADMIN\n}\n</code></pre> <p>basat en aquesta enumeraci\u00f3, farem una classe <code>Role</code> per emmagatzemar els rols que la nostra aplicaci\u00f3 suportar\u00e0:</p> Java<pre><code>@Data\n@Entity\n@Table(name = \"roles\")\npublic class Role {\n  private Integer id;\n  private ERole name;\n}\n</code></pre> <p>finalment, una classe <code>User</code> com la seg\u00fcent. Afegim noves anotacions de validaci\u00f3:</p> Java<pre><code>@Entity\n@Table(name = \"users\", \n    uniqueConstraints = { \n      @UniqueConstraint(columnNames = \"username\"),\n      @UniqueConstraint(columnNames = \"email\") \n    })\npublic class User {\n  @Id\n  @GeneratedValue(strategy = GenerationType.IDENTITY)\n  private Long id;\n\n  @NotBlank\n  @Size(max = 20)\n  private String username;\n\n  @NotBlank\n  @Size(max = 50)\n  @Email\n  private String email;\n\n  @NotBlank\n  @Size(max = 120)\n  private String password;\n\n  @ManyToMany(fetch = FetchType.LAZY)\n  @JoinTable( name = \"user_roles\", \n        joinColumns = @JoinColumn(name = \"user_id\"), \n        inverseJoinColumns = @JoinColumn(name = \"role_id\"))\n  private Set&lt;Role&gt; roles = new HashSet&lt;&gt;();\n\n  public User() {\n  }\n\n  public User(String username, String email, String password) {\n    this.username = username;\n    this.email = email;\n    this.password = password;\n  }\n\n}\n</code></pre>"},{"location":"UD5_Spring/4_Spring_Security/#23-repositori-dusuaris-i-rols","title":"2.3. Repositori d'Usuaris i Rols","text":"<p>Necessitem crear els nostres repositoris per a les \u00faltimes entitats, creant interf\u00edcies com normalment fem.</p> Java<pre><code>@Repository\npublic interface RoleRepository extends JpaRepository&lt;Role, Long&gt; {\n  Optional&lt;Role&gt; findByName(ERole name);\n}\n\n@Repository\npublic interface UserRepository extends JpaRepository&lt;User, Long&gt; {\n  Optional&lt;User&gt; findByUsername(String username);\n\n  Boolean existsByUsername(String username);\n\n  Boolean existsByEmail(String email);\n}\n</code></pre> <p>Tamb\u00e9 afegim m\u00e8todes per comprovar l'exist\u00e8ncia de l'usuari per nom i correu electr\u00f2nic, i m\u00e8todes per trobar per nom, tant <code>User</code> com <code>Role</code>.</p>"},{"location":"UD5_Spring/4_Spring_Security/#24-userdetails","title":"2.4. UserDetails","text":"<p>Spring necessita que alg\u00fa implementi la interf\u00edcie <code>UserDetails</code>, molt important perqu\u00e8 Spring Security utilitzar\u00e0 un <code>UserDetails</code>. <code>UserDetails</code> cont\u00e9 la informaci\u00f3 necess\u00e0ria per construir un objecte <code>Authentication</code> a partir de DAOs o altres fonts de dades de seguretat. Creem una classe, anomenada <code>UserDetailsImpl</code>, que:</p> <ul> <li>Ha de tenir els camps <code>username</code> i <code>password</code>, i els getters. Heu de respectar els noms, qualsevol canvi est\u00e0 prohibit. Aquests m\u00e8todes seran utilitzats per les classes d'autenticaci\u00f3.</li> <li>Sobreescriure m\u00e8todes de <code>UserDetails</code>, per exemple <code>getAuthorities()</code> i diversos m\u00e8todes per controlar si l'usuari est\u00e0 bloquejat, caducat, etc.</li> </ul> <p>Classe completa:</p> Java<pre><code>public class UserDetailsImpl implements UserDetails {\n  private static final long serialVersionUID = 1L;\n\n  private Long id;\n  private String username;\n  private String email;\n\n  @JsonIgnore\n  private String password;\n\n  private Collection&lt;? extends GrantedAuthority&gt; authorities;\n\n  public UserDetailsImpl(Long id, String username, String email, String password,\n      Collection&lt;? extends GrantedAuthority&gt; authorities) {\n    this.id = id;\n    this.username = username;\n    this.email = email;\n    this.password = password;\n    this.authorities = authorities;\n  }\n\n  public static UserDetailsImpl build(User user) {\n    List&lt;GrantedAuthority&gt; authorities = user.getRoles().stream()\n        .map(role -&gt; new SimpleGrantedAuthority(role.getName().name()))\n        .collect(Collectors.toList());\n\n    return new UserDetailsImpl(\n        user.getId(), \n        user.getUsername(), \n        user.getEmail(),\n        user.getPassword(), \n        authorities);\n  }\n\n  @Override\n  public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() {\n    return authorities;\n  }\n\n\n  @Override\n  public boolean isAccountNonExpired() {\n    return true;\n  }\n\n  @Override\n  public boolean isAccountNonLocked() {\n    return true;\n  }\n\n  @Override\n  public boolean isCredentialsNonExpired() {\n    return true;\n  }\n\n  @Override\n  public boolean isEnabled() {\n    return true;\n  }\n\n}\n</code></pre> <p>Tingues en compte que:</p> <ul> <li>Utilitzem <code>private Collection&lt;? extends GrantedAuthority&gt; authorities;</code> per emmagatzemar les autoritats (\u00e9s a dir, rols) en un format que \u00e9s ent\u00e8s per Spring Security.</li> <li>En lloc de crear un constructor, creem un <code>builder()</code>, que rep un <code>User</code>, extreu la informaci\u00f3 d'aquest i transforma la <code>List&lt;Role&gt;</code> en autoritats, i despr\u00e9s, el builder crida al constructor.</li> </ul> <p>En lloc de crear un <code>User</code> i <code>Role</code> <code>Service</code>, crearem un <code>UserDetailSeriveImpl</code> (que implementa <code>UserDetailService</code> de Spring), per tal de recuperar un <code>User</code> del repositori, i despr\u00e9s retorna un <code>UserDetailImpl</code>, de la seg\u00fcent manera:</p> Java<pre><code>@Service\npublic class UserDetailsServiceImpl implements UserDetailsService {\n  @Autowired\n  UserRepository userRepository;\n\n  @Override\n  @Transactional\n  public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n    User user = userRepository.findByUsername(username)\n        .orElseThrow(() -&gt; new UsernameNotFoundException(\"User Not Found with username: \" + username));\n\n    return UserDetailsImpl.build(user);\n  }\n\n}\n</code></pre>"},{"location":"UD5_Spring/4_Spring_Security/#25-carregues-de-dtos","title":"2.5. C\u00e0rregues de DTO's","text":"<p>En aquesta secci\u00f3 veurem les classes necess\u00e0ries que emmagatzemen informaci\u00f3 per a:</p> <ul> <li>Registrar un nou usuari, per rebre informaci\u00f3 del client i emmagatzemar un nou usuari. Aquesta classe \u00e9s <code>SignupRequest</code>.</li> <li>Iniciar sessi\u00f3 d'un usuari, per accedir al nostre sistema. Aquesta classe \u00e9s <code>LoginRequest</code>.</li> <li><code>JwtResponse</code>, relacionada com a resposta a la sol\u00b7licitud d'inici de sessi\u00f3. Aquesta resposta contindr\u00e0 un Token JWT, utilitzat per autoritzar sol\u00b7licituds posteriors. Aquesta classe \u00e9s <code>JwtResponse</code>.</li> </ul>"},{"location":"UD5_Spring/4_Spring_Security/#26-signuprequest","title":"2.6. SignupRequest","text":"<p>Aquesta classe cont\u00e9 informaci\u00f3 per registrar un nou usuari. Cont\u00e9 anotacions de validaci\u00f3.</p> <p>Java<pre><code>public class SignupRequest {\n  @NotBlank\n  @Size(min = 3, max = 20)\n  private String username;\n\n  @NotBlank\n  @Size(max = 50)\n  @Email\n  private String email;\n\n  private Set&lt;String&gt; role;\n\n  @NotBlank\n  @Size(min = 6, max = 40)\n  private String password;\n\n  // get and set\n</code></pre> Per enviar aquesta informaci\u00f3, l'objecte json rebut ser\u00e0 semblant a:</p> JSON<pre><code>{\n    \"username\":\"joange\",\n    \"email\":\"jg.camarenaestruch@edu.gva.es\",\n    \"password\":\"123456\",\n    \"role\":[\"admin\",\"user\"]\n}\n</code></pre>"},{"location":"UD5_Spring/4_Spring_Security/#27-loginrequest","title":"2.7. LoginRequest","text":"<p>Molt senzilla:</p> Java<pre><code>public class LoginRequest {\n    @NotBlank\n  private String username;\n\n    @NotBlank\n    private String password;\n</code></pre> <p>i l'objecte json associat ser\u00e0:</p> JSON<pre><code>{\n    \"username\":\"joange\",\n    \"password\":\"123456\"\n}\n</code></pre> <p>Atenci\u00f3</p> <p>En aquesta classe podem marcar els camps com a obligatoris, amb l'anotaci\u00f3 <code>@NotBlank</code> de <code>javax.validation.constraints.NotBlank</code>. Has d'afegir: XML<pre><code>    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n</code></pre></p>"},{"location":"UD5_Spring/4_Spring_Security/#28-jwtresponse","title":"2.8. JwtResponse","text":"<p>Aquesta classe DTO \u00e9s la classe que es retorna com a sol\u00b7licitud de login. Ha de contenir poca informaci\u00f3 sobre el nostre usuari i el m\u00e9s important, un token JWT. Aquest token s'utilitzar\u00e0 per autoritzar-nos, com estudiarem a la seg\u00fcent secci\u00f3.</p> Java<pre><code>public class JwtResponse {\n  private String token;\n  private String type = \"Bearer\";\n  private Long id;\n  private String username;\n  private String email;\n  private List&lt;String&gt; roles;\n</code></pre> <p>Tingues en compte que:</p> <ul> <li>Els camps d'aquesta classe es poblaran a partir de la classe <code>User</code>, com un DTO.</li> <li>Hem canviat el format del rol, de la classe <code>Role</code> a <code>String</code>, amb una millor gesti\u00f3 en els clients.</li> <li>El <code>String token</code> \u00e9s on s'emmagatzema el token JWT. De fet, un token \u00e9s una cadena de text, com mostrarem ara.</li> </ul>"},{"location":"UD5_Spring/4_Spring_Security/#3-tokens-jwt","title":"3. Tokens JWT","text":""},{"location":"UD5_Spring/4_Spring_Security/#31-que-es-un-token","title":"3.1. Qu\u00e8 \u00e9s un token?","text":"<p>JSON Web Tokens (JWT) s'han introdu\u00eft com un m\u00e8tode de securitzar la comunicaci\u00f3 segura entre dues parts. Es va introduir amb l'especificaci\u00f3 RFC 7519 per l'Internet Engineering Task Force (IETF). Tot i que podem utilitzar <code>JWT</code> amb qualsevol tipus de m\u00e8tode de comunicaci\u00f3, avui en dia, JWT \u00e9s molt popular per gestionar l'autenticaci\u00f3 i l'autoritzaci\u00f3 sobre HTTP.</p> <p>Primer, necessitar\u00e0s con\u00e8ixer algunes caracter\u00edstiques de HTTP:</p> <ul> <li>HTTP \u00e9s un protocol sense estat, el que significa que una sol\u00b7licitud HTTP no mant\u00e9 l'estat. El servidor no \u00e9s conscient de cap sol\u00b7licitud anterior enviada pel mateix client.</li> <li>Les sol\u00b7licituds HTTP haurien de ser aut\u00f2nomes. Han d'incloure informaci\u00f3 sobre sol\u00b7licituds anteriors que l'usuari ha fet en la mateixa sol\u00b7licitud.</li> </ul> <p>Hi ha algunes maneres de fer aix\u00f2, per\u00f2 la manera m\u00e9s popular \u00e9s establir un session_id, que \u00e9s una refer\u00e8ncia a la informaci\u00f3 de l'usuari:</p> <ul> <li>El servidor emmagatzemar\u00e0 aquest ID de sessi\u00f3 en mem\u00f2ria o en una base de dades. El client enviar\u00e0 cada sol\u00b7licitud amb aquest ID de sessi\u00f3.</li> <li>El servidor pot obtenir informaci\u00f3 sobre el client utilitzant aquesta refer\u00e8ncia.</li> <li>Normalment, aquest ID de sessi\u00f3 s'envia a l'usuari com una cookie.</li> </ul> <p>Aqu\u00ed tens el diagrama de com funciona l'autenticaci\u00f3 basada en sessions.</p> <p></p> <p>D'altra banda, amb JWT, quan el client envia una sol\u00b7licitud d'autenticaci\u00f3 al servidor, aquest enviar\u00e0 un token JSON al client, que inclou tota la informaci\u00f3 sobre l'usuari juntament amb la resposta.</p> <p>El client enviar\u00e0 aquest token amb totes les sol\u00b7licituds posteriors. Per tant, el servidor no haur\u00e0 d'emmagatzemar cap informaci\u00f3 sobre la sessi\u00f3. Per\u00f2 hi ha un problema amb aquest enfocament. Qualsevol pot enviar una sol\u00b7licitud falsa amb un token JSON fals i fer-se passar per alg\u00fa que no \u00e9s.</p> <p>Per exemple, suposem que despr\u00e9s de l'autenticaci\u00f3, el servidor retorna un objecte JSON al client amb el nom d'usuari i el temps d'expiraci\u00f3. Aix\u00ed, com que l'objecte JSON \u00e9s llegible, qualsevol pot editar aquesta informaci\u00f3 i enviar una sol\u00b7licitud amb ella. El problema \u00e9s que no hi ha manera de validar aquesta sol\u00b7licitud.</p> <p>Aqu\u00ed \u00e9s on entra en joc la signatura testimoni. Aix\u00ed que en lloc d'enviar nom\u00e9s un token JSON normal, el servidor enviar\u00e0 un token signat, que pot verificar que la informaci\u00f3 no ha canviat.</p> <p></p>"},{"location":"UD5_Spring/4_Spring_Security/#32-estructura-dun-jwt","title":"3.2. Estructura d'un JWT","text":"<p>Parlem de l'estructura d'un JWT a trav\u00e9s d'un token d'exemple:</p> JSON<pre><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\n</code></pre> <p>Com podeu veure, hi ha tres seccions en aquest JWT, cadascuna separada per un punt.</p> <p>Nota</p> <p>La codificaci\u00f3 <code>Base64</code> \u00e9s una manera d'assegurar que les dades no es corrompin, ja que no comprimeixen ni xifren les dades, sin\u00f3 que simplement les codifiquen d'una manera que la majoria dels sistemes poden entendre. Podeu llegir qualsevol text codificat en Base64 simplement descodificant-lo.</p> <p>La primera secci\u00f3 del JWT \u00e9s un header, que \u00e9s una cadena codificada en Base64. Si descodifiqueu el header, es veuria aix\u00ed:</p> JSON<pre><code>{\n   \"alg\":\"HS256\",\n   \"typ\":\"JWT\"\n}\n</code></pre> <p>La secci\u00f3 del header cont\u00e9 l'algoritme de hash, que es va utilitzar per generar la signatura del token i el tipus.</p> <p>La segona secci\u00f3 \u00e9s el payload que cont\u00e9 l'objecte JSON que es va enviar de tornada a l'usuari. Com que nom\u00e9s est\u00e0 codificat en Base64, qualsevol pot descodificar-lo f\u00e0cilment. \u00c9s obligatori no incloure dades sensibles en els JWT, com ara contrasenyes o informaci\u00f3 personal identificable.</p> <p>Normalment, el cos del JWT es veur\u00e0 aix\u00ed, tot i que no necess\u00e0riament s'aplica:</p> JSON<pre><code>{\n   \"sub\": \"1234567890\",\n   \"name\": \"John Doe\",\n   \"iat\": 1516239022\n}\n</code></pre> <p>Nota</p> <p>La majoria de les vegades, la propietat <code>sub</code> contindr\u00e0 l'ID de l'usuari, la propietat <code>iat</code> (issued at), abreujada com <code>em\u00e8s a</code>, \u00e9s el segell de temps d'emissi\u00f3 del token. Tamb\u00e9 podeu veure algunes propietats comunes, com ara <code>eat</code> o <code>exp</code>, que \u00e9s el temps d'expiraci\u00f3 del token.</p> <p>Totes aquestes propietats s\u00f3n els claims del token, la informaci\u00f3.</p> <p>La secci\u00f3 final \u00e9s la signatura del token. Aquesta es genera fent un hash de la cadena creada amb les dues seccions anteriors i una contrasenya secreta, utilitzant l'algoritme esmentat a la secci\u00f3 del header.</p> <p>Podeu visitar https://www.javainuse.com/jwtgenerator i https://jwt.io per generar tokens i provar amb diverses dades, secrets i hashes.</p> <p></p>"},{"location":"UD5_Spring/4_Spring_Security/#33-jwt-library-class","title":"3.3. JWT Library class","text":"<p>Afegirem al <code>pom.xml</code> les seg\u00fcents depend\u00e8ncies:</p> XML<pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;\n  &lt;artifactId&gt;jjwt-api&lt;/artifactId&gt;\n  &lt;version&gt;0.10.7&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;\n  &lt;artifactId&gt;jjwt-impl&lt;/artifactId&gt;\n  &lt;version&gt;0.10.7&lt;/version&gt;\n  &lt;scope&gt;runtime&lt;/scope&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;\n  &lt;artifactId&gt;jjwt-jackson&lt;/artifactId&gt;\n  &lt;version&gt;0.10.7&lt;/version&gt;\n  &lt;scope&gt;runtime&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Aquesta classe \u00e9s la que genera i comprova la integritat dels tokens. Anem a mostrar aquesta classe i quins elements necessita. Aquesta classe ser\u00e0 una classe de biblioteca amb m\u00e8todes per crear tokens, validar-los i extreure informaci\u00f3 d'ells. Podem trobar aquesta classe amb noms com <code>JWTUtils</code> o <code>JWTTokenProvider</code>. L'esquelet d'aquesta classe \u00e9s el seg\u00fcent:</p> <ul> <li>C\u00e0rrega o definici\u00f3 de constants del token</li> <li>M\u00e8tode per generar JWT a partir d'un objecte <code>Authentication</code></li> <li>M\u00e8todes per obtenir informaci\u00f3 del token</li> <li>M\u00e8tode per validar el token (signatura)</li> </ul> Java<pre><code>// constants and secrets\n\n  public String generateJwtToken(Authentication authentication);\n\n  public boolean validateJwtToken(String authToken);\n\n  public String getUserNameFromJwtToken(String token);\n\n  // another methods.\n</code></pre>"},{"location":"UD5_Spring/4_Spring_Security/#34-generar-tokens","title":"3.4. Generar Tokens","text":"<p>Vegem cada m\u00e8tode. Primer, necessitem un objecte <code>Authentication</code>. Hem de saber que aquest objecte representa un altre token (no el nostre JWT) amb les credencials de l'objecte que volem identificar.</p> Java<pre><code>public String generateJwtToken(Authentication authentication) {\n\n    UserDetailsImpl userPrincipal = (UserDetailsImpl) authentication.getPrincipal();\n\n    return Jwts.builder()\n        .setSubject((userPrincipal.getUsername()))\n        .setIssuedAt(new Date())\n        .setExpiration(new Date((new Date()).getTime() + jwtExpirationMs))\n        .signWith(SignatureAlgorithm.HS512, jwtSecret)\n        .compact();\n  }\n</code></pre> <p>Veiem que:</p> <ul> <li>Rebem un objecte <code>Authentication</code>, en el qual hem guardat un <code>UserDetailsImpl</code>. Com totes les implementacions de detalls d'usuari, podem obtenir el nom d'usuari, i l'utilitzem per establir el subjecte del token.</li> <li>Establim <code>IAT</code> al moment actual.</li> <li>Establim el temps d'expiraci\u00f3.</li> <li>Establim l'algoritme de xifrat i la paraula secreta, i el token est\u00e0 llest per...</li> <li>El m\u00e8tode <code>compact()</code> crea i transforma el token a String.</li> </ul> <p>Nota</p> <p>El <code>jwtSecret</code> \u00e9s la contrasenya que necessitem. \u00c9s una bona idea emmagatzemar-la dins de <code>application.properties</code> i recuperar-la a una variable, com <code>jwtExpiration</code>. Podem utilitzar l'anotaci\u00f3 <code>@Value</code>:</p> Java<pre><code>  @Value(\"${app.jwtSecret}\")\n  private String jwtSecret;\n\n  @Value(\"${app.jwtExpirationMs}\")\n  private int jwtExpirationMs;\n</code></pre>"},{"location":"UD5_Spring/4_Spring_Security/#35-validacio-de-tokens","title":"3.5. Validaci\u00f3 de Tokens","text":"<p>Molt f\u00e0cil:</p> Java<pre><code>public boolean validateJwtToken(String authToken) {\n    try {\n      Jwts.parser().setSigningKey(jwtSecret).parseClaimsJws(authToken);\n      return true;\n    } catch (SignatureException e) {\n      logger.error(\"Invalid JWT signature: {}\", e.getMessage());\n    } catch (MalformedJwtException e) {\n      logger.error(\"Invalid JWT token: {}\", e.getMessage());\n    } catch (ExpiredJwtException e) {\n      logger.error(\"JWT token is expired: {}\", e.getMessage());\n    } catch (UnsupportedJwtException e) {\n      logger.error(\"JWT token is unsupported: {}\", e.getMessage());\n    } catch (IllegalArgumentException e) {\n      logger.error(\"JWT claims string is empty: {}\", e.getMessage());\n    }\n</code></pre> <p>En aquest m\u00e8tode comprovem si \u00e9s un token v\u00e0lid. Utilitzem <code>parseClaimsJws(String token)</code>, despr\u00e9s d'assignar la contrasenya secreta per obtenir els claims. Si hi ha algun problema amb la integritat del token, podria apar\u00e8ixer una excepci\u00f3. Obtenim els claims dins d'un bloc <code>try-catch</code> i informem si passa alguna cosa. Retornarem <code>true</code> si no es captura cap excepci\u00f3.</p> <p>Nota</p> <p>Recorda que els claims s\u00f3n el contingut del payload del token. No necessitem els claims en aquest m\u00e8tode, nom\u00e9s comprovar si tot est\u00e0 b\u00e9.</p>"},{"location":"UD5_Spring/4_Spring_Security/#4-authentication-controller","title":"4. Authentication Controller","text":"<p>Ara que tamb\u00e9 sabem com crear tokens i l'estructura de <code>User</code> a la nostra base de dades, \u00e9s hora d'exposar el nostre cam\u00ed per registrar i iniciar sessi\u00f3 d'usuaris. Per tant, nom\u00e9s s\u00f3n obligatoris dos m\u00e8todes. La classe podria ser alguna cosa aix\u00ed:</p> Java<pre><code>@CrossOrigin(origins = \"*\", maxAge = 3600)\n@RestController\n@RequestMapping(\"/api/auth\")\npublic class AuthController {\n    ...\n}\n</code></pre> <ul> <li>L'anotaci\u00f3 <code>@CrossOrigin</code> permet sol\u00b7licituds de cross-origin en classes de controlador espec\u00edfiques i/o m\u00e8todes de controlador. Es processa si es configura un <code>HandlerMapping</code> apropiat. El Cross-Origin Resource Sharing (CORS) \u00e9s un concepte de seguretat que permet restringir els recursos implementats en navegadors web. Evita que el codi JavaScript produeixi o consumeixi sol\u00b7licituds contra un origen diferent. Per exemple, la vostra aplicaci\u00f3 web s'est\u00e0 executant al port 8080 i mitjan\u00e7ant JavaScript esteu intentant consumir serveis web RESTful des del port 9090. En aquestes situacions, us trobareu amb el problema de seguretat de Cross-Origin Resource Sharing als vostres navegadors web.</li> <li><code>@RequestMapping(\"/api/auth\")</code> indica que tots els controladors estan dins del cam\u00ed <code>/api/auth</code>.</li> </ul> <p>Vegem-los, per\u00f2 abans d'estudiar els m\u00e8todes, aquesta classe t\u00e9 aquestes variables necess\u00e0ries:</p> <ul> <li><code>@Autowired AuthenticationManager authenticationManager;</code> \u2192 s'utilitza per crear un token d'<code>Authentication</code>, utilitzat pel context de seguretat de Spring i pel generador de tokens.</li> <li><code>@Autowired UserRepository userRepository;</code> \u2192 s'utilitza per accedir i desar usuaris.</li> <li><code>@Autowired RoleRepository roleRepository;</code> \u2192 per comprovar si els rols que arriben a la sol\u00b7licitud s\u00f3n v\u00e0lids.</li> <li><code>@Autowired PasswordEncoder encoder;</code> \u2192 s'utilitza per encriptar la contrasenya de l'usuari.</li> <li><code>@Autowired JwtUtils jwtUtils;</code> \u2192 s'utilitza per crear tokens JWT.</li> </ul> <p>Ara que hem presentat els actors, anem a la funci\u00f3.</p>"},{"location":"UD5_Spring/4_Spring_Security/#41-signup-nou-usuari","title":"4.1. Signup (nou usuari)","text":"<p>El m\u00e8tode encarregat de crear nous usuaris rebr\u00e0 un <code>SignupRequest</code> amb aquestes dades:</p> JSON<pre><code>{\n    \"username\":\"joange\",\n    \"email\":\"jg.camarenaestruch@edu.gva.es\",\n    \"password\":\"123456\",\n    \"role\":[\"admin\",\"user\"]\n}\n</code></pre> <p>el cos del m\u00e8tode \u00e9s el seg\u00fcent, i vegem-ho per blocs:</p> Java<pre><code>@PostMapping(\"/signup\")\n  public ResponseEntity&lt;?&gt; registerUser(@Valid @RequestBody SignupRequest signUpRequest) {\n    if (userRepository.existsByUsername(signUpRequest.getUsername())) {\n      return ResponseEntity\n          .badRequest()\n          .body(new MessageResponse(\"Error: Username is already taken!\"));\n    }\n\n    if (userRepository.existsByEmail(signUpRequest.getEmail())) {\n      return ResponseEntity\n          .badRequest()\n          .body(new MessageResponse(\"Error: Email is already in use!\"));\n    }\n    // Create new user's account\n    User user = new User(signUpRequest.getUsername(), \n               signUpRequest.getEmail(),\n               encoder.encode(signUpRequest.getPassword()));\n</code></pre> <p>En aquesta primera part:</p> <ul> <li>Comprovem si existeix algun usuari amb el mateix nom d'usuari o correu electr\u00f2nic, consultant el nostre repositori. Si apareix algun error, retornarem un <code>ResponseEntity</code> com a bad request amb un missatge descriptiu.</li> <li>Finalment, creem un nou usuari amb nom d'usuari, correu electr\u00f2nic i una contrasenya encriptada.</li> </ul> <p>El seg\u00fcent bloc \u00e9s responsable d'obtenir els rols (emmagatzemats en un JSONArray de cadenes) i transformar-los en un <code>Set&lt;Role&gt;</code>.</p> Java<pre><code>    Set&lt;String&gt; strRoles = signUpRequest.getRole();\n    Set&lt;Role&gt; roles = new HashSet&lt;&gt;();\n\n    if (strRoles == null) {\n      Role userRole = roleRepository.findByName(ERole.ROLE_USER)\n          .orElseThrow(() -&gt; new RuntimeException(\"Error: Role is not found.\"));\n      roles.add(userRole);\n    } else {\n      strRoles.forEach(role -&gt; {\n        switch (role) {\n        case \"admin\":\n          Role adminRole = roleRepository.findByName(ERole.ROLE_ADMIN)\n              .orElseThrow(() -&gt; new RuntimeException(\"Error: Role is not found.\"));\n          roles.add(adminRole);\n\n          break;\n        case \"mod\":\n          Role modRole = roleRepository.findByName(ERole.ROLE_MODERATOR)\n              .orElseThrow(() -&gt; new RuntimeException(\"Error: Role is not found.\"));\n          roles.add(modRole);\n\n          break;\n        default:\n          Role userRole = roleRepository.findByName(ERole.ROLE_USER)\n              .orElseThrow(() -&gt; new RuntimeException(\"Error: Role is not found.\"));\n          roles.add(userRole);\n        }\n      });\n    }\n\n    user.setRoles(roles);\n</code></pre> <p>Vegem-ho:</p> <ul> <li>Primer comprovem si el conjunt de rols est\u00e0 buit. Si \u00e9s cert, establim un nou <code>Role</code> amb <code>ERole.ROLE_USER</code> per defecte.</li> <li>En cas contrari, hem de rec\u00f3rrer tots els rols que obtenim, comprovant cada rol a la base de dades i creant l'objecte <code>Role</code> corresponent.</li> </ul> <p>Finalment, assignem el <code>Set&lt;Role&gt;</code> a l'usuari creat en el primer bloc, i en el tercer bloc nom\u00e9s necessitem emmagatzemar el nou usuari amb <code>UserRepository</code> i enviar una resposta d'ok al client.</p> Java<pre><code>    userRepository.save(user);\n\n    return ResponseEntity.ok(new MessageResponse(\"User registered successfully!\"));\n  }\n</code></pre>"},{"location":"UD5_Spring/4_Spring_Security/#42-signin-validar-se-o-accedir","title":"4.2. Signin (Validar-se o accedir)","text":"<p>Nota</p> <p>En valenci\u00e0:</p> <ul> <li>Signin: registrarse, accedir al login.</li> <li>Signup: inscribirse, donar-se d'alta. La primera vegada</li> </ul> <p>Aquest controlador s'utilitza per iniciar sessi\u00f3 d'un usuari a la nostra aplicaci\u00f3. Com hem estudiat, el DTO que rebem en el <code>HTTP_POST</code> \u00e9s la classe <code>LoginRequest</code>, com aquesta:</p> JSON<pre><code>{\n    \"username\":\"joange\",\n    \"password\":\"123456\"\n}\n</code></pre> <p>El m\u00e8tode encarregat ser\u00e0:</p> Java<pre><code>@PostMapping(\"/signin\")\n  public ResponseEntity&lt;?&gt; authenticateUser(@Valid @RequestBody LoginRequest loginRequest) {\n\n    Authentication authentication = authenticationManager.authenticate(\n        new UsernamePasswordAuthenticationToken(loginRequest.getUsername(), loginRequest.getPassword()));\n\n    SecurityContextHolder.getContext().setAuthentication(authentication);\n    String jwt = jwtUtils.generateJwtToken(authentication);\n\n    UserDetailsImpl userDetails = (UserDetailsImpl) authentication.getPrincipal();  \n\n    List&lt;String&gt; roles = userDetails.getAuthorities().stream()\n        .map(item -&gt; item.getAuthority())\n        .collect(Collectors.toList());\n\n    return ResponseEntity.ok(new JwtResponse(jwt, \n                         userDetails.getId(), \n                         userDetails.getUsername(), \n                         userDetails.getEmail(), \n                         roles));\n  }\n</code></pre> <p>Tingues en compte:</p> <ul> <li>L'anotaci\u00f3 <code>@Valid</code> comprova que l'objecte JSON coincideixi amb la classe <code>LoginRequest</code> (mira les anotacions d'aquesta classe).</li> <li>Creem un token d'<code>Authentication</code> (aquest no \u00e9s el token JWT !!!) amb el nom d'usuari i la contrasenya rebuts. La contrasenya encara no est\u00e0 encriptada.</li> <li>L'\u00faltim token d'<code>Authentication</code> es configura al <code>SecurityContextHolder</code>, un objecte que cont\u00e9 un m\u00ednim de seguretat a nivell de fil. En aquest pas \u00e9s quan el subsistema de seguretat de Spring funciona, demanant a <code>UserDetailService</code> un usuari amb aquest nom d'usuari i contrasenya a la nostra base de dades, i es guarda en un Bean <code>UserDetails</code> a la mem\u00f2ria. Si alguna credencial \u00e9s incorrecta, es llan\u00e7ar\u00e0 una excepci\u00f3, que ser\u00e0 gestionada pel nostre sistema (ho estudiarem m\u00e9s endavant).</li> <li>Amb aquest token (autenticaci\u00f3) generem el nostre token. Recorda que dins de <code>jwtUtils</code>, nom\u00e9s obtenim el nom d'usuari per generar el subjecte del nostre token.</li> <li>Obtenim l'objecte <code>UserDetails</code> amb el m\u00e8tode <code>getPrincipal()</code>, i</li> <li>Transformem la llista d'autoritats en una llista de cadenes (has estudiat com mapar llistes? I filtrar? I reduir?).</li> <li>Finalment, creem i retornem un <code>ResponseEntity</code>, amb l'http_Status ok, amb un <code>JwtResponse</code> dins. Token m\u00e9s atributs. Un exemple de <code>JWTrespone</code> \u00e9s:</li> </ul> JSON<pre><code>{\n    \"id\": 1,\n    \"username\": \"joange\",\n    \"email\": \"joange.sales@edu.gva.es\",\n    \"roles\": [\n        \"ROLE_USER\",\n        \"ROLE_ADMIN\"\n    ],\n    \"accessToken\": \"eyJhbGciOiJIUzUxMiJ9.\n    eyJzdWIiOiJqb2FuZ2UiLCJpYXQiOjE2NzM2MjY1OTYsImV4cCI6MTY3MzcxMjk5Nn0.\n    6yMcAYYvHsQ4XKmmT6tr0PmkpJKfPusxnMVHDmIl4WJQ_KtaY08vbt27KdvJHkWCZPO\n    4dA2a2HtnAq13vMKAPw\",\n    \"tokenType\": \"Bearer\"\n}\n</code></pre> <p>Atenci\u00f3</p> <p>L'\u00faltim token t\u00e9 salts de l\u00ednia addicionals per evitar sortir del marge del paper, \u00e9s una cadena completa.</p> <p>Si el nom d'usuari no es troba a la base de dades, la nostra aplicaci\u00f3 crea la seg\u00fcent resposta:</p> JSON<pre><code>{\n    \"path\": \"/api/auth/signin\",\n    \"error\": \"Unauthorized\",\n    \"message\": \"Bad credentials\",\n    \"status\": 401\n}\n</code></pre>"},{"location":"UD5_Spring/4_Spring_Security/#5-tokens-en-funcionament","title":"5. Tokens en funcionament","text":"<p>Ara que el registre d'usuaris i l'inici de sessi\u00f3 estan implementats, fem una pregunta, Qu\u00e8 fa l'aplicaci\u00f3 client amb el JWTResponse que ha rebut despr\u00e9s del proc\u00e9s d'inici de sessi\u00f3? Les dades de l'usuari normalment s'utilitzen per a la interf\u00edcie (nom complet, avatar, etc.). Per\u00f2 qu\u00e8 passa amb els tokens?</p> <p>La resposta, com estudiarem m\u00e9s endavant, \u00e9s emmagatzemar-lo, i despr\u00e9s enviar-lo al servidor en cada sol\u00b7licitud com a m\u00e8tode d'Autenticaci\u00f3 i Autoritzaci\u00f3.</p>"},{"location":"UD5_Spring/4_Spring_Security/#51-enviant-tokens","title":"5.1. Enviant tokens","text":"<p>Per enviar un token, necessitem adjuntar-lo a la secci\u00f3 <code>Header</code>, creant un par\u00e0metre <code>Authorization</code> amb el valor <code>Bearer token_recieved</code>, com podeu veure en aquesta captura de pantalla de Postman:</p> <p></p> <p>Important</p> <p>Recorda: la paraula <code>Bearer</code> m\u00e9s un espai en blanc m\u00e9s tot el token rebut (com a <code>String</code>)</p> <p>D'acord, aix\u00ed doncs, l'aplicaci\u00f3 client ens enviar\u00e0 el token a trav\u00e9s de la sol\u00b7licitud, per\u00f2, com fa el nostre servidor per obtenir i comprovar el token? La resposta \u00e9s que hem de dir-ho en forma de filtre.</p>"},{"location":"UD5_Spring/4_Spring_Security/#6-configuracio-de-seguretat","title":"6. Configuraci\u00f3 de Seguretat","text":"<p>La classe que configura la seguretat \u00e9s <code>WebSecurityConfig</code>. Anem a explicar-la per blocs de nou. Aquesta classe est\u00e0 composta per un conjunt de Beans que s'utilitzaran en tot el projecte (recorda la injecci\u00f3 de codi). Explicarem nom\u00e9s el necessari.</p> Java<pre><code>@Configuration\n@EnableGlobalMethodSecurity(\n    prePostEnabled = true)\npublic class WebSecurityConfig { \n\n}\n</code></pre> <p>Aquesta anotaci\u00f3 <code>@Configuration</code> indica a Spring que ha de carregar aquesta classe. Tamb\u00e9 permet que Spring utilitzi anotacions de filtres pre i post (ho estudiarem m\u00e9s endavant).</p> Java<pre><code>  @Autowired\n  UserDetailsServiceImpl userDetailsService;\n\n  @Autowired\n  private AuthEntryPointJwt unauthorizedHandler;\n\n  @Bean\n  public AuthTokenFilter authenticationJwtTokenFilter() {\n    return new AuthTokenFilter();\n  }\n</code></pre> <p>Aquests beans s'explicaran m\u00e9s endavant. En poques paraules, s\u00f3n responsables de gestionar errors com a manejador d'excepcions i de com aplicar cadenes de filtres per autenticar usuaris.</p> Java<pre><code>  @Bean\n  public DaoAuthenticationProvider authenticationProvider() {\n      DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();\n\n      authProvider.setUserDetailsService(userDetailsService);\n      authProvider.setPasswordEncoder(passwordEncoder());\n\n      return authProvider;\n  }\n</code></pre> <p>Aquest Bean utilitza el <code>UserDetailService</code> i el <code>PasswordEncoder</code> per fer el proc\u00e9s d'autenticaci\u00f3. Aix\u00f2 significa accedir a la base de dades i comprovar l'usuari i la contrasenya (amb el mateix encoder que utilitzem per emmagatzemar usuaris). Els seg\u00fcents Beans creen l'<code>AuthenticationManager</code> i l'encoder.</p> Java<pre><code>  @Bean\n  public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig) throws Exception {\n    return authConfig.getAuthenticationManager();\n  }\n\n  @Bean\n  public PasswordEncoder passwordEncoder() {\n    return new BCryptPasswordEncoder();\n  }\n</code></pre> <p>I finalment, una de les configuracions m\u00e9s importants (i dif\u00edcils d'entendre), la cadena de filtres de seguretat. Les cadenes de filtres s\u00f3n codi que posem al mig entre el client i el servidor. Aquests filtres intercepten la sol\u00b7licitud, l'analitzen i despr\u00e9s, depenent del resultat del filtre, simplement passen el control al servidor o envien una resposta al client. Aquest filtre podria canviar la sol\u00b7licitud, afegint o eliminant informaci\u00f3 que ser\u00e0 utilitzada pel servidor.</p> Java<pre><code>  @Bean\n  public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n    http.cors().and().csrf().disable()\n        .exceptionHandling().authenticationEntryPoint(unauthorizedHandler).and()\n        .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()\n        .authorizeRequests().antMatchers(\"/api/auth/**\").permitAll()\n        .antMatchers(\"/api/test/**\").permitAll()\n        .anyRequest().authenticated();\n\n    http.authenticationProvider(authenticationProvider());\n\n    http.addFilterBefore(authenticationJwtTokenFilter(), UsernamePasswordAuthenticationFilter.class);\n\n    return http.build();\n  }\n</code></pre> <p>Tingueu en compte que:</p> <ul> <li>Habilitem CORS (Cross-Origin Requests) i deshabilitem CSRF (Cross Site Request Forgery)</li> <li>Establim l'authenticationEntryPoint</li> <li>Permetem l'acc\u00e9s a tots els camins a <code>/api/auth/**</code></li> <li>Permetem l'acc\u00e9s a tots els camins a <code>/api/test/**</code></li> <li>Qualsevol altra sol\u00b7licitud necessitar\u00e0 ser autenticada</li> </ul> <p>Finalment, afegim el filtre abans i el prove\u00efdor d'autenticaci\u00f3.</p> <p>En una visi\u00f3 relaxada, per entendre-ho, els filtres es combinen amb anotacions que indiquen on i quan hem de comprovar l'Autenticaci\u00f3 i l'Autoritzaci\u00f3.</p> <p></p>"},{"location":"UD5_Spring/4_Spring_Security/#61-authtokenfilter","title":"6.1. AuthTokenFilter","text":"<p>Aquesta classe cont\u00e9 el proc\u00e9s del token rebut dels clients. Ha d'implementar <code>OncePerRequestFilter</code> i sobreescriure <code>doFilterInternal()</code>.</p> Java<pre><code>@Override\n  protected void doFilterInternal(\n    HttpServletRequest request, \n    HttpServletResponse response, \n    FilterChain filterChain) throws ServletException, IOException {\n    try {\n      String jwt = parseJwt(request);\n      if (jwt != null &amp;&amp; jwtUtils.validateJwtToken(jwt)) {\n        String username = jwtUtils.getUserNameFromJwtToken(jwt);\n\n        UserDetails userDetails = userDetailsService.loadUserByUsername(username);\n        UsernamePasswordAuthenticationToken authentication =\n            new UsernamePasswordAuthenticationToken(\n                userDetails,\n                null,\n                userDetails.getAuthorities());\n        authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));\n\n        SecurityContextHolder.getContext().setAuthentication(authentication);\n      }\n    } catch (Exception e) {\n      logger.error(\"Cannot set user authentication: {}\", e);\n    }\n\n    filterChain.doFilter(request, response);\n  }\n</code></pre> <p>En paraules nostres, aquest m\u00e8tode s'executar\u00e0 quan es faci una sol\u00b7licitud i:</p> <ul> <li>Extreu el token de la sol\u00b7licitud, retornant nom\u00e9s la informaci\u00f3 rellevant (elimina <code>Bearer</code>).</li> <li>Comprova que el token sigui v\u00e0lid, i:</li> <li>Extreu el nom d'usuari (est\u00e0 en el payload del token) i</li> <li>Obt\u00e9 aquest <code>UserDetails</code> i crea un <code>UsernamePasswordAuthenticationToken</code> per ser injectat a la resta de la sol\u00b7licitud-resposta, \u00f2bviament amb autoritats.</li> <li>Finalment, continua amb el seg\u00fcent filtre, si existeix, cridant <code>filterChain.doFilter(req,res)</code>. Si no hi ha cap filtre, el dispatcher passa el control al controlador sol\u00b7licitat.</li> </ul>"},{"location":"UD5_Spring/4_Spring_Security/#62-authentrypoint","title":"6.2. AuthEntryPoint","text":"<p>Aquesta classe cont\u00e9 codi que s'executar\u00e0 quan aparegui una excepci\u00f3. Aleshores, crea un cos gen\u00e8ric dins de la resposta i estableix una resposta precisa per al client.</p>"},{"location":"UD5_Spring/4_Spring_Security/#7-controller-authorization","title":"7. Controller Authorization","text":"<p>Nom\u00e9s ens queda dir quina sol\u00b7licitud necessita ser autoritzada. Recorda que amb altres classes preparem l'autenticaci\u00f3, Qui ets?. Ara necessitem preguntar Qu\u00e8 pots fer?</p> <p>Com marquem en la nostra <code>filterChain</code>, afegim <code>addFilterBefore</code> per comprovar els rols. Per\u00f2, on hem de dir els rols que capturen cada sol\u00b7licitud? La resposta \u00e9s f\u00e0cil: els controladors. Vegem un controlador de prova amb filtre d'autoritzaci\u00f3:</p> <p>Java<pre><code>@CrossOrigin(origins = \"*\", maxAge = 3600)\n@RestController\n@RequestMapping(\"/api/test\")\npublic class TestController {\n  @GetMapping(\"/all\")\n  public String allAccess() {\n    return \"Public Content.\";\n  }\n\n  @GetMapping(\"/user\")\n  @PreAuthorize(\"hasRole('USER') or hasRole('MODERATOR') or hasRole('ADMIN')\")\n  public String userAccess() {\n    return \"User Content.\";\n  }\n\n  @GetMapping(\"/mod\")\n  @PreAuthorize(\"hasRole('MODERATOR')\")\n  public String moderatorAccess() {\n    return \"Moderator Board.\";\n  }\n\n  @GetMapping(\"/admin\")\n  @PreAuthorize(\"hasRole('ADMIN')\")\n  public String adminAccess() {\n    return \"Admin Board.\";\n  }\n}\n</code></pre> Si:</p> <ul> <li>No apareix cap anotaci\u00f3: tots els rols poden fer aquesta sol\u00b7licitud</li> <li><code>@PreAuthorize(\"hasRole('role')\")</code> \u2192 Aquesta anotaci\u00f3 indica el rol que est\u00e0 autoritzat per fer aquesta sol\u00b7licitud. Pots combinar m\u00e9s d'un rol amb <code>or</code></li> </ul>"},{"location":"UD5_Spring/4_Spring_Security/#8-exercici-com-fer-servir-aquest-projecte","title":"8. Exercici. Com fer servir aquest projecte?","text":"<p>Probablement tindr\u00e0s ja una API implementada i funcionant de manera no segura. Ara tens la tasca de fusionar amb aquest projecte per tal d'autoritzar certes operacions sols a usuaris registrats. \u00c9s una tasca llarga (que no complicada), per\u00f2 el resultat final ser\u00e0 molt gratificant.</p>"},{"location":"UD5_Spring/5_Spring_Hateoas/","title":"5. Spring Haetoas","text":""},{"location":"UD5_Spring/5_Spring_Hateoas/#1-hateoas","title":"1. HATEOAS","text":"<p>Hateoas (Hypermedia as the engine of application state) \u00e9s un principi d'API RESTful definit per Roy Fielding. Principalment significa que el client pot moure's per tota l'aplicaci\u00f3 nom\u00e9s des d'URI's generals en format hiperm\u00e8dia. El principi implica que l'API ha de guiar el client a trav\u00e9s de l'aplicaci\u00f3 retornant informaci\u00f3 rellevant sobre els seg\u00fcents passos potencials, juntament amb cada resposta.</p> <p>Per a la connexi\u00f3 entre el servidor i el client, Fielding defineix aquestes quatre caracter\u00edstiques:</p> <ul> <li>Identificaci\u00f3 \u00fanica de tots els recursos: tots els recursos han de poder ser identificats amb un URI (Identificador de Recurs \u00danic).</li> <li>Interacci\u00f3 amb recursos a trav\u00e9s de representacions: Si un client necessita un recurs, el servidor li envia una representaci\u00f3 (per exemple, HTML, JSON o XML) perqu\u00e8 el client pugui modificar o eliminar el recurs original.</li> <li>Missatges expl\u00edcits: cada missatge intercanviat entre el servidor i el client ha de contenir totes les dades necess\u00e0ries per entendre's m\u00fatuament.</li> <li>HATEOAS: Aquest principi tamb\u00e9 integra una API REST. Aquesta estructura basada en hiperm\u00e8dia facilita als clients l'acc\u00e9s a l'aplicaci\u00f3, ja que no necessiten con\u00e8ixer res m\u00e9s sobre la interf\u00edcie per poder accedir-hi i navegar-hi.</li> </ul> <p>HATEOAS \u00e9s, en resum, una de les propietats m\u00e9s b\u00e0siques de les API REST i, com a tal, essencial en qualsevol servei REST.</p> <p>Un valor retornat sense HATEOAS, amb dades d'un client:</p> JSON<pre><code>{\n    \"idCliente\": 3,\n    \"nif\": \"33333333C\",\n    \"nombre\": \"Vicente\",\n    \"apellidos\": \"Mondrag\u00f3n\",\n    \"claveSeguridad\": \"1234\",\n    \"email\": \"vicente.mondragon@tia.es\",\n    \"recomendacion\": {\n      \"idRecomendacion\": 3,\n      \"observaciones\": \"Realiza muchos pedidos\"\n    },\n    \"listaCuentas\": [\n      {\n        \"idCuenta\": 8,\n        \"banco\": \"1001\",\n        \"sucursal\": \"1001\",\n        \"dc\": \"11\",\n        \"numeroCuenta\": \"1000000008\",\n        \"saldoActual\": 7500.0,\n        \"links\": [\n\n        ]\n      },\n      {\n        \"idCuenta\": 10,\n        \"banco\": \"1001\",\n        \"sucursal\": \"1001\",\n        \"dc\": \"11\",\n        \"numeroCuenta\": \"1000000010\",\n        \"saldoActual\": -3500.0,\n        \"links\": [\n\n        ]\n      }\n    ],\n    \"listaDirecciones\": [\n      {\n        \"idDireccion\": 5,\n        \"descripcion\": \"calle de la creu, 2\",\n        \"pais\": \"Espa\u00f1a\",\n        \"cp\": \"46701\"\n      }\n    ]\n  }\n</code></pre> <p>Tingues en compte que:</p> <ul> <li>Hem obtingut totes les dades del client</li> <li>No sabem com obtenir dades de camps relacionats espec\u00edfics, com <code>Direccion</code> o <code>Cuenta</code>. Estan ah\u00ed per\u00f2 no sabem com obtenir-les</li> </ul> <p>La mateixa sol\u00b7licitud amb HATEOAS:</p> JSON<pre><code>{\n  \"idCliente\": 3,\n  \"nif\": \"33333333C\",\n  \"nombre\": \"Vicente\",\n  \"apellidos\": \"Mondrag\u00f3n\",\n  \"claveSeguridad\": \"1234\",\n  \"email\": \"vicente.mondragon@tia.es\",\n  \"links\": [\n    {\n      \"rel\": \"self\",\n      \"href\": \"http://localhost:9090/clientes/3\"\n    },\n    {\n      \"rel\": \"listaDirecciones\",\n      \"href\": \"http://localhost:9090/clientes/3/direcciones\"\n    },\n    {\n      \"rel\": \"listaCuentas\",\n      \"href\": \"http://localhost:9090/clientes/3/cuentas\"\n    }\n  ]\n}\n</code></pre> <p>Com pots veure:</p> <ul> <li>Nom\u00e9s s'envien les dades d'un client</li> <li>Tenim enlla\u00e7os, amb URI's clares per obtenir informaci\u00f3 espec\u00edfica d'aquest client</li> </ul> <p>i el m\u00e9s important Si el servidor canvia la seva estructura, enviar\u00e0 enlla\u00e7os actualitzats, i el client funcionar\u00e0 sense cap problema</p>"},{"location":"UD5_Spring/5_Spring_Hateoas/#2-afegint-hateoas","title":"2. Afegint HATEOAS","text":""},{"location":"UD5_Spring/5_Spring_Hateoas/#21-llibrerires","title":"2.1. Llibrerires","text":"<p>Atenci\u00f3</p> <p>En aquest text, afegirem capacitats HATEOAS a una API RESTful desenvolupada al llarg de la unitat.</p> <p>Nom\u00e9s necessitem afegir aquesta depend\u00e8ncia al nostre <code>pom.xml</code>, suposant que hem utilitzat un projecte iniciador de Spring:</p> XML<pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n  &lt;artifactId&gt;spring-boot-starter-hateoas&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre> <p>i ja est\u00e0.</p>"},{"location":"UD5_Spring/5_Spring_Hateoas/#22-wrappers-envoltoris","title":"2.2. Wrappers (Envoltoris)","text":""},{"location":"UD5_Spring/5_Spring_Hateoas/#221-punt-dinici","title":"2.2.1. Punt d'inici","text":"<p>Recorda el que hem fet en el nostre projecte inicial:</p> <ul> <li>Classes Model o DAO \u2192 preparades per guardar informaci\u00f3 a la base de dades. Estan anotades amb Hibernate i s\u00f3n la base dels nostres repositoris. Per exemple, <code>Cliente</code>.</li> <li>Classes DTO \u2192 preparades per transferir dades des del nostre model i cap a aquest.  </li> <li>Aquestes classes encapsulen les DAO (afegint o eliminant camps).  </li> <li>Aquestes classes tenen m\u00e8todes per convertir entre DAO i DTO.  </li> <li>\u00c9s el servei qui realitza la conversi\u00f3.  </li> <li>El client ens enviar\u00e0 informaci\u00f3 en aquestes classes DTO.  </li> <li>Aquestes classes poden ser utilitzades tant per una API Rest com per una aplicaci\u00f3 web MVC.  </li> </ul>"},{"location":"UD5_Spring/5_Spring_Hateoas/#222-envoltori-hateoas","title":"2.2.2. Envoltori HATEOAS","text":"<p>Necessitem definir una nova classe per embolicar la nostra resposta HATEOAS.</p> <p>Partint dels DTO's, cont\u00e9 tota la informaci\u00f3 d'una classe, pr\u00f2pia i relacionada (Client m\u00e9s Direcci\u00f3 m\u00e9s Comptes). Amb HATEOAS, com hem mostrat recentment, nom\u00e9s necessitem la informaci\u00f3 pr\u00f2pia del Client i necessitem generar enlla\u00e7os a entitats relacionades. Llavors, necessitem afegir a la informaci\u00f3 del client la capacitat de generar i emmagatzemar enlla\u00e7os. La classe que ho permet \u00e9s <code>RepresentationModel&lt;base_class&gt;</code> (documentaci\u00f3 completa aqu\u00ed). Aix\u00f2 afegir\u00e0 a les nostres classes:</p> <ul> <li>Una estructura per a guadar links</li> <li>M\u00e8todes per afegir, comprovar i retornar links</li> </ul> <p>Per tal de fer-ho</p> Java<pre><code>@Data @AllArgsConstructor\npublic class ClienteHATEOAS \n    extends RepresentationModel&lt;ClienteDTO&gt;\n    implements Serializable{\n\n    private static final long serialVersionUID = 1L;\n    private long idCliente;\n    private String nif;\n    private String nombre;\n    private String apellidos;\n    private String claveSeguridad;\n    private String email;\n\n    public static ClienteHATEOAS fromClienteDTO2HATEOAS(ClienteDTO clienteDTO) {\n        return new ClienteHATEOAS(\n                clienteDTO.getIdCliente(),\n                clienteDTO.getNif(),\n                clienteDTO.getNombre(),\n                clienteDTO.getApellidos(),\n                clienteDTO.getClaveSeguridad(),\n                clienteDTO.getEmail());\n    }\n} \n</code></pre> <p>Important</p> <ul> <li>Com que tenim una API base que funciona amb <code>ClienteDTO</code>, hem creat aquesta classe envoltori a partir d'ella.</li> <li>Com que HATEOAS \u00e9s nom\u00e9s un format de resposta, pots crear-lo a partir de <code>Cliente</code> com a classe base, per\u00f2 has de definir el teu servei per retornar <code>Cliente</code> tamb\u00e9.</li> <li>\u00c9s molt important crear un m\u00e8tode de conversi\u00f3 <code>fromClienteDTO2HATEOAS</code>, que inclogui els camps necessaris.</li> </ul> <p>Llavors, utilitzarem el m\u00e8tode <code>add(Link)</code> en el nostre envoltori <code>ClienteHATEOAS</code> per afegir tants <code>Link</code> com sigui necessari.</p>"},{"location":"UD5_Spring/5_Spring_Hateoas/#3-links","title":"3. Links","text":"<p>Ara, la pregunta \u00e9s com generar els nostres objectes <code>Link</code> en les nostres classes envoltori. Podr\u00edem fer-ho de manera creativa, manipulant camins en cadenes de text i composant amb m\u00e8todes complicats de subcadena i concatenaci\u00f3.</p> <p>Per\u00f2 com que sabem quin m\u00e8tode es crida per a cada refer\u00e8ncia, \u00e9s millor crear enlla\u00e7os obtenint refer\u00e8ncies al cam\u00ed des dels mateixos m\u00e8todes. Per fer-ho, hem d'utilitzar aquests m\u00e8todes i crides est\u00e0tiques:</p> Java<pre><code>import org.springframework.hateoas.Link;\nimport static org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.linkTo;\nimport static org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.methodOn;\n\nLink self=linkTo(methodOn(controller_class.class)\n            .methodName(args))\n            .withSelfRel(); // or .withRel(String Link)\n</code></pre> <ul> <li><code>linkTo</code> \u2192 m\u00e8tode est\u00e0tic que crea un <code>Link</code> des de</li> <li><code>methodOn(class)</code> \u2192 cerca en una classe de controlador un m\u00e8tode</li> <li><code>.methodName(args)</code> \u2192 obt\u00e9 una crida real per a aquest m\u00e8tode</li> <li>I per etiquetar l'enlla\u00e7:</li> <li><code>.withSelfRel()</code> \u2192 crea un enlla\u00e7 anomenat <code>self</code></li> <li><code>.withRel(String Link)</code> \u2192 crea un enlla\u00e7 amb el nom donat.</li> </ul> <p>Exemples del nostre <code>Cliente controller</code> en la seg\u00fcent secci\u00f3 </p>"},{"location":"UD5_Spring/5_Spring_Hateoas/#31-self-links","title":"3.1. Self links","text":"Java<pre><code>ClienteDTO elCliente=clienteService.getClienteById(idCliente);\n\nLink self=linkTo(methodOn(ClienteController.class)\n            .showClienteById(elCliente.getIdCliente()))\n            .withSelfRel();\n</code></pre> <p>Aquest exemple:</p> <ul> <li>Carrega un <code>ClienteDTO</code> del <code>ClienteService</code> actual.</li> <li>Despr\u00e9s busca a la classe <code>ClienteController</code> un m\u00e8tode anomenat <code>showClienteById</code>.</li> <li>Fa una crida interna i cerca el cam\u00ed i vincula l'argument al cam\u00ed (recordes <code>@PathVariable</code>?)</li> <li>Finalment, obt\u00e9 el cam\u00ed (ruta) complet amb l'argument i l'emmagatzema en el Link amb la refer\u00e8ncia <code>self</code></li> </ul> <p>El resultat ser\u00e0 alguna cosa aix\u00ed:</p> JSON<pre><code>{\n  \"rel\": \"self\",\n  \"href\": \"http://localhost:9090/clientes/3\"\n}\n</code></pre>"},{"location":"UD5_Spring/5_Spring_Hateoas/#32-referenciant-links","title":"3.2. Referenciant links","text":"Java<pre><code>ClienteDTO elCliente=clienteService.getClienteById(idCliente);\n\nLink cuentas=linkTo(methodOn(CuentaController.class)\n                .listCuentasCliente(elCliente.getIdCliente()))\n                .withRel(\"listaCuentas\");\n</code></pre> <p>Aquest exemple:</p> <ul> <li>Carrega un <code>ClienteDTO</code> del <code>ClienteService</code> actual.</li> <li>Despr\u00e9s busca a la classe <code>CuentaController</code> un m\u00e8tode anomenat <code>listCuentasCliente</code>.</li> <li>Fa una crida interna i cerca el cam\u00ed i vincula l'argument al cam\u00ed (recordes <code>@PathVariable</code>?)</li> <li>Finalment, obt\u00e9 el cam\u00ed (ruta) complet amb l'argument i l'emmagatzema en el Link amb la refer\u00e8ncia <code>self</code></li> </ul> <p>El resultat ser\u00e0 alguna cosa aix\u00ed: JSON<pre><code>{\n  \"rel\": \"listaCuentas\",\n  \"href\": \"http://localhost:9090/clientes/3/cuentas\"\n}\n</code></pre></p>"},{"location":"UD5_Spring/5_Spring_Hateoas/#33-afegint-enllacos-al-nostre-envoltori-i-exemple-complet","title":"3.3. Afegint enlla\u00e7os al nostre envoltori i exemple complet","text":"<p>Un cop hem creat els enlla\u00e7os, necessitem afegir-los a la nostra \u00faltima classe envoltori. Simplement utilitzarem el m\u00e8tode <code>add()</code> per fer-ho. En el seg\u00fcent m\u00e8tode, es rep un embolcall <code>ClienteHATEOAS</code> (amb nom\u00e9s dades de <code>ClienteDTO</code>) i s'afegeixen tants enlla\u00e7os com vulguem:</p> Java<pre><code>private void addLinks(ClienteHATEOAS elCliente) {\n  // self\n  Link self=linkTo(methodOn(ClienteController.class)\n    .showClienteById(elCliente.getIdCliente()))\n    .withSelfRel();\n\n  elCliente.add(self);\n\n  // direcciones\n  Link direcciones=linkTo(methodOn(DireccionController.class)\n      .listDireccionesCliente(elCliente.getIdCliente()))\n      .withRel(\"listaDirecciones\");\n  elCliente.add(direcciones);\n\n  //cuentas\n  Link cuentas=linkTo(methodOn(CuentaController.class)\n      .listCuentasCliente(elCliente.getIdCliente()))\n      .withRel(\"listaCuentas\");\n  elCliente.add(cuentas);\n}\n</code></pre> <p>El m\u00e8tode del controlador per obtenir un <code>Cliente</code> ser\u00e0 (comentat):</p> Java<pre><code>@GetMapping(\"/clientes/{idCliente}\")\n  public ResponseEntity&lt;ClienteHATEOAS&gt; showClienteById(@PathVariable Long idCliente){\n\n    // obtenir DTO del Servei\n    ClienteDTO elCliente=clienteService.getClienteById(idCliente);\n\n    // si no existeix, retornar no trobat\n    if (elCliente==null)\n      return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND);\n    else {\n\n      // crear un ClienteHATEOAS a partir del DTO cridant el m\u00e8tode est\u00e0tic\n      ClienteHATEOAS returnCliente=ClienteHATEOAS.fromClienteDTO2HATEOAS(elCliente);\n\n      // afegir enlla\u00e7os a ClienteHATEOAS\n      addLinks(returnCliente);\n\n      // retornar    \n      return new ResponseEntity&lt;&gt;(returnCliente,HttpStatus.OK);\n    }\n  } \n</code></pre> <p>i el resultat ser\u00e0 alguna cosa aix\u00ed:</p> JSON<pre><code>{\n  \"idCliente\": 3,\n  \"nif\": \"33333333C\",\n  \"nombre\": \"Vicente\",\n  \"apellidos\": \"Mondrag\u00f3n\",\n  \"claveSeguridad\": \"1234\",\n  \"email\": \"vicente.mondragon@tia.es\",\n  \"links\": [\n    {\n      \"rel\": \"self\",\n      \"href\": \"http://localhost:9090/clientes/3\"\n    },\n    {\n      \"rel\": \"listaDirecciones\",\n      \"href\": \"http://localhost:9090/clientes/3/direcciones\"\n    },\n    {\n      \"rel\": \"listaCuentas\",\n      \"href\": \"http://localhost:9090/clientes/3/cuentas\"\n    }\n  ]\n}\n</code></pre>"},{"location":"UD5_Spring/5_Spring_Hateoas/#4-treball-pendent","title":"4. Treball pendent","text":"<p>Ara, fent una petici\u00f3 simple a un <code>Cliente</code> tenim acc\u00e8s a tota la informaci\u00f3 i seg\u00fcents accions disponibles en les dades de la resposta</p> <p>Aix\u00f2 permet al servidor poder evolucionar sense tindre que modificar eels clients que li fan peticions, ja que qualssevol modificaci\u00f3 sera inmediatamnet notificada als usuaris de les API en les pr\u00f2pies respostes.</p> <p>Ara et toca a tu completar el projecte desenvoluat afegint les classes necess\u00e0ries i afegint el HATEOAS als teus models.</p>"},{"location":"UD5_Spring/6_Postman_Swagger/","title":"6. Test. Postman i Swagger","text":""},{"location":"UD5_Spring/6_Postman_Swagger/#apendix-1-postman","title":"Ap\u00e8ndix 1: Postman.","text":"<p>Aquest \u00e9s un programari gratu\u00eft i, a trav\u00e9s de Postman, podem fer sol\u00b7licituds:</p> <ul> <li>GET, a una ruta, indicant els par\u00e0metres en totes les seves possibilitats, en la Query de la ruta, com a identificadors en la ruta.</li> <li>POST i PUT, permetent d'una manera molt c\u00f2moda editar els objectes JSON en el cos (Body) de la sol\u00b7licitud.</li> <li>DELETE, per realitzar eliminacions.</li> </ul> <p>Vegem com podem treballar amb les consultes a la nostra API acabada de crear. El primer pas a fer \u00e9s crear un espai de treball o Workspace, on afegirem les nostres sol\u00b7licituds.</p> <p></p> <p>Despr\u00e9s, podr\u00edem comen\u00e7ar a crear <code>http_request</code>:</p> <p></p> <p>podr\u00edem canviar el tipus de sol\u00b7licitud en el selector de l'esquerra:</p> <p></p> <p>podr\u00edem establir par\u00e0metres afegint <code>?name=value</code> en la sol\u00b7licitud.</p> <p></p> <p>I podem establir valors de variables en el cam\u00ed simplement afegint-los a la sol\u00b7licitud (com a text en el cam\u00ed). Recorda que aix\u00f2 correspon amb <code>PathVariable</code>.</p> <p></p> <p>Si volem enviar dades, en forma d'objecte JSON, com fan els formularis, hem de configurar dins del cos com a dades <code>raw</code> com a json en una sol\u00b7licitud POST o PUT:</p> <p></p> <p></p> <p>Finalment, aqu\u00ed tens una sol\u00b7licitud <code>DELETE</code>:</p> <p></p>"},{"location":"UD5_Spring/6_Postman_Swagger/#apendix-2-swagger","title":"Ap\u00e8ndix 2: Swagger","text":"<p>En aquesta p\u00e0gina https://www.baeldung.com/spring-rest-openapi-documentation pots trobar com afegir a la nostra pr\u00f2pia API un generador de peticions de manera simple. </p>"},{"location":"UD6_MongoDB/1_NoSQL/","title":"1. Bases de dades NoSQL","text":"Versi\u00f3 Data Notes Versi\u00f3 1.0 Gener 2023 Versi\u00f3 inicial Versi\u00f3 1.0 Desembre 2024 Traducci\u00f3 i canvis menors <p>\u00a9 Joan Gerard Camarena Estruch</p> <p>Aquests materials es basen en els apunts d'anys anteriors creats per Joan Gerard Camarena i Jose Alfredo Murcia</p> <p>El moviment NoSQL (Not Only SQL) contempla totes aquelles alternatives als sistemes de gesti\u00f3 de bases de dades relacionals tradicionals. Les bases de dades orientades a objectes podrien ser un primer enfocament a aquestes bases de dades NoSQL. No obstant aix\u00f2, hi ha altres models, amb un enfocament totalment diferent. Aquestes s\u00f3n bases de dades basades en documents, en parells clau-valor o en gr\u00e0fics.</p> <p>Encara que algunes de les caracter\u00edstiques plantejades per aquests paradigmes s'estan incorporant als est\u00e0ndards SQL i als SGBD relacionals, la realitat actual \u00e9s que aquest tipus de bases de dades est\u00e0 creixent considerablement en moltes \u00e0rees. A principis dels anys 2000, va sorgir el web 2.0, que va suposar la conversi\u00f3 dels usuaris en generadors de contingut. Posteriorment, amb el web 3.0 o web sem\u00e0ntica, Internet es converteix en una gran base de dades, i l'acc\u00e9s a aquesta ja no \u00e9s exclusiu de les aplicacions web, sin\u00f3 de tot tipus d'aplicacions i apps. Actualment, estem davant l'auge de la intel\u00b7lig\u00e8ncia artificial i el web 4.0, com una evoluci\u00f3 de tot l'anterior. Amb tot aix\u00f2, podem imaginar la gran quantitat de dades que els servidors han d'emmagatzemar, i que requereix un emmagatzematge m\u00e9s deslocalitzat, distribu\u00eft i suficientment eficient per suportar milions de consultes di\u00e0ries.</p> <p>En aquesta unitat ens centrarem en les bases de dades de tipus document, espec\u00edficament MongoDB, una base de dades basada en documents JSON, molt popular a la web.</p>"},{"location":"UD6_MongoDB/1_NoSQL/#11-tipus-de-bases-de-dades","title":"1.1. Tipus de bases de dades","text":"<p>Podem trobar</p> <ol> <li> <p>Bases de dades clau-valor \u2192 \u00c9s un model de base de dades bastant senzill i popular, on cada element s'identifica amb una clau \u00fanica, seguint el model de taula de hash, de manera que les dades es recuperen molt r\u00e0pidament. Els objectes generalment s'emmagatzemen com a objectes binaris (BLOBs). Algunes bases de dades d'aquest tipus s\u00f3n Cassandra (Apache), Bigtable (Google) o Dynamo (Amazon).</p> </li> <li> <p>Bases de dades documentals \u2192 Aquest model emmagatzema la informaci\u00f3 en forma de documents, generalment <code>XML</code> o <code>JSON</code>, i s'utilitza una clau \u00fanica per a cada registre, de manera que es permeten cerques clau-valor. La difer\u00e8ncia respecte a les bases de dades clau-valor anteriors \u00e9s que aqu\u00ed el valor \u00e9s el document en si mateix, no dades bin\u00e0ries. Com veurem m\u00e9s endavant, s\u00f3n molt vers\u00e0tils, de manera que ni tan sols necessitem tenir una estructura comuna per als documents que guardem. El m\u00e0xim exponent d'aquest tipus de base de dades \u00e9s MongoDB.</p> </li> <li> <p>Bases de dades en gr\u00e0fics \u2192 Un gr\u00e0fic \u00e9s un conjunt de v\u00e8rtexs o nodes units per arestes, que ens permeten representar relacions entre ells. Les bases de dades en gr\u00e0fics intenten seguir aquest model, de manera que la informaci\u00f3 es representa com a nodes en un gr\u00e0fic, i les relacions entre ells es representen per arestes. D'aquesta manera, aprofitant la teoria de gr\u00e0fics, podem rec\u00f3rrer la informaci\u00f3 de manera \u00f2ptima. Alguns exemples d'aquest tipus de base de dades s\u00f3n Amazon Neptune, JanusGraph (Apache), SQL Server (Microsoft) o Neo4j.</p> </li> </ol>"},{"location":"UD6_MongoDB/2_MongoDB/","title":"2. MongoDB","text":"<p>MongoDB \u00e9s una base de dades orientada a documents, basada en l'emmagatzematge de les seves estructures de dades en documents de tipus JSON amb un esquema din\u00e0mic. Tot i que va comen\u00e7ar a ser desenvolupada per l'empresa 10gen, avui en dia \u00e9s un projecte de codi obert, amb una gran comunitat d'usuaris.</p> <p>Un servidor MongoDB pot contenir diverses bases de dades, i cadascuna d'elles est\u00e0 formada per un conjunt de col\u00b7leccions, que podr\u00edem comparar amb les taules d'una base de dades relacional. Cada col\u00b7lecci\u00f3 emmagatzema un conjunt de documents JSON, formats per atributs clau-valor, que serien els registres d'una base de dades relacional.</p> <p>A grans trets, podr\u00edem establir les seg\u00fcents comparacions:</p> Model relacional MongoDB Base de dades relacional Base de dades orientada a documents Taula Col\u00b7lecci\u00f3 Registre/Fila Documents JSON Columnes i valors de la taula Parells Clau:Valor"},{"location":"UD6_MongoDB/2_MongoDB/#21-configuracio-i-primera-execucio","title":"2.1. Configuraci\u00f3 i primera execuci\u00f3","text":"<p>MongoDB cobreix una \u00e0mplia gamma de possibilitats, des de servidors de bases de dades locals fins a bases de dades al n\u00favol. Al seu lloc web https://www.mongodb.com, podem descobrir els diferents productes i serveis que s'ofereixen, entre els quals trobem:</p> <ul> <li>Servidor MongoDB, amb les seves dues versions, la Community, versi\u00f3 gratu\u00efta i comunit\u00e0ria, i l'Enterprise, la seva versi\u00f3 comercial orientada al m\u00f3n empresarial i amb caracter\u00edstiques addicionals que milloren el rendiment i el suport. A m\u00e9s del servidor en si, tamb\u00e9 s'ofereix el servidor preparat per a \u00fas en contenidors a trav\u00e9s d'operadors de Kubernetes. El servidor est\u00e0 disponible en diverses plataformes: Linux, Solaris, MacOS X i Windows.<ul> <li>Podem utilitzar el mongo shell o compass o Robo3T gr\u00e0fic com a client, instal\u00b7lat en el nostre sistema.</li> </ul> </li> <li>MongoDB Atlas, la plataforma MongoDB al n\u00favol (DBaaS o DataBase as a Service), que permet el seu desplegament en serveis com AWS, Azure o Google Cloud.</li> <li>Realm, un servei de dades dissenyat per a aplicacions m\u00f2bils i web, i que inclou, a m\u00e9s de DB al n\u00favol, diversos serveis de backend totalment gestionats.</li> </ul> <p>Utilitzarem, com a curs actual, tots els servidors a trav\u00e9s de contenidors docker. Podr\u00edem descarregar la imatge docker via:</p> Bash<pre><code>docker pull mongo\n</code></pre> <p>i llavors crear el contenidor amb:</p> Bash<pre><code>docker run --name mongodb-srv \n    -e MONGO_INITDB_ROOT_USERNAME=\"root\" \n    -e MONGO_INITDB_ROOT_PASSWORD=\"toor\" \n    -p 27017:27017 \n    -d mongo\n</code></pre> <p>Llavors ja podem connectar des de l'eina escollida</p>"},{"location":"UD6_MongoDB/3_ShellOperations/","title":"3. Treballant amb MongoDB: Operacions b\u00e0siques de shell","text":""},{"location":"UD6_MongoDB/3_ShellOperations/#31-colleccions-i-documents","title":"3.1. Col\u00b7leccions i Documents","text":"<p>Com ja sabem, la unitat b\u00e0sica d'informaci\u00f3 amb la qual treballa MongoDB \u00e9s el document, que seria l'equivalent a un registre en un model relacional. Aquests s\u00f3n documents JSON, formats per parells clau-valor, i que representen la informaci\u00f3 de manera for\u00e7a intu\u00eftiva. Els servidors de MongoDB, per la seva banda, emmagatzemaran aquestes dades en format BSON (Binary JSON), un format de serialitzaci\u00f3 bin\u00e0ria.</p> <p>Pel que fa als documents JSON per a MongoDB, cal tenir en compte alguns aspectes:</p> <ul> <li>Pel que fa a les claus:<ul> <li>No poden ser nul\u00b7les.</li> <li>Poden consistir en qualsevol car\u00e0cter UTF-8, excepte els car\u00e0cters <code>.</code> o <code>$</code>.</li> <li>S\u00f3n sensibles a maj\u00fascules i min\u00fascules.</li> <li>Han de ser \u00faniques dins del mateix document.</li> </ul> </li> <li>Pel que fa als valors:<ul> <li>Poden ser de qualsevol tipus perm\u00e8s.</li> </ul> </li> <li>Pel que fa al document:<ul> <li>Ha de tenir un camp <code>_id</code>, amb un valor \u00fanic, que actuar\u00e0 com a identificador del document.</li> <li>Si no especifiquem aquesta clau, MongoDB la generar\u00e0 autom\u00e0ticament, amb un objecte de tipus <code>ObjectId</code>.</li> </ul> </li> </ul> <p>Si els documents s\u00f3n l'equivalent als registres, les col\u00b7leccions s\u00f3n l'equivalent a les taules, amb la difer\u00e8ncia que les col\u00b7leccions tenen un esquema din\u00e0mic, amb el qual els documents de la mateixa col\u00b7lecci\u00f3 poden presentar claus o tipus de dades diferents entre ells.</p> <p>Els noms de les col\u00b7leccions estaran subjectes a les seg\u00fcents restriccions:</p> <ul> <li>No poden ser la cadena buida (<code>\"\"</code>), ni el car\u00e0cter <code>null</code>, ni contenir el s\u00edmbol <code>$</code>.</li> <li>Podem utilitzar el punt (<code>.</code>) en els noms de les col\u00b7leccions per afegir prefixos, per\u00f2 les col\u00b7leccions no es poden crear amb el prefix <code>system.</code>, ja que aquest s'utilitza per a col\u00b7leccions internes del sistema. Per exemple, <code>db.system.test</code> no seria v\u00e0lid, per\u00f2 <code>db.systema.test</code> s\u00ed que ho seria.</li> </ul>"},{"location":"UD6_MongoDB/3_ShellOperations/#32-operacions-basiques-amb-mongodb","title":"3.2. Operacions b\u00e0siques amb MongoDB","text":"<p>A continuaci\u00f3, veurem algunes de les operacions b\u00e0siques que podem realitzar a MongoDB:</p> <ul> <li><code>insertOne(document)</code> \u2192 Afegeix un document a la col\u00b7lecci\u00f3:<ul> <li><code>db.collection.insertOne({ a:1 })</code></li> </ul> </li> <li><code>insertMany(documents)</code> \u2192 Afegeix un conjunt de documents a la col\u00b7lecci\u00f3:<ul> <li><code>db.collection.insertMany([{ a:1 },{ a:2 },{ a:3,b:5 }])</code></li> </ul> </li> <li><code>find(criteria)</code> \u2192 Obt\u00e9 tots els documents d'una col\u00b7lecci\u00f3 que coincideixen amb el patr\u00f3 especificat.<ul> <li><code>db.collection.find({a:1})</code>. Tingueu en compte que el patr\u00f3 ser\u00e0 tamb\u00e9 un objecte JSON.</li> </ul> </li> <li><code>findOne(Criterion)</code> \u2192 Obt\u00e9 un element de la col\u00b7lecci\u00f3 que coincideix amb el patr\u00f3.<ul> <li><code>db.collection.findOne()</code></li> </ul> </li> <li><code>updateOne(Criterion, Operation, [options])</code> i <code>updateMany(Criterion, Operation, [options])</code> \u2192 Actualitza un (o diversos en el cas d'updateMany) documents de la col\u00b7lecci\u00f3. Requereix dos par\u00e0metres:<ul> <li>els criteris de cerca del document a actualitzar i</li> <li>l'operaci\u00f3 d'actualitzaci\u00f3.</li> <li>Admet un tercer par\u00e0metre opcional per a opcions.<ul> <li><code>db.collection.updateOne({a:1}, {$set: {a:2}})</code></li> </ul> </li> </ul> </li> <li><code>deleteOne(Criterion)</code> i <code>deleteMany(Criterion)</code> \u2192 Elimina els documents d'una col\u00b7lecci\u00f3 que coincideixen amb els criteris.<ul> <li><code>db.collection.deleteOne({a:1})</code></li> </ul> </li> </ul> <p>A les seg\u00fcents seccions aprofundirem en les diferents operacions.</p>"},{"location":"UD6_MongoDB/3_ShellOperations/#33-tipus-de-dades","title":"3.3. Tipus de dades","text":"<p>Els tipus de dades amb els quals treballa MongoDB s\u00f3n similars als que podem trobar en JavaScript i Java. MongoDB admet els tipus b\u00e0sics descrits a la taula seg\u00fcent:</p> <ul> <li><code>null</code> \u2192 Representa tant el valor nul com un camp que no existeix.</li> <li><code>boolean</code> \u2192 Permet els valors true i false.</li> <li><code>number</code> \u2192 Representa valors num\u00e8rics de punt flotant. Si volem utilitzar tipus enters o enters llargs, hem d'utilitzar les nostres pr\u00f2pies classes: NumberInt (32 bits) o NumberLong (64 bits).</li> <li><code>String</code> \u2192 Representa qualsevol cadena de text UTF-8 v\u00e0lida.</li> <li><code>Date</code> \u2192 Representa dates, expressades en mil\u00b7lisegons.</li> <li><code>array</code> \u2192 Llistes de valors que es representen com a vectors.</li> <li><code>Documents incrustats</code> \u2192 Els documents poden tenir altres documents incrustats en ells.</li> <li><code>ObjectId</code> \u2192 Aquest \u00e9s el tipus per defecte per als camps <code>_id</code>, i est\u00e0 dissenyat per generar f\u00e0cilment valors \u00fanics a nivell global.</li> </ul>"},{"location":"UD6_MongoDB/3_ShellOperations/#331-data","title":"3.3.1. Data","text":"<p>Mongo utilitza el tipus <code>Date</code> de JavaScript. Quan generem un nou objecte de tipus Date, hem d'utilitzar l'operador <code>New</code>, ja que en cas contrari obtindr\u00edem una representaci\u00f3 de la data en forma de cadena. Per exemple, si definim les variables <code>a</code> i <code>b</code> de la seg\u00fcent manera:</p> JavaScript<pre><code>test&gt; let a=Date()\n\ntest&gt; let b=new Date()\n</code></pre> <p>els resultats serien prou diferents:</p> JavaScript<pre><code>test&gt; a\nSun May 08 2022 06:46:01 GMT+0200 (Central European Summer Time)\ntest&gt; typeof(a)\nstring\n\ntest&gt;b\nISODate(\"2022-05-08T04:46:09.371Z\")\n\ntest&gt; typeof(b)\nobject\n</code></pre>"},{"location":"UD6_MongoDB/3_ShellOperations/#332-arrays","title":"3.3.2. Arrays","text":"<p>Els arrays es poden utilitzar per representar col\u00b7leccions ordenades, com llistes o cues, o col\u00b7leccions desordenades, com conjunts. Com en JavaScript, i a difer\u00e8ncia d'altres llenguatges, com Java, cada element del vector pot tenir un tipus de dada diferent, incloent-hi altres objectes de tipus vector.</p> <p>Vegem alguns exemples sobre vectors en JavaScript i, per tant, en MongoDB:</p> JavaScript<pre><code>// array creation\ntest&gt; let v={objetos: [\"casa\", 10, {texto: \"hola\"}, false] }\n\n// ask for objects components\ntest&gt; v\n{ objetos: [ 'casa', 10, { texto: 'hola' }, false ] }\n\ntest&gt; v.objetos\n[ 'casa', 10, { texto: 'hola' }, false ]\n\n// ask for array cells\ntest&gt; v.objetos[1]\n10 \n\ntest&gt; v.objetos[2]\n{ texto: 'hola' }\n\n// change values\ntest&gt; v.objetos[3]=!v.objetos[3]\ntrue \n\ntest&gt; v\n{ objetos: [ 'casa', 10, { texto: 'hola' }, true ] }\n</code></pre>"},{"location":"UD6_MongoDB/3_ShellOperations/#333-documents-incrustats","title":"3.3.3. Documents incrustats","text":"<p>Un parell clau-valor en un document pot tenir un altre document com a valor. Aix\u00f2 es coneix com a documents incrustats (embedded), i seria quan s'utilitza un objecte JSON dins d'un altre. Per exemple:</p> JavaScript<pre><code>&gt; let peli={ \n        titulo: \"Rogue One. A Star Wars Story.\",\n        anyo: 2016,\n      director: {\n          nombre: \"Gareth\",\n          apellidos:  \"Edwards\",\n          anyo_nacimiento: 1975,\n          nacionalidad: \"brit\u00e1nica\"\n      }\n   }\n</code></pre> <p>Com podem veure, el document en si mateix cont\u00e9 informaci\u00f3 sobre la pel\u00b7l\u00edcula i el seu director. En un model relacional, normalment tindr\u00edem dues taules relacionades entre si. En aquest cas, \u00e9s possible que si volem mantenir informaci\u00f3 espec\u00edfica sobre els directors, acabem amb informaci\u00f3 redundant.</p>"},{"location":"UD6_MongoDB/3_ShellOperations/#334-que-son-els-objectids","title":"3.3.4. Que s\u00f3n els OBjectIds?","text":"<p>La classe ObjectId utilitza 12 bytes, organitzats de la seg\u00fcent manera:</p> <p></p> <ul> <li>Timestamp (bytes 0-3) \u2192 La marca de temps en segons des de l'1 de gener de 1970.</li> <li>Machine ID (bytes 4-6) \u2192 Identificador \u00fanic de la m\u00e0quina, normalment un hash del seu hostname.</li> <li>PID (bytes 7-8) \u2192 Identificador del proc\u00e9s que genera l'ObjectID, per garantir la unicitat dins de la mateixa m\u00e0quina.</li> <li>Increment (bytes 9-11) \u2192 Valor auto-incremental, per garantir la unicitat en el mateix segon, m\u00e0quina i proc\u00e9s.</li> </ul> <p>Com podem veure, \u00e9s un mecanisme m\u00e9s robust que un camp auto-incremental com en MySQL. Aix\u00f2 correspon a la naturalesa distribu\u00efda de MongoDB, de manera que els objectes es poden generar en un entorn multi-host.</p>"},{"location":"UD6_MongoDB/3_ShellOperations/#34-afegint-informacio-a-les-colleccions","title":"3.4. Afegint informaci\u00f3 a les col\u00b7leccions","text":"<p>La manera natural d'afegir elements a la base de dades \u00e9s a trav\u00e9s dels diferents m\u00e8todes d'inserci\u00f3, disponibles en totes les col\u00b7leccions.</p>"},{"location":"UD6_MongoDB/3_ShellOperations/#341-insertone","title":"3.4.1. <code>insertOne()</code>","text":"<p>Permet inserir un document a la col\u00b7lecci\u00f3. Per exemple, per inserir l'objecte peli creat a la secci\u00f3 anterior, podem fer:</p> JavaScript<pre><code>test&gt; db.misPelis.insertOne(peli)\n{\n    acknowledged: true,\n    insertedId: ObjectId(\"6277510ab54867b80b742ddf\")\n}\n</code></pre> <p>Com podem veure, la resposta \u00e9s un document JSON que cont\u00e9 un valor boole\u00e0 que indica si l'operaci\u00f3 ha estat exitosa, i un ObjectID, amb l'ID assignat autom\u00e0ticament.</p> <p>Important</p> <p>Tingueu en compte:</p> <ul> <li>Si la col\u00b7lecci\u00f3 a la qual afegim un document no existeix, es crear\u00e0 autom\u00e0ticament.</li> <li>Pel que fa al camp <code>_id</code>, com podem veure, es va generar autom\u00e0ticament. No obstant aix\u00f2, podem indicar aquest identificador, sense que sigui de tipus ObjectId, l'\u00fanica restricci\u00f3 \u00e9s que sigui \u00fanic, per evitar duplicats.</li> <li>No hem utilitzat cap esquema per a la col\u00b7lecci\u00f3, ja que cada document que inserim pot tenir un esquema diferent.</li> </ul>"},{"location":"UD6_MongoDB/3_ShellOperations/#342-insertmany","title":"3.4.2. <code>insertMany()</code>","text":"<p>Permet afegir diversos documents a una col\u00b7lecci\u00f3. Aleshores, hem de proporcionar un array de documents:</p> JavaScript<pre><code>// we create three objects\ntest&gt; let peli2={titulo: \"Star Wars. A new Hope\", anyo: 1977};\ntest&gt; let peli3={titulo: \"Empire Strikes Back\", anyo: 1981};\ntest&gt; let peli4={titulo: \"Return of the Jedi\", anyo: 1984};\n\n// insert them, in array way\ntest&gt; db.misPelis.insertMany([peli2, peli3, peli4])\n{\n  acknowledged: true,\n  insertedIds: {\n'0': ObjectId(\"627759a5b54867b80b742de0\"),\n'1': ObjectId(\"627759a5b54867b80b742de1\"),\n'2': ObjectId(\"627759a5b54867b80b742de2\")\n  }\n}\n</code></pre> <p>Important</p> <p>Si es produeix un error durant la inserci\u00f3, ni el document que provoca l'error ni els documents seg\u00fcents s'inseriran a la col\u00b7lecci\u00f3.</p>"},{"location":"UD6_MongoDB/3_ShellOperations/#35-eliminant-informacio","title":"3.5. Eliminant informaci\u00f3","text":"<p>Per eliminar documents d'una col\u00b7lecci\u00f3 utilitzarem les ordres <code>deleteOne()</code>, <code>deleteMany()</code> o <code>findOneAndDelete()</code>, proporcionant-los com a par\u00e0metre un JSON amb una condici\u00f3 que volem que compleixin el document o documents a eliminar.</p> <ul> <li>L'ordre deleteOne nom\u00e9s eliminar\u00e0 el primer element que coincideixi amb els criteris, aix\u00ed que si volem eliminar un document espec\u00edfic, hem d'utilitzar criteris que corresponguin a identificadors \u00fanics, com el <code>_id</code>.</li> <li>L'ordre deleteMany eliminar\u00e0 tots els documents que coincideixin amb els criteris.</li> </ul> <p>Tant <code>deleteOne</code> com <code>deleteMany</code> retornen un document amb un boole\u00e0, indicant si l'operaci\u00f3 s'ha realitzat, aix\u00ed com el nombre d'elements eliminats (deletedCount).</p> <p>Per la seva banda, findOneAndDelete tamb\u00e9 elimina un document, basant-se en criteris de selecci\u00f3 i ordenaci\u00f3, per\u00f2 tamb\u00e9 retornant el document que ha estat eliminat.</p> <p>Per exemple, creem una col\u00b7lecci\u00f3 amb diversos elements:</p> JavaScript<pre><code>db.pruebas.insertMany([{x:1}, {x:2}, {x:3}, {x:4}, {x:5}, {x:6}, {x:7}]);\n\n// to delete one document\ntest&gt; db.pruebas.deleteOne({})\n{ acknowledged: true, deletedCount: 1 }\n\n// as no confition is set, is satisfied by all documents, \n// then first document will be deleted\n\n// to delete several documents, for instance its x's value greather than 3\ntest&gt; db.pruebas.deleteMany({x:{$gt:3}})\n{ acknowledged: true, deletedCount: 4 }\n\n// delete and return a document\ntest&gt; db.pruebas.findOneAndDelete({x:2})\n{ _id: ObjectId(\"6277687fb54867b80b742deb\"), x: 2 }\n</code></pre> <p>Si volem eliminar tots els documents d'una col\u00b7lecci\u00f3, podr\u00edem utilitzar l'ordre <code>drop</code> en lloc d'aix\u00f2, per\u00f2 cal anar amb molta cura, ja que tamb\u00e9 eliminar\u00e0 alguna metainformaci\u00f3.</p> JavaScript<pre><code>test&gt; db.pruebas.drop() \n</code></pre>"},{"location":"UD6_MongoDB/3_ShellOperations/#36-actualitzacio-de-documents","title":"3.6. Actualitzaci\u00f3 de documents","text":"<p>Per actualitzar documents, podem optar per actualitzacions de reempla\u00e7ament, utilitzant el m\u00e8tode <code>replaceOne()</code>, o fer modificacions als documents existents, utilitzant els m\u00e8todes <code>updateOne()</code>, <code>updateMany()</code> i <code>findOneAndUpdate()</code>. Aquests m\u00e8todes rebran dos arguments: el primer ser\u00e0 els criteris o condicions que han de complir els documents a actualitzar, i el segon ser\u00e0 un document amb el nou document o les actualitzacions a aplicar.</p>"},{"location":"UD6_MongoDB/3_ShellOperations/#361-actualitzacio-de-reemplacament-replace","title":"3.6.1. Actualitzaci\u00f3 de reempla\u00e7ament (replace)","text":"<p>L'operaci\u00f3 de reempla\u00e7ament, com el seu nom indica, reempla\u00e7a un document sencer que compleix els criteris d'actualitzaci\u00f3 amb un altre document nou. Per exemple, creem una nova col\u00b7lecci\u00f3 de calendaris, per emmagatzemar contactes, amb informaci\u00f3 sobre tel\u00e8fons:</p> <p>JavaScript<pre><code>test&gt; db.agenda.insertOne({nombre:\"Jose\", telefonos:[{trabajo:\"55512345\", casa:\"555111222\"}]}\n)\n{\n  acknowledged: true,\n  insertedId: ObjectId(\"627783dbb54867b80b742df8\")\n}\n</code></pre> Com podem veure, aquest m\u00e8tode retorna el <code>_id</code> de l'objecte, a trav\u00e9s del qual podrem identificar aquest document de manera inequ\u00edvoca. Aix\u00ed, podr\u00edem reempla\u00e7ar aquest document per un altre mitjan\u00e7ant:</p> JavaScript<pre><code>test&gt; db.agenda.replaceOne({\"_id\":ObjectId(\"62778439b54867b80b742df9\")},\n  {nombre: \"Jose\", \n  correos:[{trabajo: \"jose@empresa.com\"}, \n  {personal: \"jose@proveedor.com\"}]} )\n\n// and the response is\n{\n  acknowledged: true,\n  insertedId: null,\n  matchedCount: 1,\n  modifiedCount: 1,\n  upsertedCount: 0 \n}\n</code></pre> <p>Com podem veure, es tracta de reempla\u00e7ar tot el document, amb la qual cosa podem fins i tot modificar la seva estructura.</p> <p>Com hem anticipat, les modificacions es realitzen utilitzant els m\u00e8todes <code>updateOne()</code>, <code>updateMany()</code> i <code>findOneAndUpdate()</code>. Similar a les operacions d'eliminaci\u00f3, el m\u00e8tode <code>updateOne()</code> modificar\u00e0 nom\u00e9s el primer document que coincideixi amb els criteris donats i el m\u00e8tode <code>updateMany()</code>, tots aquells que coincideixin amb els criteris. Per la seva banda, el m\u00e8tode <code>findOneAndUpdate()</code> modifica el document i retorna el document original per defecte, tot i que aix\u00f2 \u00e9s configurable a trav\u00e9s d'opcions.</p>"},{"location":"UD6_MongoDB/3_ShellOperations/#3611-modificadors","title":"3.6.1.1. Modificadors","text":"<p>Els modificadors s\u00f3n claus especials que ens permeten especificar operacions d'actualitzaci\u00f3 m\u00e9s complexes. Normalment, no necessitarem reempla\u00e7ar tot el document, com en el cas anterior, sin\u00f3 afegir o modificar camps espec\u00edfics:</p> <ul> <li><code>$set</code> \u2192 Assigna un valor a un camp del document. Si no existeix, el crear\u00e0.<ul> <li><code>db.collection.updateOne({criteri}, {$set: {camp:valor} });</code></li> </ul> </li> <li><code>$unset</code> \u2192 Elimina un camp d'un o m\u00e9s documents. Com que necessitem introduir un parell clau-valor, afegirem un boole\u00e0 com a valor.<ul> <li><code>db.collection.updateMany({criteri}, {$unset: {camp:true} });</code></li> </ul> </li> <li><code>$inc</code> \u2192 Incrementa o decrementa el valor num\u00e8ric d'una clau (no es refereix a l'identificador), creant-ne una de nova si no existeix.<ul> <li><code>db.collection.updateOne({criteri}, {$inc: {camp:increment} });</code></li> </ul> </li> <li><code>$push</code> \u2192 Afegeix elements a un array. Si l'array no existeix, el crea amb els elements que indiquem en el push, mentre que si ja existeix, els afegeix al final d'aquest.<ul> <li><code>db.collection.update({criteri}, {$push: {nom_array:{llista_de_valors} } });</code></li> </ul> </li> <li><code>$pull</code> \u2192 Elimina elements d'un array basant-se en algun criteri.<ul> <li><code>db.collection.update({criteri},{$pull:{vector:element}})</code>.</li> </ul> </li> <li><code>$pop</code> \u2192 Elimina elements d'un array tractat com una pila o cua, \u00e9s a dir, eliminant el primer (-1) o \u00faltim (1) element.<ul> <li><code>db.collection.update({criteri},{$pop:{vector: [ -1 | 1 ] }})</code></li> </ul> </li> </ul> <p>Information</p> <p>Aquests modificadors funcionen tant amb <code>updateOne</code> com amb <code>updateMany</code>.</p>"},{"location":"UD6_MongoDB/3_ShellOperations/#3612-upserts","title":"3.6.1.2. Upserts","text":"<p>Quan no es troba cap document que coincideixi amb els criteris per a una actualitzaci\u00f3, com \u00e9s d'esperar, no es produeix cap canvi a la col\u00b7lecci\u00f3. D'altra banda, de vegades, podem desitjar que si un document amb certs criteris no existeix quan volem modificar-lo, es cre\u00ef. Aix\u00f2 s'aconsegueix a trav\u00e9s d'actualitzacions especials, anomenades <code>upserts</code>. Amb aquesta operaci\u00f3, ens estalviem de buscar primer a la col\u00b7lecci\u00f3 per saber si hem de realitzar una operaci\u00f3 d'inserci\u00f3 (si no existeix) o de modificaci\u00f3 (si existeix).</p> <p>Per realitzar un upsert, utilitzarem el tercer argument de les actualitzacions, que consisteix en un document amb diferents opcions en format clau-valor, afegint la clau upsert a true.</p> JavaScript<pre><code>db.collection.updateOne({criteria},{modification}, {upsert:true});\n</code></pre>"},{"location":"UD6_MongoDB/4_Queries/","title":"4. Consultese en Mongo","text":""},{"location":"UD6_MongoDB/4_Queries/#41-find","title":"4.1. find()","text":"<p>La comanda find ens permet recuperar els documents d'una col\u00b7lecci\u00f3 que coincideixen amb un criteri especificat com a document JSON. La seva sintaxi b\u00e0sica \u00e9s la seg\u00fcent:</p> <p>JavaScript<pre><code>db.collection.find({criteria_in_JSON_format});\n</code></pre> Hem de tenir en compte aspectes com els tipus de dades que utilitzem, que \u00e9s important, ja que el document <code>{edad:20}</code> no \u00e9s el mateix que <code>{edad:\"20\"}</code>.</p> <p>D'altra banda, tamb\u00e9 hem de considerar que el document buit <code>{}</code> coincideix amb tots els documents, de manera que la consulta  <code>db.collection.find({})</code> retornaria tots els objectes de la col\u00b7lecci\u00f3.</p>"},{"location":"UD6_MongoDB/4_Queries/#411-quines-claus-recuperar","title":"4.1.1. Quines claus recuperar?","text":"<p>La comanda find retorna els documents complets que coincideixen amb els criteris de selecci\u00f3. Si no volem obtenir totes les claus, podem especificar quines claus volem consultar, incloent-les en un segon par\u00e0metre:</p> JavaScript<pre><code>db.collection.find({query_document}, {key_1:1, key_2:1});\n</code></pre> <p>Com podem veure, aquest segon par\u00e0metre tamb\u00e9 s'expressa en format JSON (de nou) i est\u00e0 format per dues claus (<code>key_1</code> i <code>key_2</code>), ambdues amb un valor d'1. Aquest valor num\u00e8ric tamb\u00e9 s'interpreta com a <code>true</code>. \u00c9s a dir, especifiquem aqu\u00ed quins s\u00f3n els camps que volem mostrar. En cas que vulguem mostrar tots els camps i amagar-ne alguns, utilitzar\u00edem la mateixa sintaxi, per\u00f2 ara fent servir un 0 per aquells camps que volem amagar.</p>"},{"location":"UD6_MongoDB/4_Queries/#412-operacions-de-comparacio","title":"4.1.2. Operacions de comparaci\u00f3","text":"<p>MongoDB ens permet realitzar comparacions amb dades num\u00e8riques, sempre utilitzant el format de document JSON  <code>db.collection.find({key: {$operator:value} });</code></p> <p>Els operadors de comparaci\u00f3 que podem utilitzar a MongoDB s\u00f3n:</p> <ul> <li><code>$lt</code> \u2192 Menor que</li> <li><code>$lte</code> \u2192 Menor o igual que</li> <li><code>$gt</code> \u2192 Major que</li> <li><code>$gte</code> \u2192 Major o igual que</li> </ul>"},{"location":"UD6_MongoDB/4_Queries/#413-operacio-or","title":"4.1.3. Operaci\u00f3 OR","text":"<p>Si volem realitzar un filtre o consulta on es compleixin diverses condicions (una operaci\u00f3 AND), nom\u00e9s haurem de separar-les per comes en el mateix document JSON que utilitzem com a criteri. D'altra banda, si el que volem \u00e9s dur a terme una operaci\u00f3 OR, hem d'utilitzar un operador especial.</p>"},{"location":"UD6_MongoDB/4_Queries/#414-operadors-in-i-nin","title":"4.1.4. Operadors <code>$IN</code> i <code>$NIN</code>","text":"<p>Un cas especial d'OR \u00e9s quan volem comprovar si un camp es troba dins d'un conjunt espec\u00edfic de valors. \u00c9s a dir, si \u00e9s un valor o un altre. Per aix\u00f2 utilitzem l'operador <code>$in</code>, de la seg\u00fcent manera:</p> JavaScript<pre><code>db.collection.find({key:{$in:[vector_de_valors]}})\n</code></pre> <p>De manera similar, existeix l'operador <code>$nin</code> (Not In), que obt\u00e9 els documents on el valor especificat no es troba a la llista. Hem de tenir en compte que en aquest \u00faltim cas tamb\u00e9 es mostraran aquells documents que tinguin un valor nul per a la clau.</p>"},{"location":"UD6_MongoDB/4_Queries/#415-operador-or","title":"4.1.5. Operador <code>$OR</code>","text":"<p>Quan volem realitzar l'operaci\u00f3 OR en diferents camps del document, utilitzarem l'operador <code>$OR</code>, al qual passem un vector de possibles condicions, de la seg\u00fcent manera:</p> JavaScript<pre><code>db.collection.find({$or:[condition1, condition2,...]})\n</code></pre> <p>Attention</p> <p>Les condicions del array son condicions en json</p>"},{"location":"UD6_MongoDB/4_Queries/#416-operador-not","title":"4.1.6. Operador <code>$NOT</code>","text":"<p>L'operador <code>$NOT</code> \u00e9s un operador metacondicional, \u00e9s a dir, sempre s'aplica a un altre criteri, invertint el seu valor de certesa. La seva sintaxi seria:</p> JavaScript<pre><code>db.collection.find({key:{$not: {criterion}}}).pretty();\n</code></pre>"},{"location":"UD6_MongoDB/4_Queries/#417-operador-exists","title":"4.1.7. Operador <code>$EXISTS</code>","text":"<p>Recordem que en MongoDB, els documents no tenen una estructura o esquema com\u00fa, per la qual cosa \u00e9s possible que hi hagi claus definides nom\u00e9s en alguns d'ells. L'operador <code>$exists</code> s'utilitza per comprovar l'exist\u00e8ncia o no d'una determinada clau. La sintaxi a utilitzar seria:</p> JavaScript<pre><code>db.collection.find({key:{ $exists: true|false }})\n</code></pre> <p>Amb aix\u00f2 obtenim els documents per als quals la clau existeix o no, depenent de si hem indicat true o false a la consulta.</p>"},{"location":"UD6_MongoDB/4_Queries/#42-resultats-de-les-consultes-i-tipus-de-dades","title":"4.2. Resultats de les consultes i tipus de dades","text":"<p>Els tipus de dades a MongoDB poden tenir alguns comportaments especials. Veurem alguns casos per saber qu\u00e8 fer en determinades situacions.</p>"},{"location":"UD6_MongoDB/4_Queries/#421-valors-nulls","title":"4.2.1. valors nulls","text":"<p>El valor null coincideix amb les seg\u00fcents situacions:</p> <ul> <li>Quan el valor de la clau \u00e9s null, o</li> <li>Quan la clau no existeix en el document (en aquest cas, normalment es diu que el camp no est\u00e0 informat)</li> </ul>"},{"location":"UD6_MongoDB/4_Queries/#422-expressions-regulars-i-cadenes-de-caracters","title":"4.2.2. Expressions regulars i cadenes de car\u00e0cters","text":"<p>Quan apliquem un filtre de document per un camp de text, pot ser que no coneguem exactament el valor del camp pel qual volem filtrar. Les expressions regulars ofereixen un mecanisme molt potent per a la coincid\u00e8ncia de cadenes.</p> <p>MongoDB ens permet utilitzar aquestes expressions de diverses maneres, ja sigui utilitzant expressions regulars de Javascript o utilitzant l'operador <code>$regex</code>, que utilitza Expressions Regulars Compatibles amb Perl (PCRE). Les expressions regulars de Javascript s'expressen utilitzant la seg\u00fcent sintaxi:</p> JavaScript<pre><code>{ key: /pattern/&lt;options&gt; }\n</code></pre> <p>Com podem veure, utilitzem un patr\u00f3 similar a una cadena de text, per\u00f2 utilitzant la barra inclinada <code>/</code> com a delimitador en lloc de les cometes (<code>'</code>). Per la seva banda, si utilitzem l'operador <code>$regex</code>, podem utilitzar la seg\u00fcent sintaxi:</p> JavaScript<pre><code>{ key: { $regex: /pattern/, $options: '&lt;options&gt;' } }\n{ key: { $regex: 'pattern', $options: '&lt;options&gt;' } }\n{ key: { $regex: /pattern/&lt;options&gt; } }\n</code></pre> <p>Podem trobar diverses opcions per a expressions regulars:</p> <ul> <li><code>i</code> \u2192 Les coincid\u00e8ncies no distingeixen entre maj\u00fascules i min\u00fascules:<ul> <li><code>{name:/john/i}</code></li> <li><code>{name: { $regex: 'john',$options: 'i'}}</code></li> </ul> </li> <li><code>m</code> \u2192 Permet incloure car\u00e0cters com <code>^</code> o <code>$</code>, per coincidir al principi o al final, en cadenes amb m\u00faltiples l\u00ednies.<ul> <li><code>{name:/^John/m}</code></li> <li><code>{name: { $regex: 'John', $options: 'm'}}</code></li> </ul> </li> <li><code>x</code> Ignora els espais en blanc en el patr\u00f3 <code>$regex</code>, sempre que no estiguin escapats o inclosos en una classe de car\u00e0cters.<ul> <li><code>{name: { $regex: ' J oh n',$options: 'x'}}</code></li> </ul> </li> <li><code>s</code> Permet que el car\u00e0cter punt (<code>.</code>) representi qualsevol car\u00e0cter, incloent el car\u00e0cter de nova l\u00ednia.<ul> <li><code>{name:/ju.n/s}</code></li> <li><code>{name: { $regex: 'thu.n',$options: 's'}}</code></li> </ul> </li> </ul> <p>Podeu trobar m\u00e9s informaci\u00f3 sobre expressions regulars i casos particulars en qu\u00e8 es recomana utilitzar un tipus d'expressi\u00f3 o una altra en la documentaci\u00f3 oficial de MongoDB sobre <code>$regex</code> aqu\u00ed.</p>"},{"location":"UD6_MongoDB/4_Queries/#43-consideracions-sobre-el-tipus-de-dades-de-les-consultes","title":"4.3. Consideracions sobre el tipus de dades de les consultes","text":""},{"location":"UD6_MongoDB/4_Queries/#431-consultes-amb-arrays","title":"4.3.1. Consultes amb arrays","text":"<p>Per cercar elements coincidents dins d'un array, procedim amb la mateixa sintaxi com si fos qualsevol altra clau, utilitzant el document de consulta <code>{key:value}</code>, sent la clau un array, i el valor, ja sigui un n valor que ha de contenir l'array, o un altre vector ordenat que volem que coincideixi exactament.</p> <p>Per exemple:</p> <ul> <li><code>db.collection.find({ my_vector : value })</code> \u2192 Coincideix amb tots els documents en els quals el vector <code>my_vector</code> apareix, en la posici\u00f3 que sigui, el valor indicat.<ul> <li><code>db.users.find({roles:\"admin\"})</code> mostra els usuaris que en l'array <code>roles</code> tenen el rol admin (o altres).</li> </ul> </li> <li><code>db.collection.find({ my_vector : [value] })</code> \u2192 Coincideix amb tots els documents en els quals el vector <code>my_vector</code> apareix nom\u00e9s el valor indicat.<ul> <li><code>db.users.find({roles:[\"admin\"]})</code> mostra els usuaris que tenen exactament el rol admin.</li> </ul> </li> </ul> <p>A m\u00e9s, tamb\u00e9 podem utilitzar expressions regulars o la resta d'operadors que hem vist com a condicions.</p> <p>D'altra banda, tamb\u00e9 podem referir-nos a un element espec\u00edfic del vector pel seu \u00edndex, utilitzant la notaci\u00f3 de punts i entre cometes:</p> <ul> <li><code>db.collection.find({\"my_vector.position\" :[value]})</code><ul> <li><code>db.users.find({\"roles.2\":[\"admin\"]})</code> mostra l'usuari que t\u00e9 com a tercer rol admin</li> </ul> </li> </ul>"},{"location":"UD6_MongoDB/4_Queries/#432-loperador-all","title":"4.3.2. L'operador <code>$all</code>","text":"<p>Amb <code>$all</code> podem especificar m\u00e9s d'un element coincident dins de l'array:</p> <ul> <li><code>db.collection.find({ my_vector : {$all:[value1, value2,...]}})</code><ul> <li><code>db.users.find({roles:{$all:[\"mod\",\"admin\"]}})</code> mostra els usuaris que tenen els rols mod i admin (i possiblement altres).</li> </ul> </li> </ul>"},{"location":"UD6_MongoDB/4_Queries/#433-loperador-size","title":"4.3.3. L'operador <code>$size</code>","text":"<p>Utilitzant <code>$size</code> podem incloure condicions sobre la longitud dels vectors:</p> <ul> <li><code>db.collection.find({ my_vector : {$size:size} })</code></li> </ul>"},{"location":"UD6_MongoDB/4_Queries/#434-loperador-slice","title":"4.3.4. L'operador <code>$slice</code>","text":"<p>L'operador slice ens permet obtenir un subconjunt dels elements del vector, amb la seg\u00fcent sintaxi:</p> <ul> <li><code>key: {$slice: x}</code>:<ul> <li>si x&gt;0 obt\u00e9 els primers x elements</li> <li>si x&lt;0, obt\u00e9 els \u00faltims x elements</li> </ul> </li> <li><code>key: {$slice: [ x , y ] }</code> Obt\u00e9n y elements des de l'element a la posici\u00f3 x del document embegut</li> </ul> <p>Per consultar documents embeguts, simplement especifiqueu el cam\u00ed complet de la clau, tancat entre cometes i separat per punts: <code>db.collection.find({\"path.to.key\":value_or_condition})</code></p>"},{"location":"UD6_MongoDB/4_Queries/#44-cursors","title":"4.4. Cursors","text":"<p>Quan realitzem una consulta, MongoDB retorna els resultats utilitzant cursos, que s\u00f3n punters als resultats de la consulta, com connectors a la unitat 2. Els clients que utilitzen Mongo iteren sobre aquests cursos per recuperar els resultats, i ofereixen un conjunt de funcionalitats, com limitar els resultats, etc.</p> <p>Quan realitzem una consulta en una base de dades amb molts resultats, el client (<code>mongosh</code>) retorna nom\u00e9s 20 resultats i el missatge <code>Type \"it\" for more</code>, per continuar iterant el cursor.</p>"},{"location":"UD6_MongoDB/4_Queries/#441-limit-skip-i-sort","title":"4.4.1. Limit, Skip i Sort","text":"<p>MongoDB ens permet fer certes limitacions en els resultats. Entre elles, podem destacar:</p> <ul> <li><code>limit</code> \u2192 Per limitar el nombre de resultats</li> <li><code>skip</code> \u2192 Salta un nombre espec\u00edfic de resultats.</li> <li><code>sort</code> \u2192 Ordena els resultats. Necessites un objecte JSON amb les claus per ordenar, i un valor de 1 per ordenar ascendentment o -1 per ordenar descendentment.</li> </ul>"},{"location":"UD6_MongoDB/4_Queries/#45-introduccio-al-marc-dagrupacio","title":"4.5. Introducci\u00f3 al Marc d'Agrupaci\u00f3","text":"<p>Les consultes d'agrupaci\u00f3 que realitz\u00e0vem amb operadors com <code>GROUP BY</code>, <code>SUM</code> o <code>COUNT</code> en SQL es poden realitzar amb el Marc d'Agrupaci\u00f3 de MongoDB. Les consultes d'agrupaci\u00f3 tenen la seg\u00fcent sintaxi:</p> JavaScript<pre><code>db.collection.aggregate( [&lt;pipeline&gt;] )\n</code></pre> <p>El pipeline o tuberia t\u00e9 un concepte similar a les tiberies d'Unix: els resultats d'una ordre es passen com a entrada a una altra, per obtenir resultats conjuntament.</p> <p>Les operacions que podem realitzar dins d'aquestes consultes d'agrupaci\u00f3 s\u00f3n:</p> <ul> <li><code>$project</code> \u2192 Per realitzar una projecci\u00f3 sobre un conjunt de dades d'entrada, afegint, eliminant o recalculant camps perqu\u00e8 la sortida sigui diferent.</li> <li><code>$match</code> \u2192 Filtra l'entrada per reduir el nombre de documents, deixant nom\u00e9s aquells que compleixen certes condicions.</li> <li><code>$limit</code> \u2192 Restringeix el nombre de resultats.</li> <li><code>$skip</code> \u2192 Salta un cert nombre de registres.</li> <li><code>$unwind</code> \u2192 Converteix un array per retornar-lo separat en documents.</li> <li><code>$group</code> \u2192 Agrupa documents segons una certa condici\u00f3.</li> <li><code>$sort</code> \u2192 Ordena un conjunt de documents, segons el camp especificat.</li> <li><code>$geoNear</code>\u2192 S'utilitza com a dades geoespacials, retornant els documents ordenats per proximitat segons un punt geoespacial.</li> </ul> <p>Per realitzar c\u00e0lculs sobre les dades produ\u00efdes per les canonades, utilitzarem expressions. Les expressions s\u00f3n funcions que realitzen una certa operaci\u00f3 sobre un grup de documents, vector o camp espec\u00edfic. Algunes d'aquestes expressions s\u00f3n <code>$max</code>, <code>$min</code>, <code>$divide</code> o <code>$substr</code>.</p> <p>Podeu trobar molta m\u00e9s informaci\u00f3 sobre agregacions a la documentaci\u00f3 oficial de MongoDB.</p>"},{"location":"UD6_MongoDB/4_Queries/#46-exercicis","title":"4.6. Exercicis","text":"<p>Seguim treballant amb la col\u00b7lecci\u00f3 de pel\u00b7l\u00edcules. En aquest cas, utilitzarem el terminal mongosh (o robo3t si ho prefereixes), i realitzarem les seg\u00fcents consultes sobre aquesta col\u00b7lecci\u00f3.</p> <ol> <li>Obteniu totes les produccions que es van estrenar el <code>2015</code> o que s\u00f3n del tipus <code>s\u00e8rie</code>.</li> <li>Obteniu totes les pel\u00b7l\u00edcules que NO es van estrenar entre els anys <code>2000</code> i <code>2002</code>.</li> <li>Obteniu totes les pel\u00b7l\u00edcules per a les quals la clau \"directors\" no est\u00e0 definida.</li> <li>Obteniu el t\u00edtol de totes les pel\u00b7l\u00edcules que comencen amb la cadena <code>star wars</code>, independentment de maj\u00fascules o min\u00fascules.</li> <li>Obteniu el t\u00edtol de totes les pel\u00b7l\u00edcules que contenen el g\u00e8nere com\u00e8dia (<code>Comedy</code>).</li> <li>Mostreu el t\u00edtol i els g\u00e8neres de les pel\u00b7l\u00edcules que contenen el g\u00e8nere com\u00e8dia (<code>Comedy</code>) o aventura (<code>Adventure</code>).</li> <li>Obteniu el t\u00edtol i els g\u00e8neres de les pel\u00b7l\u00edcules que tenen tres g\u00e8neres.</li> <li>Obteniu les pel\u00b7l\u00edcules amb una qualificaci\u00f3 de <code>Rotten Tomatoes</code> superior a <code>4</code>.</li> <li>Feu la mateixa consulta que abans, per\u00f2 limitant el nombre de documents a 10.</li> <li>Ara mostreu el t\u00edtol i la qualificaci\u00f3 d'aquelles pel\u00b7l\u00edcules amb una qualificaci\u00f3 superior a 4, ordenades per qualificaci\u00f3 (de m\u00e9s alta a m\u00e9s baixa) i limitant els resultats a 10.</li> </ol>"},{"location":"UD6_MongoDB/5_Mongo_Java/","title":"5. MongoDB i Java","text":"<p>Anem a veure com accedir a MongoDB des dels nostres programes Java. Primerament, com vam veure a la unitat 2, estudiarem com accedir directament  i despr\u00e8s des de ORM.</p>"},{"location":"UD6_MongoDB/5_Mongo_Java/#51-drivers","title":"5.1. Drivers","text":"<p>Com ja sabem, per connectar des de les nostres aplicacions a una base de dades necessitem un controlador o driver. MongoDB ofereix drivers oficials per a una multitud de plataformes, incloent C, C++, C#, NodeJS, Python, i per descomptat, Java, entre molts altres.</p> <p>Focalitzant-nos en Java, MongoDB ens ofereix dos drivers:</p> <ul> <li>El driver Java per a aplicacions s\u00edncrones.</li> <li>El driver de Reactive Streams per al processament de Streams as\u00edncrons.</li> </ul> <p>Encara que actualment hi ha una tend\u00e8ncia cap a la programaci\u00f3 reactiva, treballarem amb el driver Java s\u00edncron per facilitar la comprensi\u00f3 i centrar-nos en l'acc\u00e9s real a les dades.</p>"},{"location":"UD6_MongoDB/5_Mongo_Java/#511-el-driver-java","title":"5.1.1. El driver Java","text":"<p>Utilitzant el MongoDB Driver per a Java podem connectar tant a una base de dades local o remota, com a un cl\u00faster de MongoDB Atlas. Aquest driver (MongoDB Java Driver) es pot trobar als repositoris Maven, i proporciona un gran nombre de classes i interf\u00edcies per facilitar el treball amb MongoDB des de Java.</p> <p>En un projecte Gradle haur\u00edem d'utilitzar:</p> Bash<pre><code>implementation group: 'org.mongodb', name: 'mongo-java-driver', version: '3.12.10'\n</code></pre> <p>mentre que en un projecte Maven:</p> XML<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.mongodb&lt;/groupId&gt;\n    &lt;artifactId&gt;mongo-java-driver&lt;/artifactId&gt;\n    &lt;version&gt;3.12.10&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"UD6_MongoDB/5_Mongo_Java/#52-connexio-a-una-base-de-dades","title":"5.2. Connexi\u00f3 a una base de dades","text":"<p>Per connectar i comunicar-nos amb una base de dades necessitem un client. En el cas del driver de Java per a MongoDB, el client s'implementa a trav\u00e9s de la classe <code>MongoClient</code>.</p> <p>La classe <code>MongoClient</code> representa un conjunt de connexions a un servidor MongoDB. Aquestes connexions s\u00f3n segures per a fils, \u00e9s a dir, diversos fils d'execuci\u00f3 poden accedir-hi de manera segura.</p> <p>La manera de crear inst\u00e0ncies de <code>MongoClient</code> \u00e9s a trav\u00e9s del m\u00e8tode <code>MongoClients.create()</code>. A m\u00e9s, generalment, nom\u00e9s necessitem una inst\u00e0ncia d'aquesta classe, fins i tot en aplicacions multi-fil. El m\u00e8tode <code>MongoClients.create</code> pren com a argument una <code>Connection String</code>, amb el seg\u00fcent format simplificat (els par\u00e0metres entre claud\u00e0tors s\u00f3n opcionals):</p> Bash<pre><code>mongodb:// [usuari:contrasenya @] host[:port] /?opcions\n</code></pre> <p>Aix\u00ed, una manera d'obtenir, per exemple, una connexi\u00f3 al servidor local seria:</p> Java<pre><code>String uri = \"mongodb://localhost:27017\";\nMongoClient mongoClient = MongoClients.create(uri);\n</code></pre> <p>La classe MongoClient, entre altres, suporta els seg\u00fcents m\u00e8todes:</p> <ul> <li><code>getDatabase(String name)</code> \u2192 Obt\u00e9 una refer\u00e8ncia a una base de dades el nom de la qual es passa com a argument.</li> <li><code>listDatabaseNames()</code> \u2192 Obt\u00e9 una llista de Strings (interf\u00edcie <code>MongoIterable</code>) amb els noms de les bases de dades del servidor.</li> <li><code>close()</code> \u2192 Tanca la connexi\u00f3 amb el servidor. Sempre s'ha de fer quan ja no es vagi a utilitzar.</li> </ul>"},{"location":"UD6_MongoDB/5_Mongo_Java/#521-mongodatabase","title":"5.2.1. MongoDatabase","text":"<p>El m\u00e8tode <code>getDatabase()</code> de la classe <code>MongoClient</code> retorna una refer\u00e8ncia a un objecte que implementa la interf\u00edcie <code>MongoDatabase</code>, que representa una connexi\u00f3 a una base de dades. Aquesta interf\u00edcie defineix els seg\u00fcents m\u00e8todes:</p> <ul> <li><code>getCollection(String name)</code> \u2192 Obt\u00e9 una refer\u00e8ncia a la col\u00b7lecci\u00f3.</li> <li><code>listCollectionNames()</code> \u2192 Obt\u00e9 una llista de Strings (interf\u00edcie <code>MongoIterable</code>) amb els noms de les col\u00b7leccions de la base de dades.</li> <li><code>listCollections()</code> \u2192 Obt\u00e9 una llista de refer\u00e8ncies (<code>MongoCollection</code>) a les col\u00b7leccions de la base de dades.</li> <li><code>createCollection(String name)</code> \u2192 Crea una nova col\u00b7lecci\u00f3 amb el nom especificat a la base de dades.</li> <li><code>drop()</code> \u2192 Elimina la base de dades.</li> </ul> <p>Aqu\u00ed trobar\u00e0s un exemple de connexi\u00f3 i llistat de bases de dades i col\u00b7leccions d'un servidor donat:</p> Java<pre><code>public MongoClient connectServer(){\n  String uri = \"mongodb://root:toor@localhost:27017\";\n  MongoClient mongoClient = MongoClients.create(uri);\n  return mongoClient;\n}\n\npublic void disConnect(MongoClient client){\n  client.close();\n}\n\npublic void getInfo(MongoClient client) {\n  // get list of databases\n  for (String dbname : client.listDatabaseNames()) {\n      // Write its name\n      System.out.println(\"Database: \" + dbname);\n\n      // Get a database reference\n      MongoDatabase db = client.getDatabase(dbname);\n\n      // Get database collections\n      MongoIterable&lt;String&gt; colecciones = db.listCollectionNames();\n\n      // show collections name\n      for (String coleccion : colecciones) {\n          System.out.println(\"\\t\\t &gt; \" + coleccion);\n      }\n  }\n}\n</code></pre>"},{"location":"UD6_MongoDB/5_Mongo_Java/#53-consultes","title":"5.3. Consultes","text":"<p>El m\u00e8tode <code>getCollection()</code> de <code>MongoDatabase()</code> ens proporciona una col\u00b7lecci\u00f3 de <code>Document</code> (<code>MongoCollection&lt;Document&gt;</code>), sobre la qual podrem realitzar consultes utilitzant el m\u00e8tode <code>find()</code>. Aquest m\u00e8tode, que ja coneixem del shell de MongoDB, ens permetr\u00e0 filtrar documents basant-nos en certs criteris.</p> <p>Aquests criteris s'expressen com a filtres (query filters en la documentaci\u00f3), i poden contenir diversos operadors de consulta sobre alguns camps que determinaran quins documents de la col\u00b7lecci\u00f3 s'inclouen com a resultats.</p> <p>La classe <code>Filter</code> ens proporciona m\u00e8todes de f\u00e0brica per realitzar aquestes consultes, de manera similar a com treball\u00e0vem amb el shell de MongoDB. Aquesta classe ens ofereix:</p> <ul> <li>Consulta buida, amb <code>Filters.empty()</code>.</li> <li>Operadors de comparaci\u00f3: Per realitzar consultes basades en valors de la col\u00b7lecci\u00f3:<ul> <li><code>Filters.eq(key, value)</code>, <code>Filters.gt(key, value)</code>, <code>Filters.gte(key, value)</code>, <code>Filters.lt(key, value)</code> o <code>Filters.lte(key, value)</code>.</li> </ul> </li> <li>Operadors l\u00f2gics: Per realitzar operacions l\u00f2giques sobre el resultat d'altres consultes: <code>Filter.and(other_filters)</code>, <code>Filter.or(other_filters)</code>, etc.</li> <li>Operadors d'array: Permeten realitzar consultes basades en el valor o nombre d'elements d'un vector: <code>Filters.size(vector, size)</code>.</li> <li>Altres operadors, com <code>Filter.exists()</code> o <code>Filter.regex()</code>, per comprovar l'exist\u00e8ncia d'una clau o realitzar una cerca amb expressi\u00f3 regular.</li> </ul> <p>A m\u00e9s dels filtres, tamb\u00e9 podrem incloure operacions d'agregaci\u00f3, a trav\u00e9s del m\u00e8tode <code>aggregate()</code> d'una inst\u00e0ncia de <code>MongoCollection</code>. Pots consultar la documentaci\u00f3 sobre agregacions a la guia d'operacions d'agregaci\u00f3 de MongoDB.</p> <p>D'altra banda, l'API del driver de MongoDB tamb\u00e9 ens permet realitzar projeccions de camps utilitzant la classe <code>Projections</code>, que ofereix els m\u00e8todes <code>Projections.fields()</code>, <code>Projections.include()</code> o <code>Projections.excludeID()</code>.</p> <p>Exemple de cerca de pel\u00b7l\u00edcules d'un any donat, nom\u00e9s 10 resultats:</p> Java<pre><code>public void getPelisAnyo(MongoClient client, int anyo) {\n\n    // get collection from database\n    MongoDatabase db=client.getDatabase(\"mflix\");\n\n    // get documents from that colection\n    MongoCollection&lt;Document&gt; colPelis = db.getCollection(\"movies\");\n\n    // And now, we apply a filter and limit\n    FindIterable&lt;Document&gt; docsPelis = colPelis\n            .find(Filters.eq(\"year\", anyo))\n            .limit(10);\n\n    // we show it\n    for (Document doc : docsPelis) {\n        System.out.println(doc.toString());\n    }\n}\n</code></pre> <p>Recorda</p> <p>La classe <code>Document</code> t\u00e9 diversos m\u00e8todes per treballar com a documents JSON a la unitat 1. Podem obtenir cada camp donada una clau, obtenint el seu valor.</p> <p>Un altre exemple amb filtres i projeccions:</p> Java<pre><code>public void getPelisEntre(MongoClient client, int anyo1, int anyo2) {\n\n    // check anyo values\n    if (anyo1&gt;anyo2){\n        int tmp=anyo1;\n        anyo1=anyo2;\n        anyo2=tmp;\n    }\n\n    // get document collection\n    MongoDatabase db=client.getDatabase(\"mflix\");\n    MongoCollection&lt;Document&gt; colPelis = db.getCollection(\"movies\");\n\n    // Creamos el filtro\n    Bson filter=Filters.and(\n        Filters.gte(\"year\", anyo1),\n        Filters.lte(\"year\", anyo2)\n    );\n\n    // Create projecction\n    Bson projection=Projections\n            .fields(Projections.include(\"title\", \"year\"),\n                    Projections.excludeId());\n\n    // Run the filters\n    FindIterable&lt;Document&gt; DocsPelis = colPelis\n            .find(filter)\n            .projection(projection);\n\n    // Show the films\n    for (Document doc : DocsPelis) {\n        System.out.println(doc.toString());\n    }\n}\n</code></pre>"},{"location":"UD6_MongoDB/6_Spring_MongoDB/","title":"6. Spring Data MongoDB i API REST","text":"<p>Com sabem, el projecte Spring Data, incl\u00f2s a la plataforma Spring, proporciona un marc per simplificar l'acc\u00e9s i la persist\u00e8ncia de dades en diferents repositoris d'informaci\u00f3. Dins d'aquest projecte hi ha Spring Data MongoDB, que proporciona integraci\u00f3 amb bases de dades MongoDB, a trav\u00e9s d'un model centrat en POJOs que interactuen amb col\u00b7leccions de documents i proporciona un repositori d'acc\u00e9s a dades.</p> <p>En aquesta secci\u00f3, i continuant amb la unitat anterior, abordarem el desenvolupament de components d'acc\u00e9s a dades a trav\u00e9s de Spring Data, aix\u00ed com microserveis que ofereixen aquestes dades a trav\u00e9s d'una API REST, tot aix\u00f2 seguint el patr\u00f3 MVC que ja coneixem.</p>"},{"location":"UD6_MongoDB/6_Spring_MongoDB/#61-definint-el-model-document","title":"6.1. Definint el Model \u2013 Document","text":"<p>Una base de dades MongoDB est\u00e0 composta per col\u00b7leccions de <code>Document</code>. Tot i que aquests Documents poden tenir estructures diferents entre si o diferents tipus de dades, el model requereix una estructura est\u00e0tica. Aix\u00ed doncs, el primer que hem de fer \u00e9s crear una classe que representi aquest Document Principal per a MongoDB, que ser\u00e0 el que es retornar\u00e0 per les consultes que es facin.</p> <p>En aquest context, hi ha dues anotacions principals que utilitzarem:</p> <ul> <li><code>@Document</code> \u2192 per indicar que una classe correspon a un objecte de domini (domain object) que es pot mapar a la base de dades per oferir persist\u00e8ncia. Aquesta anotaci\u00f3 per a MongoDB seria l'equivalent a <code>@Entity</code> en JPA. Si no s'indica res, el nom de la col\u00b7lecci\u00f3 que s'utilitzar\u00e0 s'interpretar\u00e0 com a corresponent al nom de la classe en min\u00fascules. Aix\u00ed, si tenim la classe <code>com.jaume.ad.Person</code>, s'utilitzar\u00e0 la col\u00b7lecci\u00f3 <code>person</code>. No obstant aix\u00f2, podem indicar la col\u00b7lecci\u00f3 amb la qual estem treballant, ja sigui a trav\u00e9s dels atributs value o collection, amb la seg\u00fcent sintaxi:<ul> <li><code>@Document(value=\"collection\")</code></li> <li><code>@Document(\"collection\")</code></li> <li><code>@Document(collection=\"collection\")</code></li> </ul> </li> <li><code>@Id</code> S'aplica a un camp, i s'utilitza per indicar que el camp s'utilitzar\u00e0 com a identificador. Com sabem, cada document a MongoDB requereix un identificador. Si no se'n proporciona cap, el controlador assignar\u00e0 un <code>ObjectID</code> autom\u00e0ticament. \u00c9s important tenir en compte que els tipus de dades que podem utilitzar com a identificadors poden ser tant <code>Strings</code> com <code>BigInteger</code>, ja que Spring s'encarregar\u00e0 de convertir-los al tipus ObjectID.</li> </ul> <p>Important</p> Text Only<pre><code>Existeix una anotaci\u00f3 `@DocumentReference` per relacionar Documents un dins d'altres, per exemple quan emmagatzemem en una classe objectes d'altres classes, com les relacions en bases de dades SQL.\n</code></pre> <p>A m\u00e9s d'aquestes, hi ha altres anotacions m\u00e9s espec\u00edfiques que podem utilitzar. Si ho desitgeu, podeu consultar-les a la documentaci\u00f3 de refer\u00e8ncia de Spring Data MongoDB aqu\u00ed.</p>"},{"location":"UD6_MongoDB/6_Spring_MongoDB/#62-definint-el-repositori","title":"6.2. Definint el Repositori","text":"<p>Com sabem, el repositori \u00e9s la interf\u00edcie encarregada de gestionar l'acc\u00e9s a les dades. En el cas de MongoDB, aquest derivar\u00e0 de <code>MongoRepository</code>, que ser\u00e0 una interf\u00edcie parametritzada per dos arguments:</p> <ul> <li><code>MongoRepository&lt;T, Id&gt;</code>, on:<ul> <li><code>T</code> \u2192 El tipus de document, que correspondr\u00e0 a la classe definida al model, i</li> <li><code>Id</code>\u2192 El tipus de dada al qual pertanyer\u00e0 l'identificador.</li> </ul> </li> </ul> <p>La interf\u00edcie MongoRepository, com hem dit, ser\u00e0 espec\u00edfica per a MongoDB, i derivar\u00e0 de les interf\u00edcies <code>CrudRepository</code> i <code>PagingAndSortingRepository</code>, de les quals heretar\u00e0 tots els seus m\u00e8todes. D'aquesta manera, al repositori nom\u00e9s haurem de declarar aquells m\u00e8todes que siguin m\u00e9s espec\u00edfics per a la nostra aplicaci\u00f3, ja que tots els m\u00e8todes per implementar operacions CRUD, aix\u00ed com <code>findAll()</code> i <code>findById()</code> seran heretats de <code>MongoRepository</code>.</p> <p>Per definir les nostres pr\u00f2pies consultes al repositori, utilitzarem l'anotaci\u00f3 <code>@Query</code>, proporcionant la consulta en q\u00fcesti\u00f3 com a valor:</p> Java<pre><code>@Query(value=\"{ parameterized_query}\")   // respecte a la classe base del repositori\nList&lt;DocumentType&gt; methodName(list_parameters);\n</code></pre> <p>Per subministrar par\u00e0metres a la consulta, aquests es reben com a arguments del m\u00e8tode, i es referencien pel seu ordre a la consulta: <code>?0</code> per al primer argument, <code>?1</code> per al segon, etc. Potser en versions m\u00e9s noves es poden utilitzar par\u00e0metres de manera nominal, com <code>:parameter_name</code>.</p>"},{"location":"UD6_MongoDB/6_Spring_MongoDB/#63-definint-el-servei","title":"6.3. Definint el servei","text":"<p>Els serveis s'encarreguen de la capa de negoci de la nostra aplicaci\u00f3, i accedeixen a les dades a trav\u00e9s del repositori, enviant els resultats al controlador. Aquests serveis, en general, es caracteritzen per:</p> <ul> <li>Utilitzar les anotacions <code>@Service</code>, per indicar a Spring que s'est\u00e0 implementant un servei</li> <li>D'una banda, es defineix la interf\u00edcie del Servei i, d'altra banda, es realitza la implementaci\u00f3 a trav\u00e9s de la classe <code>ServiceImpl</code>.</li> <li>S'utilitza l'anotaci\u00f3 <code>@Autowired</code> en refer\u00e8ncies a repositoris per enlla\u00e7ar o injectar el servei en q\u00fcesti\u00f3 amb aquest repositori.</li> <li>Un cop obt\u00e9 les dades del repositori, les envia al controlador.</li> </ul>"},{"location":"UD6_MongoDB/6_Spring_MongoDB/#64-definint-el-controlador","title":"6.4. Definint el controlador","text":"<p>Finalment, ens queda la implementaci\u00f3 del controlador, que ja coneixem de Spring. Recordem les caracter\u00edstiques principals d'aquest:</p> <ul> <li>Utilitzar l'anotaci\u00f3 <code>@RestController</code> a nivell de classe per indicar que es tracta d'un controlador REST</li> <li>Utilitzar l'anotaci\u00f3 <code>@RequestMapping</code> a nivell de classe per especificar el cam\u00ed base per als punts finals del servei,</li> <li>Utilitzar l'anotaci\u00f3 <code>@Autowired</code> a les propietats que fan refer\u00e8ncia al servei, per injectar-lo autom\u00e0ticament,</li> <li>Utilitzar les anotacions <code>@GetMapping</code>, <code>@PostMapping</code>, <code>@PutMapping</code>, <code>@DeleteMapping</code> als m\u00e8todes que implementaran sol\u00b7licituds de tipus GET, POST, PUT o DELETE, especificant el seu Endpoint.</li> <li>Utilitzar les anotacions <code>@PathVariable</code> o <code>@RequestParam</code> o <code>@RequestBody</code> als arguments dels m\u00e8todes anteriors per obtenir els valors del cam\u00ed, sol\u00b7licitud o cos.</li> </ul>"},{"location":"UD6_MongoDB/6_Spring_MongoDB/#2-swagger","title":"2. Swagger","text":"<p>Fins ara, estem provant la nostra API REST amb Postman, per\u00f2 ara oferim una eina que s'integra amb Spring i Tomcat per provar la nostra API de manera r\u00e0pida i senzilla.</p> <p>Swagger (https://swagger.io) \u00e9s molt senzill de comen\u00e7ar:</p> <ol> <li>Afegir depend\u00e8ncies.</li> <li>Afegir una classe de configuraci\u00f3, que escaneja els nostres controladors per trobar quins punts d'entrada estan definits.</li> <li>Crear autom\u00e0ticament una interf\u00edcie d'usuari, que mostra quins punts d'entrada estan definits i eines per provar-los.</li> </ol>"},{"location":"UD6_MongoDB/6_Spring_MongoDB/#21-dependencia","title":"2.1. Depend\u00e8ncia","text":"<p>Has d'afegir al teu <code>pom.xml</code>:</p> XML<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.springfox&lt;/groupId&gt;\n    &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;\n    &lt;version&gt;2.9.2&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"UD6_MongoDB/6_Spring_MongoDB/#22-classe-de-configuracio","title":"2.2. Classe de configuraci\u00f3","text":"<p>Necessitem crear una classe com aquesta:</p> Java<pre><code>package com.jaumeii.moviesapi.swagger;\n\nimport java.util.Collections;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\nimport springfox.documentation.service.Contact;\nimport springfox.documentation.builders.PathSelectors;\nimport springfox.documentation.builders.RequestHandlerSelectors;\n\nimport springfox.documentation.service.ApiInfo;\nimport springfox.documentation.spi.DocumentationType;\nimport springfox.documentation.spring.web.plugins.Docket;\nimport springfox.documentation.swagger2.annotations.EnableSwagger2;\n\n@Configuration\n@EnableSwagger2\npublic class SwaggerConfig {\n\n    @Bean\n    public Docket apiDocket() {\n        return new Docket(DocumentationType.SWAGGER_2)\n                .select()\n                .apis(RequestHandlerSelectors.basePackage(\"com.jaumeii.moviesapi.controller\"))\n                .paths(PathSelectors.any())\n                .build()\n                .apiInfo(getApiInfo());\n    }\n\n    private ApiInfo getApiInfo() {\n        return new ApiInfo(\n                \"Movies controller\",\n                \"Eines per provar l'API de pel\u00b7l\u00edcules\",\n                \"1.0\",\n                \"http://www.ieseljust.com\",\n                new Contact(\"admin\", \"https://ieseljust.com\", \"admin@ieseljust.com\"),\n                \"LICENSE\",\n                \"LICENSE URL\",\n                Collections.emptyList()\n                );\n    }\n}\n</code></pre> <p>Cal implementar dos m\u00e8todes:</p> <ul> <li><code>Docket apiDocket()</code> \u2192 que crea un <code>Docket</code>. Aquest <code>Docket</code> cont\u00e9 refer\u00e8ncies per treballar i provar la nostra API</li> <li><code>ApiInfo getApiInfo()</code> \u2192 que crea un <code>ApiInfo</code>, i com el seu nom indica, \u00e9s informaci\u00f3 b\u00e0sica sobre per a qu\u00e8 s'ha creat aquesta API.</li> </ul> <p>Atenci\u00f3</p> Text Only<pre><code>En l'exemple tenim els nostres controladors definits a `com.jaumeii.moviesapi.controller`, i \u00e9s tot el que podr\u00edem fer.\n</code></pre>"},{"location":"UD6_MongoDB/6_Spring_MongoDB/#23-proves","title":"2.3. Proves","text":"<p>Quan el nostre projecte Spring s'inicia, podem veure la informaci\u00f3 del registre:</p> Text Only<pre><code>2023-01-29 08:37:16.400  INFO 61951 --- [  restartedMain] pertySourcedRequestMappingHandlerMapping : Mapped URL path [/v2/api-docs] onto method [springfox.documentation.swagger2.web.Swagger2Controller#getDocumentation(String, HttpServletRequest)]\n</code></pre> <p>Aix\u00f2 significa que tenim un nou punt d'entrada <code>/v2/api-docs</code>. Si provem aquest punt d'entrada, obtenim alguna cosa aix\u00ed:</p> JavaScript<pre><code>    \"swagger\": \"2.0\",\n    \"info\": {\n        \"description\": \"Eines per provar l'API de pel\u00b7l\u00edcules\",\n        \"version\": \"1.0\",\n        \"title\": \"Movies controller\",\n        \"termsOfService\": \"http://www.ieseljust.com\",\n        \"contact\": {\n            \"name\": \"admin\",\n            \"url\": \"https://ieseljust.com\",\n            \"email\": \"admin@ieseljust.com\"\n        },\n        \"license\": {\n            \"name\": \"LICENSE\",\n            \"url\": \"LICENSE URL\"\n        }\n    },\n    \"host\": \"localhost:8080\",\n    \"basePath\": \"/\",\n    \"tags\": [\n        {\n            \"name\": \"movie-controller\",\n            \"description\": \"Movie Controller\"\n        }\n    ],\n    \"paths\": {\n        \"/api/v1/movie/byNumDirectors/{how_many}\": {\n            \"get\": {\n                \"tags\": [\n                    \"movie-controller\"\n                ],\n                \"summary\": \"findByYear\",\n                \"operationId\": \"findByYearUsingGET\",\n                \"produces\": [\n                    \"*/*\"\n    ...\n</code></pre> <p>\u00c9s un document JSON que descriu la nostra API. Per\u00f2 per treballar de manera c\u00f2moda, podem sol\u00b7licitar <code>/swagger-ui.html</code>, i obtenim:</p> <p></p> <p>Aquesta p\u00e0gina d'interf\u00edcie d'usuari cont\u00e9 la informaci\u00f3 b\u00e0sica que hem establert al m\u00e8tode <code>getApiInfo()</code>. A la part inferior podem veure m\u00e9s elements. Si obrim, obtenim:</p> <p></p> <p>Podem veure informaci\u00f3 sobre els punts d'entrada i els models que retorna l'API. A m\u00e9s, podem entrar a cada punt d'entrada per obtenir informaci\u00f3 sobre els par\u00e0metres, i finalment executar-lo.</p>"},{"location":"UD6_MongoDB/6_Spring_MongoDB/#3-apendix-solucio-a-lexercici-sobre-consultes-mongo","title":"3. Ap\u00e8ndix. Soluci\u00f3 a l'exercici sobre consultes mongo","text":"<ol> <li>Obteniu totes les produccions que es van estrenar el <code>2015</code> o s\u00f3n del tipus <code>series</code>.</li> </ol> <p>Consell</p> Text Only<pre><code>Necessitem utilitzar l'operador `$or`, amb una matriu de condicions.\n</code></pre> JavaScript<pre><code>db.movies.find({$or:[{year:2015}, {type:\"series\"}]})\n</code></pre> <ol> <li>Obteniu totes les pel\u00b7l\u00edcules NO estrenades entre els anys <code>2000</code> i <code>2002</code>.</li> </ol> <p>Consell</p> Text Only<pre><code>Necessitem utilitzar l'operador `$not`, amb una condici\u00f3 per negar.\n</code></pre> JavaScript<pre><code>db.movies.find({year:{$not: {$gte: 2000, $lte: 2002}}}).pretty();\n</code></pre> <ol> <li>Obteniu totes les pel\u00b7l\u00edcules per a les quals la clau \"directors\" no est\u00e0 definida.</li> </ol> <p>Consell</p> Text Only<pre><code>Necessitem utilitzar l'operador `$exists` o comprovar un camp `null`.\n</code></pre> JavaScript<pre><code>db.movies.find({directors:{$exists:false}})\n\nor\n\ndb.movies.find({directors:null})\n</code></pre> <ol> <li>Obteniu el t\u00edtol de totes les pel\u00b7l\u00edcules que comencen amb la cadena <code>star wars</code>, independentment de maj\u00fascules.</li> </ol> <p>Consell</p> Text Only<pre><code>\u00c9s interessant utilitzar expressions regulars. Recordeu utilitzar l'opci\u00f3 `i` per incloure una comprovaci\u00f3 no sensible a maj\u00fascules.\n</code></pre> JavaScript<pre><code>db.movies.find({\"title\":/^star wars/i},{title:1})\n\nor\n\ndb.movies.find({\"title\": {$regex:'^star wars', $options:'i'}},{title:1})\n</code></pre> <ol> <li>Obteniu el t\u00edtol de totes les pel\u00b7l\u00edcules que contenen el g\u00e8nere com\u00e8dia (<code>Comedy</code>).</li> </ol> <p>Consell</p> Text Only<pre><code>Busquem a la matriu `genres` un g\u00e8nere donat.\n</code></pre> JavaScript<pre><code>db.movies.find({genres:\"Comedy\"}, {genres:1})\n</code></pre> <ol> <li>Mostreu el t\u00edtol i els g\u00e8neres de les pel\u00b7l\u00edcules que contenen el g\u00e8nere com\u00e8dia (<code>Comedy</code>) o aventura (<code>Adventure</code>).</li> </ol> <p>Consell</p> Text Only<pre><code>Necessitem provar que la pel\u00b7l\u00edcula compleix `$all` els g\u00e8neres donats.\n</code></pre> JavaScript<pre><code>db.movies.find(\n    {genres:{ $all: [\"Comedy\", \"Adventure\"]}},\n    {title:1, genres:1})\n</code></pre> <ol> <li>Obteniu el t\u00edtol i els g\u00e8neres de les pel\u00b7l\u00edcules que tenen tres g\u00e8neres.</li> </ol> <p>Consell</p> Text Only<pre><code>Busquem una matriu `genres` amb tres g\u00e8neres: operador `$size`.\n</code></pre> JavaScript<pre><code>db.movies.find({ genres : {$size:3} }, {title: 1, genres:1})\n</code></pre> <ol> <li>Obteniu les pel\u00b7l\u00edcules amb una qualificaci\u00f3 de <code>Rotten Tomatoes</code> superior a <code>4</code>.</li> </ol> <p>Consell</p> Text Only<pre><code>Necessitem comprovar dins de documents incrustats, mitjan\u00e7ant notaci\u00f3 de punts dins d'una cadena.\n</code></pre> JavaScript<pre><code>db.movies.find({\"tomatoes.viewer.rating\":{$gt:4}})\n</code></pre> <ol> <li>Feu la mateixa consulta que abans, per\u00f2 limitant el nombre de documents a 10.</li> </ol> <p>Consell</p> Text Only<pre><code>Necessitem `limitar` els resultats.\n</code></pre> JavaScript<pre><code>db.movies.find({\"tomatoes.viewer.rating\":{$gt:4}}).limit(10)\n</code></pre> <ol> <li>Ara mostreu el t\u00edtol i la qualificaci\u00f3 d'aquestes pel\u00b7l\u00edcules amb una qualificaci\u00f3 superior a 4, ordenades per qualificaci\u00f3 (de m\u00e9s alta a m\u00e9s baixa) i limitant els resultats a 10.</li> </ol> <p>Consell</p> Text Only<pre><code>I ara afegint un filtre d'ordenaci\u00f3.\n</code></pre> JavaScript<pre><code>db.movies.find(\n        {\"tomatoes.viewer.rating\":{$gt:4}},\n        {title:1, \"tomatoes.viewer.rating\":1})\n        .sort({\"tomatoes.viewer.rating\":-1})\n        .limit(10)\n</code></pre>"},{"location":"en/about/","title":"About me","text":"<p>Joan Gerard Camarena Estruch</p> <p>Abstract TO-DO</p>"},{"location":"en/","title":"Data Access","text":""},{"location":"en/#multiplatform-applications-development","title":"Multiplatform Applications Development","text":""},{"location":"en/#2024-2025","title":"2024 - 2025","text":"<p>Teacher:</p> <ul> <li>Joan Gerard Camarena Estruch jg.camarenaestruch at edu.gva.es</li> </ul>"},{"location":"en/license/","title":"License","text":"<p>This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.</p> <p>You are free to:</p> <ul> <li>Share \u2014 copy and redistribute the material in any medium or format</li> <li>Adapt \u2014 remix, transform, and build upon the material</li> </ul> <p>Under the following terms:</p> <ul> <li>Attribution \u2014 You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use.</li> <li>NonCommercial \u2014 You may not use the material for commercial purposes.</li> <li>ShareAlike \u2014 If you remix, transform, or build upon the material, you must distribute your contributions under the same license as the original.</li> </ul> <p>For more details, please refer to the full license text at https://creativecommons.org/licenses/by-nc-sa/4.0/legalcode.</p>"},{"location":"en/Practiques/APAC1/","title":"1. Environment and program execution","text":"<p>In this first Data Access CEPA (Continuous Evaluation Practice Activity), we are going to implement the file persistence part of a geometric figures project partially done.</p> <p>You are provided with a compressed file with the APAC1_AD Gradle project, with the figure hierarchy implementation and various utilities. The project has been created with <code>gradle init</code>, which creates a small structure of directories and files for us, such as the <code>gradlew</code> and <code>gradlew.bat</code> launchers (which we will not use).</p> <p>In order to build the project we will:</p> Bash<pre><code>$ gradle build\nBUILD SUCCESSFUL in 1 s\n5 actionable tasks : 5 up-to-date\n</code></pre> <p>and to run the project:</p> Bash<pre><code>gradle run --console plain\n</code></pre> <p>the <code>--console plain</code> option skip showing messages saying about the program execution. In addition, to pass some arguments to the program (in our program the height and width of the canvas) we must indicate as follows <code>--args=\"500 500\"</code>. The string in the double quotes will be the args variable of main.</p> <p>Once the program is running, the following prompt will be showed:</p> Text Only<pre><code># Figura: \n</code></pre> <p>This program let us draw a scene formed by several figures. The available options supported by the current version are (in Valencian):</p> <ul> <li><code>dimensions ample alt</code> : It sets the height and with of the canvas.</li> <li><code>cercle x y radi #color</code> : It adds a circle to the current scene. The circle will be placed at <code>x,y</code> coordinates, with the given radius and a color, in <code>#RRGGBB</code> format. This color is validated by a utility function.</li> <li><code>rectangle x y height width #color</code>: It adds a rectangle placed in <code>x,y</code> coordinates, with the given measures and color.</li> <li><code>linia x1 y1 x2 y2 #color</code>: It adds a line from the <code>(x1,y1)</code> starting point to the <code>(x2,y2)</code> final point and specified color. A fixed thickness by 3 pixels is establishe by the program.</li> <li><code>draw</code>: It will open a JavaFX window and draw all the figures stored and introduced in a canvas. When we will close the windows, the app will be finished.</li> </ul>"},{"location":"en/Practiques/APAC1/#2-new-behaviors","title":"2. New behaviors","text":"<p>In order to improve the base program, we must add the date persistence, adding functions to store and recover scenes. The orders wue have to implement are:</p> <ul> <li><code>import [file.txt | file.obj]</code> \\(\\rightarrow\\) It will import from disk scenes configurations, stored in text files or object files. The program will decide the format taking into account the file extension.</li> <li><code>export [file.txt | file.obj |file.svg | file.json]</code> \\(\\rightarrow\\) It will export to disk current scene configuration, saving it in text files, object files, svg format (a special xml format) or json format. The program will decide the format taking into account the file extension.</li> </ul> <p>Note</p> <p>All the files will be saved in the root project folder</p>"},{"location":"en/Practiques/APAC1/#21-sample-files-of-scenes","title":"2.1. Sample files of scenes","text":"<p>Text file</p> <p>Text Only<pre><code>dimensions 500 500\nrectangle 10 10 480 480 #ccccee \ncercle 250 250 100 #aaaaaa\nlinia 50 250 450 250 #aaaaaa\nlinia 50 50 50 450 #aaaaaa\nlinia 450 40 450 450 #aaaaaa\n</code></pre> SVG file</p> XML<pre><code>&lt;?xmlversion=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?&gt;\n&lt;svg height=\"500\" width=\"500\"&gt;\n  &lt;rect fill=\"#ccccee\" height=\"480\" width=\"480\" x=\"10\" y=\"10\"/&gt;\n  &lt;circle cx=\"250\" cy=\"250\" fill=\"#aaaaaa\" r=\"100\"/&gt;\n  &lt;line stroke=\"#aaaaaa\" stroke-width=\"3\" x1=\"50\" x2=\"450\" y1=\"250\" y2=\"250\"/&gt;\n  &lt;line stroke=\"#aaaaaa\" stroke-width=\"3\" x1=\"50\" x2=\"50\" y1=\"50\" y2=\"450\"/&gt;\n  &lt;line stroke=\"#aaaaaa\" stroke-width=\"3\" x1=\"450\" x2=\"450\" y1=\"40\" y2= \"450\"/&gt;\n&lt;/svg&gt;\n</code></pre> <p>Note</p> <p>This kind of xml is maded because after export this scene, you may open it with Inkscape. You can use it to prove you have done it well.</p> <p>JSON format</p> JSON<pre><code>{\"escena\": {\n    \"width\": 320,\n    \"height\": 320\n    \"figuras\": [\n        {\"cercle\": {\n            \"r\": \"26\",\n            \"cx\": \"166\",\n            \"cy\": \"105\",\n            \"fill\": \"#94c147\"\n        }},\n        {\"rectangle\": {\n            \"x\": \"137\",\n            \"width\": \"58\",\n            \"y\": \"108\",\n            \"fill\": \"#ffffff\",\n            \"height\": \"58\"\n        }},\n        {\"rectangle\": {\n            \"x\": \"139\",\n            \"width\": \"52\",\n            \"y\": \"111\",\n            \"fill\": \"#94c147\",\n            \"height\": \"52\"\n        }}\n     ],\n}}\n</code></pre>"},{"location":"en/Practiques/APAC1/#3-project-structure","title":"3. Project structure","text":"<p>First, we have <code>build.gradle</code> file, with information about project building, with graphics and JSON libraries. In our project structure, we have:</p> <p>Text Only<pre><code>main\n  |-- java\n  |   `--com\n  |      `-- ieseljust\n            `-- ad\n                `-- figures\n                    |-- App.java\n                    |-- cercle.java\n                    |-- escena.java\n                    |-- figura.java\n                    |-- FileManager.java\n                    |-- HexColorValidator.java\n                    |-- Linia.java\n                    |-- punt.java\n                    `-- Rectangle.java\n</code></pre> as you can view, inside src folder, we could take into account:</p> <ul> <li>App \\(\\rightarrow\\) main class. It shows the prompt and it creates the canvas. You don't have to modify this class.</li> <li>figura, cercle, linia, rectangle, punt \\(\\rightarrow\\) these classes form the inheritance tree (except punt). They have the necessary attributes and methods. You probably need to add methods to get the representation of that class to text, json or xml. You must do the necessary classes serializables too.</li> <li>escena \\(\\rightarrow\\) it contains some attributes and the collection of figures</li> <li>FileManager \\(\\rightarrow\\) class that have to deal with the storing process. We have to do the main work on it, as we can show in the next point.</li> </ul>"},{"location":"en/Practiques/APAC1/#4-filemanager-class","title":"4. <code>FileManager</code> class","text":"<p>As we explained, here is where you have to store and recover the information in several formats.</p>"},{"location":"en/Practiques/APAC1/#41-exists-method","title":"4.1. exists method","text":"Java<pre><code>public Boolean Exists(String file)\n</code></pre> <p>It will return a logic value depending on the existence of the file or no.</p>"},{"location":"en/Practiques/APAC1/#42-importfromtext-method","title":"4.2. <code>importFromText</code> method","text":"<p>Java<pre><code>public Escena importFromText(String file)\n</code></pre> Import a scene in text format, in the format indicated at the beginning of this document. In the imgs folder, you have a couple of images to test. As you can see, it receives the path to the file in String format, and it will return an object of type Scene.</p> <p>Note that, in addition to the figures, the dimensions command may appear, which will indicate that we will have to modify the dimensions of the Scene.</p>"},{"location":"en/Practiques/APAC1/#43-importfromobj-method","title":"4.3. <code>importFromObj</code> method","text":"Java<pre><code>public Escena importFromObj(String file)\n</code></pre> <p>Importing a serialized scene in object format, in the format indicated at the beginning of this document. In the imgs folder, you have a couple of images to test. As you can see, it receives the path to the file in String format, and it will return an object of type Scene.</p>"},{"location":"en/Practiques/APAC1/#44-exporttext-method","title":"4.4. <code>exportText</code> method","text":"Java<pre><code>public Boolean exportText(Escena escena, String file)\n</code></pre> <p>This method will export a given scene to a text file, in the format specified above, to be able to read them with <code>importFromText</code>.</p> <p>The method will receive the Scene object, and a String with the name of the file to be saved, with a <code>.txt</code> extension.</p> <p>For the implementation of this method, you will find it useful to implement a method called <code>getAsText</code> (or similar) in each type of figure, and returns the figure itself in the format of interest. In this way, to export the scene, we will go through the different figures and obtain the representation of each one.</p>"},{"location":"en/Practiques/APAC1/#45-exportobj-method","title":"4.5. <code>exportObj</code> method","text":"Java<pre><code>public Boolean exportObj(Escena escena, String file)\n</code></pre> <p>This method will export a given scene to an objects file, to be able to read it with <code>importFromObj</code>.</p> <p>The method will receive the Scene object, and a String with the name of the file to be saved, with an <code>.obj</code> extension.</p> <p>Warning</p> <p>Remember the use of <code>Serializable</code> modifier on the needed classes.</p>"},{"location":"en/Practiques/APAC1/#46-exportsvg-method","title":"4.6. <code>exportSVG</code> method","text":"Java<pre><code>public Boolean exportSVG(Escena escena, String file)\n</code></pre> <p>This method will export a given scene to a svg file, in the xml format specified above in the previous pages. The method will receive the Scene object, and a String with the name of the file to be saved, with a <code>.svg</code> extension.</p> <p>Some details of the format:</p> <ul> <li>We include <code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?&gt;</code> always.</li> <li>The root element is the <code>&lt;svg&gt;</code> tag, with two attributes width and height.</li> <li>Every figure inheritor will be the equivalent <code>rect</code>, <code>circle</code> and <code>line</code> tag. Look at the document sample.</li> <li>To do a correct circle position, you have to add the radius to the figure position: <code>this.posicio.getX()+this.radi</code> and <code>this.posicio.getY()+this.radi</code></li> </ul> <p>Note</p> <p>To get a correct implementation of this method (and others that will become) is interesting to proceed as we notice:</p> <ul> <li>declare an abstract method in Figura class. <code>getAsSVG()</code>, for instance.</li> <li>implement this method on every descent class.</li> </ul>"},{"location":"en/Practiques/APAC1/#47-exportjson-method","title":"4.7. <code>exportJSON</code> method","text":"Java<pre><code>public Boolean exportJSON(Escena escena,String filename)\n</code></pre> <p>This method will create a JSON representation of the scene that the method receives. As the note given in the last point, is an interesting practice to create the <code>getAsJson()</code> method in the top class an implement in the bottom classes. </p> <p>:::note</p> <p>To do a more efficient work, implement the methods as follows:</p> <ul> <li><code>importFromText</code>, so you can import a full scene provided and could draw it.</li> <li><code>exportToText</code>, so you can check your scene will be the same as the original one.</li> <li><code>exportToObj</code>, so you can save a scene imported from text</li> <li><code>importFromObj</code>, to check the exported one has been well done.</li> <li>At the end the rest of exports, to SVG and JSON :::</li> </ul>"},{"location":"en/Practiques/APAC1/#5-practice-delivery","title":"5. Practice delivery","text":"<p>To do the practice upload you have to fulfill the following:</p> <ul> <li>Execute <code>gradle clean</code> in order to clean all the packages and libraries.</li> <li>Compress the project folder. Zip format is mandatory.</li> <li>Upload the practice at the aules platform, avoiding emails or other communication tools.</li> </ul>"},{"location":"en/Practiques/APAC2/","title":"1. Overview","text":"<p>Let's go to create a DBMS client, like MySQL workbench, but in a console version with a shell and a prompt. Our client allows us to connect to a server, select a database and finally throws several SQL queries.</p>"},{"location":"en/Practiques/APAC2/#11-server-mode","title":"1.1. Server Mode","text":"<p>When starting our program, it will ask for server's data</p> Bash<pre><code>gradle run --console plain\n...\n$ Server: 127.0.0.1\n$ Port: 3308\n$ Username: root\n$ Password:\n$ (root) on 127.0.0.1:3308&gt;\n</code></pre> <p>As you can see on last line, prompt is <code>(user) on IP:port&gt;</code>. Our client show where we are connected always.</p> <p>List of order tha will be accepted by or client when connected are (server mode):</p> <ul> <li><code>show databases</code> or <code>sh db</code> \\(\\rightarrow\\) show a list with all databases in our DBMS.</li> <li><code>info</code> \\(\\rightarrow\\) show information abaut DBMS and connection settings.</li> <li><code>import script_name</code> \\(\\rightarrow\\) Allow to load a sql scrip from a file.</li> <li><code>use db_name</code> \\(\\rightarrow\\) change our program to database mode.</li> <li><code>quit</code> \\(\\rightarrow\\) finish our program.</li> </ul>"},{"location":"en/Practiques/APAC2/#12-database-mode","title":"1.2. Database Mode","text":"<p>Once we are connected to a server, and selected a database, our client will enter in database mode:</p> Bash<pre><code>$ (root) on 127.0.0.1:3308&gt;use Ciclismo\n$ (root) on 127.0.0.1:3308[Ciclismo]&gt;\n</code></pre> <p>you can view that database name is added to the prompt, and now the program is waiting for commands to the database. You must implement these orders :</p> <ul> <li><code>sh tables</code> \\(\\rightarrow\\) show all tables on selected database.</li> <li><code>describe table_name</code> \\(\\rightarrow\\) show description of this table: fields, data types and primary keys at least.</li> <li><code>insert Nom_de_la_Taula</code> \\(\\rightarrow\\)  on an interactive way, ask to the user for each field value, and insert a new row.</li> <li><code>sql</code> \\(\\rightarrow\\) It runs whatever query on selected database.</li> <li><code>quit</code> \\(\\rightarrow\\) returns to DBMS mode.</li> </ul>"},{"location":"en/Practiques/APAC2/#2-project-structure-and-tips","title":"2. Project structure and tips","text":"<p>The project contains theses classes:</p> <p></p> <p>Let's go to revise the class functions</p>"},{"location":"en/Practiques/APAC2/#21-servermanager","title":"2.1. ServerManager","text":"<p>It contains main, and when starting, ask the user for the server information. Then, it starts <code>ConnectionManager</code> class with the given values.</p>"},{"location":"en/Practiques/APAC2/#22-connectionmanager","title":"2.2. ConnectionManager","text":"<p>It manages the main program shell, and has as attributes:</p> Java<pre><code>String server;\nString port;\nString user;\nString pass;\n</code></pre> <p>and as methods:</p> <ul> <li><code>ConnectionManager()</code> \\(\\rightarrow\\) default const.</li> <li><code>ConnectionManager(String server, String port, String user, String pass)</code> \\(\\rightarrow\\) general const.</li> <li><code>public Connection connectDBMS()</code> \\(\\rightarrow\\) starts and returns a connection.</li> <li><code>public void showInfo()</code> \\(\\rightarrow\\)  show server's information.</li> <li><code>public void showDatabases()</code> \\(\\rightarrow\\) show server's tables.</li> <li><code>public void importScript(String script)</code> \\(\\rightarrow\\) loads and run a script.</li> <li><code>public void startShell()</code> \\(\\rightarrow\\) inits the server's mode shell. This shell is almost implemented.</li> </ul>"},{"location":"en/Practiques/APAC2/#23-databasemanager","title":"2.3. DatabaseManager","text":"<p>It manage the database mode shell, and need an extra attribute than Connection manager:</p> Java<pre><code>String server;\nString port;\nString user;\nString pass;\nString dbname;\n</code></pre> <p>and as methods:</p> <ul> <li><code>DatabaseManager()</code> \\(\\rightarrow\\) default const.</li> <li><code>DatabaseManager(String server, String port, String user, String pass,String dbname)</code> \\(\\rightarrow\\) general const.</li> <li><code>public Connection connectDatabase()</code> \\(\\rightarrow\\) starts and returns a connection to the current database.</li> <li><code>public void insertIntoTable(String table)</code> \\(\\rightarrow\\) starts the insertion assistant to the given table.</li> <li><code>public void showDescTable(String table)</code> \\(\\rightarrow\\) show table metadata.</li> <li><code>public void executeSelect(String query)</code> \\(\\rightarrow\\) run a given query (of any type) and show results on screen, if any.</li> <li><code>public void startShell()</code> \\(\\rightarrow\\) inits the database's mode shell. You have to do a full implementation.</li> </ul>"},{"location":"en/Practiques/APAC2/#3-tables-insertions","title":"3. Table's insertions.","text":"<p>The <code>insertIntoTable</code> is probably the hardest method in the task, due to need to ask for table metadata first, in order to know the table fields and data types, and then ask to the user for the values and formats.</p> <p>The advice that will be given is to set three list with:</p> <ol> <li>Fields list that need to insert</li> <li>Values list to we are going to set</li> <li>Types list of each field</li> </ol> <p>Furthermore, you need to generate a placeholders list or String, with so many <code>?</code> as you need.</p> <p>Advice</p> <p>Remember that asking for table metadata, the columns that you need are:</p> <ul> <li>Column 4 : column name</li> <li>Column 6: column data type</li> <li>Column 18 nullable or not. This field is mandatory if were not null.</li> <li>Column 23: incremental or not. You don't need this field, if were incremental.</li> </ul> <p>And last, a fine tunning is placeholders assignation, because it depends of data type. Take into account that:</p> <ul> <li>If data type is <code>INT</code>, we will use <code>setInt</code>.</li> <li>If data type is <code>DATETIME</code>, we will use <code>setDate</code> with a casting to <code>java.sql.Data</code> (not <code>java.Date</code>).</li> <li>For a default or very specific type, you could setString, and hope that casts works properly.</li> </ul> <p>\u00a9 Joan Gerard Camarena, October-2022</p> <p>\u00a9 Last revision, October-2024</p>"},{"location":"en/Practiques/APAC3/","title":"APAC3","text":"<p>About the practice</p> <p>This practice is a free statement practice. You have to create your own task, with several limits, obviously. You have to do the maintenance of a database of your choice: you can create it from zero, you can choose one of last course, you can get from internet etc. </p>"},{"location":"en/Practiques/APAC3/#1-the-database","title":"1. The database","text":"<p>The database restrictions are:</p> <ul> <li>It must contains at least three entities.</li> <li>It must contains at least three relationships, one of each class: <code>1-1</code>, <code>1-M</code> and <code>N:M</code>. If you want, you can create a reflexive relation.</li> <li>Use MySQL</li> </ul>"},{"location":"en/Practiques/APAC3/#2-the-program","title":"2. The program","text":""},{"location":"en/Practiques/APAC3/#21-structure","title":"2.1. Structure","text":"<p>Create an Hibernate program with the goal of doing the basic CRUD operations in the database (Create, Read, Update and Delete). Map all the entities and relationships of the database.</p>"},{"location":"en/Practiques/APAC3/#22-crud","title":"2.2. CRUD","text":"<p>As all the work of each entity is the same (changing the entity's name), you must create only one Entity full CRUD. Then, create methods to insert, delete, update and select information of one entity.</p>"},{"location":"en/Practiques/APAC3/#23-relationships","title":"2.3. Relationships","text":"<p>Imagine that we have a <code>1:M</code> relationship, an <code>Author</code> writes several <code>Books</code>. With your own relationships do the same as follows:</p>"},{"location":"en/Practiques/APAC3/#231-task-1","title":"2.3.1. Task 1","text":"<p>You have to show records from a entity, for instance <code>show Author</code>. This command will show all Authors in database. But if the command is <code>show -r Author</code> it will show for each author the books that has written. (<code>r</code> means recursively)</p>"},{"location":"en/Practiques/APAC3/#232-task-2","title":"2.3.2. Task 2","text":"<p>When you want to insert a new Book, you can run <code>add Book</code>, and then, in an interactive way, the program will ask the values of the book and create it and store it, establishing the Author to <code>null</code>. But if you run <code>add -r Book</code>, the program will show all Authors in the database. The user will select one, and this Author is setted as book's author. </p> <p>In the Author selection process,  there will be an extra option (Author 0, for instance) when the book's author is not in the database, and we will create a new Author, and then assign to the Book. Both Author and Book will be saved.</p>"},{"location":"en/Practiques/APAC3/#3-task","title":"3. Task.","text":"<p>To upload the task on the platform, you only need to write a link to a private repository of student's GitHub. You must add your teacher's user as a guest of your repo (<code>joange</code> - jgcamarena@ieseljust.com). The task will be presented as next points.</p> <p>In your work's folder you must have:</p> <ol> <li>A script with the database create table and some sample data. You must generate it with MySQL Workbench sql dump.</li> <li>A picture of your database structure, created with MySQL Workbench reverse engineering.</li> <li>A maven project that implement the requirements of this text.</li> <li><code>Readme.md</code> file with documentation about your program. </li> </ol>"},{"location":"en/Practiques/APAC3/#31-checkpoint-1-the-database","title":"3.1. Checkpoint 1. The database.","text":"<p>In this task you must present your repo when you finish part 1 and 2. The teacher will mark it as <code>OK</code> before you start to program with part 3.</p>"},{"location":"en/Practiques/APAC3/#32-checkpoint-2-the-program","title":"3.2. Checkpoint 2. The program.","text":"<p>When you finish the task, present your repo.</p> <p>(c) Joan Gerard Camarena Estruch, November 2022</p>"},{"location":"en/UD1_Files/00_Exercises/","title":"File System","text":""},{"location":"en/UD1_Files/00_Exercises/#ls-la","title":"<code>ls -la</code>","text":"<p>In this exercise we are going to implement a tuned version of the <code>ls</code> program. It will list a directory in a specific view mode. Both directory and view will be indicated when we start the program.</p> <p>The view mode can be list, columns or table:</p> <ul> <li>List \\(\\rightarrow\\) The file names one above others.</li> <li>Columns \\(\\rightarrow\\) The same as list but in several columns</li> <li>Table \\(\\rightarrow\\) File information will be showed, like this pattern: <code>DFRWH name size mod_data</code>:</li> <li><code>D</code> \\(\\rightarrow\\) it's a directory</li> <li><code>F</code> \\(\\rightarrow\\) it's a file</li> <li><code>R</code> \\(\\rightarrow\\) we can read the file</li> <li><code>W</code> \\(\\rightarrow\\) we can write the file</li> <li><code>H</code> \\(\\rightarrow\\) the file is hidden</li> </ul>"},{"location":"en/UD1_Files/00_Exercises/#submission","title":"Submission","text":"<p>A single <code>.java</code> file with the program. To help you with some task here is some code to format a string list in columns. The <code>MAX_FILES_BY_COLUMN = 4</code> must be initialized.</p> Java<pre><code>public static void ListaColumnas(String[] filenames){\n  int columnas = (filenames.length / MAX_FILES_BY_COLUMN)+1; \n  String[][] salida = new String[MAX_FILES_BY_COLUMN][columnas];\n  for (int i=0;i&lt;filenames.length;i++){\n    salida[i % MAX_FILES_BY_COLUMN][i / MAX_FILES_BY_COLUMN]=\n        filenames[i];\n  }\n  //bucle para mostrar salida ls\n  for (int i=0;i&lt;MAX_FILES_BY_COLUMN;i++){ \n    for (int j=0; j&lt;columnas;j++)\n      System.out.print(salida[i][j] + \" - \"); \n    System.out.println(\" /n\");\n  }\n}\n</code></pre>"},{"location":"en/UD1_Files/00_Exercises/#hidden-files","title":"Hidden files","text":"<p>Write a Java program that find out all the hidden files of a directory and its subdirectories recursively.</p>"},{"location":"en/UD1_Files/00_Exercises/#biggest-file","title":"Biggest file","text":"<p>Write a Java program to find the big file of a set of files in a directory.</p>"},{"location":"en/UD1_Files/00_Exercises/#text-files","title":"Text Files","text":""},{"location":"en/UD1_Files/00_Exercises/#how-many-vowels","title":"How many vowels?","text":"<p>Write a program who receives a name of a text based file, and a vowel. The program will show the number of times that appear that vowel on the file.</p>"},{"location":"en/UD1_Files/00_Exercises/#tail-and-head","title":"<code>tail</code> and <code>head</code>","text":"<p>Write your own version of tail and head gnu utils. You can find out information in:</p> <ul> <li>tail</li> <li>head</li> </ul> <p>:::note</p> <p>Remember that these programs show the last and first ten lines by default. If you want to modify it, you can adjust with <code>-nX</code> where X is the number of lines you want to show. :::</p>"},{"location":"en/UD1_Files/00_Exercises/#binary-files","title":"Binary Files","text":""},{"location":"en/UD1_Files/00_Exercises/#find-size-of-an-image-file-hard","title":"Find size of an image file (HARD)","text":"<p>According to the specification of bmp or png pictures, as you can see:</p> <ul> <li>BMP specification</li> <li>PNG specification</li> </ul> <p>write a program that recieves a filename of a png or a bmp file and returns the image's width and height</p>"},{"location":"en/UD1_Files/00_Exercises/#csv-files","title":"CSV Files","text":"<p>Make a function to show a CSV file, according to the next requirements:</p> <ul> <li>We must indicate to the function the separator character.</li> <li>We must indicate to the function if the CSV has a header line or not.</li> <li>(Improvement) The function must calculate the max column size for each line, and show each column in the size previously calculated, as mysql show its tables. </li> </ul> <p>On the platform you have a MLB players names CSV files, but you can choose a file by your own.</p>"},{"location":"en/UD1_Files/00_Exercises/#xml-files","title":"XML Files","text":"<p>In the platform you will find a file called <code>monaco2017.xml</code> containing a lot of information about the F1 2017 championship race in Monaco. Apart from other information, we could find:</p> XML<pre><code>&lt;Result number=\"5\" position=\"1\" positionText=\"1\" points=\"25\"&gt;\n    &lt;Driver driverId=\"vettel\" code=\"VET\" url=\"http://en.wikipedia.org/wiki/Sebastian_Vettel\"&gt;\n        &lt;PermanentNumber&gt;5&lt;/PermanentNumber&gt;\n        &lt;GivenName&gt;Sebastian&lt;/GivenName&gt;\n        &lt;FamilyName&gt;Vettel&lt;/FamilyName&gt;\n        &lt;DateOfBirth&gt;1987-07-03&lt;/DateOfBirth&gt;\n        &lt;Nationality&gt;German&lt;/Nationality&gt;\n    &lt;/Driver&gt;\n    &lt;Constructor constructorId=\"ferrari\" url=\"http://en.wikipedia.org/wiki/Scuderia_Ferrari\"&gt;\n        &lt;Name&gt;Ferrari&lt;/Name&gt;\n        &lt;Nationality&gt;Italian&lt;/Nationality&gt;\n    &lt;/Constructor&gt;\n    &lt;Grid&gt;2&lt;/Grid&gt;\n    &lt;Laps&gt;78&lt;/Laps&gt;\n    &lt;Status statusId=\"1\"&gt;Finished&lt;/Status&gt;\n    &lt;Time millis=\"6284340\"&gt;1:44:44.340&lt;/Time&gt;\n    &lt;FastestLap rank=\"2\" lap=\"38\"&gt;\n        &lt;Time&gt;1:15.238&lt;/Time&gt;\n        &lt;AverageSpeed units=\"kph\"&gt;159.669&lt;/AverageSpeed&gt;\n    &lt;/FastestLap&gt;\n&lt;/Result&gt;\n</code></pre> <p>Within the <code>Result</code> we will find as attributes the pilot's number (<code>number</code> attribute) and the position in which he finished the race (<code>position</code>). In addition, we will find the following elements:</p> <ul> <li>Driver: information about who the driver is.</li> <li>Manufacturer: information about the brand of the car</li> <li>Grid: Position in which the driver has started</li> <li>Laps: Laps completed</li> <li>Status: which tells us with the <code>statusID=1</code> attribute that the pilot finished the race.</li> <li>Time: which tells us the milliseconds attribute how long it took to complete the race (in ms), and in its value the difference with respect to the first ones.</li> <li>FastesLap: which tells us the classification with respect to the fast lap in its rank attribute.</li> </ul> <p>On the platform you will find:</p> <ul> <li>Driver class: full implemented, who need the driver portion of the XML to create a Driver object.</li> <li>ResultadoCarrera: partially implemented, with the following attributes:</li> </ul> Java<pre><code>private Driver d;\nprivate String constructor;\nprivate int initialPos;\nprivate int finalPos;\nprivate long timeMillis;\nprivate int completedLaps;\nprivate int rankFastesLap;\nprivate boolean finisher;\n</code></pre> <p>Complete the program, adding:</p> <ul> <li><code>Constructor(Element result)</code>, that receives a XML Element.</li> <li><code>public String toCSV()</code>, who will return all fields sepparated by <code>;</code>.</li> <li><code>public ArrayList&lt;ResultadoCarrera&gt; carregaResultadosXML(String nomXML)</code> who receive the name of XML file and will load all the results.</li> <li><code>public void saveAsCSV(String nomFitxer, ArrayList&lt;ResultadoCarrera&gt; elsResultats)</code> who will save on a csv text file the results loaded previously.</li> </ul>"},{"location":"en/UD1_Files/00_Exercises/#json-files","title":"JSON Files","text":"<p>On the platform you will find a file called <code>SW.json</code>. It recovers information about characters of the famous saga. Write a program to obtain:</p> <ul> <li>Characters that did not drive any vehicle.</li> <li>List of characters, ordered by number of films that it appears.</li> <li>Create an XML file like this, with a brief summary information:</li> </ul> XML<pre><code>&lt;character films=\"4\" vehicles=\"0\"&gt;\n  &lt;name&gt;Luke Skywalker&lt;/name&gt;\n  &lt;mass&gt;77&lt;/mass&gt;\n  &lt;url&gt;https://swapi.dev/api/people/1/&lt;/url&gt;\n&lt;/character&gt;\n</code></pre> <p>Let's go starting the course playing with databases and programs, to review all the concepts you need to begin with the main topics with a solid base.</p>"},{"location":"en/UD1_Files/1_File_System/","title":"File system","text":""},{"location":"en/UD1_Files/1_File_System/#1-introduction","title":"1. Introduction","text":"<p>In the beginning of computer science, files were the only mechanism to store information. Nowadays, Operating Systems manage storage devices almost transparently to the user. Without going into details of the underlying storage technologies, they offer us an abstraction by means of which we have only to worry about two concepts: files and directories.</p> <ul> <li>File \u2192 information containers (all kind and format of the information).</li> <li>Directories \u2192 file organizers, and may contain files and other directories.</li> </ul> <p>Following with information (the content of the file), we can find a classical classification:</p> <ul> <li>Text File \u2192 the information is stored in files, so that can be viewed or opened with any plain text editor, like vi, nano, or notepad. </li> <li>Binary File \u2192 the information is stored coded in binary format. As the student know, any kind of information (text, numbers, photos, etc.) can be traduced to 0's and 1's. In our way (programmers) we can transform objects and variables in different ways.</li> </ul> <p>Notice than...</p> <ul> <li>Regardless that we store information in text file, it appears a new concept: structure. If we organize information in several ways, we can speak about csv files, xml files, json files. The csv, xml and json are structures, because at the end, all of them are text files.</li> <li>People think that text files are weak files to store information, but it is not true. Cryptographic technics offers us methods to store information inside text files safety. For example 'htpasswd' in 'apache' or '/etc/shadow' in Linux systems. At the bottom you can view a PGP public key sample, stored in a text file</li> </ul> Bash<pre><code>-----BEGIN PGP PUBLIC KEY BLOCK-----\nComment: Alice's OpenPGP certificate\nComment: https://www.ietf.org/id/draft-bre-openpgp-samples-01.html\n\nmDMEXEcE6RYJKwYBBAHaRw8BAQdArjWwk3FAqyiFbFBKT4TzXcVBqPTB3gmzlC/U\nb7O1u120JkFsaWNlIExvdmVsYWNlIDxhbGljZUBvcGVucGdwLmV4YW1wbGU+iJAE\n...\nDAAKCRDyMVUMT0fjjlnQAQDFHUs6TIcxrNTtEZFjUFm1M0PJ1Dng/cDW4xN80fsn\n0QEA22Kr7VkCjeAEC08VSTeV+QFsmz55/lntWkwYWhmvOgE=\n=iIGO\n-----END PGP PUBLIC KEY BLOCK-----\n</code></pre>"},{"location":"en/UD1_Files/1_File_System/#2-accessing-the-file-system-in-java","title":"2. Accessing the file system in Java","text":"<p><code>Java</code> offers us several ways to access the file system. This way is independent of the underlying device that stores the information. The device can be a hard disk, ssd disk, optical drive, etc. The class that offers us this possibility is the File class. We are going to review the main facts of this class, and then revise some samples.</p> <ul> <li>The constructor of the class is overloaded, as most java classes. We could use:</li> <li><code>File(File parent, String child)</code> \u2192 Creates a new File instance from a parent abstract pathname and a child pathname string.</li> <li><code>File(String pathname)</code> \u2192 Creates a new File instance by converting the given pathname string into an abstract pathname.</li> <li><code>File(String parent, String child)</code> \u2192 Creates a new File instance from a parent pathname string and a child pathname string.</li> <li> <p><code>File(URI uri)</code> \u2192 Creates a new File instance by converting the given file: URI into an abstract pathname.</p> </li> <li> <p>To access the file we must use a path name. This is the path, and we have two possibilities:</p> </li> <li>Absolute path \u2192 the path from the root directory of the system to the file we would, starting with <code>/</code> in Linux systems or <code>letter:</code> in Windows systems. Remember to use <code>/</code> to separate folders in Linux and <code>\\\\</code> in Windows. It is not an erratum, due to the backslash is a symbol with own meaning, we have to escape it, doubling it to get the meaning we would.</li> <li>Relative path \u2192 we suppose that the file we would is in the same folder that the project/program we are executing. In this case we only provide the file name, without any folder at the beginning of the path.</li> </ul> <p>Java<pre><code>// absolute paths\nFile f=new File(\"/home/joange/texto.md\") //  Linux\nFile f=new File(\"C:\\\\Usuarios\\\\joange\\\\Dektop\\\\texto.md\") //  Windows\n...\n// relative paths\nFile f=new File(\"texto.md\") //  Linux\nFile f=new File(\"docs\\\\texto.md\") //  Windows\n</code></pre> - The same class <code>File</code> is used to access either a regular file or a directory. Is task of the programmer to difference between them with the file methods as well as to check if a file exists. To do this, we could use several methods like:   - <code>boolean exists()</code> \u2192 returns true if the file object exists, and false otherwise.   - <code>boolean isFile()</code> and <code>isDirectory()</code> \u2192 returns true either the object is a regular file or a directori. Obviously, these methods are exclusive</p>"},{"location":"en/UD1_Files/1_File_System/#3-creating-files","title":"3. Creating files","text":"<p>If we want to create a folder or a regular file, we can use this methods</p> <ul> <li><code>boolean createNewFile()</code> \u2192 Atomically creates a new, empty file named by this abstract pathname if and only if a file with this name does not yet exist.</li> <li><code>static FilecreateTempFile(String prefix, String suffix)</code> \u2192 Creates an empty file in the default temporary-file directory, using the given prefix and suffix to generate its name.</li> <li><code>boolean mkdir()</code> \u2192 Creates the directory named by this abstract pathname.</li> <li><code>boolean mkdirs()</code> \u2192 Creates the directory named by this abstract pathname, including any necessary but nonexistent parent directories.</li> <li><code>boolean renameTo(File dest)</code> \u2192 Renames the file denoted by this abstract pathname.</li> <li><code>boolean delete()</code>\u2192 Deletes the file or directory denoted by this abstract pathname.</li> </ul> <p>Note</p> <ul> <li>In next sections we will study how to create files when we save content inside them. In other words, we do not need to create the file adhoc and then populate. There are mechanisms to create the file in an automatized way.</li> <li>The difference between mkdir and mkdirs is that the second option will create all directories between the root file system and the current directory meanwhile the first need that the path exists.</li> </ul>"},{"location":"en/UD1_Files/1_File_System/#4-asking-for-file-properties","title":"4. Asking for file properties","text":"<p>Normally we open files to write or read their content, but sometimes we need to ask for file properties, like size, permits and so. File class will help us again.</p> <p>General information:</p> <ul> <li><code>boolean exists()</code> \u2192 Tests whether the file or directory denoted by this abstract pathname exists.</li> <li><code>long lastModified()</code> \u2192 Returns the time that the file denoted by this abstract pathname was last modified.</li> <li><code>long length()</code> \u2192 Returns the length of the file denoted by this abstract pathname.</li> </ul> <p>Information about permits. This information is the information than the user can recover with <code>ls -la</code> in the <code>chmod</code> style:</p> <ul> <li><code>boolean canExecute()</code> \u2192 Tests whether the application can execute the file denoted by this abstract pathname.</li> <li><code>boolean canRead()</code> \u2192 Tests whether the application can read the file denoted by this abstract pathname.</li> <li><code>boolean canWrite()</code> \u2192 Tests whether the application can modify the file denoted by this abstract pathname.</li> </ul> <p>Content of a directory:</p> <ul> <li><code>String[] list()</code> \u2192 Returns an array of strings naming the files and directories in the directory denoted by this abstract pathname.</li> <li><code>File[] listFiles()</code> \u2192 Returns an array of abstract pathnames denoting the files in the directory denoted by this abstract pathname.</li> <li><code>String[] list(FilenameFilter filter)</code> \u2192 Returns an array of strings naming the files and directories in the directory denoted by this abstract pathname that satisfy the specified filter.</li> <li><code>File[] listFiles(FilenameFilter filter)</code> \u2192 Returns an array of abstract pathnames denoting the files and directories in the directory denoted by this abstract pathname that satisfy the specified filter.</li> </ul> <p>Tip</p> <p>We suggest the student to find out information about the class FilenameFilter</p>"},{"location":"en/UD1_Files/1_File_System/#41-solved-exercise","title":"4.1. Solved Exercise","text":"<p>Analyze and explain what this little program do:</p> Java<pre><code>public static void main(String[] args) {\n        String ruta = args[0];\n        File f = new File(ruta);\n\n        if (f.exists()) {\n            if (f.isFile()) {\n                System.out.println(\"El tama\u00f1o es de \" + f.length());\n                System.out.println(\"Puede ejecturase: \" + f.canExecute());\n                System.out.println(\"Puede leerse: \" + f.canRead());\n                System.out.println(\"Puede escribirse: \" + f.canWrite());\n            } else {\n                String[] losArchivos = f.list();\n                System.out.println(\"El directorio \" + ruta + \" contiene:\");\n                for (String archivo : losArchivos) {\n                    System.out.println(\"\\t\" + archivo);\n                }\n            }\n\n        } else {\n            System.out.println(\"El fichero o ruta no existe\");\n        }\n}\n</code></pre> <p>Solution</p> <ol> <li>This program read from the command line a path, and create a File object.</li> <li>Then, check if the path exist or no over the file system. In case it doesn't exist, the program finish.</li> <li>If the path exists, next test is to verify if it is a file:</li> <li>We read some trivial properties like size and permits </li> <li>If the path pointed by the file is a directory, we get the content of this directory, and show on the screen</li> </ol>"},{"location":"en/UD1_Files/2_Reading_and_writing_files/","title":"1. Reading and writing files","text":"<p>Java offers a wide variety of ways to manipulate the contents of files, bringing great power but complexity at the same time.</p> <p>The reading and writing of files in Java is done through data flows or <code>streams</code>, which may be either oriented to bytes or considered as a set of characters. The concept of file, which is static, must be differentiated from the concept of stream, which has a dynamic character: a file is stored on disk, but from the point of view of the application, we are interested in the transfer of this information from the file to our program. A classic comparison: streams would be like water pipes, while files would be reservoirs. The concept of data flow, apart from the scope of files, will also be applicable to the transfer of information, for example through the network or between processes.</p> <p>Streams can be classified into:</p> <ul> <li><code>Input Streams</code>: Those that go from a source (e.g. file) to the program.</li> <li><code>Output Streams</code>: Those that exit the program to a destination (e.g. file).</li> </ul> <p>When reading and storing data, we must be very careful with the types of data we work with, since the same sequence of bits on disk represents different information depending on the type of data used. Even when dealing with the same type of data, as in the case of characters, special care must be taken, since different systems may use different coding. Java, for example for the char type uses 16-bit Unicode (UTF-16), but we can try to access encoded files, for example with UTF-8 or ASCII.</p> <p>The parent superclasses for handling byte-oriented streams are <code>InputStream</code> and <code>OutputStream</code>. Others are derived from these, but for file management we are interested in two: <code>FileInputStream</code> and <code>FileOutputStream</code>.</p>"},{"location":"en/UD1_Files/2_Reading_and_writing_files/#11-fileinputstream","title":"1.1. FileInputStream","text":"<p>The <code>FileInputStream</code> class is used to access files for reading, and has two main constructors:</p> <ul> <li><code>FileInputStream (File f)</code> \u2192 Receives an object of type <code>File</code>, which will reference the object we will read from.</li> <li><code>FileInputStream (String name)</code> \u2192 Receives a string with the name or path of the location of the file to be read.</li> </ul> <p>The main methods we have for this class are:</p> <ul> <li><code>int read()</code> \u2192 Abstract sequential reading method: Returns an integer corresponding to the next byte of an input stream (file, byte array...). If it reaches the end of the sequence, it returns <code>-1</code>. On error, it will throw an exception of type <code>IOException</code>.</li> <li><code>int read(byte[] buffer)</code> \u2192 Reads a given number of bytes from the input (as long as the buffer), saving them to the buffer. It will return the number of bytes effectively read, which at most will be as large as the buffer. If no bytes are available return <code>-1</code>.</li> <li><code>int available()</code> \u2192 Indicates the bytes we have available for reading.</li> <li><code>long skip(long des)</code> \u2192 Skips as many bytes as the parameter indicates. The return value is the number of bytes that have been effectively dumped (they can be less than what we have indicated if we reach the end for example).</li> <li><code>int close()</code> \u2192 Closes the data stream.</li> </ul>"},{"location":"en/UD1_Files/2_Reading_and_writing_files/#12-fileoutputstream","title":"1.2. FileOutputStream","text":"<p>The FileOutputStream class is used to access files for writing. It has the following builders:</p> <ul> <li><code>FileOutputStream (File f)</code> \u2192 Receives an object of type <code>File</code> and opens it in write mode. In case it does not exist, it will be created, and if it exists, it will be overwritten.</li> <li><code>FileOutputStream (String name)</code> \u2192 Receives a string with the name or path of the location of the file to be written, and opens it in write mode. In case it does not exist, it will be created, and if it exists, it will be overwritten.</li> <li><code>FileOutputStream (File f, boolean append)</code> \u2192 Gets an object of type <code>File</code> and opens it in append mode, to write to the end. If it doesn't exist, it will be created, and if it exists, it will write behind it (only if append is set to True).</li> <li><code>FileOutputStream (String , boolean append)</code> \u2192 Receives a string with the name or path of the file location to be written and opens it in append mode, to be written at the end. If it doesn't exist, it will be created, and if it exists, it will write behind it (only if append is set to True).</li> </ul> <p>The main methods of the class are:</p> <ul> <li><code>write(int byte)</code> \u2192 Writes the byte to the output stream. Although this is an integer parameter, only one byte is written. If there is an error, an IOException is thrown.</li> <li><code>void write(byte[ ] buffer)</code> \u2192 Writes the contents of the buffer (byte vector) to the file. If the buffer is null, it will throw an exception.</li> <li><code>void write(byte[ ] buffer, int pos, int length)</code> \u2192 Writes the contents of the buffer (byte vector) from position pos, and as many bytes as given in length.</li> <li><code>void flush()</code> \u2192 Forces the remaining bytes in the write cache to be written to the output file.</li> <li><code>void close()</code> \u2192Closes the output stream and frees the resources.</li> </ul>"},{"location":"en/UD1_Files/2_Reading_and_writing_files/#121-solved-exercise","title":"1.2.1. Solved Exercise","text":"<p>Create a simple Java program that copies a file to another file byte to byte. Source and destination file will be indicated on the command line.</p> <p>Solution</p> Java<pre><code>class FileCopy {\n    /*\n    Class to test FileInputStream and FileOutputStream. \n\n    Copy byte to byte of files\n\n    Sintaxi:\n        FileCopy sourceFile destinationFile.\n\n    */\n    public static void main(String[] args) throws Exception {\n        // Byte readed from source\n        int bytes;        \n        // Bytes (effectively) writen to dest\n        long bytesCopied=0; \n\n        // Streams \n\n        FileInputStream fis= null;\n        FileOutputStream fos=null;\n\n        // To provide information about source\n        File f; \n\n\n        // Are the arguments ok?\n        if(args.length!=2){\n            System.out.println(\"Nombre d'arguments erroni. Sintaxi:\\n FileCopy fitxerOrigen fitxerDesti\");\n            return;\n        }\n\n        try{\n\n            // show source size\n            f=new File(args[0]);\n            System.out.println(\"Total: \"+f.length()+\" bytes\");\n\n            // Create streams          \n            fis=new FileInputStream(args[0]);\n            fos=new FileOutputStream(args[1]);\n\n            do {\n                // read one byte from source\n                bytes=fis.read();                 \n                // write in destination\n                if (bytes!=-1)\n                    fos.write(bytes);\n                // Update number of bytes\n                bytesCopied++;                    \n\n                // Show progress (think alternatives as exercise)\n                System.out.print(\"\\rCopiats \"+(bytesCopied-1)+\" bytes...\");\n            }while (bytes!=-1);\n            System.out.println(\"Done it!\");\n\n\n        }catch (IOException exc){\n            System.out.println(\"Error d'entrada i eixida: \"+exc);\n        }finally {\n            // At the end, we have to close the files, either an error exists or not.\n            try {\n                if (fis!=null) fis.close();\n            }catch (IOException exc){\n                System.out.println(\"Error en tancar el fitxer d'origen.\");\n            }\n            try {\n                if(fos!=null) fos.close();\n            }catch (IOException exc){\n                System.out.println(\"Error en tancar el fitxer dest\u00ed.\");\n            }\n        }\n    }\n}\n</code></pre> <p>Think and try</p> <p>With the sample program we have seen, we could copy files of every kind: text, audio, video. Try it as your own and test the content is the same.</p> <p>Challenge</p> <p>Try to change the last program in order to read data in 32 bytes chunks, using the accurate methods of the classes. Share your solution in the forum.</p>"},{"location":"en/UD1_Files/2_Reading_and_writing_files/#13-text-files","title":"1.3. Text Files","text":"<p>As stated, Java allows streams to be managed with either a byte orientation or a character orientation. The abstract classes for managing character-oriented streams are <code>Reader</code> and <code>Writer</code>. These are derived from others, but for the management of files we focus on <code>FileReader</code> and <code>FileWriter</code>.</p>"},{"location":"en/UD1_Files/2_Reading_and_writing_files/#131-filereader","title":"1.3.1. <code>FileReader</code>","text":"<p>The FileReader class serves to access files for reading, and has two constructors:</p> <ul> <li><code>FileReader (File f)</code> \u2192 Receives an object of type <code>File</code>, which will reference the object from which it is to be obtained.</li> <li><code>FileReader (String name)</code> \u2192 Receives a String with the name or path to the file.</li> </ul> <p>The methods we have for this class are pretty much the same as we have for <code>FileInputStream</code>, with the difference that we now read characters instead of bytes. One aspect to consider is that these characters will be represented in the format of the host operating system (UTF-8 in the case of Linux), unlike the UTF-16 used by other internal storage classes:</p> <ul> <li><code>int read()</code> \u2192 Reads the next character from the input stream and returns it as an integer. If there are no characters left, it returns -1, and if there is an error, it throws an exception of type IOException.</li> <li><code>int read(char[] buffer)</code> \u2192 Fills the buffer with as many characters from the input as it has (at most). It returns the number of characters effectively read. This number will be the length of the buffer or less if there are not enough characters to read. If none, return -1.</li> <li><code>int available()</code> \u2192 Returns the number of characters available to read.</li> <li><code>long skip(long des)</code> \u2192 Skips as many characters as the parameter indicates. The return value is the number of characters that have been effectively thrown (they can be less than what we have indicated if we reach the end for example)</li> <li><code>int close()</code> \u2192 Closes the data stream</li> </ul>"},{"location":"en/UD1_Files/2_Reading_and_writing_files/#132-filewriter","title":"1.3.2. <code>FileWriter</code>","text":"<p>The FileWriter class would be the equivalent of <code>FileOutputStream</code> in character-oriented streams version. The class constructors are:</p> <ul> <li><code>FileWriter (File f)</code> \u2192 Opens the file specified by <code>File</code> for writing. If the file does not exist, it will be created, and if it exists, it will delete the contents.</li> <li><code>FileWriter (String name)</code> \u2192 Opens the file specified by a string with name and path in writing mode. If it does not exist, it will be created, and if it exists, it will delete the content</li> <li><code>FileWriter (File f, boolean append)</code> \u2192 Receives an object of type File and opens it in append mode, to write at the end. If it doesn't exist, it will be created, and if it exists, it will write behind it.</li> <li><code>FileWriter (String name_f, boolean append)</code> \u2192 Receives a string with the name or path of the location of the file to be written and opens it in append mode, to write at the end. If it doesn't exist, it will be created, and if it exists, it will write behind it.</li> </ul> <p>The main methods of the FileWriter class are very similar to those of <code>OutputStream</code>:</p> <ul> <li><code>write(int character)</code> \u2192 Writes the character to the output stream, with the operating system's own encoding. If there is an error, an IOException is thrown.</li> <li><code>void write(char[] buffer)</code> \u2192 Writes the contents of the buffer (character vector) to the file. If the buffer is null, it will throw an exception.</li> <li><code>void write(char[] buffer, int pos, int length)</code> \u2192 Writes the contents of the buffer (character array) from position pos, and as many bom bytes are given in length.</li> <li><code>void flush()</code> \u2192 Forces the remaining bytes in the write cache to be written to the output file.</li> <li><code>void close()</code> \u2192 Closes the output stream and frees the resources.</li> <li><code>void write(String text)</code> \u2192 Writes the entire text content to the file.</li> </ul>"},{"location":"en/UD1_Files/2_Reading_and_writing_files/#133-solved-exercise","title":"1.3.3. Solved Exercise","text":"<p>Create a simple Java program that merge all the files inside a folder in a unique file. The source folder and destination file will be indicated in program's call. We suppose all the files inside that folder are text files.</p> <p>Solution</p> Java<pre><code>class MergeTexts {\n    /*\n\n\n    Sintax:\n        MergeTexts DirectoriOrigen FitxerDest\u00ed\n\n    */\n    public static void main(String[] args) throws Exception {\n\n        File dir; // Source dir\n        // Collection of files from that dir\n        File[] files; \n\n        // readed characters\n        int characters;\n\n        // Input and Output Streams \n        FileReader fin=null;\n        FileWriter fout=null;\n\n        // Check the args\n        if(args.length!=2){\n            System.out.println(\"Nombre d'arguments erroni. Sintaxi:\\n mergeTexts DirectoriOrigen fitxerDesti\");\n            return;\n        }\n\n        try{\n\n            // We get the list of Files\n            dir=new File(args[0]);\n            files=dir.listFiles();\n\n\n            // Open and close output stream (in order to create the file)\n            fout=new FileWriter(args[1]);\n            fout.close();\n\n            // Re-open it\n            fout=new FileWriter(args[1], true);\n\n            // Iterate among the list\n            for (int i=0; i&lt;files.length; i++){\n                // open input stream\n                fin=new FileReader(args[0]+\"/\"+files[i].getName());\n                System.out.println(\"Merging \"+args[0]+\"/\"+files[i].getName());\n                // and merge to the output one\n                do {\n                    characters=fin.read();                 \n                    if (characters!=-1)\n                        fout.write(characters);\n                }while (characters!=-1);\n                fin.close(); //close the file merged\n\n            }\n            fout.close(); //close the output file\n\n        }catch (Exception exc){\n            // Catch all the exception (we coud improve it)\n            System.out.println(\"Input/Output error: \"+exc);\n        }\n    }\n}\n</code></pre> <p>Improve your code</p> <p>Try to improve the last code creating a <code>merge()</code> function. We should call it inside the main loop</p>"},{"location":"en/UD1_Files/2_Reading_and_writing_files/#14-decorators","title":"1.4. Decorators","text":"<p>Decorator Design Pattern</p> <p>Decorator classes are those that inherit from a certain class, and they provide added functionality to the original. In the case of input and output streams, we have decorators that allow us to read or write complete lines, instead of byte by byte, or save certain data format. It simplifies our work, adding a more natural and human-friendly way to use the base classes.</p> <p>The <code>InputStream</code> class has several decorators, but we'll stick with the following:</p> <ul> <li><code>DataInputStream</code> \u2192 Allows reading data of any type (integer, logical, etc.)</li> <li><code>ObjectInputStream</code> \u2192 Add the option to reads an entire object</li> </ul> <p>The <code>OutputStream</code> class, on the other hand, also has different decorators, among which we highlight:</p> <ul> <li><code>DataOutputStream</code> \u2192 Allows writing data of any type (integer, logical, etc.)</li> <li><code>PrintStream</code> \u2192 Allows writing data of any type, and also accepts <code>printf</code> and <code>println</code> methods</li> <li><code>ObjectOutputStream</code> \u2192 Allows writing (serializing) objects</li> </ul> <p>Regarding the decorator classes for character-oriented streams, we have, on the one hand, the (most prominent) <code>Reader</code> decorators:</p> <ul> <li><code>BufferedReader</code> \u2192 Creates an input buffer, allowing for example to read a complete line</li> </ul> <p>And for writer:</p> <ul> <li><code>BufferedWriter</code> \u2192 Creates an output buffer, allowing for example to write a full line</li> <li><code>PrintWriter</code> Allows the writing of data of different types, and has methods such as printf and println</li> </ul> <p>The <code>BufferedReader</code> class, among others, has the <code>readLine()</code> method, which allows reading an entire line of the file up to the end of the line, very useful in text files.</p> <p>On their behalf, the BufferedWriter class provides the <code>newLine()</code> method to enter the carriage return character, and the <code>write(String chain, int start, int length)</code> method to write a string or a specific part.</p> <p>The other decorator for writing is the <code>PrintWriter</code>, which offers us the methods <code>print(data)</code>, <code>println(data)</code> and <code>printf()</code>, for formatting.</p> <p>Alternatives to...</p> <p>Obviously, you could :</p> <ul> <li>concatenate <code>\\n</code> at the end of every String on every <code>print()</code> method instead calling <code>newLine()</code>.</li> <li>use <code>println()</code> instead calling <code>newLine()</code>.</li> </ul>"},{"location":"en/UD1_Files/2_Reading_and_writing_files/#141-solved-exercise","title":"1.4.1. Solved Exercise","text":"<p>Create a program to copy a text file adding the number lines at the beginning of each line.</p> <p>Solution</p> Java<pre><code>public class NumberLines {\n    public static void main(String[] args) throws Exception {\n\n        // Input and Output\n        BufferedReader fin;\n        PrintWriter fout;\n\n        // line counter\n        int num_linia;\n        // readed line\n        String linia;\n\n        // check args\n        if (args.length != 2) {\n            System.out.println(\"Nombre d'arguments erroni. Sintaxi:\\n numberLines fitxer eixida\");\n            return;\n        }\n\n        // Creare decorators\n        fin = new BufferedReader(new FileReader(args[0]));\n        fout = new PrintWriter(new FileWriter(args[1]));\n\n        num_linia = 1;\n        do {\n            // Read the line\n            linia = fin.readLine();\n            if (linia != null) {\n                fout.println(num_linia + \". \" + linia);\n            }\n            num_linia++;\n        } while (linia != null); // until we can't read\n\n        // close all\n        fin.close();\n        fout.close();\n\n    }\n}\n</code></pre>"},{"location":"en/UD1_Files/2_Reading_and_writing_files/#15-binary-files","title":"1.5. Binary Files","text":"<p>In this section and the following we will see how to storage different types of data and objects in files of different formats: binary files, XML or JSON files. Now, we will focus on binary files, both for storing structured data on the one hand, and objects, on the other, a process known as serialization.</p>"},{"location":"en/UD1_Files/2_Reading_and_writing_files/#151-storing-structured-data-in-binary-files","title":"1.5.1. Storing structured data in binary files","text":"<p>In the previous section we saw how to work with character and byte files. In the case of byte files, we have seen how to read and write them sequentially, byte by byte to the end of the file. Let's now see how to store structured data in binary files and how to be able to read them.</p> <p>Let's imagine that we want to save the following table, which combines data of different types. This sample will appear in next sections.</p> Module Hours Qualification Acc\u00e9s a Dades 6 8.45 Programaci\u00f3 de serveis i processos 3 9.0 Desenvolupament d'interf\u00edcies 6 8.0 Programaci\u00f3 Multim\u00e8dia i dispositius m\u00f2bils 5 7.34 Sistemes de Gesti\u00f3 Empresarial 5 8.2 Empresa i iniciativa emprenedora 3 7.4 <p>As we can see, we have text data, integer and floating point numeric data. If we want to maintain the types, character-oriented streams like <code>Reader</code> or <code>Writer</code> will not be useful, so we should use <code>InputStream</code> and <code>OutputStream</code>. The disadvantage is that it would be necessary to know exactly how many bytes each type of data occupies.</p> <p>In order to efficiently save these structures, we can make use of the <code>DataInputStream</code> and <code>DataOutputStream</code> classes, which are stream decorators and which offer us the following methods to save or retrieve data of different types, without worrying about what they occupy internally each. As you can see, there are reciprocal methods to read and write every base types.</p> <code>DataInputStream</code> <code>DataOutputStream</code> Description <code>byte readByte()</code> <code>void writeByte(int)</code> a byte <code>short readShort()</code> <code>void writeShort(short)</code> short int <code>int readInt()</code> <code>void writeInt(int)</code> an int <code>long readLong()</code> <code>void writeLong(long)</code> a long int <code>float readFloat()</code> <code>void writeFloat(float)</code> single precision <code>double readDouble()</code> <code>void writeDouble(double)</code> double precision <code>char readChar()</code> <code>void writeChar(int)</code> a Unicode char <code>String readUTF()</code> <code>void writeUTF(String)</code> a UTF-8 string <p>Warning</p> <p>A UTF-8 string is different of a single String. When a String is written, as is evident, the whole characters are storage. Saving it as UTF-8 string, add information about the string's length, and this information is essential to cut this strings when you will read in a future.</p> <p>Imagine you save two strings, \"euro\" and \"sport\". The result will be, at the end \"eurosport\". When somebody open this file in the future, how do he or she know the number of string stored (\"euro\", \"sport\" or simply \"eurosport\" (TV channel))</p> <p>Saving as UTF-8, when you save \"euro\" and \"sport\", the result is \"4euro5sport\". When somebody try to read it, first of all see a '4', and read \"euro\". Then, see a '5', and then read \"sport\". Notice that if \"eurosport\" is stored, the result is \"9eurosport\". Try to write a sample program with this string, opening the resulting file with amn hexadecimal editor.</p>"},{"location":"en/UD1_Files/2_Reading_and_writing_files/#152-solved-exercise","title":"1.5.2. Solved exercise","text":"<p>Write a program who has data stored in three parallel arrays, storing modules data of DAM. Write two functions, one for write this data on a file and another to read it. Consider to storage data group by module, instead name, hours and grade.</p> <p>Soluci\u00f3</p> Java<pre><code>public class Moduls{\n\n    // several arrays with modules data\n    String[] moduls={\"Acc\u00e9s a Dades\", \"Programaci\u00f3 de serveis i processos\", \"Desenvolupament d'interf\u00edcies\", \"Programaci\u00f3 Multim\u00e8dia i dispositiud m\u00f2bils\", \"Sistemes de Gesti\u00f3 Empresarial\", \"Empresa i iniciativa emprenedora\"};\n    int[]  hores={6, 3, 6, 5, 5, 3};\n    double[] notes={8.45, 9.0, 8.0, 7.34, 8.2, 7.4};\n\n    public void readFiLe(String name) throws IOException {\n        // Per lleginr el fitxer binari, creem un DataInputStream\n        // a partir del FileInputStream creat a partir del nom\n        DataInputStream f = new DataInputStream(new FileInputStream(name));\n\n        // Mentre el DataInputStream tinga dades disponibles\n        while (f.available()&gt;0){\n            // Llegirem del fitxer cada dada, amb l'ordre corresponent\n            // en funci\u00f3 del tipus\n            // (per tant, hem de saber l'ordre en qu\u00e8 guardem!)\n            System.out.println(\"M\u00f2dul: \" + f.readUTF());\n            System.out.println(\"Hores: \" + f.readInt());\n            System.out.println(\"Notes: \" + f.readDouble());\n            System.out.println();\n        }\n        f.close();\n    }\n\n    public void writeFile(String name) throws IOException{\n        // Per escriure el fitxer, fem \u00fas de DataOutputStream\n        DataOutputStream f = new DataOutputStream(new FileOutputStream(name));\n\n        // Recorrerem qualsevol dels vectors (tots haurien de tindre)\n        // la mateixa longitud\n        for (int i=0;i&lt;this.moduls.length;i++){\n            // I per a cada posici\u00f3, escriurem en funci\u00f3 del tipus de dada\n            f.writeUTF(this.moduls[i]);\n            f.writeInt(this.hores[i]);\n            f.writeDouble(this.notes[i]);\n\n        }\n        f.close();\n    }\n\n    public static void main(String[] args) throws IOException {\n\n        // Comprovem els arguments\n        if (args.length!=2){\n            System.out.println(\"Nombre d'arguments incorrecte.\\n\\nSintaxi: \\n\\t java Moduls [read | write] fitxer.dat\");\n            System.exit(0);\n        }\n\n        // Defining the class\n        Moduls moduls=new Moduls();\n\n        // Depending the args, we will proceed\n        if (args[0].equals(\"read\")) \n        moduls.readFiLe(args[1]);\n        else if (args[0].equals(\"write\")) \n        moduls.writeFile(args[1]);\n        else \n        System.out.println(\"No entenc l'ordre \"+args[0]+\"\\n\");\n    }\n}\n</code></pre>"},{"location":"en/UD1_Files/2_Reading_and_writing_files/#16-object-serialization","title":"1.6. Object serialization","text":"<p>Java provides a generic object serialization system: a recursive system that iterates over each object contained in an instance, until it reaches the primitive types, which it stores as an array of bytes. Apart from this information of the primitive types, additional information is also stored, or metadata specific to each class, such as the name or attributes among others. Thanks to this metadata, which describes the objects we save, we can automate serialization in a generic way, ensuring that we can read the objects later.</p> <p>The disadvantage of this method is that when we change the definition of the class (for example adding one more attribute, or changing its type), the metadata is modified, and we would not be able to read serialized objects with previous versions of the class In addition, it is also necessary to take into account that this is a specific mechanism of Java, and that we will not be able to consult these objects from other languages.</p> <p>For all of this, other techniques are preferable for the permanent storage of objects, which we will see later, but serialization can be useful for temporary storage, within the same execution of the application.</p> <p>What are this?</p> Text Only<pre><code>**Research:** try to find information about ***SerialVersionUID***, and what it use is important for.\n</code></pre>"},{"location":"en/UD1_Files/2_Reading_and_writing_files/#161-the-serializable-interface-and-decorators","title":"1.6.1. The <code>Serializable</code> interface and <code>Decorators</code>","text":"<p>If we want a class to be serializable, it must implement the Serializable interface, the purpose of which is simply to act as a marker to indicate to the JVM that the class can be serialized, so this class will have no methods.</p> <p>It should be said that all the classes corresponding to the basic types already implement the Serializable interface, as well as the String class, containers and Arrays. In the case of collections, it will depend on its contents, if its elements are serializable, the collection will be as well. If the object we want to serialize or those of any of its objects do not implement the Serializable interface, the exception <code>NotSerializableException</code> is thrown.</p> <p>The <code>ObjectInputStream</code> and <code>ObjectOutputStream</code> decorators offer us the ability to serialize any de-serializable object. In order to write an object, we will make use of the <code>writeObject</code> method of <code>ObjectOutputStream</code>, and to read it we will make use of <code>readObject</code>, of <code>ObjectInputStream</code>. </p> <p>Sheeps with sheeps</p> <p>Note that reading objects must be done on instances of the same class that was saved. Otherwise, a <code>ClassCastException</code> is thrown. Also, you must have the compiled code of the class, to avoid the <code>ClassNotFoundException</code> exception. </p> <p>In addition, <code>readObject</code> return an Object, and we need an object of a specific class. For this reason you have to cast from Object to the needed class. Inheritance concepts are very important to guarantee robust programs. </p>"},{"location":"en/UD1_Files/2_Reading_and_writing_files/#162-solved-exercise","title":"1.6.2. Solved exercise","text":"<p>Starting with the same base of the <code>Moduls</code> class in the previous exercise, we are going to create a <code>Modul</code> class, to store a single module. This kind of classes are called POJO's (Plain Old Java Objects), and are designed only to storage information. (It will appear later, togethre with BEAN's classes).</p> <p>Once the <code>Modul</code> class is created, write a program to save on a file objects directly. Later, write the complementary function to read all the stored objects from that file. </p> <p>Solution</p> Java<pre><code>/**\n    Class to storage a single module in memory\n*/\n\nclass Modul implements Serializable{\n    String nom;\n    int hores;\n    double nota;\n\n    public Modul(){\n        // Constructor buit\n    }\n\n    public Modul(String nom, int hores, double nota){\n        this.nom=nom;\n        this.hores=hores;\n        this.nota=nota;\n    }\n\n    public String getModul() {return this.nom;}\n    public int getHores() {return this.hores;}\n    public double getNota() {return this.nota;}\n} \n\n/**\n    Write and Read modules to/from file\n*/\n\npublic class Moduls2 {\n\n    // Arrays with source data\n    String[] moduls = {\"Acc\u00e9s a Dades\", \"Programaci\u00f3 de serveis i processos\", \"Desenvolupament d'interf\u00edcies\", \"Programaci\u00f3 Multim\u00e8dia i dispositiud m\u00f2bils\", \"Sistemes de Gesti\u00f3 Empresarial\", \"Empresa i iniciativa emprenedora\"};\n    int[] hores = {6, 3, 6, 5, 5, 3};\n    double[] notes = {8.45, 9.0, 8.0, 7.34, 8.2, 7.4};\n\n    public void EscriuObjecte(String nom) throws IOException {\n\n        //destination file\n        ObjectOutputStream f = new ObjectOutputStream(new FileOutputStream(nom));\n\n        Modul m; // Single object\n\n        // loop along the arrays\n        for (int i = 0; i &lt; this.moduls.length; i++) {\n            m = new Modul(this.moduls[i], this.hores[i], this.notes[i]);\n            f.writeObject(m);\n        }\n\n        // close the file\n        f.close();\n\n    }\n\n    public void LligObjecte(String nom) throws IOException, ClassNotFoundException {\n\n        // input file\n        ObjectInputStream f = new ObjectInputStream(new FileInputStream(nom));\n\n        Modul m;\n        // we don't know how many objects exists in the file.\n        try {\n            while (true) { // forever\n\n                m = (Modul) f.readObject();\n\n                // show the module\n                System.out.println(\"Modul: \" + m.getModul());\n                System.out.println(\"Hores: \" + m.getHores());\n                System.out.println(\"Nota: \" + m.getNota());\n                System.out.println();\n\n            }\n        } catch (EOFException ex) {\n            f.close();\n        }\n\n    }\n\n    public static void main(String[] args) throws IOException, ClassNotFoundException {\n\n        // test the args\n        if (args.length != 2) {\n            System.out.println(\"Nombre d'arguments incorrecte.\\n\\nSintaxi: \\n\\t java Moduls2 [ read | write ] fitxer.obj\");\n            System.exit(0);\n        }\n\n        Moduls2 moduls = new Moduls2();\n\n        // depending the args\n        if (args[0].equals(\"read\")) {\n            moduls.LligObjecte(args[1]);\n        } else if (args[0].equals(\"write\")) {\n            moduls.EscriuObjecte(args[1]);\n        } else {\n            System.out.println(\"No entenc l'ordre \" + args[0] + \"\\n\");\n        }\n\n    }\n\n}\n</code></pre> <p>Less work, but the same in the end</p> <p>You probably will think about it: If all in Java inherits from Object, an ArrayList is an Object...Can I save or load an entire ArrayList in one unique call?. Try it as an improvement of the last exercise.</p>"},{"location":"en/UD1_Files/3_XML_Files/","title":"1. XML Files","text":""},{"location":"en/UD1_Files/3_XML_Files/#11-why-xml","title":"1.1. Why XML?","text":"<p>When we want to save data that can be read by different applications and platforms, it is best to use standard storage formats that multiple applications can understand (portability). A very specific case is markup languages, and the best known is the XML (eXtensible Markup Language) standard.</p> <p>With XML documents we structure the information by inserting marks or tags between the information. These tags have a beginning and an end, and can nest inside others, as well as contain textual information. Since the information will be textual, we don't have the problem of different data representation, since any data, of whatever type, will be passed to text. In order to also avoid the problem of different text encoding systems, XML allows the encoding used to save the document to be included in the header of the document.</p> <p>The way to store information in XML, in a hierarchical way, is very similar to the way objects in an application do it, so that these can be translated in a relatively convenient way to an XML document. Starting with our previous sample:</p> Module Hours Qualification Acc\u00e9s a Dades 6 8.45 Programaci\u00f3 de serveis i processos 3 9.0 Desenvolupament d'interf\u00edcies 6 8.0 Programaci\u00f3 Multim\u00e8dia i dispositius m\u00f2bils 5 7.34 Sistemes de Gesti\u00f3 Empresarial 5 8.2 Empresa i iniciativa emprenedora 3 7.4 <p>can be represented with only tags or labels <code>xml</code>:</p> XML<pre><code>&lt;curs&gt;\n    &lt;modul&gt;\n      &lt;nom&gt;Acc\u00e9s a Dades&lt;/nom&gt;\n      &lt;hores&gt;6&lt;/hores&gt;\n      &lt;qualificacio&gt;8.45&lt;/qualificacio&gt;\n    &lt;/modul&gt;\n    &lt;modul&gt;\n      &lt;nom&gt;Programaci\u00f3 de serveis i processos&lt;/nom&gt;\n      &lt;hores&gt;3&lt;/hores&gt;\n      &lt;qualificacio&gt;9.0&lt;/qualificacio&gt;\n    &lt;/modul&gt;\n    &lt;modul&gt;\n      &lt;nom&gt;Desenvolupament d'interf\u00edcies&lt;/nom&gt;\n      &lt;hores&gt;6&lt;/hores&gt;\n      &lt;qualificacio&gt;8.0&lt;/qualificacio&gt;\n    &lt;/modul&gt;\n    &lt;modul&gt;\n      &lt;nom&gt;Programaci\u00f3 Multim\u00e8dia i dispositiud m\u00f2bils&lt;/nom&gt;\n      &lt;hores&gt;5&lt;/hores&gt;\n      &lt;qualificacio&gt;7.34&lt;/qualificacio&gt;\n    &lt;/modul&gt;\n    &lt;modul&gt;\n      &lt;nom&gt;Sistemes de Gesti\u00f3 Empresarial&lt;/nom&gt;\n      &lt;hores&gt;5&lt;/hores&gt;\n      &lt;qualificacio&gt;8.2&lt;/qualificacio&gt;\n    &lt;/modul&gt;\n    &lt;modul&gt;\n      &lt;nom&gt;Empresa i iniciativa emprenedora&lt;/nom&gt;\n      &lt;hores&gt;3&lt;/hores&gt;\n      &lt;qualificacio&gt;7.4&lt;/qualificacio&gt;\n    &lt;/modul&gt;\n&lt;/curs&gt;\n</code></pre> <p>or can be represented with tags and attributes:</p> <p>XML<pre><code>&lt;curs&gt;\n    &lt;modul nom=\"Acc\u00e9s a Dades\" hores=\"6\" qualificacio=\"8.45\" &gt;\n    &lt;modul nom=\"Programaci\u00f3 de serveis i processos\" \"hores\"=3 qualificacio=\"9.0\" &gt;\n    &lt;modul nom =\"Desenvolupament d'interf\u00edcies\" hores=\"6\" qualificacio=\"8.0\" &gt;\n    &lt;/modul&gt;\n    &lt;modul nom=\"Programaci\u00f3 Multim\u00e8dia i dispositiud m\u00f2bils\" hores=\"5\" qualificacio=\"7,34\"&gt;\n    &lt;modul nom=\"Sistemes de Gesti\u00f3 Empresarial\" hores=\"5\" \"qualificacio\"=8.2 /&gt;\n    &lt;modul nom=\"Empresa i iniciativa emprenedora\"  hores=\"3\" qualificacio=\"7.4\" /&gt;\n    &lt;/modul&gt;\n&lt;/curs&gt;\n</code></pre> An XML parser or analyzer is a class that allows you to analyze an XML file and extract information from it, relating it according to its position in the hierarchy. The analyzers, according to their way of functioning, can be:</p> <ul> <li>Sequential or syntactic analyzers, which extract the content as the opening and closing tags are discovered. They are very fast, but have the problem that you have to read the whole document in order to access a specific part. In Java there is the SAX (Simple API for XML) parser as a sequential parser.</li> <li>Hierarchical analyzers, which are usually the most used, and which save all the data of the XML document in memory, in the form of a hierarchical structure (DOM or Document Object Model, being the preferred ones for applications that have to read the data more continuously.</li> </ul>"},{"location":"en/UD1_Files/3_XML_Files/#12-the-document-object-model-dom","title":"1.2. The Document Object Model (DOM)","text":"<p>The DOM (Document Object Model) is the structure specified by the W3C where the information of XML documents is stored. The DOM has been linked mainly to the web world, with HTML and Javascript as the main drivers. In Java, the DOM is implemented using interfaces.</p> <p>The main interface of the DOM in Java is <code>Document</code>, and it represents the entire XML document. Since it is an interface, it can be implemented in several classes.</p> <p>Note</p> <p>An interface is a kind of template for building classes, and is generally composed of a set of unimplemented method header declarations that specify how one or more classes behave. In addition, a class can implement one or more interfaces. In this case, the class will have to declare and define all the methods of each of the interfaces, or declare itself as an abstract class.</p> <p>An interface should also not be confused with an abstract class, as there are some differences, as the interface has all abstract methods; cannot declare instance variables; a class can implement several interfaces, but not inherit from several superclasses; and the interface does not have to belong to any hierarchy, so that classes that do not have any inheritance relationship can implement the same interface.</p> <p>Apart from <code>Document</code>, the W3C also defines the abstract class <code>DocumentBuilder</code>, which allows to create the DOM from the XML. In addition, the <code>DocumentBuilderFactory</code> class is specified, which allows us to manufacture <code>DocumentBuilders</code>, since being abstract it cannot be instantiated directly.</p> <p>It should be said, as a warning, that Java offers many libraries from which to import Document. The libraries we will use to parse XMLs will be:</p> <ul> <li>The <code>java.xml.parsers.*</code> library, which will offer the <code>DocumentBuilderFactory</code> and <code>DocumentBuilder</code> classes, and</li> <li>The <code>org.w3c.dom.*</code> library for the <code>Document</code> class.</li> </ul>"},{"location":"en/UD1_Files/3_XML_Files/#121-documentbuilder-and-documentbuilderfactory","title":"1.2.1. <code>DocumentBuilder</code> and <code>DocumentBuilderFactory</code>","text":"<p>As discussed, <code>DocumentBuilder</code> defines an API for obtaining DOM instances from an XML document. In order to obtain an instance of the class, the <code>DocumentBuilderFactory</code> factory must be used, and specifically the <code>newDocumentBuilder()</code> method:</p> <p>On the other hand, in order to read and interpret the XML document, the <code>DocumentBuilderFactory</code> class provides the <code>parse()</code> method, which parses an XML indicated by a File, and returns a Document object.</p> <p>Let's see everything with an example. We continue with storing data about course modules, but now with XML. The following method will serve us, in order to open an XML document, parse it and return the DOM generated in a Document. We can use it everywhere in our programs, because the task is always similar:</p> Java<pre><code>public Document OpenXML(String name) throws IOException,SAXException, ParserConfigurationException, FileNotFoundException {\n\n    // Create an instance of DocumentBuilderFactory\n    DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n    // Using the DocumentBuilderFactory instance we create a DocumentBuilder\n    DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n    //And we use DocumentBuilder's \"parse\" method to get the document\n    Document doc = dBuilder.parse(new File(name));\n\n    return document;\n}\n</code></pre> <p>It should be said that the above function could have been simplified without using the intermediate statements, but it is a little offuscated:</p> Java<pre><code>public Document OpenXML(String name) throws IOException,SAXException, ParserConfigurationException, FileNotFoundException {\n     return DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(name);\n}\n</code></pre> <p>On the other hand, the <code>DocumentBuilder</code> class also allows us to create a new DOM, with the <code>newDocument()</code> method. This will serve us later in order to store the XML documents. The proceeding way is:</p> <ul> <li>First thing, we will have to do is create a new DOM with newDocument()</li> <li>Add the elements and </li> <li>then store it on a file. </li> </ul> <p>In later sections, we will see how to do all this. For now we're going to focus on interpreting and reading the DOM.</p> <p>You can visit this links in order to find more information about the DocumentBuilder and DocumentBuilderFactory classes can be found in the OpenJDK API:</p>"},{"location":"en/UD1_Files/3_XML_Files/#13-classes-and-methods-of-dom","title":"1.3. Classes and Methods of DOM","text":"<p>So far we've seen how to open and parse an XML document with DocumentBuilder to create an object of type Document. In this section we will see how to work with this document in order to access the different elements. As we know, the DOM has a hierarchical structure, made up of nodes. The different types of nodes we can find are:</p> <ul> <li><code>Document</code> \u2192 which is the main node and represents all the XML.</li> <li><code>Element</code> \u2192 which represents the different tags (including the root). In other words, all tags are Elements, ones nested inside othres.</li> <li><code>TextElement</code> \u2192 which represents the content of a text tag.</li> <li><code>Attribute</code> \u2192 which represents the attributes.</li> </ul> <p>All these interfaces derive from the <code>Node</code> interface, so they will inherit its attributes and methods, and in addition, they will provide their own attributes and methods.</p> <p>Let's see the most important methods of each interface:</p>"},{"location":"en/UD1_Files/3_XML_Files/#131-node-interface-methods","title":"1.3.1. Node interface methods","text":"<p>Methods related to obtaining information</p> <ul> <li><code>String getNodeName()</code> \u2192 Gets the name of the current node</li> <li><code>short getNodeType()</code> \u2192 Gets the node type (ELEMENT_NODE, ATTRIBUTE_NODE, TEXT_NODE...)</li> <li><code>String getNodeValue()</code>\u2192 Gets the value of the node</li> <li><code>NodeList getChildNodes()</code> \u2192 Gets a list with child nodes</li> <li><code>Node getFirstChild()</code> \u2192 Returns the first child</li> <li><code>Node getLastChild()</code> \u2192 Returns the last child</li> <li><code>NamedNodeMap getAttributes()</code> \u2192 Returns a list with the attributes of the node</li> <li><code>Node getParentNode()</code> \u2192 Returns the parent node</li> <li><code>String getTextContent()</code> \u2192 Returns the text contained in the element and its descendants</li> <li><code>boolean hasChildNodes()</code> \u2192 Returns true if the node has any children</li> <li><code>boolean hasAttributes()</code> \u2192 Returns true if the node has any attributes</li> </ul> <p>Methods related to writing</p> <ul> <li><code>Node appendChild(Node node)</code> \u2192 Appends a new node as the last child node.</li> <li><code>void removeChild(Node node)</code> \u2192 Removes the specified node from the child nodes.</li> </ul>"},{"location":"en/UD1_Files/3_XML_Files/#132-element-interface-methods","title":"1.3.2. Element interface methods:","text":"<p>Methods related to obtaining information</p> <ul> <li><code>String getAttribute(String name)</code> \u2192 Returns the value of the attribute given by name.</li> <li><code>NodeList getElementsByTagName(String name)</code> \u2192  Returns a list of child nodes that match the given name.</li> <li><code>boolean hasAttribute(String name)</code> \u2192 Returns true if the element has the given attribute.</li> </ul> <p>Methods related to writing</p> <ul> <li><code>void setAttribute(String name, String value)</code> \u2192 Adds an attribute to the element, with the given name and value.</li> <li><code>void removeAttribute(String name)</code> \u2192 Removes the attribute indicated by name.</li> </ul>"},{"location":"en/UD1_Files/3_XML_Files/#133-document-interface-methods","title":"1.3.3. Document interface methods:","text":"<p>Methods related to obtaining information</p> <ul> <li><code>Element getDocumentElement()</code> \u2192  Returns the root element of the document.</li> <li><code>NodeList getElementsByTagName(String name)</code> \u2192  Returns a list of child nodes that match the given name</li> </ul> <p>Methods related to writing</p> <ul> <li><code>Element createElement(String name)</code> \u2192 Creates a new element with the given name.</li> <li><code>Text createTextNode(String text)</code> \u2192 Creates a new text element.</li> <li><code>Node appendChild(Node node)</code> \u2192 Appends a new child node.</li> </ul> <p>Objects of type <code>NodeList</code>, which represent a list of nodes, offer the <code>item(int index)</code> method to access the different nodes in the list, indicating their order.</p>"},{"location":"en/UD1_Files/3_XML_Files/#14-reading-xml-files","title":"1.4. Reading XML files","text":"<p>Let's go to review all concepts in this section with a practice. We are going to create a class who includes all the necessary methods to open, read, show and write XML files. We work with the document in section \\ref{xmlDoc}. </p> <p>In order to start reading the document, the first thing we will have to do is get the root of the document, with <code>getDocumentElement()</code>, which returns an object of type <code>Element</code>. Remember that doc variable contains the whole DOM, read with method explained previously: Java<pre><code>Element root = doc.getDocumentElement();\n</code></pre></p> <p>With this root element, we could already display all the content with <code>getTextContent()</code>. It will show on screen as text format, only print:</p> Java<pre><code>System.out.println(root.getTextContent());\n</code></pre> <p>But what we're interested in is traversing the entire DOM and accessing its elements. For this, starting from this root element, we will follow the following steps:</p> <ol> <li>We will search for all <code>&lt;modul&gt;</code> tags with <code>getElementsByTagName</code>. This method returns us a list of nodes (object of type <code>NodeList</code>). </li> <li>It will be necessary to traverse the list of nodes (<code>NodeList</code>) to access each element. For this, you must use the <code>item(int index)</code> method, which will return an element of type <code>Node</code>, and which must be converted to <code>Element</code> explicitly with a cast operation.</li> <li>For each element, we'll access the node name to display the name and order, using <code>getNodeName()</code></li> <li>We look for the different tags found within each module ('name', 'hours' and 'grade') with <code>getElementsByTagName()</code>. This method have given us again a NodeList for each type of tag. Since we will only have one item, we only need to access the unique element, represented by <code>item(0)</code>.</li> <li>It should be noted that with the above we will have the first (and only) label 'name', 'hours' or 'grade' of the module, but we are not yet in the content, since this is an element of type <code>TEXT_NODE</code>. To access it, we will have to access the first child of the tag (<code>getFirstChild()</code>) and get its value with <code>getNodeValue()</code></li> </ol> Java<pre><code>    // We will get a list of nodes (Step 1)\n    NodeList modules = root.getElementsByTagName(\"modul\");\n\n    // For each node (Step 2)\n    for (int i = 0; i &lt; modules.getLength(); i++) {\n        Element el = (Element) modules.item(i);\n\n        // Display the node name (Step 3)\n        System.out.println(el.getNodeName() + \" \" + (i + 1));\n\n        // And we show the value of the different tags \n        System.out.println(\"Nom: \" + el.getElementsByTagName(\"nom\").item(0).getFirstChild().getNodeValue());\n        System.out.println(\"Hores: \" + el.getElementsByTagName(\"hores\").item(0).getFirstChild().getNodeValue());\n        System.out.println(\"Qualificaci\u00f3: \" + el.getElementsByTagName(\"qualificacio\").item(0).getFirstChild().getNodeValue());\n        System.out.println();\n    }\n}\n</code></pre>"},{"location":"en/UD1_Files/3_XML_Files/#15-writing-xml-files","title":"1.5. Writing XML Files","text":"<p>Now let's go to the writing part of the XML documents. For this, we will start from a file that already contains the information in binary format of the modules (for example from previous section), we will read it, and we will import its information in XML format.</p> <p>The first thing we need to do is read the object file using an <code>ObjectInputStream</code>:</p> Java<pre><code>ObjectInputStream f = new ObjectInputStream(new FileInputStream(file));\n</code></pre> <p>And create an empty Xml Document, using the <code>DocumentBuilder</code> and <code>DocumentBuilderFactory</code> classes:</p> Java<pre><code>Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n</code></pre> <p>Once we have the empty document, we create the root element (curso), and add it to the document:</p> Java<pre><code>Element root = doc.createElement(\"curso\");\ndoc.appendChild(root);\n</code></pre> <p>Remember that we will access the object file, so we will have to know exactly what the class we want to read is like, and access the corresponding methods in order to obtain information about it. For this, first, you need to define an object of type <code>Modul</code>, and we will read the object file with the <code>readObject</code> method of File. Once we have read an object, we will create the tag that encompasses each of them: the <code>modul</code> tag:</p> Java<pre><code>Modul m = (Modul) f.readObject();\nElement modul = doc.createElement(\"modul\");\n</code></pre> <p>And inside it, and as we extract the different properties of the Modul object, we will create child nodes and add them to the module. For example, for module name:</p> Java<pre><code>Element name = doc.createElement(\"nom\");\nname.appendChild(doc.createTextNode(m.getModul()));\nmodule.appendChild(name);\n</code></pre> <p>As we can see, we have created an object of type Element with the label 'name', and we have added as a child a node of type text (TEXT_NODE), which we have extracted directly from the object <code>Modul m</code> with its own function <code>getModul()</code>. Additionally, we added this tag to the <code>&lt;modul&gt;</code> tag, with appendChild.</p> <p>We will have to do the same for the hours of each module and the qualification, but for this, we will have to take into account that the getHores and getNota methods do not return a String, but an int and a double, so they will have to be converted to text:</p> Java<pre><code>Element hours = doc.createElement(\"hores\");\nhours.appendChild(doc.createTextNode(Integer.toString(m.getHores())));\nmodule.appendChild(hours);\n\nElement qualification = doc.createElement(\"qualificacio\");\nqualification.appendChild(doc.createTextNode(Double.toString(m.getNote())));\nmodule.appendChild(grade);\n</code></pre> <p>We'll put this entire procedure inside a loop that slides the entire object file. Once we have read each of the modules, we will have to add them to the root element with:</p> Java<pre><code>root.appendChild(module);\n</code></pre> <p>And we will already have our XML document at the root. Now we would have to convert this object of type <code>Element</code> into a text string in order to be able to write it to the disk. For this we will make use of the <code>Transformer</code> utility.</p>"},{"location":"en/UD1_Files/3_XML_Files/#151-transformer","title":"1.5.1. Transformer","text":"<p>Java offers us the <code>Transformer</code> utility to convert information between different hierarchical formats, such as the Document object that contains the DOM of our XML, to an XML text file.</p> <p>The <code>Transformer</code> class, like <code>DocumentBuilder</code>, is also an abstract class, so it also requires a factory to be instantiated. The Transformer class works with two types of adapters. Adapters are classes that make different hierarchies compatible. These adapters are <code>Source</code> and <code>Result</code>. The classes that implement these adapters will be responsible for making the different types of containers compatible with what the Transformer class requires. So, and to clarify, we have the <code>DOMSource</code>, <code>SAXSource</code> or <code>StreamSource</code> classes, which are adapters of the information source container for DOM, SAX or Stream; and of <code>DOMResult</code>, <code>SAXResult</code>, and <code>StreamResult</code> as equivalent adapters to the target container.</p> <p>For our case, since we have a DOM and want to convert it to a Stream, we will need a <code>DomSource</code> and a <code>StreamResult</code>. Let's see the code needed to do this:</p> Java<pre><code>Transformer trans = TransformerFactory.newInstance().newTransformer();\nDOMSource source = new DOMSource(doc);\nStreamResult result = new StreamResult(new FileOutputStream(file+\".xml\"));\n</code></pre> <p>The first thing we have done is to create an object of type Transformer with the newTransformer() method of an instance (newInstance()) of the Transformers factory TransformerFactory. Then we defined the source (source) and the result (result) for the transformation, the source being a DomSource created from the doc that contains our document, and the result a StreamResult, which will write the stream to disk through a FileOutputStream.</p> <p>And finally, we do the transformation from one element to another, which will automatically generate the output XML file:</p> Java<pre><code>trans.transform(source, result);\n</code></pre> <p>You can get</p> <p>The full sample is available on Aules platform</p>"},{"location":"en/UD1_Files/3_XML_Files/#16-advanced-techniques-xml-binding","title":"1.6. Advanced techniques: XML binding","text":"<p>The Binding technique consists of generating Java classes with specific formats, such as XML, so that each XML tag or attribute corresponds to a property of a certain class. This correspondence is called a mapping.</p> <p>In Java, there are different libraries for mapping or binding: JAXB, JuBX, XMLBinding, etc. JAXB (Java Architecture for XML Binding) is a powerful library that has been included in the standard since JDK 6, but has been removed in version 11, and is suggested to be included as a third-party package. JAXB makes use of annotations to get the information needed to map the binding. Annotations are special Java indications that allow you to associate information and functionality to objects, without interfering with the structure of the data model. Annotations can be associated with a package, class, attribute, or parameter, and are declared with the <code>@</code> symbol in front of the annotation name. When the compiler detects an annotation, it creates an instance and injects it into the affected element, without interfering with the class itself. When an application needs the information from the annotations, they can get the injected instance.</p> <p>For example, in the <code>Modul</code> class we had defined, we would use the annotation <code>@XmlRootElement</code> to indicate the root element of the module, and the annotations <code>@XmlElement</code>, to indicate that the setters of the class will also write XML elements.</p> Java<pre><code>@XmlRootElement\nclass Modul {\n\n    String nom;\n    int hores;\n    double nota;\n\n    public String getNom() { return nom; }\n    @XmlElement\n    public void setNom(String nom) { this.nom = nom; }\n\n\n    public int getHores() { return hores; }\n    @XmlElement\n    public void setHores(int hores) { this.hores = hores; }\n\n    public double getNota() { return nota; }\n    @XmlElement\n    public void setNota(double nota) { this.nota = nota;}\n\n\n}\n</code></pre> <p>With this we would have only the class with annotations ready to save a module as an XML document. To save the entire hierarchy we should create the <code>Curs</code> class, which would contain an <code>ArrayList</code> of modules.</p> <p>As for this course, we will not delve further into this technique, since for our purposes, the XML parsing that we have seen in previous sections is sufficient.</p> <p>More and more</p> <p>We are going to use lots of annotations this course, keep calm...</p>"},{"location":"en/UD1_Files/4_JSON_Files/","title":"1. JSON Files","text":"<p>JSON is another lightweight text format for data exchange. JSON stands for JavaScript Object Notation, and is a subset of the language's literal object notation, which has been adopted alongside XML as one of the major standards for data exchange and storage.</p> <p>One of the advantages of JSON over XML is the ease of writing parsers, but more important than that, is that it expresses the same thing as XML but in a much more concrete and concise way, so it is commonly used in environments where the flow of data is important, as is the case with the servers of Google, Yahoo, etc. serving millions of users.</p>"},{"location":"en/UD1_Files/4_JSON_Files/#11-json-format","title":"1.1. JSON format","text":"<p>The complete specification can be viewed here</p> <p>The types of data that we can represent in JSON are:</p> <ul> <li>Numbers, both integers and decimals.</li> <li>Strings, expressed between quotes and with the possibility of including escape sequences.</li> <li>Booleans, to represent the values <code>true</code> and <code>false</code>.</li> <li>Null, to represent the <code>null</code> value.</li> <li>Array, to represent lists of zero or more values, of any type, enclosed in square brackets and separated by commas.</li> <li>Objects, as collections of <code>&lt;key&gt;:&lt;value&gt;</code> pairs, separated by commas and braces, and of any value type.</li> </ul> <p>We will see it better with a well-known example: The one of the modules we are working with:</p> <p>JSON<pre><code>{\n  \"curs\": [\n        {\n          \"nom\": \"Acc\u00e9s a Dades\",\n          \"hores\": 6,\n          \"qualificacio\":  8.45\n        },\n        {\n          \"nom\": \"Programaci\u00f3 de serveis i processos\",\n          \"hores\": 3,\n          \"qualificacio\": 9.0\n        },\n        {\n          \"nom\": \"Desenvolupament d'interf\u00edcies\",\n          \"hores\": 6,\n          \"qualificacio\": 8.0\n        },\n        {\n          \"nom\": \"Programaci\u00f3 Multim\u00e8dia i dispositius m\u00f2bils\",\n          \"hores\": 5,\n          \"qualificacio\": 7.34\n        },\n        {\n          \"nom\": \"Sistemes de Gesti\u00f3 Empresarial\",\n          \"hores\": 5,\n          \"qualificacio\": 8.2\n        },\n        {\n          \"nom\": \"Empresa i iniciativa emprenedora\",\n          \"hores\": 3,\n          \"qualificacio\": 7.4\n        }\n      ]\n}\n</code></pre> Let's see how <code>curs</code> is an array or a list of modules (although we don't use the modul label now), which in this case are objects with three elements: the name which is a string of characters, the hours which is an integer, and the rating, which is represented as a decimal number. Note that, like XML, we also need a root object, in this case the current element.</p> <p>Internet is full of services that offers information in JSON format as well. For instance, you can visit:</p> <ul> <li>https://arkhamdb.com/api/public/card/01001</li> <li>https://swapi.dev/api/films/1/</li> <li>http://hp-api.herokuapp.com/api/characters</li> </ul> <p>There is a wide range of Java libraries for manipulating JSON documents (GSON, Jackson, JSON.simple...). In our case, we are going to use the <code>org.json</code> library, which we can check in the Maven repository: https://mvnrepository.com/artifact/org.json/json</p> <p>In the next section we will comment on the functionality of the library, and in an attached document, we will see how to incorporate it into our projects through the Gradle dependency manager.</p>"},{"location":"en/UD1_Files/4_JSON_Files/#12-orgjson","title":"1.2. <code>org.JSON</code>","text":"<p>The library provides a set of classes for parsing JSON documents for Java, as well as converters between JSON and XML. Among the classes it offers, we could highlight:</p> <ul> <li><code>JSONObject</code> \u2192 Store key-value pairs in unordered form. Values \u200b\u200bcan be Boolean, JSONArray, Number, String, and JSONObject.NULL. Their constructors take as input different representations (String, maps, beans) and store them as a set of key-value elements.</li> <li><code>JSONTokener</code> \u2192 Parses a JSON string, and is used internally by JSONObject and other classes to parse JSON strings.</li> <li><code>JSONArray</code> \u2192 Stores a sequence of values, and represents a JSON array.</li> <li><code>JSONWriter</code> \u2192 Provides a way to produce JSON text. It has an <code>append(String)</code> method, which adds more text to a JSON object of text type, in addition to the key(String) and value(String) methods for adding keys and values \u200b\u200bto a JSON string. The class also allows you to write an array.</li> </ul>"},{"location":"en/UD1_Files/4_JSON_Files/#13-creating-json-files","title":"1.3. Creating JSON files","text":"<p>Our samples are based on the data of DAM modules saw in previous sections. Consider this code block as starting point where an array <code>Curs</code> is created and populated with modules :</p> Java<pre><code>private void creaCurs() {    \n    // Aquest m\u00e8tode inicializa l'objecte \"Curs\" de la classe JSONLib\n    // que no \u00e9s m\u00e9s que un vector de m\u00f2duls\n\n    // Definim els vectors per inicialitzar dades\n    String[] moduls={\"Acc\u00e9s a Dades\", \"Programaci\u00f3 de serveis i processos\", \"Desenvolupament d'interf\u00edcies\", \"Programaci\u00f3 Multim\u00e8dia i dispositiud m\u00f2bils\", \"Sistemes de Gesti\u00f3 Empresarial\", \"Empresa i iniciativa emprenedora\"};\n    int[]  hores={6, 3, 6, 5, 5, 3};\n    double[] notes={8.45, 9.0, 8.0, 7.34, 8.2, 7.4};\n\n    // Recorrem els vectors, creant els objectes\n    // de tipus Modul i guardant-los en Curs\n    for (int i=0;i&lt;moduls.length;i++){\n        Modul m = new Modul(moduls[i], hores[i], notes[i]);\n        this.Curs.add(m);\n    }\n}\n</code></pre> <p>To create the whole JSON file, we need to create individual JSON's, representing every object. Due to this object gets the information from the objects, it is a good idea to create methods inside the module object to get the JSON representation of every object:</p> Java<pre><code>public JSONObject getModulJSON(){\n    JSONObject modul = new JSONObject();\n\n    modul.put(\"nom\", this.nom);        \n    modul.put(\"hores\", this.hores);\n    modul.put(\"nota\",  this.nota);\n\n    // Si volguerem afegir un element nul, \n    // hauriem de fer:\n    // modul.put(\"atribut\", JSONObject.NULL);\n\n    return modul;\n\n};\n</code></pre> <p>Once the individual JSON is solved, we need to create the main JSON, the one who contains all the modules. It is easy to guess that the main element will be an array, containing all the module objects inside it.</p> Java<pre><code>private JSONObject creaJSON() {\n\n        // root element \"Curs\"\n        JSONObject curs = new JSONObject();\n\n        // who is a JSONArray\n        JSONArray jsarray = new JSONArray();\n\n        // we populate the array with individual modules\n        for (Modul m : this.Curs) {\n            JSONObject modul_json = m.getModulJSON();\n            jsarray.put(modul_json);\n        }\n\n        // Create the curs element with the array\n        curs.put(\"curs\", jsarray);\n\n        return (curs);\n    }\n</code></pre> <p>Finally, we need to save it to disk in a text file. This code block stores a JSONObject, using a FileWriter with an specific indentation:</p> Java<pre><code>private void escriuJSON(String filename, JSONObject jso){\n\n    try {\n        FileWriter file = new FileWriter(filename);\n        file.write(jso.toString(4)); // 4 s\u00f3n els espais d'indentaci\u00f3\n        file.close();\n\n    } catch (IOException e) {\n        System.out.println(\"Error, no es pot crear el fitxer \"+filename);\n    }\n}\n</code></pre>"},{"location":"en/UD1_Files/4_JSON_Files/#14-reading-json-files","title":"1.4. Reading JSON files","text":"<p>In order to read JSON files, we have to split the task in two parts. Firstly, and very simple, is to read from the file to a String, and call to the JSONObject constructor with this string. Then, we need to process it.</p> Java<pre><code>private JSONObject LligJSON(String filename){\n    try {\n        // Amb FileReader llegirem car\u00e0cter a \n        // car\u00e0cter el fitxer i l'afegim al string myJson\n        FileReader file = new FileReader(filename); \n        String myJson=\"\";\n\n        int i;\n        while ((i=file.read()) != -1) \n            myJson=myJson+((char) i);\n\n        //System.out.println(myJson);\n        file.close();\n\n        // I fem \u00fas del constructor de JSONObject\n        // al que li passem un string amb el JSON:\n        return (new JSONObject(myJson));\n\n\n    } catch (Exception e)\n    {\n        System.out.println(\"Error llegint el fitxer\");\n        return null;\n    }\n\n}\n</code></pre> <p>Once we have the main <code>JSONObject</code>, we need to recover the <code>JSONArray</code> (called curs). We could use the length() method to go over all modules with a <code>for</code> loop. To obtain the single objects of a JSONObject, the <code>get(string label)</code> method is provided, returning the object labeled. We need to take care of the type, and do conversions when we need it. In the sample above we only show the JSON, instead of create objects in memory.</p> Java<pre><code>private void MostraJson(JSONObject json){\n\n    // amb el m\u00e8tode getJSONArray obtenim el primer\n    // element \"curs\", que era una llista\n    JSONArray jsa=json.getJSONArray(\"curs\");\n\n    // I ara recorrem aquesta llista:\n    for (int i = 0; i &lt; jsa.length(); i++) {\n        // Agafem cada element de l'array amb \"get\"\n        JSONObject modul=(JSONObject)jsa.get(i);\n        // Amb el get anterior tindrem objectes JSON \n        // de m\u00f2duls, tipus:\n        // {\"nom\": \"Modul\", \"hores\": hores, \"nota\": nota }\n        // Als valors d'aquests parells tamb\u00e9 accedirem amb get:\n        System.out.println(\"Modul: \"+ modul.get(\"nom\"));\n        System.out.println(\"Hores: \"+ modul.get(\"hores\"));\n\n        System.out.println(\"Nota: \"+modul.get(\"nota\"));\n\n        /*\n        En esta funci\u00f3 escrivim els objectes JSON. Si volgu\u00e9rem\n        crear de nou l'estructura d'objectes, crear\u00edem cadascun \n        dels m\u00f2duls amb:\n            Modul m=new Modul(modul.get(\"nom\"), modul.get(\"hores\"), modul.get(\"nota\"));\n        */\n    }\n}\n</code></pre>"},{"location":"en/UD1_Files/5_Extra_Formats/","title":"1. Extra formats","text":"<p>In this section we will study two type of text files that are used widely in computer science, and the way to work with it.</p>"},{"location":"en/UD1_Files/5_Extra_Formats/#11-csv-files","title":"1.1. CSV files","text":"<p>A comma-separated values (CSV) file is a standard text file which uses a comma (<code>,</code>) to separate value. Each line of the file consists of one or more fields, separated by commas. Each field may or may not be enclosed in double-quotes. In addition, several formats use different characters as separator, as semicolon (<code>;</code>) or hash (<code>#</code>). The RFC 4180 defines the format or definitions of a CSV file or text/csv file.</p> <p>In case that the symbol that is used as separator appears inside the values, enclose the content between quotation marks it is a good idea.</p> <p>A sample of csv can be viewed here:</p> Text Only<pre><code>Chevrolet Chevelle Concours (sw);0;8;350.0;165.0;4142.;11.5;70;US\nFord Torino (sw);0;8;351.0;153.0;4034.;11.0;70;US\nPlymouth Satellite (sw);0;8;383.0;175.0;4166.;10.5;70;US\nAMC Rebel SST (sw);0;8;360.0;175.0;3850.;11.0;70;US\nDodge Challenger SE;15.0;8;383.0;170.0;3563.;10.0;70;US\nPlymouth Cuda 340;14.0;8;340.0;160.0;3609.;8.0;70;US\nFord Mustang Boss 302;0;8;302.0;140.0;3353.;8.0;70;US\n</code></pre> <p>The way to process a csv in Java is:</p> <ol> <li>Open as a text file for reading. We need to read line by line, because every line is a register. Read one line into a String variable.</li> <li>Process individual records:</li> <li>We could separate every field. A good option is use <code>split(char)</code> method from string. We will obtain an array of string with the individual fields values.</li> <li>Process each field value by your own</li> </ol> <p>Attention</p> <p>It is a good idea to start using <code>Files</code> and <code>Paths</code> abstract classes. These classes improve the use of File and it inherited classes, offering useful methods that allow us to do quick operations with less code lines. For example, the following line, starting from the <code>filename</code> open it and then read the whole file, returning a <code>List</code> with lines separated on each item of the collection.</p> Java<pre><code>List&lt;String&gt; lines=Files.readAllLines(Paths.get(filename));\n</code></pre> <p>More info in:</p> <ul> <li>Files</li> <li>Paths</li> </ul>"},{"location":"en/UD1_Files/5_Extra_Formats/#12-properties-files","title":"1.2. Properties files","text":""},{"location":"en/UD1_Files/5_Extra_Formats/#121-properties-file","title":"1.2.1. Properties file","text":"<p>At last, but not least, we are going to show you an important kind of text file, who is properties files. This files stores, as you know, several properties that are used during program execution. The program, when starting, load these properties and do a tuning of several option.  Example of these files are <code>my.conf</code> in MySQL, <code>php.ini</code> in PHP, etc.</p> <p>The aspect of this file is several lines (one by property) and every line <code>attribute=value</code>. For example, a supposed file:</p> Text Only<pre><code># properties of my program\nport=1234\nvolume=90\nbright=56\nload_on_start=true\n</code></pre> <p>The way to process a properties file in Java is similar to a CSV:</p> <ol> <li>Open as a text file for reading. We need to read line by line, because every line is a different property. Read one line into a String variable.</li> <li>Process individual records:</li> <li>We could separate every field. A good option is use <code>split(char)</code> method from string. We will obtain an array of string with the individual fields values. The separators are normally <code>=</code>, <code>:</code>.</li> <li>Left of the separator is the property name</li> <li>Right of the separator is the property's value</li> <li>Notice that if a line starts with slash (<code>#</code>) should be a comment, and will be ignored</li> </ol>"},{"location":"en/UD1_Files/5_Extra_Formats/#122-java-properties-object","title":"1.2.2. Java Properties object","text":"<p>Java has an object very useful to manage this kind of information. With properties, we can store a set of properties with a hash table (basically a pair key-value). It has methods prepared to load and save from and to streams of text or, moreover XML files. Interesting method for properties are:</p> <p>Reading from file (text or XML)</p> <ul> <li><code>void load(InputStream inStream)</code> \u2192 Reads a property list (key and element pairs) from the input byte stream.</li> <li><code>void load(Reader reader)</code> \u2192 Reads a property list (key and element pairs) from the input character stream in a simple line-oriented format.</li> <li><code>void loadFromXML(InputStream in)</code> \u2192 Loads all of the properties represented by the XML document on the specified input stream into this properties table.</li> </ul> <p>Writing to file (text or XML)</p> <ul> <li><code>void store(OutputStream out, String comments)</code> \u2192 Writes this property list (key and element pairs) in this Properties table to the output stream in a format suitable for loading into a Properties table using the load(InputStream) method.</li> <li><code>void store(Writer writer, String comments)</code> \u2192 Writes this property list (key and element pairs) in this Properties table to the output character stream in a format suitable for using the load(Reader) method.</li> <li><code>void storeToXML(OutputStream os, String comment)</code> \u2192 Emits an XML document representing all the properties contained in this table.</li> </ul> <p>Working with properties (inherited from HashTable)</p> <ul> <li><code>Set&lt;K&gt; keySet()</code> \u2192 Returns a Set view of the keys contained in this map.</li> <li><code>V get(Object key)</code> \u2192<code>Returns the value (</code>V<code>)to which the specified</code>key<code>is mapped, or</code>null` if this map contains no mapping for the key.</li> <li><code>boolean  containsKey(Object key)</code> Tests if the specified object is a key in this hashtable. </li> <li><code>V put(K key, V value)</code> \u2192 Maps the specified key to the specified value in this hashtable.</li> <li><code>V remove(Object key)</code> \u2192 Removes the key (and its corresponding value is returned) from this hashtable.</li> </ul>"},{"location":"en/UD1_Files/5_Extra_Formats/#123-sample-program","title":"1.2.3. Sample program","text":"<p>In the next program you can view sample of reading and creating properties files in Java</p> Java<pre><code>    /**\n     * Load the file specified and show its properties in different ways\n     * @param filename \n     */\n    private void loadAndShowProperties(String filename) {\n\n        Properties properties = new Properties();\n\n        try {\n            properties.load(new FileInputStream(new File(filename)));\n\n            System.out.println(\"Whole set: \" + properties);\n\n            properties.list(System.out);\n\n            Set&lt;Object&gt; keys = properties.keySet( );\n\n            System.out.println(\"My listing: \");\n            for (Object key : keys) {\n                System.out.println(key + \" - \" + properties.getProperty((String) key));\n            }\n\n        } catch (FileNotFoundException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (IOException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n\n    }\n\n    /**\n     * Create a properties object, populated with samples and stores into a \n     * text file and a XML file\n     * @throws IOException \n     */\n    private void writeProperties() throws IOException {\n        Properties props = new Properties();\n\n        props.put(\"Color\", \"Green\");\n        props.put(\"Range\", \"123\");\n        props.put(\"Visible\", \"false\");\n        props.put(\"Size\", \"Big\");\n        props.put(\"Status\", \"functional\");\n        props.put(\"Value\", \"345.24\");\n\n        props.store(new FileWriter(new File(\"propis.properties\")), \"Sample props file\");\n\n        props.storeToXML(new FileOutputStream(new File(\"propis.xml\")), \"Sample XML Props\");\n    }\n</code></pre>"},{"location":"en/UD1_Files/5_Extra_Formats/#13-environment-env-files-and-dot_env","title":"1.3. Environment, <code>.env</code> files and <code>dot_env</code>","text":""},{"location":"en/UD1_Files/5_Extra_Formats/#131-why-using-environment","title":"1.3.1. Why using environment?","text":"<p>Environment variables are a crucial aspect of configuring and managing applications across different environments, such as development, testing, and production. They provide a way to dynamically pass configuration data to applications without hardcoding values directly in the source code. This approach enhances the flexibility, portability, and security of applications.</p> <p>In Java, accessing environment variables is straightforward, thanks to the <code>System</code> class, which provides methods to retrieve environment variables. This capability is especially useful for:</p> <ul> <li>Configuring application settings like database URLs, API keys, and file paths.</li> <li>Managing environment-specific configurations without altering the codebase.</li> <li>Keeping sensitive information, such as passwords and tokens, out of the source code.</li> </ul> <p>By understanding how to effectively utilize environment variables in Java, developers can create more adaptable and secure applications. </p>"},{"location":"en/UD1_Files/5_Extra_Formats/#132-getting-environment-variables","title":"1.3.2. Getting environment variables","text":"<p>To access environment variables in Java, you can use the <code>System.getenv()</code> method. This method is overloaded, and coud be:</p> <ul> <li><code>System.getenv()</code> \u2192 returns a <code>Map</code> object containing all the environment variables and their corresponding values.</li> <li><code>System.getenv(String)</code> \u2192 returns a <code>String</code> with the value of the specific environment variable or null if it does not exists.</li> </ul> <p>How to retrieve environment variables in Java:</p> Java<pre><code>Map&lt;String, String&gt; env = System.getenv();\n\n// Access a specific environment variable\nString value = env.get(\"VARIABLE_NAME\");\n\n// Print all environment variables\nfor (Map.Entry&lt;String, String&gt; entry : env.entrySet()) {\n    System.out.println(entry.getKey() + \" = \" + entry.getValue());\n}\n</code></pre> <p>Notice that:</p> <ul> <li>The Map class returns a collection of entries with pairs key-value</li> <li>The environment variables are case-sensitive, so make sure to use the correct casing when accessing them.</li> </ul>"},{"location":"en/UD1_Files/5_Extra_Formats/#133-the-dot-env-approach","title":"1.3.3. The <code>dot-env</code> approach","text":"<p>Storing configuration in the environment is one of the tenets of a twelve-factor app. Anything that is likely to change between deployment environments\u2013such as resource handles for databases or credentials for external services\u2013should be extracted from the code into environment variables.</p> <p>But it is not always practical to set environment variables on development machines or continuous integration servers where multiple projects are run. Dotenv load variables from a .env file into ENV when the environment is bootstrapped.</p> <p>Unfortunately, loading <code>.env</code> files in Java is not natively supported by the language itself, but you can use external libraries to accomplish this task. One of the popular libraries for this purpose is <code>dotenv-java</code>. This library allows you to easily load environment variables from a .env file into your Java application. https://github.com/cdimascio/dotenv-java</p> <p>Add the Dependency</p> <p>First, you need to add the dotenv-java library to your project. If you are using Maven, add the following dependency to your pom.xml file:</p> XML<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.github.cdimascio&lt;/groupId&gt;\n    &lt;artifactId&gt;java-dotenv&lt;/artifactId&gt;\n    &lt;version&gt;5.2.2&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>If you are using Gradle, add the following to your build.gradle file:</p> Text Only<pre><code>implementation 'io.github.cdimascio:java-dotenv:5.2.2'\n</code></pre> <p>Create <code>.env</code> file</p> <p>The <code>.env</code> file is like config files. You can store it on the root path of your application</p> Text Only<pre><code>DATABASE_URL=jdbc:mysql://localhost:3306/testdb\nDATABASE_USER=root\nDATABASE_PASSWORD=password\n</code></pre> <p>Load the configuration</p> Java<pre><code>import io.github.cdimascio.dotenv.Dotenv;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Load the .env file\n        Dotenv dotenv = Dotenv.load();\n\n        // Retrieve environment variables\n        String databaseUrl = dotenv.get(\"DATABASE_URL\");\n        String databaseUser = dotenv.get(\"DATABASE_USER\");\n        String databasePassword = dotenv.get(\"DATABASE_PASSWORD\");\n\n        // Print the values\n        System.out.println(\"Database URL: \" + databaseUrl);\n        System.out.println(\"Database User: \" + databaseUser);\n        System.out.println(\"Database Password: \" + databasePassword);\n\n        // Use the variables as needed\n        // For example, establish a database connection using these variables\n    }\n}\n</code></pre> <p>Attention</p> <p>Notice that with java dotenv library, you will use <code>dotenv.get()</code> instead of <code>System.getenv()</code> method, due to you are accessing local file.</p>"},{"location":"en/UD2_Connectors/1_Object_relational_impedance_mismatch/","title":"1. Object\u2013relational impedance mismatch","text":"<p>Database Management Systems (DBMS - SGBD in spanish) are mostly based in Entity-Relationship model (E/R), where information is stored in several tables related to each other. It is a simple and efficient technology, which has endured over the years, and which is still the model used by most databases and DBMSs today. Despite the success, the model has some limitations, such as the representation of poorly structured or complex information.</p> <p>Conceptual models help us model a complex reality, and are based on a process of reality abstraction. Each model has a way of capturing this reality, but, all of them are closer to the human mentality than to the memory of a computer.</p> <p>When we model a database, we make use of the Entity-Relationship conceptual model, and subsequently, we do a process of transform into tables and normalizing this model, to have a relational data model.</p> <p>In the case of object-oriented programming, we try to represent reality through objects and the relationships between them. This is another type of conceptual model, but one that aims to represent the same reality as the relational one.</p> <p>So, we have two different approaches to represent the reality of a problem: the Relational Model of the database and the Object-Oriented model of our applications.</p>"},{"location":"en/UD2_Connectors/1_Object_relational_impedance_mismatch/#11-representation-of-information-with-the-relational-model","title":"1.1. Representation of information with the relational model","text":"<p>The relational model is based on tables and the relationship between them:</p> <ul> <li>Each table has as many columns as attributes we want to represent, and as many rows as records or elements of that type contain.</li> <li>The tables have a primary key, which identifies each of the records, and can be formed by one or more attributes.</li> <li>The relationship between tables is represented by external keys, which consist of including in a table the primary key of another table, as a reference to it. When is removed a record of a table, whose primary key is referenced by another, must be ensured that we maintain the referential integrity of the database. Then, before this deletion of a primary key, we can:</li> <li>Do not allow deletion (NO ACTION),</li> <li>Carry out the deletion in cascade, also deleting all the records that referred to the primary key of the deleted record (CASCADE),</li> <li>Set to null (SET NULL), so that the external key referred to the primary key from the other table takes the value of <code>NULL</code>.</li> <li>The different fields of the tables can also have certain associated restrictions, as they can to be:</li> <li>Non-null value constraint, so the field cannot be null in any case,</li> <li>Uniqueness restriction on one or several fields, so that the value must be unique in the whole table. </li> <li>Domain restriction, or what is the same, can have a set of possible values default</li> </ul> <p>Attention</p> <p>Primary keys have both properties: non-null value and uniqueness.</p>"},{"location":"en/UD2_Connectors/1_Object_relational_impedance_mismatch/#1101-sample","title":"1.1.0.1. Sample","text":"<p>A database to store information about players, games etc., can be like this:</p> <p></p> <p>And implementing with <code>MySQL</code>:</p> SQL<pre><code>CREATE SCHEMA IF NOT EXISTS `BDJocs` DEFAULT CHARACTER SET utf8 ;\nUSE `BDJocs` ;\n\nCREATE TABLE IF NOT EXISTS `BDJocs`.`jugador` (\n  `id` INT NOT NULL,\n  `nick` VARCHAR(45) NULL,\n  `dataRegistre` DATETIME NULL,\n  PRIMARY KEY (`id`))\nENGINE = InnoDB;\n\nCREATE TABLE IF NOT EXISTS `BDJocs`.`Genere` (\n  `id` INT NOT NULL,\n  `nom` VARCHAR(45) NULL,\n  `descripci\u00f3` VARCHAR(256) NULL,\n  PRIMARY KEY (`id`))\nENGINE = InnoDB;\n\nCREATE TABLE IF NOT EXISTS `BDJocs`.`Joc` (\n  `id` INT NOT NULL,\n  `nom` VARCHAR(45) NULL,\n  `descripci\u00f3` VARCHAR(256) NULL,\n  `Genere_id` INT NOT NULL,\n  PRIMARY KEY (`id`),\n  INDEX `fk_Joc_Genere1_idx` (`Genere_id` ASC),\n  CONSTRAINT `fk_Joc_Genere1`\n    FOREIGN KEY (`Genere_id`)\n    REFERENCES `BDJocs`.`Genere` (`id`)\n    ON DELETE NO ACTION\n    ON UPDATE NO ACTION)\nENGINE = InnoDB;\n\nCREATE TABLE IF NOT EXISTS `BDJocs`.`Puntuacions` (\n  `jugador_id` INT NOT NULL,\n  `Joc_id` INT NOT NULL,\n  `puntuacio` INT NULL,\n  PRIMARY KEY (`jugador_id`, `Joc_id`),\n  INDEX `fk_jugador_has_Joc_Joc1_idx` (`Joc_id` ASC),\n  INDEX `fk_jugador_has_Joc_jugador1_idx` (`jugador_id` ASC),\n  CONSTRAINT `fk_jugador_has_Joc_jugador1`\n    FOREIGN KEY (`jugador_id`)\n    REFERENCES `BDJocs`.`jugador` (`id`)\n    ON DELETE NO ACTION\n    ON UPDATE NO ACTION,\n  CONSTRAINT `fk_jugador_has_Joc_Joc1`\n    FOREIGN KEY (`Joc_id`)\n    REFERENCES `BDJocs`.`Joc` (`id`)\n    ON DELETE NO ACTION\n    ON UPDATE NO ACTION)\nENGINE = InnoDB;\n</code></pre>"},{"location":"en/UD2_Connectors/1_Object_relational_impedance_mismatch/#12-representation-of-information-with-the-object-oriented-model","title":"1.2. Representation of information with the object-oriented model","text":"<p>Like the Entity-Relationship model, the Object-Oriented model is a conceptual data model, but which focuses the importance on the modeling of objects.</p> <p>An object can represent any conceptual element: entities, processes, actions... An object it does not only represent the characteristics or properties, but also focuses on the processes that they suffer. In terms of the object-oriented model, we say that an object is data plus operations or behavior.</p> <p>In the introductory unit we already reviewed object-oriented programming, so we will limit ourselves to a brief review of the main concepts:</p> <ul> <li>An object is an entity with certain properties and certain behavior.</li> <li>In terms of OOP, properties are known as attributes, and the set of their values determine the state of the object at a given moment.</li> <li>Behavior is determined by a series of functions and procedures that we call methods, and that modify the state of the object.</li> <li>An object will also have a name by which it is identified.</li> <li>A class is an abstraction of a set of objects, and an object must belong necessarily to some class.</li> <li>The classes define the attributes and methods that the objects of this class will possess.</li> <li>An object is said to be an instance of a class.</li> </ul> <p>The same sample that we have represented lately, with an object-oriented representation could be:</p> <p></p> <p>As we can see, it has a similar structure, to which we have also added some methods such as getters and the setters. In addition, the different classes do not have an identifier attribute, since each object he identifies himself. We see a small approximation of how we would implement this hierarchy in Java.</p> <p>The <code>Genere</code> class is a POJO class, that only stores information (name and description of the game kind)and implements getters and setters.</p> Java<pre><code>public class Genere {\n    protected String nom;\n    protected String descripcio;\n\n    public Genere(String nom, String descripcio) {\n        this.nom = nom;\n        this.descripcio = descripcio;\n    }\n\n    public String getNom() {return nom;}\n    public void setNom(String nom) {this.nom = nom;}\n\n    public String getDescripcio() {return descripcio;}\n    public void setDescripcio(String descripcio) {\n        this.descripcio = descripcio;\n    }\n}\n</code></pre> <p>Class <code>Joc</code> stores name, description and genre of the game. Unlike the relational model, where what is stored it would be an external key to genre, since we don't have external keys here, we store one object itself (the reference).</p> Java<pre><code>public class Joc {\n\n    protected String nom;\n    protected String descripcio;\n    protected Genere genere;\n\n    public Joc(String nom, String descripcio, Genere genere) {\n        this.nom = nom;\n        this.descripcio = descripcio;\n        this.genere = genere;\n\n    }\n\n    public String getNom() {return this.nom;}\n    public void setNom(String nom) {this.nom = nom;}\n\n    public String getDescripcio() {return this.descripcio;}\n    public void setDescripcio(String descripcio) {\n        this.descripcio= descripcio;\n    }\n\n    public Genere getGenere() {return this.genere;}\n\n    public void setGenere(Genere genere) {this.genere = genere;}\n}\n</code></pre> <p><code>Registre</code> class present the relation between <code>Jugador</code> and <code>Joc</code> (when a player plays a game), and stores points and a reference to the game.</p> Java<pre><code>public class Registre {\n    private int puntuacio;\n    private Joc joc;\n\n    public Registre(int puntuacio, Joc joc) {\n        this.puntuacio = puntuacio;\n        this.joc = joc;\n    }\n\n    public int getPuntuacio() {return puntuacio;}\n    public void setPuntuacio(int puntuacio) {\n        this.puntuacio = puntuacio;\n    }\n\n    public Joc getJoc() {return joc;}\n\n    public void setJoc(Joc joc) {this.joc = joc;}   \n}\n</code></pre> <p>And finally, the <code>Jugador</code> class stores nick and registry date for each player, and then, an array with all the games that the player has played:</p> Java<pre><code>public class Jugador {\n\n    private String nick;\n    private Date dataRegistre;\n    private Set&lt;Registre&gt; puntuacions;\n\n    public Jugador(String nick, Date dataRegistre) {\n        this.nick = nick;\n        this.dataRegistre = dataRegistre;\n    }\n\n    public String getNick() {return nick;}\n    public void setNick(String nick) {this.nick = nick;}\n\n    public Date getDataRegistre() {return dataRegistre;}\n    public void setDataRegistre(Date dataRegistre) {\n        this.dataRegistre = dataRegistre;\n    }\n\n    public Set getPuntuacions() {return this.puntuacions;}\n    public void setPuntuacio(Joc joc, int puntuacio) {\n        Registre registre = new Registre(puntuacio, joc);\n        this.puntuacions.add(registre);\n    }\n}\n</code></pre> <p>The <code>Set</code> interface and the <code>HashSet</code> class</p> <p><code>Set</code> is an interface of the <code>java.util</code> package that deals with a collection or set of elements uncluttered and without duplicates.</p> <p>On the other hand, <code>HashSet</code> is a class that implements the <code>Set</code> interface, and that is based on one hash table, a data structure that allows you to locate objects based on a key that indicates the position in the table, allowing direct access to the element, which makes them ideal for searches, insertions and deletions.</p>"},{"location":"en/UD2_Connectors/1_Object_relational_impedance_mismatch/#13-relational-vs-object-oriented-model","title":"1.3. Relational vs Object-Oriented model","text":"<p>Conceptually, the object-oriented model is a dynamic model, which focuses on objects and on the processes that these undergo, but which does not take into account, from the start, their persistence. We have to achieve, therefore, the ability to save the states of the objects permanently, and load them when the application needs them, as well as maintaining consistency between this stored data and the objects that represent them in the application.</p> <p>One way to offer this persistence to objects would be to use a Relational DBMS, but we will encounter some complications. The first, from a conceptual point of view, is that the entity-relationship model focuses on the data, while the object-oriented model focuses on the objects, understood as groups of data, and the operations performed on them.</p> <p>Another, quite important difference, is the linking of elements between one model and another. For one other hand, the relational model adds extra information to the tables in the form of a foreign key, while in the object-oriented model, we don't need this external data, but rather the binding between objects is done through references between them. An object, for example, won't need a key either primary, since the object is identified by itself.</p> <p>As we have seen in the example of the previous sections, the tables in the relational model had a key primary, to identify objects and external keys to express relationships, while in the object-oriented model, these disappear, expressing the relationships between objects through references. In addition, the way these relationships are expressed is also different. In the relational model, for example, the Scores record is a table that links the Player table to the Game table, and add to this the player's score in the game. On the other hand, in the Java implementation we have done, we have objects of type <code>Registre</code> that store a score and a reference to Game, however is the Player class, which maintains the set of Records of its scores.</p> <p>On the other hand, when manipulating the data, it must be taken into account that the relational model has of languages \u200b\u200b(mainly SQL) designed exclusively for this purpose, while in one object-oriented language works differently, so it will be necessary to incorporate mechanisms which allow these queries to be made from the programming language. Also, when we get the results of the query, we also encounter another problem, and that is the conversion of results. One querying a database always returns a result in the form of a table, so it will be necessary to transform these in states of the application objects.</p> <p>All these differences imply what is known as object-relational lag, and that it will force us to make certain conversions between objects and tables when we want to save the information in a DBMS. In this unit and the following ones, we will see how to overcome this lag from different approaches.</p>"},{"location":"en/UD2_Connectors/2_Connectors/#11-the-client-server-architecture-in-dbms","title":"1.1. The client-server architecture in DBMS","text":"<p>Once we know the object-relational lag, let's focus on how to access to relational databases from programming languages. The RDBMS, became popular in the 80s, and are the most widespread today. Except for some exceptions, they work following a client-server architecture, so we have a server where it runs the DBMS and various clients that connect to the server and make corresponding requests.</p> <p>RDBMS offered it own programming languages, but were closely tied to them, and the application maintenance was very expensive. For this reason, the trend was decouple (separate) the RDBMS from the programming language, and make use of connection standards between them.</p> <p>Thanks to the client-server architecture, RDBMS were able to separate data on the one hand, and the programs to access them by others. This versatility had a small drawback, and it is that it was necessary to develop on the one hand the server, but on the other, also the client side in order to be able to connect to servers. These connections between clients and servers will require protocols and specific languages. The concept of middleware is born here, understood as an intermediate layer of persistence, made up of libraries, languages \u200b\u200band protocols located on the client and server and that allow connecting the database with the applications.</p> <p>Although each DBMS initially implemented specific solutions, standards were imposed, among which we find the query language SQL (Structured Query Language), and which assumed a great advance, since it unified the way to access the databases, although the applications continued requiring an API to make use of SQL.</p>"},{"location":"en/UD2_Connectors/2_Connectors/#12-database-access-protocols","title":"1.2. Database access protocols","text":"<p>When we talk about DB access protocols, we come across two main connection rules:</p> <ul> <li>ODBC (Open Data Base Connectivity): This is an API (Application Program Interface) developed by Microsoft for Windows systems that allows you to add different plugins to several relational databases based on SQL, in a simple and transparent way. Using ODBC, applications can open connections to the database, send queries, updates and manage results.</li> <li>JDBC (Java Database Connectivity), which defines a cross-platform API, which they can use Java programs to connect to the DBMS.</li> </ul>"},{"location":"en/UD2_Connectors/2_Connectors/#13-jdbc","title":"1.3. JDBC","text":"<p>As we said, JDBC is a Java-specific database connection API. Its operation mode is as follows:</p> <ul> <li>An API is offered, encapsulated in classes, which guarantees uniformity in the way in which the applications connect to the database, regardless of the underlying RDBMS.</li> <li>We will need a controller for each database to which we want to connect. Java does not have any specific ODBC library, but it does, in order not to lose the potential of these connections, special drivers were incorporated that act as adapters between JDBC and ODBC, from so that it is possible, through this bridge, to connect any Java application with any ODBC connection. Currently, almost all DBMS have JDBC drivers, but in case you don't know about them have it, you can make use of this ODBC-JDBC bridge.</li> </ul>"},{"location":"en/UD2_Connectors/2_Connectors/#131-jdbc-architecture","title":"1.3.1. JDBC architecture","text":"<p>The JDBC standard library provides a set of implementation-free interfaces. Controllers of each DBMS will be in charge of implementation. Applications, in order to access the database, will have to use the JDBC interfaces, so it is for the implementation of each DBMS is completely transparent to the application.</p> <p></p> <p>As we can see, Java applications access the different methods that the API specifies as interfaces, but it is the controllers that access the database.</p> <p>It should be said that applications can use several JDBC drivers simultaneously, and access, therefore, to multiple databases. The application specifies a JDBC driver using a URL (Universal Resource Locator) to the Drivers manager, and this is the one responsible for correctly establishing the connections with the databases through the drivers. Controllers can be of different types:</p> <ul> <li>Type I or Bridge Controllers, characterized by making use of technology external to JDBC and acting of adapter between JDBC and the specific technology used. An example is the JDBC-ODBC bridge.</li> <li>Type II or drivers with partially native API, or native drivers. They are trained on one hand Java and on the other that makes use of operating system libraries. Its use is due to some DBMS that incorporate proprietary plugins that do not follow any standards (usually pre-ODBC/JDBC).</li> <li>Type III or Java controllers via network protocol, which are controllers developed in Java that translate JDBC calls to a network protocol against an intermediate server. Is a very flexible system, since changes in the implementation of the database do not affect applications.</li> <li>Type IV or pure/100% Java, also called native protocol, and these are drivers written entirely in Java. Requests to the DBMS are made through the network protocol that uses the DBMS itself, so there is no need for native code on the client or an intermediary server. Is the alternative that has ended up being imposed, since it does not require any type of installation.</li> </ul>"},{"location":"en/UD2_Connectors/2_Connectors/#14-mysql-docker-workbench","title":"1.4. MySQL, Docker, Workbench","text":"<p>This year we will use MySQL as DBMS, because its wide use in several contexts and for simplicity. To use it, you should install <code>mysql-server</code> as a service in your system, as you studied last years.</p> <p>The MySQL server can be installed in your machine, or you can install it on a virtual machine or can be configured as a Docker container. In order to have a cleaner system, the recommended option is with docker container, since you could run several versions of MySQL without interferences between them.</p> <p>Tip</p> <p>You have an extra documentation about how to create a MySQL container in a document called Docker per a MySQL. So, and for the rest of the document, we're going to assume that you already have the Docker image of MySQL and from a container running on port <code>3308</code> (MySQL uses 3306 by default, but in our container we will expose the service for 3308, in case you already have a local MySQL server running for   3306).</p> Bash<pre><code># Remember that to create the container (only fisrt time)\n\ndocker run --name mysql-srv\n      -p 3308:3306\n      -e MYSQL_ROOT_PASSWORD=\"root\"\n      -d mysql:latest\n\n# It will create and start the container\n\n# To stop the container\ndocker stop mysql-srv\n\n# And to start the container ( AVOID TO run IT AGAIN !!!)\ndocker start mysql-srv\n</code></pre> <p>And at last but not least, obviously, you could use a graphical tool to access MySQL, like <code>mysql-workbench</code> or <code>dbeaver</code>. You have to configure a connection to the port of Docker:</p> \\[\\begin{center} \\begin{minipage}{0.9\\textwidth} \\includegraphics[width=0.9\\columnwidth]{./img/WorkBench.png} \\end{minipage} \\end{center}\\] <p>Warning</p> <p>Review your Database Module's notes how to work in workbench:</p> <ul> <li>Load and run SQL scripts</li> <li>Retrieve database structure</li> <li>Edit and create SQL</li> <li>Edit and save data</li> </ul> <p>In the platform you will find a script DB Jocs Schemna. You will execute in order our samples work fine.</p>"},{"location":"en/UD2_Connectors/3_Connecting/","title":"1. Connecting to databases","text":""},{"location":"en/UD2_Connectors/3_Connecting/#11-mysql-jdbc-controller","title":"1.1. MySQL JDBC controller","text":"<p>In order to create Java programs using MySQL driver, we need to load in our program and previously in our development environment. As we will use <code>Gradle</code> let's go how to use it:</p> <ol> <li>We need to find our server JDBC version, and we can find it in maven central repository https://mvnrepository.com.</li> <li>We will search for <code>mysql jdbc</code>, and it will get as first result MySQL Connector/J.</li> <li>Be notice to select the correct version, and then select the package manager (gradle, maven, etc.) and you will get:</li> </ol> Bash<pre><code>// https://mvnrepository.com/artifact/mysql/mysql-connector-java\nimplementation group: 'mysql', name: 'mysql-connector-java', version: '8.0.30'\n</code></pre> <ol> <li>When you save or build your project, you will be able to import your drivers properly</li> </ol> <p></p>"},{"location":"en/UD2_Connectors/3_Connecting/#12-connection-url","title":"1.2. Connection URL","text":"<p>Once you have imported your driver, you need to tell your Java program how to connect to your database and finally connect to it. For this task we should create a <code>Connection</code> using a special URL called connection URL. As others URL, a connection URL may contain:</p> <ul> <li>Protocol \\(\\rightarrow\\) we will use <code>jdbc</code>.</li> <li>DBMS \\(\\rightarrow\\) we could use <code>mysql</code>, <code>postgres</code>, <code>sqlite</code>, <code>sqlserver</code> or any DBMS with a JDBC connector.</li> <li>Server address \\(\\rightarrow\\) we could use either a full name or the server IP.</li> <li>[optional]Port \\(\\rightarrow\\) the port where the server is listening. If none is used, the driver will try to connect to the default one. Remember to separate port from address with <code>:</code>.</li> <li>Other parameters, separating it with <code>?</code> at the beginning and with <code>&amp;</code> between parameters. For exemple:</li> <li>user=<code>username</code></li> <li>pass=<code>password</code></li> <li>useUnicode=<code>true</code></li> <li>characterEncoding=<code>UTF-8</code></li> </ul> <p>A sample connection URL can be:</p> Java<pre><code>String connectionUrl = \"jdbc:mysql://localhost:3308/Cycling?useUnicode=true&amp;characterEncoding=UTF-8&amp;user=root&amp;password=root\";\n</code></pre> <p>A better option will be:</p> Java<pre><code>String server=\"localhost\";\nint port=3308;\nString user=\"root\";\nString pass=\"root\";\nString DBName=\"Cycling\";\nString connectionUrl = \"jdbc:mysql://\"+server+\":\"+port;\nconnectionUrl+=\"/\" + DBName;\nconnectionUrl+=\"?useUnicode=true&amp;characterEncoding=UTF-8\";\nconnectionUrl+=\"&amp;user=\"+user;\nconnectionUrl+=\"&amp;password=\"+pass;\n</code></pre> <p>Warning</p> <p>Notice that both samples are hard-coded code, because you have values of the server (user and password) written inside Strings. Is a better option to store this values inside variables or in properties files.</p>"},{"location":"en/UD2_Connectors/3_Connecting/#13-connection-class","title":"1.3. <code>Connection</code> class","text":"<p>In Java the class needed to manage the driver is <code>java.sql.DriverManager</code>. It tries to load the drivers from the system when reading the JDBC drivers property, but we can indicate that it is loaded using the instruction:</p> Java<pre><code>Class.forName(\"com.mysql.cj.jdbc.Driver\");\n</code></pre> <p>The class that will centralize all operations with the database is <code>java.sql.Connection</code>, and we must obtain it from the <code>DriverManager</code> with any of the 3 static methods it has:</p> <ul> <li><code>static Connection getConnection(String url)</code> \\(\\rightarrow\\) Returns a connection, if it is possible, to the database whose parameters are specified in the connection URL. Remember from last part how to create a connection URL.</li> <li><code>static Connection getConnection(String url, Properties info)</code> \\(\\rightarrow\\) Returns a connection, if it is possible, to the database, with some parameters specified in the URL and others in a properties object (<code>Properties</code> class studied in unit 1). We will see samples later.</li> <li><code>static Connection getConnection(String url, String user, String pass)</code> \\(\\rightarrow\\) Returns a connection, if it is possible, to the database whose parameters are specified in the URL. User and password data are provided in two additional parameters, so you do not need to write in your connection URL.</li> </ul> <p>A first sample will be:</p> Java<pre><code>public static void main (String [] args ) \n  throws ClassNotFoundException, SQLException{\n\n    Class.forName(\"com.mysql.cj.jdbc.Driver\");\n    String server=\"localhost\";\n    int port=3308;\n    String user=\"root\";\n    String pass=\"root\";\n    String DBName=\"Cycling\";\n    String connectionUrl = \"jdbc:mysql://\"+server+\":\"+port;\n    connectionUrl+=\"/\" + DBName;\n    connectionUrl+=\"?useUnicode=true&amp;characterEncoding=UTF-8\";\n\n   Connection conn = DriverManager.getConnection(connectionUrl,user,pass);\n\n   // if no exception is catched, you are connected to your DBMS\n</code></pre> <p>With the <code>Connection</code> object that we have now connected, we will send our queries and ask for information, as we will see later.</p>"},{"location":"en/UD2_Connectors/3_Connecting/#14-organizing-our-connection","title":"1.4. Organizing our connection","text":"<p>Our application is going to connect to one (or more) databases. We can make many requests to said database, and if we are implementing a multithreaded application, the number of requests can increase a lot. That is why we have to control where and when connections are created and closed. A good idea is to create a class that encapsulates all these processes. The skeleton of such a class would be as follows:</p> Java<pre><code>public class ConnexioBD {\n\n    private Connection laConnexio = null;\n\n    // write here access variables, like user, server or whatever\n\n    private void connect() {\n        // do the connetion (look the sample). \n        // Take care. private method. It will be called inside the class\n    }\n\n    // close connection, if it's opened\n    public void disConnect() {\n        if (laConnexio != null) {\n            laConnexio.close();\n        }\n    }\n\n    // returns the connection. \n    // It will be create first time of after closed\n    public Connection getConexio(){\n        if (laConnexio == null) {\n            this.connect();\n        }\n        return this.laConnexio;\n    } \n}\n</code></pre>"},{"location":"en/UD2_Connectors/3_Connecting/#141-solved-exercise","title":"1.4.1. Solved exercise","text":"<p>Create a single project with two classes. One for connecting to your database, as the last sample, and a main class that connect and show if an error have happened.</p> <p>The exercise's solution is linked here connexio.properties and ConnexioDB.java</p>"},{"location":"en/UD2_Connectors/4_Resultset/","title":"1. <code>ResultSet</code> class.","text":"<p>Now, we are connected to the database, is time to start asking for information to the DBMS. This information will be in form of queries (SQL) or others methods, but almost 90% of times, as the SQL's, the information returned is in a tabular format. Tabular formats are well known because programs like MySQL Workbench or DBeaver show data in these way.</p> <p>In Java, the class who allow to works with data in tabular format coming from databases is called <code>Resultset</code>. A <code>Resultset</code> is composed by a table (rows and columns) and a pointer to a row, called <code>cursor</code>.</p> <p></p> <ol> <li>When we retrieve data from databases, the information is stored in the table, and the cursor points to an imaginary void row called <code>beforeFisrt</code>. </li> <li><code>Resultset</code> contains a special method called <code>next()</code>, that do two actions:</li> <li>Returns <code>true</code> if exists a data row after the current row pointed by the cursor, and <code>false</code> otherwise.</li> <li>Push forward the cursor, and points to the next row.</li> <li>When a <code>Resultset</code> cursor return <code>false</code>, is because all rows have been visited, and now, the cursor is pointing to another imaginary row called <code>afterLast</code></li> </ol> <p>When the cursor is pointing a real row, is when we can retrieve data of the columns of the current row. We can use a special and overloaded method, as follows:</p> <ul> <li><code>getXXX(int columnPosition)</code> \\(\\rightarrow\\) return the data, where <code>XXX</code> is a datatype (Int, Float, Double, String, etc.) of the position of the column, starting in 1.</li> <li><code>getXXX(String columnName)</code> \\(\\rightarrow\\) return the data, where <code>XXX</code> is a datatype (Int, Float, Double, String, etc.) of the column with the given name.</li> </ul> <p>Danger</p> <p>Take into account:</p> <ul> <li>The columns start in 1 instead of 0, unlike arrays</li> <li>If you do not know the data type of a column, you can use <code>getObject</code>and it returns a generic <code>Object</code>.</li> <li>These methods could throw <code>SQLException</code>, if the column rank or name is out of rank or not exists.</li> </ul>"},{"location":"en/UD2_Connectors/4_Resultset/#11-resulsetmetadata","title":"1.1. ResulSetMetaData","text":"<p>ResultSets from of a query also have a set of metadata. This metadata can be obtained using the <code>ResultSetMetaData</code>. Most relevant methods of this class are:</p> <ul> <li><code>int getColumnCount()</code> \\(\\rightarrow\\) Gets the number of columns in the ResultSet.</li> <li><code>String getColumnName(index)</code> \\(\\rightarrow\\) Gets the name of the column indicated in the index (remember that first is 1).</li> <li><code>String getColumnTypeName(index)</code> \\(\\rightarrow\\) Gets the type of the column</li> </ul> <p>ResulSetMetaData is obtained from each previously generated ResultSet, with <code>getMetaData()</code> method.</p>"},{"location":"en/UD2_Connectors/4_Resultset/#12-resultset-algorithm","title":"1.2. ResultSet algorithm","text":"<p>Regardless the data content of your ResultSet, the way in we should work is as follows:</p> Java<pre><code>// Connect to DB\nConnection conn = ...;\n\n// recover data\nResultSet rst= conn...\n\n// while data available exists\nwhile (rst.next()){\n    //process the current row\n}\n</code></pre> <p>Be notice than:</p> <ul> <li>Inside the while loop you don't need to call <code>next()</code> again. You skip one row otherwise.</li> <li>When the last row were processed, <code>next()</code> return <code>false</code>, and the loop finish.</li> </ul>"},{"location":"en/UD2_Connectors/4_Resultset/#13-sample","title":"1.3. Sample","text":"<p>In this block of code let's go to see a brief sample to run a query (<code>Select * from table</code>). We will see queries in next sections.</p> Java<pre><code>//with a previous connection\nString taula=\"Jocs\";\nResultSet rst = con.createStatement().executeQuery(\"SELECT * FROM \" +taula);\nSystem.out.println(Colors.Cyan);\nSystem.out.println(\"\");\nSystem.out.println(\"Contingut de \" + taula);\nSystem.out.println(\"******************************\");\n\nResultSetMetaData rsmdQuery = rst.getMetaData();\n\n// print the columns name\nfor (int i = 1; i &lt;= rsmdQuery.getColumnCount(); i++)\n  System.out.print(String.format(\"%-25.25s\",rsmdQuery.getColumnName(i)));\n\nSystem.out.println();\nSystem.out.println(Colors.Reset);\n\n// print the values\nwhile (rs.next()) {\n  for (int i = 1; i &lt;= rsmdQuery.getColumnCount(); i++)\n  System.out.print(String.format(\"%-25.25s \",rst.getString(i)));\n  System.out.println();\n}\n</code></pre>"},{"location":"en/UD2_Connectors/5_Metadata/","title":"1. Database Metadata","text":"<p>Before retrieving data, we are going to study how to get information about the database we are connected. The metadata of a database describe the structure it has: tables of which it is composed the database, the fields that make up these tables, the types of these fields, etc. Even though we usually know this structure beforehand, it is possible that we need it on occasion of her for this we have the <code>DatabaseMetaData</code> and <code>ResultsetMetaData</code> interfaces.</p> <p><code>DatabaseMetaData</code> interface provides us with information about the tables and views of the database, as well as its structure. In the following we have some of the most relevant methods of this interface.</p> <ul> <li><code>String getDatabaseProductName()</code> \\(\\rightarrow\\) Gets the name of the DBMS.</li> <li><code>String getDriverName()</code> \\(\\rightarrow\\) Gets the name of the JDBC driver in use.</li> <li><code>String getURL()</code> \\(\\rightarrow\\) Gets the URL of the connection.</li> <li><code>String getUserName()</code> \\(\\rightarrow\\) Gets the name of the user connected to the DB.</li> <li><code>ResultSet getTables(String catalog, String schema, String patternTableName, String[] type)</code> \\(\\rightarrow\\) Get information from the tables available in the catalog indicated.</li> <li><code>ResultSet getColumns(String catalog, String schema, String patternNameTable, String patternColumnName)</code> \\(\\rightarrow\\) Gets information from the columns of the table specified in the catalog and diagram indicated </li> <li><code>ResultSet getPrimaryKeys(String catalog, String schema, String patternNameTable)</code> \\(\\rightarrow\\) Gets the list of fields that make up the primary key.</li> <li><code>ResultSet getImportedKeys(String catalog, String schema, String patternNameTable)</code> \\(\\rightarrow\\) Gets a list with the foreign keys defined in the table.</li> <li><code>ResultSet getExportedKeys(String catalog, String schema, String patternNameTable)</code> \\(\\rightarrow\\) Gets a list with the foreign keys that point to this table</li> </ul> <p>Additional information</p> <p>At this point, it is necessary to point out that the terms catalog and scheme tend to be confused. By standards, a catalog contains several schematics, with detailed system information, from the form of internal storage to the conceptual schemes. In a catalog, there seems to be one schema called INFORMATION_SCHEMA, with the views and domains of the information schema of the system.</p> <p>In any case, most DBMS match the catalog with the database. Moreover, in this query we specify the database name as catalog, while if open MySQLWorkbench, the database is represented as a schema. We can find more information about it in these links:</p> <ul> <li>https://stackoverflow.com/questions/7022755/whats-the-difference-between-a-catalog-and-a-schema-in-a-relational-database</li> <li>https://www.quora.com/What-is-the-difference-between-system-catalog-and-database-schemain-a-Database</li> </ul>"},{"location":"en/UD2_Connectors/5_Metadata/#11-solved-exercise","title":"1.1. Solved Exercise","text":"<p>Let's go to create a Java program that shows internal information of a database <code>BDJocs</code>, through <code>DataBaseMetaData</code>. Let's view the program step by step.</p> <p>Info</p> <p>You can view all the information of the method and how the data is stored in each method's ResultSet in this link.</p>"},{"location":"en/UD2_Connectors/5_Metadata/#111-create-the-connection","title":"1.1.1. Create the connection","text":"<p>Remember how to connect to a DBMS in a easy way:</p> Java<pre><code>// load JDBC driver\n2 Class.forName(\"com.mysql.cj.jdbc.Driver\");\n3 // Connecto to DBMS and DB BDJosc, with user and pass\n4 Connection con = DriverManager.getConnection(\"jdbc:mysql://localhost:3308/BDJocs\", \"root\", \"root\");\n</code></pre> <p>Very simple, load the driver and connect to DB, in the way we have studied</p>"},{"location":"en/UD2_Connectors/5_Metadata/#112-retrieve-metadata-from-dbms-and-show-in-a-friendly-format","title":"1.1.2. Retrieve metadata from DBMS, and show in a friendly format","text":"<p>We will use <code>Color</code> class to show data to paint text in console. You have this class in CEPA 1, inside the project.</p> Java<pre><code>// get the metadata\nDatabaseMetaData dbmd = con.getMetaData();\n\nSystem.out.println(Colors.Blue+\"\\nDBMS information--------\"+Colors.Reset);\nSystem.out.println(Colors.Bright_White+\"SGBD:\\t\"+Colors.Reset + dbmd.getDatabaseProductName());\nSystem.out.println(Colors.Bright_White+\"SGBD:\\t\"+Colors.Reset + dbmd.getDriverName());\nSystem.out.println(Colors.Bright_White+\"SGBD:\\t\"+Colors.Reset + dbmd.getURL());\nSystem.out.println(Colors.Bright_White+\"SGBD:\\t\"+Colors.Reset + dbmd.getUserName());\n</code></pre> <p>As you can see, we get the name of the DBMS, driver, URL a user we are using. Obviously, is the same that we put when we created Connection object, but it's a good example to show information.</p>"},{"location":"en/UD2_Connectors/5_Metadata/#113-retrieve-tables-in-a-schemadatabase","title":"1.1.3. Retrieve tables in a schema/database","text":"<p>Using <code>getTables()</code> method we could recover the tables and more information. We suppose <code>BDJocs</code> exists in our DBMS:</p> Java<pre><code>System.out.println(Colors.Bright_White+String.format(\"%-15s %-15s %-15s\",\"Database\",\"Table\",\"Type\"));\nSystem.out.println(\"-------------------------------------------------------\"+Colors.Reset);\nResultSet rsmd = dbmd.getTables(\"BDJocs\", null, null, null);\nwhile (rsmd.next()) {\n  System.out.println(String.format(\"%-15s %-15s %-15s\",rsmd.getString(1),rsmd.getString(3),rsmd.getString(4)));\n}\n</code></pre> <p>Comments:</p> <p>Revise <code>String.format()</code> to set a specific column length. From javadoc, we get than the ResultSet returned by <code>getTables</code> has the following columns:</p> <ol> <li>TABLE_CAT String \u2192 table catalog (may be null)</li> <li>TABLE_SCHEM String \u2192 table schema (may be null)</li> <li>TABLE_NAME String \u2192 table name</li> <li>TABLE_TYPE String \u2192 table type. Typical types are \"TABLE\", \"VIEW\", \"SYSTEM TABLE\", \"GLOBAL TEMPORARY\", \"LOCAL TEMPORARY\", \"ALIAS\", \"SYNONYM\".</li> <li>REMARKS String \u2192 explanatory comment on the table</li> <li>TYPE_CAT String \u2192 the types catalog (may be null)</li> <li>TYPE_SCHEM String \u2192 the types schema (may be null)</li> <li>TYPE_NAME String \u2192 type name (may be null)</li> <li>SELF_REFERENCING_COL_NAME String \u2192 name of the designated \"identifier\" column of a typed table (may be null)</li> <li>REF_GENERATION String \u2192 specifies how values in SELF_REFERENCING_COL_NAME are created. Values are \"SYSTEM\", \"USER\", \"DERIVED\". (may be null)</li> </ol> <p>We get columns 1, 3 and 4.</p>"},{"location":"en/UD2_Connectors/5_Metadata/#114-get-the-tables-columns","title":"1.1.4. Get the table's columns","text":"<p>Is the moment to get the columns of a table, using <code>getColumns()</code> method:</p> Java<pre><code>String table=...; // we set the name of an existing table\nResultSet columnes = dbmd.getColumns(\"BDJocs\",null , taula, null);\nSystem.out.println(Colors.Bright_White+String.format(\"%-25s %-15 s%-15s\",\"Atribut/Claus\",\"Tipus\",\"Pot ser nul?\"+Colors.reset));\n\nwhile (columnes.next()){\n    String columnName=columnes.getString(4);\n    String tipus=columnes.getString(6);\n    String nullable=columnes.getString(18);\n\n    System.out.println(String.format(\"%-25s %-15s %15s\",columnName,tipus,nullable));\n}\n</code></pre> <p>Comments:</p> <ul> <li><code>getColumns()</code> returns 24 columns ResultSet, with a lot of table information. We get only columns 4, 6 and 18 with the name, type and if can be null. You can view javadoc for more information.</li> <li>In the same way, to get information about keys, we can use:</li> <li><code>getPrimaryKeys()</code> returns a ResultSet with the tables' primary keys.</li> <li><code>getExportedKeys()</code> returns a ResultSet with the columns that point to the current table primary key. It means all the fields in other table that point to current table primary key.</li> <li><code>getImportedKeys()</code> returns a ResultSet with the columns that are imported primary keys to the current table. It means the columns that are foreign key (and point to a primary key in other tables).</li> </ul> <p>You have the whole sample in package <code>DatabaseMeta</code> in sample application and following link.  </p>"},{"location":"en/UD2_Connectors/6_CRUD/","title":"1. Statements and CRUD operations","text":"<p>In this section we are going to study the main goal working with databases: manipulate data. We will always work with the same template:</p> <ol> <li>Connect to de database.</li> <li>Prepare the query</li> <li>Execute the query</li> <li>Data processing, if needed.</li> </ol> <p>Point 1 has been studied on previous sections. </p> <p>In order to create the queries, we should use the following classes/interfaces:</p> <ul> <li><code>Statement</code> \\(\\rightarrow\\) It is used in a general way, and it is useful when we want to perform static SQL statements, since no accepts parameters. We create <code>Statement</code> with <code>createStatement()</code> method from <code>Connection</code> class.</li> <li><code>PreparedStatement</code> \\(\\rightarrow\\) It is used when we want to launch several requests, and in addition, it is allowed to perform dynamic sentences. We create <code>PreparedStatement</code> with <code>prepareStatement()</code> method from <code>Connection</code> class.</li> <li><code>CallableStatement</code> \\(\\rightarrow\\) Used to access stored procedures in the database, and also accepts input parameters. We create <code>CallableStatement</code> with <code>prepareCall()</code> method from <code>Connection</code> class.</li> </ul> <p>When the statement is ready, we can execute it with:</p> <ul> <li><code>executeQuery</code> \\(\\rightarrow\\) Executes statements that we expect to return data (SELECT queries). The return value from this execution is, as you will guess, a ResultSet.</li> <li><code>executeUpdate</code> \\(\\rightarrow\\) Executes statements that are not expected to return data, but they will be used to modify the database connected (INSERT, DELETE, UPDATE queries and CREATE TABLE)</li> </ul>"},{"location":"en/UD2_Connectors/6_CRUD/#11-create-insert","title":"1.1. Create (Insert)","text":"<p>Let's go to see a simple <code>INSERT</code> statement sample.  </p> Java<pre><code>ConnexioDB conDB=new ConnexioDB(\"BDJocs\");\nConnection con=conDB.getConnexio();\n\nString SQL=\"INSERT INTO Joc VALUES (1, 'Double Dragon', 'Dos germans bessons experts en arts marcials s`han de fer cam\u00ed en un escenari urb\u00e0 on  membres de bandes rivals volen deixar-los fora de combat.', 1);\";\n\nStatement st=con.createStatement();\n\nint affectedRows=st.executeUpdate(SQL);\n\nSystem.out.println(affectedRows+ \"row has been inserted\");\n</code></pre> <p>As you can see, is very easy to understand the code. We create an empty Statement and the run the SQL \"per se\". The execution returns numbres of rows inserted. We will see better ways to insert data, using scripts.</p> <p>Info</p> <p>This code is a reduced version, because when we are working with databases <code>SQLException</code> could appear. We suppose that the connection process is already done.</p>"},{"location":"en/UD2_Connectors/6_CRUD/#12-read-select","title":"1.2. Read (Select)","text":"<p>Reading is the most important process we will do, because only with the login process inside an App are retrieving information from a database. In all cases we must write the sentence (SQL), execute it and finally process the returned data. Depending on the way we prepare the sentence, we could distinguish between:</p> <ol> <li>Fixed sentences</li> <li>Variable sentences</li> <li>Prepared sentences</li> </ol> <p>We will see both ways in details. We will use for this the <code>Instituto.sql</code> script and database.</p>"},{"location":"en/UD2_Connectors/6_CRUD/#121-fixed-sentences","title":"1.2.1. Fixed sentences","text":"<p>This sentence, as its name says, are fixed or constant sentences. The SQL is fixed, and it has not any variables.</p> Java<pre><code>// The query\nString SQL=\"Select * from Persona\";\n// The statement\nStatement st=con.createStatement();\n// The execution\nResultSet rst=st.executeQuery(SQL);\n\n// processing\nwhile(rst.next()){\n    System.out.print(ConsoleColors.BLUE_BRIGHT+ \"Person: \"+ ConsoleColors.RESET);\n    /*\n    System.out.println(\n            rst.getString(3)+ \", \"+\n            rst.getString(2)+ \" \"+\n            rst.getInt(4));\n    */\n    System.out.println(\n            rst.getString(\"apellidos\")+ \", \"+\n            rst.getString(\"nombre\")+ \" \"+\n            rst.getInt(\"edad\"));\n}\n\nrst.close();\n</code></pre> <p>In the processing of the information, ResultSet has:</p> <ul> <li><code>type getType(int columnIndex)</code> \\(\\rightarrow\\) overloaded method, that return the given datatype, using the ResultSet column's index. Remember that first column is 1 instead of 0. The type will be Int, String, Double, etc. if you know the type. For unknown columns you can use <code>Object</code> as a generic type.</li> <li><code>type getType(String columnName)</code> \\(\\rightarrow\\) same as above method but accessing to the column with the name that we have selected in the query or the name in the table.</li> </ul>"},{"location":"en/UD2_Connectors/6_CRUD/#122-variable-sentences","title":"1.2.2. Variable sentences","text":"<p>Imagine that you want to recover names with <code>Ma</code> inside him.</p> SQL<pre><code>String SQL=\"Select * from Persona where nombre like '%Ma%'\";\n</code></pre> <p>In this case, this query is hardcoded, and if you want to change the portion inside the text, you have to edit your code. To avoid hard-coding, we can write:</p> Java<pre><code>ConnexioDB conDB=new ConnexioDB(\"Instituto\");\n\nConnection con=conDB.getConnexio();\n\n// hardcoded String\n// String SQL=\"Select * from Persona where nombre like '%Ma%'\";\n\nString nombre=Utilitats.leerTextoC(\"Give me part of the name: \");\n// The query\nString SQL=\"Select * from Persona where nombre like '%\" + nombre + \"%'\";\n// The statement\nStatement st=con.createStatement();\n// The execution\nResultSet rst=st.executeQuery(SQL);\n\n// processing\nwhile(rst.next()){\n    System.out.print(ConsoleColors.BLUE_BRIGHT+ \"People with \" +nombre+\": \"+ ConsoleColors.RESET);\n    System.out.println(\n            rst.getString(\"apellidos\")+ \", \"+\n            rst.getString(\"nombre\")+ \" \"+\n            rst.getInt(\"edad\"));\n}\n\nrst.close();\n</code></pre> <p>As we can see, the data is now in variables, but the construction of the SQL is more complex. Note that the texts must be between quotation marks and the numbers must not, which makes very easy to do mistakes. But it can be worse, this type of code can incur SQL injection problems, as we see in the example that follows:</p> Java<pre><code>String idPersona=Read.readText(\"Tell me the id to consult: \");\nString SQL = \"Select * from Person where idPersona=\"+idPersona;\n</code></pre> <ul> <li>If the user enters <code>4</code> \\(\\rightarrow\\) It will show the person of ID equal to 4</li> <li>If the user enters <code>4 or 1=1</code> \\(\\rightarrow\\) It will show all the people</li> </ul> <p>We must avoid this type of queries in user validation statements, for which we will use the prepared statements and, obviously to be very careful checking the inputs.</p>"},{"location":"en/UD2_Connectors/6_CRUD/#123-prepared-sentences","title":"1.2.3. Prepared sentences","text":"<p>To avoid the SQL injection problem, as long as we have parameters in our query, we will make use of prepared statements. In the prepared statements, where we have to make use of a marker, instead of composing it with concatenations within the String, we will indicate it with a question mark (<code>?</code>), a character called placeholder.</p> <p>Next, we must assign values to these placeholders, using <code>setType(int pos)</code> methods where <code>Type</code> is the data type that we are going to assign and <code>pos</code> is the position of the placeholder, starting with 1. Let's see the example:</p> Java<pre><code>ConnexioDB conDB=new ConnexioDB(\"Instituto\");\n\nConnection con=conDB.getConnexio();\n\nString ID=Utilitats.leerTextoC(\"Give me an id: \");\n// The query\nString SQL=\"Select * from Persona where idPersona = ?\" ;\n// The statement\nPreparedStatement pst=con.prepareStatement(SQL);\n// fill placeholders\n\npst.setString(1, ID);\n\n// The execution\nResultSet rst=pst.executeQuery();\n\n// processing\nwhile(rst.next()){\n    System.out.print(ConsoleColors.BLUE_BRIGHT+ \"People with \" +ID+\": \"+ ConsoleColors.RESET);\n    System.out.println(\n            rst.getString(\"apellidos\")+ \", \"+\n            rst.getString(\"nombre\")+ \" \"+\n            rst.getInt(\"edad\"));\n}\n\nrst.close();\n</code></pre> <p>Advice</p> <p>You can combine ResultSet with ResultSetMetaData to get the columns name and data types stored in the database. Yoy will find a sample in the platform.</p>"},{"location":"en/UD2_Connectors/6_CRUD/#13-update-update-and-delete-delete","title":"1.3. Update (Update) and Delete (Delete)","text":"<p>Update and delete a row, are both considered as updates, because they modify the database status. In fact, we also consider inserting as database update too. Both tasks will be inclosed in a <code>executeUpdate()</code> method. Let's go to study through samples:</p>"},{"location":"en/UD2_Connectors/6_CRUD/#131-delete-sample","title":"1.3.1. Delete sample","text":"<p>Let's go to delete rows from a table of people between given ages:</p> Java<pre><code>ConnexioDB conDB = new ConnexioDB(\"Instituto\");\nConnection con = conDB.getConnexio();\n\n// give the age's bounds\nint minAge = Utilitats.leerEnteroC(\"Give me minimal age: \");\nint maxAge = Utilitats.leerEnteroC(\"Give me maximun age: \");\n\n// The query\nString SQL = \"Delete from Persona where edad between ? and ?\";\n\n// The statement\nPreparedStatement pst = con.prepareStatement(SQL);\n\n// fill placeholders            \npst.setInt(1, minAge);\npst.setInt(2, maxAge);\n\n// show the query after resolve placeholders\nSystem.out.println(pst);\n\n// The execution\nint deletedtedRows = pst.executeUpdate();\n\n// how many roas affecte\nSystem.out.println(deletedtedRows + \" has been deleted.\");\n</code></pre> <p>Warning</p> <p>Deleting data is a very sensitive operation. Be careful to:</p> <ul> <li>Don't forget <code>WHERE</code> clause when deleting, because you will delete all data from the table.</li> <li>If you want to delete all the table, including the structure (definition + table), you must use <code>DROP TABLE</code> instead of <code>DELETE</code>.</li> <li>If you try to delete a row pointed by a foreign key, you will get the <code>SQLIntegrityConstraintViolationException</code> and a message like Cannot delete or update a parent row: a foreign key constraint fails.</li> </ul>"},{"location":"en/UD2_Connectors/6_CRUD/#132-update-sample","title":"1.3.2. Update sample","text":"<p>Let's go to add years to given id people:</p> Java<pre><code>ConnexioDB conDB = new ConnexioDB(\"Instituto\");\n\nConnection con = conDB.getConnexio();\n\n// give the age's bounds\nint difAge = Utilitats.leerEnteroC(\"Give me number oy years: \");\nint idMin = Utilitats.leerEnteroC(\"Give me minimum id: \");\n\n// The query\nString SQL = \"Update Persona set edad=edad+ ? where idPersona &gt; ?\";\n\n// The statement\nPreparedStatement pst = con.prepareStatement(SQL);\n\n// fill placeholders            \npst.setInt(1, difAge);\npst.setInt(2, idMin);\n\nSystem.out.println(pst);\n// The execution\nint updatedRows = pst.executeUpdate();\n\nSystem.out.println(updatedRows + \" has been updated.\");\n</code></pre> <p>Warning</p> <p>Remember to: </p> <ul> <li><code>UPDATE</code> clause don't need <code>FROM</code> because we say the table name directly.</li> <li>It appears <code>SET</code> clause, with pairs <code>field=updatet_value</code>, to assign the new value to selected fields.</li> <li>If we forget <code>FROM</code> clause, all rows will be updated.</li> </ul>"},{"location":"en/UD2_Connectors/6_CRUD/#14-scripts","title":"1.4. Scripts","text":"<p>A script, which we usually have created in an external file, is a set of SQL statements executed in order from top to bottom. We could take as a strategy to read the file line by line and execute it one by one, but JDBC allows executing a set of instructions in block. To do this, the first thing we need to do is enable multiple execution by adding a parameter to the connection, which is <code>allowMultiQueries=true</code>.</p> <p>Next, we must load the file and compose a String with the entire script. To normalize it and make it totally portable, we must be careful with the line breaks, since depending on the system it is a <code>\\n</code> or a <code>\\r\\n</code> combination. We can read line by line and save it in a <code>StringBuilder</code>, adding <code>System.getProperty(\"line.separator\")</code> as separators.</p> <p>Then we will only need to create a statement with said String and execute it with <code>executeUpdate()</code>. Let's see it:</p> Java<pre><code>ConnexioDB conDB = new ConnexioDB(\"Instituto\");\n\nConnection con = conDB.getConnexio();\n\nFile script = new File(\"sql/EsquemaCine.sql\");\n\nBufferedReader bfr = bfr = new BufferedReader(new FileReader(script));\n\nString line = null;\nStringBuilder sb = new StringBuilder();\n\n// Obtenemos el salto de linea del sistema subyacente\nString breakLine = System.getProperty(\"line.separator\");\n\nwhile ((line = bfr.readLine()) != null) {\n    sb.append(line);\n    sb.append(breakLine);\n}\n\nString query = sb.toString();   // generemos el Script en un String\nStatement stm = con.createStatement();\nint result = stm.executeUpdate(query);\nSystem.out.println(\"Script ejecutado con salida \" + result);\n</code></pre> <p>Advice</p> <p>Do you remember <code>Files</code> and <code>Paths</code> classes? Rewrite last sample to get cleaner code.</p>"},{"location":"en/UD2_Connectors/6_CRUD/#15-transactions","title":"1.5. Transactions","text":"<p>If we want to protect data integrity, as well as avoid unexpected blocking situations in multithreaded applications, we must protect our operations, especially those that modify data through the use of transactions.</p> <p>A transaction defines an execution environment in which save operations remain stored in memory until the transaction is completed. If at a certain moment something fails, the state is returned to the initial point of the same (initial point), or some intermediate marking point. By default, opening a connection starts a transaction.</p> <ul> <li>Each execution on the connection generates a transaction on itself. </li> <li>If we want to disable this option so that the transaction encompasses several executions, we must mark it through <code>Connection.setAutoCommit(false);</code>.</li> <li>To definitively accept the transaction we will do it through <code>Connection.commit();</code> </li> <li>To cancel the transaction <code>Connection.rollback();</code></li> </ul>"},{"location":"en/UD2_Connectors/6_CRUD/#16-updatable-resultsets","title":"1.6. Updatable ResultSets","text":"<p>The working methods revised in previous sections, specially when updating or deleting rows, works directly on the database. It means that you delete or update a row without loading previously in memory. What happens if you want to show data to user and then the user decide to delete or update the row. In this time, is better to use updatable ResultSet.</p> <p>We have studied ResultSet as a collection of rows, and used it only for reading. We can use it to edit and delete data too. To do this, we need to open the ResultSet in different way as we have seen. For last, but not least, it will depend on the database the availability to crete this kind of ResultSets.</p> <p>To get it, not depends on ResultSet even how Statement was created. We must use this constructor:</p> Java<pre><code>public abstract Statement createStatement(\n    int arg0,   // resultSetType           \n    int arg1,   // resultSetConcurrency\n    int arg2)   // resultSetHoldability\n    throws SQLException\n</code></pre> <p>As you can see, there are 3 arguments to tell what kind or ResultSet we give in the end. These three arguments can be:</p> <ul> <li><code>resultSetType</code> \\(\\rightarrow\\) these are options about moving and passing through rows in the ResultSet:</li> <li><code>TYPE_FORWARD_ONLY</code> \\(\\rightarrow\\) default option. ResultSet can be passed one time only.</li> <li><code>TYPE_SCROLL_INSENSITIVE</code> \\(\\rightarrow\\) Allow rewinding and skipping to an absolute or relative position.</li> <li><code>TYPE_SCROLL_SENSITIVE</code> \\(\\rightarrow\\) Same as before but allow seeing changes done in the database.</li> <li><code>ResultSetConcurrency</code> \\(\\rightarrow\\) these are options about if ResultSet can be updated or no:</li> <li><code>CONCUR_READ_ONLY</code> \\(\\rightarrow\\) default option. Read only. If we want to update something, only cas use <code>DELETE</code> or <code>UPDATE</code> clauses.</li> <li><code>CONCUR_UPDATABLE</code> \\(\\rightarrow\\) ResultSet's rows can be updated or deleted.</li> <li><code>ResultSetHoldability</code> these options are about behavior closing ResultSet:</li> <li><code>HOLD_CURSORS_OVER_COMMIT</code> \\(\\rightarrow\\) ResultSet remains opened after commit the transaction.</li> <li><code>CLOSE_CURSORS_AT_COMMIT</code> \\(\\rightarrow\\) ResultSet is closed after commit the transaction. It improves performance.</li> </ul> <p>In next sample we could ask our DBMS if these kinds of ResultSet are supported:</p> Java<pre><code>ConnexioDB conDB = new ConnexioDB(\"Instituto\");\nConnection con = conDB.getConnexio();\nDatabaseMetaData dbmd = con.getMetaData();\n\nSystem.out.println(\"TYPE_FORWARD_ONLY: \" + dbmd.supportsResultSetType(ResultSet.TYPE_FORWARD_ONLY));\nSystem.out.println(\"TYPE_SCROLL_INSENSITIVE: \" + dbmd.supportsResultSetType(ResultSet.TYPE_SCROLL_INSENSITIVE));\nSystem.out.println(\"TYPE_SCROLL_SENSITIVE: \" + dbmd.supportsResultSetType(ResultSet.TYPE_SCROLL_SENSITIVE));\nSystem.out.println(\"CONCUR_READ_ONLY: \" + dbmd.supportsResultSetConcurrency(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY));\nSystem.out.println(\"CONCUR_UPDATABLE: \" + dbmd.supportsResultSetConcurrency(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE));\n</code></pre>"},{"location":"en/UD2_Connectors/6_CRUD/#161-resultset-movement","title":"1.6.1. ResultSet movement","text":"<p>As we can see, not only could move cursor forward:</p> <ul> <li><code>next</code>, <code>previous</code>, <code>first</code> and <code>last</code> \\(\\rightarrow\\) as the name says, move forward, backward, beginning and last row. It returns true if the cursor is pointing over a row and false otherwise.</li> <li><code>beforeFirst</code> and <code>afterLast</code>\\(\\rightarrow\\) the cursor will point out of the rows, before the first or after the last row.</li> <li><code>relative(int n)</code> \\(\\rightarrow\\) the cursor moves n rows (forward or backward, depending on the sign).</li> <li><code>absolute(int n)</code> \\(\\rightarrow\\) the cursor is pointed on row n.</li> </ul>"},{"location":"en/UD2_Connectors/6_CRUD/#162-deleting-rows-in-a-resultset","title":"1.6.2. Deleting rows in a ResultSet","text":"<p>After placing the cursor on the row to be deleted we can delete it from the ResultSet (and from the database) with the <code>deleteRow()</code> method. When deleting a row, the cursor will be pointing to the row before the one deleted.</p>"},{"location":"en/UD2_Connectors/6_CRUD/#163-updating-rows-in-a-resultset","title":"1.6.3. Updating rows in a ResultSet","text":"<p>After placing the cursor on the desired row, we must:</p> <ol> <li>Update the desired columns, using the <code>updateType(int column, type newValue)</code> method, where the i-th column (or with its name) is assigned the new value of the given type.</li> <li>Once all the desired columns have been modified, the changes are saved with <code>updateRow()</code>.</li> </ol> <p>Advice</p> <p>We can't update an entire row, we should update column by column and then update the row.</p>"},{"location":"en/UD2_Connectors/6_CRUD/#164-inserting-rows-in-a-resultset","title":"1.6.4. Inserting rows in a ResultSet","text":"<p>If we want to insert a new row in a ResultSet, we must:</p> <ol> <li>Generate a new empty row, and this is achieved with the <code>moveToInsertRow()</code>. </li> <li>On this row we apply the <code>updateType(int column, type newValue)</code> method to all the columns that we must set a value, and finally</li> <li>We will proceed to insert the new row with <code>insertRow()</code>.</li> </ol> <p>!!! warning \"Important</p> Text Only<pre><code>- These Update, Delete and Insert operations can only be performed on queries that originate in a table without groupings.\n- To avoid complexity in our programs, it is worth assessing the convenience of translating the ResultSet updates to pure SQL and executing it natively in the databases through new statements.\n</code></pre>"},{"location":"en/UD2_Connectors/7_Row_to_Object/","title":"1. From rows to Objects","text":"<p>Finally, to close the unit, we are going to work in the natural way: recover data from database, create objects from ResultSet, and save data into database.</p> <p>We will study a new way to create ours POJO's (and BEAN's), using a modern library called Lombok.</p>"},{"location":"en/UD2_Connectors/7_Row_to_Object/#11-pojos-beanss-and-project-lombok","title":"1.1. POJO's, BEANS's and Project Lombok","text":"<p>We must create classes according to our object-oriented model. Depending on how we made classes, could be POJO's or BEAN's or another kind of classes. Let's go to understand it (extracted from here).</p>"},{"location":"en/UD2_Connectors/7_Row_to_Object/#111-pojo","title":"1.1.1. POJO","text":"<p>It means Plain Old Java Object. It is a class who:</p> <ul> <li>It should not extend any class.</li> <li>It should not implement any interface.</li> <li>It should not contain specific annotations.</li> </ul> <p>There is no restriction on access-modifiers of fields. They can be private, default, protected, or public. It is also not necessary to include any constructor in it.</p> <p>A sample of POJO is, for instance:</p> Java<pre><code>// AS POJO\npublic class Modul {\n  // attributes\n  String nom;\n  int hores;\n  double nota;\n  // constructor\n  public Modul(String nom, int hores, double nota) {\n      this.nom = nom;\n      this.hores = hores;\n      this.nota = nota;\n  }\n  // getters\n  public String getModul(){return this.nom;}\n  public int getHores() {return this.hores;}\n  public double getNota() {return this.nota;}\n\n  @Override\n  public String toString() {\n      return \"Modul{\" + \"nom=\" + nom + \", hores=\" + hores + \", nota=\" + nota + '}';\n  } \n}\n</code></pre> <p>As you can see, a POJO is the minimalist class that we can do.</p>"},{"location":"en/UD2_Connectors/7_Row_to_Object/#112-bean","title":"1.1.2. BEAN","text":"<p>Beans are special type of POJO's. There are some restrictions on POJO to be a BEAN.</p> <ul> <li>All JavaBeans are POJOs but not all POJOs are JavaBeans.</li> <li><code>Serializable</code>, they should implement Serializable interface. Still, some POJOs who don\u2019t implement a Serializable interface are called POJOs because Serializable is a marker interface and therefore not of many burdens.</li> <li>Fields should be private. This is to provide complete control on fields.</li> <li>Fields should have getters or setters or both.</li> <li>A no arguments constructor should be there in a bean.</li> <li>Fields are accessed only by constructor or getter setters.</li> </ul> Java<pre><code>// AS POJO\npublic class Modul {\n  // attributes\n  private String nom;\n  private int hores;\n  private double nota;\n  // constructor\n  public Modul() { }\n  // getters\n  public String getModul(){return this.nom;}\n  public int getHores() {return this.hores;}\n  public double getNota() {return this.nota;}\n// setters\n  public void getModul(){return this.nom;}\n  public void getHores() {return this.hores;}\n  public void getNota() {return this.nota;}\n\n  @Override\n  public String toString() {\n      return \"Modul{\" + \"nom=\" + nom + \", hores=\" + hores + \", nota=\" + nota + '}';\n  } \n}\n</code></pre> <p>To sum up, POJO classes and Beans both are used to define java objects to increase their readability and reusability. POJOs don\u2019t have other restrictions while beans are special POJOs with some restrictions.</p>"},{"location":"en/UD2_Connectors/7_Row_to_Object/#113-lombok","title":"1.1.3. Lombok","text":"<p>Regardless using POJO or BEAN, there are some repetitive tasks that we have to do to create our classes. Most of this task are implemented by IDE's, as well as create getters, setters, encapsulate fields, create constructors, etc. Project Lombok is a library that avoid doing this repetitive tasks, and saying what we want and the library and compiler do the rest.</p> <p>In this link setup Lombok you will find how to set up the library, in each project manager (gradle, maven, etc.) and in each IDE (Netbeans, Eclipse, IntelliJ, etc.). </p> <p>Once you have installed, you only need to say through annotations, what do you want:</p> <ul> <li><code>@Getter</code> \\(\\rightarrow\\) will generate all Getters.</li> <li><code>@Setter</code> \\(\\rightarrow\\) will generate all Setters.</li> <li><code>@Data</code> \\(\\rightarrow\\) all methods that needs a POJO, including <code>ToString</code></li> <li><code>@AllArgsConstructor</code> ou <code>@NoArgsConstructor</code> \\(\\rightarrow\\) generate the constructor you want</li> </ul> <p>In this v\u00eddeo you will find an explanation about how to add gradle dependency and using Lombok.</p>"},{"location":"en/UD2_Connectors/7_Row_to_Object/#12-loading-objects","title":"1.2. Loading objects","text":"<p>Let's go to finish with a sample:</p>"},{"location":"en/UD2_Connectors/7_Row_to_Object/#121-class-persona","title":"1.2.1. Class Persona","text":"<p>This class is the POJO of one person. It will create getters, setter, toString and the main methods with only a few lines and some annotations.</p> Java<pre><code>@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class Persona {\n    private int idPersona;\n    private String nombre;\n    private String apellidos;\n    private int edad;\n}\n</code></pre> <p>Notice that with Lombok work is made easy.</p>"},{"location":"en/UD2_Connectors/7_Row_to_Object/#122-filling-an-array","title":"1.2.2. Filling an Array","text":"<p>To fill a data structure from database, you have to get data first. You must create the Statement or PreparedStatement, run the query. </p> <p>The main task is transforming the ResultSet into a List, but it's a easy task:</p> <ul> <li>Loop over the ResultSet (with next), and for each row:</li> <li>Create an object with the values stored in the columns</li> <li>Add this object to the List</li> </ul> Java<pre><code>ArrayList&lt;Persona&gt; lasPersonas= new ArrayList();\n\nConnexioDB conDB=new ConnexioDB(\"Instituto\");\n\nConnection con=conDB.getConnexio();\n\nString SQL=\"Select * from Persona\" ;\n// The statement\nStatement st=con.createStatement(\n        ResultSet.TYPE_SCROLL_INSENSITIVE,\n        ResultSet.CONCUR_READ_ONLY);\n\n// The execution\nResultSet rst=st.executeQuery(SQL);\n\nif (!rst.next()){\n    System.out.println(\"No people in DB\");\n}\nelse{\n    rst.beforeFirst();\n    while(rst.next()){\n        Persona p= new Persona(\n                rst.getInt(1),\n                rst.getString(2),\n                rst.getString(3),\n                rst.getInt(4));\n        System.out.println(\"Adding \" +p);\n        lasPersonas.add(p);\n    }\n}\n\nSystem.out.println(\"Added \" + lasPersonas.size() + \" people\");\nrst.close();\n</code></pre> <p>Now you could change the information in the objects, and finally, if any modification has been done, you should save on database. The questions are:</p> <ul> <li>How do I know if an object has been update?</li> <li>How do I know what field should save?</li> </ul> <p>As you can see, there are several tasks that require a control of data modification and how to save it. This task will be easy with ORM, and we will study them.</p> <p> Versi\u00f3 Autor Data 0 Joan Gerard Camarena Juliol de 2021 1 Joan Gerard Camarena Octubre de 2022 2 Joan Gerard Camarena Setembre de 2024 <p></p>"},{"location":"en/UD3_Hibernate/1_Mapping/","title":"1.Object mapping","text":""},{"location":"en/UD3_Hibernate/1_Mapping/#1-introduction-mapping-technics","title":"1. Introduction. Mapping technics.","text":"<p>In previous units we have studied the access from our programs to files and relational databases. As seen, the big problem is that our programs handle objects, while databases handle tables, which causes the use of different models, and ends in the aforementioned object-relational gap.</p> <p>The object-relational mapping come to fill the gap between both models, preventing us from spending time in our code converting between the results of the operations and our objects. From the use of an ORM (Object Relational Mapping), once the correspondence between models has been established, in our programs we will only work with one model, the object-oriented model. In this way we manage to avoid our programs from that gap, focusing on the business logic.</p> <p>ORM techniques (Object-Relational Mapping Tools) are responsible, through a set of descriptions and metadata (data who describes data) to make a correspondence between the primitive data of both models and their structures: between tables and objects, fields and attributes, their identifiers and their primary keys. This correspondence will not always be simple, and metadata that can express greater complexity will have to be available.</p> <p>For example:</p> <ul> <li>We may find that sometimes it may be interesting to store a property in more than one column, or several properties in a single column.</li> <li>At other times, there may be properties that are not stored, or database fields that do not appear in the objects</li> <li>You use attributes with non-primitive data types that need to be cast in other tables, and decide which fields will be foreign keys that point to the new tables.</li> </ul> <p>In the same way as the definition of the data, we will need an object persistence mechanism, so that the objects can be \"tracked\" in memory, and when changes in them are reflected directly in the database.</p>"},{"location":"en/UD3_Hibernate/1_Mapping/#2-mapping","title":"2. Mapping","text":"<p>With this mapping tools we will:</p> <ul> <li>Reduce or development time</li> <li>Forget our underlying DBMS</li> <li>Work with objects, attributes and methods. You do not need nothing about tables and relations.</li> </ul> <p>Al mapping tools are based in these three solid bases</p>"},{"location":"en/UD3_Hibernate/1_Mapping/#21-mapping-technics","title":"2.1. Mapping technics","text":"<p>We highlight two object-relational mapping techniques:</p> <ul> <li>Those that embed the definitions within the code of the classes, and are linked to the language, such as C++ macros or PHP and Java annotations.</li> <li>Those that save the definitions in files independent of the code, generally in XML or JSON</li> </ul> <p>These are not mutually exclusive techniques, as both are available in most environments, and can even coexist in the same application.</p>"},{"location":"en/UD3_Hibernate/1_Mapping/#22-query-language","title":"2.2. Query language","text":"<p>As DBMS includes SQL as query language, most ORM's includes its own language, based on OQL Object Query Language. Like SQL we can ask for information but based on objects instead of tables.</p>"},{"location":"en/UD3_Hibernate/1_Mapping/#23-synchronization","title":"2.3. Synchronization","text":"<p>ORM's includes several processes focused on:</p> <ul> <li>Track and discover the changes that objects undergo during their life cycle in order to store them.</li> <li>Create and start new instances of objects from the data stored in the database.</li> <li>From the objects, extract their information to reflect it in the database tables.</li> </ul> <p>Note</p> <p>We will study lifecycle of objects when are loaded and saved from/to database.</p>"},{"location":"en/UD3_Hibernate/2_Hibernate/","title":"2. Introduction to Hibernate","text":""},{"location":"en/UD3_Hibernate/2_Hibernate/#1-hibernate","title":"1. Hibernate","text":"<p>Hibernate is an ORM framework for Java, which facilitates the mapping of attributes between a relational database and the object model of our application through XML files or annotations in the entity beans. It is free software distributed under the GPL 2.0 license, so it can be used in commercial applications.</p> <p>The main function of Hibernate will be to offer the programmer the tools to detail his data model and the relationships between them, so that it is the ORM itself that interacts with the database, while the developer is dedicated to manipulating objects.</p> <p>In addition, it offers a query language, called HQL (Hibernate Query Language), so that it is the ORM itself that translates this language to that of each database engine, thus maintaining portability at the expense of a slight increase in time of execution.</p> <p></p> <p>When objects are created, they are volatile or transient (will be destructed when the application finish). When we want to store them with Hibernate, they are tracked with one mechanism called Session. The objects loaded from databases are tracked too. If we want, we could finish the tracking, deleting the object when we do not need more.</p> <p>Moreover, a query language is provided, HQL or Hibernate Query Language, based on OQL. The underlying part of the session, as can be seen, allows the use of various technologies, including JDBC to connect to the necessary DBMS.</p>"},{"location":"en/UD3_Hibernate/2_Hibernate/#2-configuration","title":"2. Configuration","text":"<p>Hibernate, as a good framework does not need an installation, because is integrated in our project as libraries. We could choose to install lots of jar libraries, but is pretty good to use a package manager to automate this task. The building process of the project will be easier at the end.</p> <p>We will use Maven as package manager.</p>"},{"location":"en/UD3_Hibernate/2_Hibernate/#3-dependencies","title":"3. Dependencies.","text":"<p>In our projects two basic tools will be used: Hibernate and a driver to connect to the chosen database. Obviously, we need to add the dependencies to the package manager. In maven, the dependencies are included in the <code>Pom.xml</code> file, in the root folder of our project. Inside de <code>&lt;dependencies&gt;</code> tag you must add:</p> XML<pre><code>&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;mysql&lt;/groupId&gt;\n    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n    &lt;version&gt;8.0.27&lt;/version&gt;\n&lt;/dependency&gt;\n\n&lt;!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-core --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;\n    &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;\n    &lt;version&gt;5.6.3.Final&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>If you have chosen Gradle as package manager, your <code>build.gradle</code> set as:</p> Bash<pre><code>dependencies {\n    // https://mvnrepository.com/artifact/mysql/mysql-connector-java\n    implementation group: 'mysql', name: 'mysql-connector-java', version: '8.0.27'\n\n    // https://mvnrepository.com/artifact/org.hibernate/hibernate-core\n    implementation group: 'org.hibernate', name: 'hibernate-core', version: '5.6.3.Final'\n}\n</code></pre> <p>Remember</p> <p>Remember that you can find the packages in https://mvnrepository.com/repos/central</p>"},{"location":"en/UD3_Hibernate/2_Hibernate/#4-project-structure","title":"4. Project structure","text":"<p>Once we have added dependencies, we must create a project structure to organize our classes, in order to separate the logic program. We will show a brief description, getting a deeper explanation later.</p>"},{"location":"en/UD3_Hibernate/2_Hibernate/#41-beans","title":"4.1. Beans","text":"<p>Beans are the evolution of POJOs, that we have studied in previous units. Remember that these classes are common objects, out of inheritance trees and without implement any interfaces. They are used to storing information about one concept (I need a Car...create a Car).</p> <p>As an extension of POJO's, Beans appear, without restrictions in attributes, constructors and inheritance. They have some restrictions:</p> <ul> <li>Its attributes must be <code>private</code> (encapsulation).</li> <li>They must implement <code>serializable</code> interface.</li> <li>They must have public getters and setters.</li> <li>They must implement a generic constructor (without arguments).</li> </ul> <p>Remember</p> <p>The serialization runtime associates with each serializable class a version number, called a <code>serialVersionUID</code>, which is used during deserialization to verify that the sender and receiver of a serialized object have loaded classes for that object that are compatible with respect to serialization.</p> <p>If the receiver has loaded a class for the object that has a different <code>serialVersionUID</code> than that of the corresponding sender's class, then deserialization will result in an <code>InvalidClassException</code>. A serializable class can declare its own <code>serialVersionUID</code> explicitly by declaring a field named <code>serialVersionUID</code> that must be static, final, and of type long:</p> Java<pre><code>static final long serialVersionUID = 137L;\n</code></pre> <p>In summary, Beans are data access components, and they represent entities in our application. It is a good idea to create our Beans in the same package, normally called <code>Model</code>.</p> <p>Tip</p> <p>Remember <code>Lombok</code> library? It is very useful to create our beans with only a few lines of code.</p>"},{"location":"en/UD3_Hibernate/2_Hibernate/#42-mapping-files","title":"4.2. Mapping files","text":"<p>Once entities are created, we need to map each entity. Each mapping sets the references between beans and tables, attributes and columns, in order to establish a perfect match between them.</p> <p>First option will be creating mapping files, with the syntax (in XML) between classes and tables. If the bean is called <code>Car</code>, the mapping file should be <code>Car.hbm.xml</code>:</p> <ul> <li><code>hbm</code> is for hibernate mapping</li> <li><code>xml</code> because syntax is in XML specification.</li> </ul> <p>We will study mapping files in next sections.</p>"},{"location":"en/UD3_Hibernate/2_Hibernate/#43-other-files","title":"4.3. Other files","text":"<p>Finally, we will have the rest of the classes of the program, as well as the application or main class. If you are designing an application with a graphical environment, there would be data representation classes or views. Similarly, in case of a web application, controllers and services would be missing.</p>"},{"location":"en/UD3_Hibernate/2_Hibernate/#5-project-configuration","title":"5. Project Configuration","text":"<p>Let's take a closer look at the Hibernate configuration file. In the Hibernate configuration file we can set the options in a disorderly way, but it is recommended to group the option blocks for clarity and maintenance, as well as to indicate through comments what we are doing at that moment. We will see it with a complete example, which we will detail little by little in the following sections.</p>"},{"location":"en/UD3_Hibernate/2_Hibernate/#51-hibernatecfgxml","title":"5.1. Hibernate.cfg.xml","text":"XML<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n  &lt;!DOCTYPE hibernate-configuration PUBLIC \n    \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\" \n    \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\"&gt;\n\n &lt;hibernate-configuration&gt;\n    &lt;session-factory&gt;\n      &lt;!-- Connection properties --&gt;\n      &lt;!-- Driver JDBC --&gt;\n        &lt;property name=\"connection.driver_class\"&gt;\n          com.mysql.cj.jdbc.Driver\n        &lt;/property&gt;\n\n      &lt;!-- Add ?createDatabaseIfNotExist=true to create database  --&gt;\n      &lt;property name=\"connection.url\"&gt;\n        jdbc:mysql://localhost:3308/DBName\n      &lt;/property&gt;\n\n      &lt;!--user and pass --&gt;\n      &lt;property name=\"connection.username\"&gt;root&lt;/property&gt;\n      &lt;property name=\"connection.password\"&gt;root&lt;/property&gt;\n\n      &lt;!-- extra conf --&gt;\n\n      &lt;!-- JDBC connection pool for concurrent connections --&gt;\n      &lt;property name=\"connection.pool_size\"&gt;5&lt;/property&gt;\n\n      &lt;!--  dialect connector. Useful for Foreing Keys--&gt;\n      &lt;property name=\"dialect\"&gt;\n        org.hibernate.dialect.MySQL5InnoDBDialect\n      &lt;/property&gt;\n\n      &lt;!-- one thread one session --&gt;\n      &lt;property name=\"current_session_context_class\"&gt;thread&lt;/property&gt;\n\n      &lt;!-- show \"reals\" SQL ops. only for development--&gt;\n      &lt;property name=\"show_sql\"&gt;true&lt;/property&gt;\n\n      &lt;!-- DB maintenance --&gt;\n      &lt;property name=\"hbm2ddl.auto\"&gt;update&lt;/property&gt;\n\n      &lt;!-- options hbm2dll:\n        create : \n          create always DB when session factory is loaded. Data will be lost.\n        update : \n          Data will be safe, but database structure will be update. \n          Useful in production.\n        create-drop : \n          like create and dropping the database.\n        validate:   \n          check the mapping between database and beans.\n      --&gt;\n\n      &lt;!-- Mapping files. Can be combined--&gt;\n\n      &lt;!-- mapping classes --&gt;\n      &lt;mapping class=\"package.class1\" /&gt;\n      &lt;mapping class=\"package.class2\" /&gt;\n\n      &lt;!-- Maping files--&gt;\n      &lt;mapping resource=\"class3.hbm.xml\" /&gt;\n      &lt;mapping resource=\"class4.hbm.xml\" /&gt;\n    &lt;/session-factory&gt;\n&lt;/hibernate-configuration&gt;\n</code></pre> <p>Notice than:</p> <ul> <li>Show SQL queries option is high recommended to have it set to <code>true</code>, at least in first projects, to see how the mapping of objects to SQL queries actually occurs.</li> <li>The <code>hbm2ddl</code> option is very powerful, since if we only start from the object-oriented model, Hibernate will create the database for us (obviously empty of data). We will see in a later practice another very interesting <code>hbm2java</code> will appear, which through reverse engineering will allow us to create our Beans from the relational design.</li> <li>XML mapping files () must be together with the java classes, in the same package. <li>Mappings within the classes () refer to the Beans themselves, as we will see in next section."},{"location":"en/UD3_Hibernate/2_Hibernate/#52-loading-scripts","title":"5.2. Loading scripts","text":"<p>If you want to insert some data in your database test applications, it is a good idea to have a SQL script and load it automatically when hibernate configuration is loaded. You can add a file under <code>src/main/resources</code> called <code>import.sql</code>, and, after table creation, if exists, this script will be executed. This is the way to start a project with existing test data in our databases.</p> <p>Moreover, if you want to execute more scripts, you can add specific files in <code>hibernate.cfg.xml</code>, as follows:</p> XML<pre><code>&lt;property name=\"hibernate.hbm2ddl.import_files\"&gt;\n  /import1.sql, /import2.sql\n&lt;/property&gt;\n</code></pre>"},{"location":"en/UD3_Hibernate/2_Hibernate/#6-loading-configuration-and-sessions","title":"6. Loading configuration and Sessions","text":"<p>In order to load the previous configuration file, we must create a <code>SessionFactory</code> object throw we can create <code>Session</code> instances to connect to our database. The structure of this class will be always the same: load the configuration xml file, and then create the SessionFactory. </p> Java<pre><code>public class HibernateUtil {\n\n    private static final SessionFactory sessionFactory;\n\n    // C\u00f3digo est\u00e1tico. S\u00f3lo se ejecuta una vez, como un Singleton\n    static {\n        try {\n            // Creamos es SessionFactory desde el fichero hibernate.cfg.xml \n            sessionFactory = new Configuration()\n                .configure(new File(\"hibernate.cfg.xml\")).buildSessionFactory();    \n        } catch (Throwable ex) {\n            System.err.println(\"Error en la inicializaci\u00f3n.  \" + ex);\n            throw new ExceptionInInitializerError(ex);\n        }\n    }\n\n    public static SessionFactory getSessionFactory() {\n        return sessionFactory;\n    }\n}\n</code></pre> <p>Attention</p> <p>This implementation has been done with Singleton design pattern, in order to have a unique instance of SessionFactory</p>"},{"location":"en/UD3_Hibernate/3_Entities_Beans/","title":"3. Entities","text":""},{"location":"en/UD3_Hibernate/3_Entities_Beans/#1-mapping-entities-beans","title":"1. Mapping Entities. Beans","text":"<p>Once we have studied the project configuration and setup, it is time to start to map our entities and relationships. Starting with the relational model, we are going to use next entity <code>Peli</code>, based on:</p> SQL<pre><code>CREATE TABLE `Peli` (\n  `idPeli` int(11) NOT NULL AUTO_INCREMENT,\n  `titulo` varchar(45) NOT NULL,\n  `anyo` varchar(45) NOT NULL,\n  `director` varchar(45) NOT NULL,\n  PRIMARY KEY (`idPeli`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8\n</code></pre> <p>You can find it in the resource folder in a <code>DBCine1.sql</code> script. The class to encapsulate this entity looks like:</p> Java<pre><code>package Model;\n\nimport java.io.Serializable;\n\n/**\n *\n * @author joange\n */\npublic class Peli implements Serializable{\n\n    private Long idPeli;\n    private String titulo;\n    private int anyo;\n    private String elDirector;\n\n    public Peli() {\n    }\n\n    public Peli(String titulo, int anyo, String elDirector) {\n        this.titulo = titulo;\n        this.anyo = anyo;\n        this.elDirector = elDirector;\n    }\n  // more to come\n}\n</code></pre> <p>Tip</p> <p>Remember that you can use <code>Lombook</code> library to create beans in a faster way.</p>"},{"location":"en/UD3_Hibernate/3_Entities_Beans/#2-mapping-files","title":"2. Mapping files","text":"<p>The bean created in last section cannot be persisted yet. In order to do it, we must create an external file to the class, with the extension <code>hbm.xml</code> and with the same name as the class (Hibernate Mapping). The file location does not matter, but it is a good idea to save the model classes on one side and the mapping files on the other. </p> <p>So we will create an <code>orm</code> package and within it, we will create the <code>Peli.hbm.xml</code> file. Let's go to explain it by example, because syntax is pretty big.</p> XML<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\" \n  \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"&gt;\n&lt;hibernate-mapping&gt;\n    &lt;class name=\"Model.Peli\" table=\"Peli\" &gt;\n        &lt;id column=\"idPeli\" name=\"idPeli\" type=\"int\"&gt;\n            &lt;generator class=\"native\"/&gt;\n        &lt;/id&gt;\n        &lt;property name=\"titulo\" type=\"string\"/&gt;\n        &lt;property name=\"anyo\" /&gt;\n        &lt;property column=\"director\" name=\"elDirector\" /&gt;\n    &lt;/class&gt;\n&lt;/hibernate-mapping&gt;\n</code></pre> <p>We point on basics:</p> <ul> <li>Lines 1-3 are xml header, pointing to the dtd file with grammar in order to check that file is well-formed.</li> <li><code>&lt;hibernate-mapping&gt;</code> \\(\\rightarrow\\) tell that this file is a mapping</li> <li><code>&lt;class&gt;</code> \\(\\rightarrow\\) is the tag to specify what class we are mapping, and has two attributes:</li> <li><code>name=\"Model.Peli\"</code> \\(\\rightarrow\\) pointer to the class (Java file), without extension.</li> <li><code>table=\"Peli\"</code> \\(\\rightarrow\\) here we write the name of the table in the database who will contain the data.</li> <li>It remains to say the fields in the class and its respective column. We distinguish between:</li> <li><code>&lt;property&gt;</code> \\(\\rightarrow\\) for normal fields. It could appear several attributes:<ul> <li><code>name</code> \\(\\rightarrow\\) (mandatory) is the name of the field inside the class</li> <li><code>column</code> \\(\\rightarrow\\) is the name of the matching column in the table. If no <code>column</code> is set, hibernate will suppose that it is the same as <code>name</code> attribute.</li> <li><code>type</code> \\(\\rightarrow\\) is the java type of the column. By default, Hibernate will use the same as the specified by the class, but we must indicate to resolve ambiguous fields (look next figure, specially in Date and Time formats)</li> </ul> </li> <li><code>&lt;id&gt;</code> \\(\\rightarrow\\) (mandatory) is the field that will be used as primary key, and also could appear name, column and type attributes. Exists the possibility that primary key will be generated by the DBMS, and we will set how, with<ul> <li><code>&lt;generator&gt;</code> \\(\\rightarrow\\) set the engine to generate primary key, that can be set in several ways. With <code>native</code> we use the same method of the underlying database. On this tutorial you can get a full samples link</li> </ul> </li> </ul> <p>Attention</p> <ul> <li>You have to save this file to be accessed in our project. A good option is to create a <code>resources</code> folder inside <code>src/main</code> and save these files inside.</li> <li>Hibernate needs get/set methods in order to access fields of our objects. Nevertheless, maybe you don't want to create any methods, nut hibernate needs. The solution is to add a new attribute <code>access=field</code> that allows hibernate to get/set without getters and setters.</li> </ul> <p></p> <p>Note</p> <p>We will study more options like foreign keys in next sections.</p> <p>Now is time to create a little program to prove all the contents. Take a look to next code:</p> Java<pre><code>// get a Session and start a transaction\nSession laSesion=HibernateUtil.getSessionFactory().getCurrentSession();\nlaSesion.getTransaction().begin();\n\n// Create new object\nPeli p=new Peli(\"Piratas del caribe\", 2003, \"Gore Verbinsky\");\nSystem.out.println(\"Unsaved: \"+ p);\n\n// save in the database\nLong idNueva=(Long)laSesion.save(p);\n\n// Get the saved object (with another varaible)\nPeli q=laSesion.get(Peli.class, idNueva);\n\nSystem.out.println(\"Saved: \" + q);\n\n//close all\nlaSesion.getTransaction().commit();\nlaSesion.close();\n</code></pre> <p>Comments:</p> <ul> <li>Notice than to save an Object (e.g. insert a row in the database), you only need to run <code>Session.save(Object)</code>.</li> <li>To get one object from database, there is an easy way, knowing class and primary key of the object. Method is <code>Session.get(class,ID)</code>, and we get an onject of this class whit this ID.</li> <li>Notice that when we create new object, it hasn't an ID (remember that is auto generated), but when we save it, a new ID was assigned.</li> </ul> <p>Important</p> <p>If we choose to <code>create</code> in <code>hbm2ddl.auto</code> property, as you will guess, the database will be empty. It's a good idea to create a file called <code>imports.sql</code> with some data needed to test our programs.</p>"},{"location":"en/UD3_Hibernate/3_Entities_Beans/#3-mapping-classes-annotations","title":"3. Mapping classes. Annotations","text":"<p>Before starting annotating classes, let's show that:</p> <ul> <li> <p>JDO (Java Data Objects) is a persistence standard developed by Apache, which includes a persistence framework based on post compilation. Although trying to achieve a more efficient technique, there are few commercial initiatives that follow this standard.</p> </li> <li> <p>The alternative is JPA (Java Persistance API), a persistence standard incorporated into JDK 5, with various libraries that support it, and based on the principle of reflection, which uses metadata as well as information about the classes and the structure What a fan that the virtual machine can access the information collected from the objects to invoke their methods and build new instances. The two most widely implemented ORMs in Java: Hiberate and EJB use this standard.</p> </li> </ul> <p>Mapping classes is easy, and we only need to match every field with every column. The drawback is than we need to maintain two files: classes and mapping files. For this reason, we can join both elements, adding inside classes the specific annotations to do the match. JPA interface allow us to do this task.</p> <p>Let's go to show a class with annotations, and compare with mapping files. Moreover, we will use Lombok to create the class, that use annotations too ;).</p> Java<pre><code>@Data\n@NoArgsConstructor\n@Entity\n@Table(name = \"Car\")\npublic class Car implements Serializable {\n\npublic Car(String plate, String brand, int year) {\n    this.plate = plate;\n    this.brand = brand;\n    this.year = year;\n}\n\nstatic final long serialVersionUID = 137L;\n\n@Id\n@GeneratedValue(strategy = GenerationType.IDENTITY)\nprivate long idCar;\n\n@Column\nprivate String plate;\n\n@Column(name = \"marca\")\nprivate String brand;\n\n@Column\nprivate int year;\n}\n</code></pre> <p>Info</p> <p>Hibernate create firstly his annotations, in package <code>org.hibenate.annotations</code>, but from version 4, all these annotations were deprecated and we must take care, and import annotations from <code>javax.persistence</code></p> <p>Let's go to see main annotations, instead you will have lots of them in JPA documentation:</p> <ul> <li><code>@Entity</code> to focus that this class represent an entity in our database. Moreover, we must associate this entity to a <code>@Table</code> with the correct name.</li> <li>To set database fields, we must use <code>@Column</code>. You could specify more options, specially if the name of the column is different of field name. Take a look of next picture for more options. An interesting option is to set an auto generated value, with <code>@GeneratedValue</code>. If you do not set <code>name</code> option, it is supposed to be same.</li> <li>To mark a field as primary key you need <code>@Id</code>. In this case you do not need to set with <code>@Column</code></li> </ul>"},{"location":"en/UD3_Hibernate/3_Entities_Beans/#4-componenets","title":"4. Componenets","text":"<p>Let's go to revise a special design patters, who is aggregation. Is when we need a special entity that only make sense inside another entity, for instance a wheel did not have sense outside a car. If the entity can exist by its own, is when we use a relation, and we will study in next section.</p> <p>The aggregate class is also called a component.</p> <p>Info</p> <p>These components is also substituted by a 1:1 relationship with an existence constraint, when in the normalization process is joined in the same table.</p> <p>To create component, the aggregated class must be defined with <code>@Embeaddable</code> (and obviously without <code>@Entity</code>). This annotation says to Hibernate that the existence of these objects must be inside another objects. Inside these objects, as fields, the objects must be marked as <code>@Embeeded</code>. Let's go to see a sample:</p> <p>A component <code>Wheel</code></p> Java<pre><code>@Embeddable\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class Wheel {\n\n    @Column\n    int diameter;\n    @Column\n    char speedCode;\n}\n</code></pre> <p>An aggregation <code>CarWheel</code></p> Java<pre><code>@Data\n@NoArgsConstructor\n@Entity\n@Table(name = \"Car\")\npublic class CarWheel implements Serializable {\n\n    public CarWheel(String plate, String brand, int year, Wheel wheel) {\n        this.plate = plate;\n        this.brand = brand;\n        this.year = year;\n        this.wheel = wheel;\n    }\n\n    static final long serialVersionUID = 137L;\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private long idCar;\n\n    @Column\n    private String plate;\n\n    @Column(name = \"marca\")\n    private String brand;\n\n    @Column\n    private int year;\n\n    @Embedded\n    private Wheel wheel;\n\n}\n}\n</code></pre> <p>When Hibernate creates the table, be notice that no table <code>Wheel</code> will be created. Against, all fields are inside <code>CarWheel</code>. Two last fiels are properties from <code>Wheel</code> class.</p> SQL<pre><code>Hibernate: \ncreate table Car (\n    idCar bigint not null auto_increment, \n    marca varchar(255), \n    plate varchar(255), \n    year integer, \n    diameter integer, \n    speedCode char(1), \n  primary key (idCar)) engine=InnoDB\n</code></pre> <p>Attention A problem could appear when you try to store two embedded components, for instance two addresses from an employee, because as hibernate creates fields from component class, fields name will be duplicated. In order to avoid this drawback, the solution is to rename the component class fields, as follows (inside the aggregate class):</p> Java<pre><code>@Embedded\nprivate Wheel wheel1;\n\n@Embedded\n@AttributeOverrides({\n        @AttributeOverride(name=\"diameter\", column = @Column(name=\"diameter2\") ),\n        @AttributeOverride(name=\"speedCode\", column = @Column(name=\"speedCode2\") )\n})\nprivate Wheel wheel2;\n</code></pre> <p>Notice that:</p> <ul> <li>First embedded field do not need nothing special.</li> <li>In second, we most override the attribute names, starting an <code>@AttributeOverrides</code> with several <code>@AttributeOverride</code>, marking old name and new column name.</li> </ul> <p>Tip</p> <p>This situation is not usual, but is important to solve it when you need it. </p>"},{"location":"en/UD3_Hibernate/3_Entities_Beans/#5-exercise","title":"5. Exercise","text":"<p>Do the following task:</p> <ul> <li>Create a maven project and add all the dependencies that you need.</li> <li>Create two classes by you own, but thinking that they will be related in a future. For instance, Teacher and Topic, or Driver and Car, or Pet and Vet. At this moment you don't need to create any relation.</li> <li>Each class must have an ID, and almost 4 fields, with several data types (do not create all String fields).</li> <li>Map both classes:</li> <li>One with an external XML file.</li> <li>The other with JPA annotations.</li> <li>Create a main App when you ask the user for data and store (and save) in the same database</li> </ul>"},{"location":"en/UD3_Hibernate/4_Relationships/","title":"4. Relationships","text":""},{"location":"en/UD3_Hibernate/4_Relationships/#1-mapping-relations","title":"1. Mapping Relations","text":"<p>As we mentioned in the introduction, we are going to analyze how to map the different types of relationships. Before we start discussing the cardinality of relationships, we have to consider the meaning of these relationships, and we are going to review the concept of directionality of relationships.</p> <ul> <li>Unidirectional \\(\\rightarrow\\) We will say that a relationship is unidirectional when we will access the related object (component) from another object (owner). For example, if we mount an engine in a car, the logical thing is that the owner is the car, and from it, we will obtain the engine. In this case, inside the Car object, an Engine object will appear, and the Engine will not have an existence of its own.</li> <li>Bi directional \\(\\rightarrow\\) They are relations in which the related elements usually have the same weight or entity. For example, a Group of an institute and a Tutor. From a group if it makes sense to know the tutor, and we can also from a teacher (the tutor), access the group he tutors. In this case, within the Group object we have a reference to the Tutor object and vice versa.</li> </ul> <p>Warning</p> <p>In this type of references, as can be deduced, there is an intrinsic recursion. So, when we handle this type of bidirectional relationships, be very careful not to cause loops, since even something as simple as printing can cause our program to crash and the well-known <code>StackOverflowException</code></p> <p>From now, we could study all representations with JPA</p>"},{"location":"en/UD3_Hibernate/4_Relationships/#2-one-to-one-relationships","title":"2. One to One Relationships","text":"<p>For the explanation of the examples, we will see the design and implementation in the database of each case and how it looks in Hibernate. For this example we are going to represent a 1:1 relationship between Group and Teacher, whereas you can see that a Group has a Tutor, and a Tutor only could tutoring one Group.</p> <p></p> <p>Firstly, the class that is pointed by the foreign key. Easy-peasy, because we do not need nothing to do.</p> Java<pre><code>@Data\n@NoArgsConstructor\n@Entity\n@Table(name=\"Profesor\")\npublic class Profesor {\n\n  static final long serialVersionUID = 1L;\n\n  @Id\n  @GeneratedValue(strategy=GenerationType.IDENTITY)\n  private int idTeacher;\n\n  @Column\n  private String name;\n\n  public Profesor(String name) {\n      this.name = name;\n  }   \n}\n</code></pre> <p>And now, the class that contains the foreign key. Here we need to mark that a Group need a Teacher as tutor. Let's see:</p> <p>Java<pre><code>@Data\n@NoArgsConstructor\n@Entity\n@Table(name = \"Grupo\")\npublic class Grupo implements Serializable {\n\n  static final long serialVersionUID = 137L;\n\n  @Id\n  @GeneratedValue(strategy = GenerationType.IDENTITY)\n  private long idGroup;\n\n  @Column\n  private String level;\n\n  @Column\n  private String course;\n\n  @Column\n  private int year;\n\n  @OneToOne(cascade = CascadeType.ALL)\n  @JoinColumn(\n      name=\"id_tutor\",\n      referencedColumnName = \"idTeacher\",\n      unique=true,\n      foreignKey = @ForeignKey(name = \"FK_GRP_TEACH\"))\n  private Profesor tutor;\n\n  public Grupo(String level, String course, int year) {\n      this.level = level;\n      this.course = course;\n      this.year = year;\n  }  \n\n}\n</code></pre> Notice that Group class contains a field called <code>tutor</code> of <code>Profesor</code> class, and:</p> <ul> <li><code>@OneToOne(cascade = CascadeType.ALL)</code> we mark this relation as 1:1. Moreover, we say the <code>cascade</code> attribute, the most important thing. Cascading is the way say that when we perform some action on the target entity (Grupo), the same action will be applied to the associated entity (Profesor). Let's review the most relevant options:</li> <li><code>CascadeType.ALL</code> propagates all operations. The same operation that we do in the target will be done it in the associated.</li> <li><code>CascadeType.PERSIST</code> propagates only persist operation on database (save).</li> <li><code>CascadeType.SAVE_UPDATE</code> is from Hibernate, not JPA, and propagate the <code>saveOrUpdate()</code> method. Is very similar to persist.</li> <li><code>CascadeType.REMOVE</code> or <code>CascadeType.DELETE</code> propagates deletion of entities. Be very careful with this option to avoid lose data.</li> <li>In the <code>@JoinColumn</code> we set:</li> <li>name of the column in our database</li> <li>name of the column referenced in target entity Profesor</li> <li><code>unique=true</code> to ensure that the relation is 1:1 (a teacher can not be related with any other Group)</li> <li>[optional] to set the foreign key constraint name, in case you want to rename or remove in future operations.</li> </ul> <p>You can find more info at baeldung</p>"},{"location":"en/UD3_Hibernate/4_Relationships/#21-one-to-one-bidirectional","title":"2.1. One to One bidirectional","text":"<p>If we want to store in Profesor the groups that he or she is tutoring, we need to add a reference to the Group. Due to we have done the foreign key in Group, it will be very easy:</p> Java<pre><code>@OneToOne(mappedBy= \"tutor\") \nprivate Grupo elGrupo;\n</code></pre> <p>With <code>mappedBy=\"tutor\"</code> we are saying that in <code>Grupo</code> class exists a field called <code>tutor</code> with the whole information about the relation. Notice that no extra fields will beb added in Profesor, because information about the relation is in Group table.</p>"},{"location":"en/UD3_Hibernate/4_Relationships/#3-one-to-many","title":"3. One to Many","text":"<p>For this explanation we will start from the following model, in which a Book has an Author who has written it, and an Author may have written several Books. In the relational schema, the relationship is from <code>idAuthor</code> in Books, which is foreign key to the Author table (ID).</p> <p></p> <p>First, we can decide who is the owner of the relation. It really does not mind, but in several designs it is very clear, for instance between <code>Student</code> and <code>Email</code>, who obviously the owner is <code>Student</code>. Normally should be the class with many cardinality the owner. Let's go with the sample.</p> Java<pre><code>@Entity\n@Table(name=\"Libro\")\npublic class Libro implements Serializable {\n\n    @Id\n    @GeneratedValue(strategy=GenerationType.IDENTITY)\n    private Long idLibro;\n\n    @Column\n    private String titol;\n\n    @Column\n    private String tipus;\n\n    @ManyToOne(cascade=CascadeType.PERSIST)\n    @JoinColumn(name=\"idAutor\",\n                foreignKey = @ForeignKey(name = \"FK_LIB_AUT\" ))\n    private Autor elAutor;\n</code></pre> <p>In this sample, a <code>Book</code> has an (unique) author. We implement it storing a reference to an Author object, called <code>elAutor</code> inside our Book. We have to write the relation information in this field:</p> <ul> <li>We must mark this field as <code>@ManyToOne</code>, because Book is at the many's side of the relation (remember that an Author can write several Books)</li> <li>The foreign key will be annotated with <code>@JoinColumn</code> label, with several attributes:</li> <li>Since <code>elAutor</code> is the initial point of the foreign key, who point to the <code>Author</code> table, we need to say the name of the primary key in it class. This attribute is optional, but is a good option to improve our code.</li> <li>Optional, we can name the constraint of the foreign key, with a well-structured name, with the <code>foreignKey</code> attribute</li> </ul> Java<pre><code>@Entity\n@Table(name=\"Libro\")\npublic class Autor implements Serializable{\n\n    static final long serialVersionUID = 137L;\n\n    @Id\n    @GeneratedValue(strategy=GenerationType.IDENTITY)\n    private Long idAutor;\n\n    @Column\n    private String nom;\n\n    @Column\n    private String nacionalitat;\n\n    @OneToMany(mappedBy=\"elAutor\",\n            cascade=CascadeType.PERSIST,\n            fetch = FetchType.LAZY)\n    private Set&lt;Libro&gt; elsLlibres;\n\n    // rest of the class\n</code></pre> <p><code>Author</code> class is on the one side, and it means that it can write many <code>Books</code>. For this reason we store all the books it has written in a <code>Set</code> of books. The annotations will be:</p> <ul> <li>As one Author can write many books, we mark the Set of books as <code>@OneToMany</code>. As we have written the relation specification in Book, we could say that the relation is mapped in <code>elAutor</code> field inside <code>Book</code> class, with <code>mappedBy=\"elAutor\"</code> easily.</li> </ul> <p>Decissi\u00f3</p> <p>Instead of storing books in a Set, it can be stored in List. The main difference is to answer this question: is it important the order?. If you respond yes, you must use a List. It the response is no you must use a Set.</p> <p>Espai</p> <p>The <code>1:N</code> that we have explained is bidirectional relation. It means that from an Author we can get all the Books he/she has written, and from a Book we can get the Author.</p> <p></p> <p>You could find several pages and books who explain unidirectional <code>1:N</code> relations. It means that with this kind of implementation we only can travel in one direction. In this case we must store only inside a Book who is the author, because Book is the owner. We must remove the Set of books in author to get an unidirectional relation.</p>"},{"location":"en/UD3_Hibernate/4_Relationships/#31-fetch-type","title":"3.1. Fetch type","text":"<p>This attribute usually appears when we have in a <code>1:N</code> or <code>N:M</code> relationship in a class that has a collection of related classes (can also be specified with a <code>1:1</code> but is less common). When Hibernate loads an object, it will load its general attributes (name, nationality, etc...), but what about the Books he has written, loads them or not?</p> <ul> <li><code>DateType.EAGER</code> \\(\\rightarrow\\) Literally translated as anxious (ansioso). We can't wait, and when Author is loaded, Hibernate will resolve the relationship and load all the books with all the internal data for each book. We have all the data at the moment.</li> <li><code>DateType.LAZY</code> \\(\\rightarrow\\) Literally as lazy (vago), but more representative as lazy loading. If we load the Author, Hibernate only loads the Author's own attributes, without loading its Books. When we try to access their books from our program, Hibernate is activated and loads them. That is, in LAZY mode, the data is loaded when is needed.</li> </ul> <p>What we will do?*</p> <p>Which is better or worse? The answer is not simple, since both have pros and cons:</p> <ul> <li>In <code>EAGER</code> only one access is made, while in <code>LAZY</code> two accesses or more. </li> <li>In the <code>EAGER</code> all data is loaded, even if they are not needed, in the <code>LAZY</code> only what is needed is loaded. </li> </ul> <p>The programmer must assess and balance the amount of information required at a given time and the cost of access to the database.</p>"},{"location":"en/UD3_Hibernate/4_Relationships/#4-many-to-many","title":"4. Many to Many","text":"<p>In this section we will finish with the last type of relationships that we can find in the E/R model, which are many-to-many relationships. It can appear other relationships with higher cardinalities, such as ternary relationships, but as was studied in the first year, all of them can be modeled with binary transformations.</p> <p>Within binary relationships, we can find two possibilities: </p> <ul> <li>Relationships that simply indicate the relationship (for example, that a character may or may not carry a certain type of weapon in a role-playing game) or </li> <li>Relationships that, apart from indicating it, add new attributes. For instance, an actor participates in a film in a type of role: main, secondary, etc.</li> </ul> <p>In the relational model, both cases ended up being modeled as a new table (with or without the attribute). If we find ourselves in the second case, a new table with the attributes it possesses must be modeled with a class, so the <code>N:M</code> relationship between two tables there will be <code>two one-to-many relationships 1:N and N:1</code> (actor-performance and performance-film) We will focus on the first case, since we are already prepared to solve the second one.</p> <p>Improving</p> <p>For the second part, this tutorial explains how to do it N_M with attributes. Is very recommmended to implement it a sample.</p> <p>We are going to model the typical case of a Teacher who teaches several Modules, which can be taught by several teachers. The scheme looks like below:</p> <p></p> <p>As we can see, the typical central table of the <code>N:M</code> relationship remains. As previously mentioned, the Teaching table will not exist in the OO model, since it only serves to relate the elements.</p> <p>The Module and Teacher classes are as follows (only the part related to the relationship is shown) choosing in this case Teacher as the owner of the relationship:</p> Java<pre><code>// in Professor, a set of Modulo\n@ManyToMany(cascade=CascadeType.PERSIST,\n            fetch=FetchType.LAZY)\n@JoinTable(name=\"Docencia\",\n          joinColumns = {@JoinColumn(\n            name=\"idProfesor\",\n            foreignKey = @ForeignKey(name = \"FK_DOC_PROF\" ))},\n          inverseJoinColumns = {@JoinColumn(\n            name=\"idModulo\",\n            foreignKey = @ForeignKey(name = \"FK_DOC_MOD\" ))})\nprivate Set&lt;Modulo&gt; losModulos=new HashSet&lt;&gt;();\n</code></pre> Java<pre><code>// in Modulo.. a set of Professor\n@ManyToMany(cascade = CascadeType.PERSIST,\n            fetch = FetchType.LAZY,\n            mappedBy = \"losModulos\")\nprivate Set&lt;Profesor&gt; losProfesores=new HashSet&lt;&gt;();;\n</code></pre> <p>This is the most complicated specification, let's go:</p> <ul> <li>In both classes the mapping is <code>@ManyToMany</code></li> <li>In both cases we indicate how we handle the cascade operations (<code>cascade</code>) and the loading of the related objects of the other class (<code>fetch</code>)</li> <li>In the owner class (<code>Professor</code>) a <code>Set&lt;Module&gt;</code> is mapped with the relationship will start from my current class <code>Professor</code> \\(\\rightarrow\\) teaching \\(\\rightarrow\\) <code>Modulo</code> (the base type of the Set)</li> <li>With <code>@JoinTable</code> It is indicated that the relationship links to a table with <code>Docencia</code> name, where:</li> <li>It will be linked (<code>joincolumns</code>), and the join is with <code>@JoinColumn</code>:<ul> <li>Starting from the <code>idProfesor</code> field inside the <code>Docencia</code> table</li> <li>Finishing on the <code>Profesor</code> primary key,</li> <li>The FK is named <code>foreignKey = @ForeignKey(name = \"FK_DOC_PROF\" )</code>.</li> </ul> </li> <li>Pay attention that name inside @JoinTable are names in the table Docencia (existing only on the database).</li> <li>It is mapped from the <code>Docencia</code> table to the <code>Modulo</code> source entity inversely (from the point to the origin of the arrow):   </li> <li>This is achieved with <code>inverseJoinColumns</code>:<ul> <li>linking from the <code>idModule</code> field (<code>@JoinColumn</code>).</li> <li>We also name the FK.</li> </ul> </li> <li>In the related class (<code>Modulo</code>), which is not the owner, we simply indicate that the owner is <code>Profesor</code>, by means of <code>mappedBy=\"losModulos\"</code>.</li> </ul> <p>A sample code will be like this:</p> Java<pre><code>Profesor p1 = new Profesor(\"Mario Bened\u00e9\");\nProfesor p2 = new Profesor(\"Jose Fernandez\");\n\nModulo m1 = new Modulo(\"Acceso a Datos\");\nModulo m2 = new Modulo(\"Bases de Datos\");\nModulo m3 = new Modulo(\"Programaci\u00f3n\");\nModulo m4 = new Modulo(\"Dise\u00f1o de Interfaces\");\n\n// a\u00f1adimos modulos a p1\np1.addModulo(m3);\np1.addModulo(m1);\n\n// a\u00f1adimos modulos a p2\np2.addModulo(m2);\np2.addModulo(m3);\np2.addModulo(m4);\n\n// guardamos\nlaSesion.persist(p1);\nlaSesion.persist(p2);\n</code></pre> <p>and the hibernate output will be something like:</p> Bash<pre><code>Hibernate: drop table if exists Modulo\nHibernate: drop table if exists Profesor\nHibernate: create table Docencia (\n    idProfesor bigint not null, \n    idModulo bigint not null, \n    primary key (idProfesor, idModulo)) engine=InnoDB\nHibernate: create table Modulo (\n    idModulo bigint not null auto_increment, \n    nombre varchar(255), \n    primary key (idModulo)) engine=InnoDB\nHibernate: create table Profesor (\n    idProfe bigint not null auto_increment, \n    nomProfe varchar(255), \n    primary key (idProfe)) engine=InnoDB\nHibernate: alter table Docencia add constraint FK_DOC_MOD \n    foreign key (idModulo) references Modulo (idModulo)\nHibernate: alter table Docencia add constraint FK_DOC_PROF \n    foreign key (idProfesor) references Profesor (idProfe)\nHibernate: insert into Profesor (nomProfe) values (?)\nHibernate: insert into Modulo (nombre) values (?)\nHibernate: insert into Modulo (nombre) values (?)\nHibernate: insert into Profesor (nomProfe) values (?)\nHibernate: insert into Modulo (nombre) values (?)\nHibernate: insert into Modulo (nombre) values (?)\nHibernate: insert into Docencia (idProfesor, idModulo) values (?, ?)\nHibernate: insert into Docencia (idProfesor, idModulo) values (?, ?)\nHibernate: insert into Docencia (idProfesor, idModulo) values (?, ?)\nHibernate: insert into Docencia (idProfesor, idModulo) values (?, ?)\nHibernate: insert into Docencia (idProfesor, idModulo) values (?, ?)\n</code></pre> <p>After all the tables were created, Hibernate creates the foreign keys, and then insert the recors. Firstly, Profesor and Modulo, and finally the relation in Docencia table.</p>"},{"location":"en/UD3_Hibernate/5_HQL/","title":"5. Queries","text":""},{"location":"en/UD3_Hibernate/5_HQL/#1-hibernate-query-language","title":"1. Hibernate Query Language","text":"<p>Full documentation can be found here:</p> <ul> <li>In spanish</li> <li>In english</li> </ul> <p>The HQL language (Hibernate Query Language) was born with the aim of saving the relational model, since it is a supraset of SQL (extension of SQL that includes SQL). The first consideration is that, by default, its functionality is to retrieve objects from the database, not tables as we did in the SQL language through <code>ResultSet</code>. The queries with HQL will be made from a Query interface, which will be the place where we will specify what we want to get. Optionally we can add to the query the necessary parameters for its execution, to avoid hard-coded queries.</p> <p>Firstly, the query will be prepared. When creating it, we have to take into account two options, with four possible combinations: </p> <ul> <li>It will return one result or more than one and,</li> <li>It will return the result encapsulated in objects or in a composite way. </li> </ul> <p>Depending on the answer obtained, in the second step we will choose one of the four options seen below.</p> Java<pre><code>1 Query q=session.createQuery(\"HQL statement\");\n\n2.1 List&lt;Object&gt; resultsObjects=q.list();\n\n2.2 List&lt;Object []&gt;mixedresults=q.list();\n\n2.3 Object result=q.uniqueResult();\n\n2.4 Object[] result=q.uniqueResult();\n\n1. // process information obtained\n</code></pre> <ol> <li>In first option the query returns a collection of objects (several rows, on object in a row).</li> <li>This option return a collection with a composite of objects and another types: for example a Student a number of topics and number of teachers.</li> <li>Both last options is when, instead of a collection, the query returns a unique object/composite.</li> </ol> <p>Note</p> <ul> <li><code>session.createQuery</code> allow to write an HQL query, with or without parameters</li> <li><code>Query.list()</code> get all the objects (as a List) from the database that satisfy the query.</li> <li><code>Query.uniqueResult()</code> get a single object from the database.</li> </ul> <p>Before details, here you will find some general ideas:</p> <ul> <li>We can remove the <code>Select *</code>, to indicate that we want it all attributes.</li> <li>There is a medium case sensitivity: HQL reserved words are case-insensitive, but references to objects (their names) are case-sensitive: it does not matter to put <code>From</code> or <code>fROm</code>, but a <code>Student</code> is not the same as a <code>student</code>. It is recommended to write sentences in lower case, in order to distinguish from the classes.</li> <li>After <code>from</code>, it appears the name of a class(es), not tables.</li> <li>Assigning aliases is highly recommended. We can use joins in similar way to SQL.</li> <li>Then the <code>where</code> can appear, with its SQL-like conditions.</li> <li>Text constants are enclosed in single quotes.</li> <li>We can query from collections that appear inside the objects (from the teacher's set of students, for instace).</li> <li>There is no <code>limit</code> operator.</li> <li><code>order by</code> is used similarly to SQL.</li> <li><code>group by</code> is allowed, and aggregate functions are: COUNT, AVG, SUM, MIN and MAX. </li> </ul>"},{"location":"en/UD3_Hibernate/5_HQL/#2-recovering-objects","title":"2. Recovering objects","text":"<p>From now, the samples are based on this schema, that you will find here Docencia</p> <p></p> <p>Tip</p> <p>Now is a good moment to try to do a reverse engineering approach to build your project from database.</p>"},{"location":"en/UD3_Hibernate/5_HQL/#3-queries","title":"3. Queries","text":""},{"location":"en/UD3_Hibernate/5_HQL/#31-getting-simple-objects","title":"3.1. Getting simple objects","text":"<p>These queries are the ones that we want to retrieve an object or collection of these from the database (one or more rows, in comparison with ResultSet). Each result is a single object from a table in the database. They will be characterized because the Select word may not appear or simply indicate the alias of the class we have. Let's see the examples. </p> <p>The following example shows all students:</p> Java<pre><code>// complete and polite\nQuery&lt;Alumno&gt; q=laSesion.createQuery(\"Select a from Alumno a\");\n\n// OR\n\n// in a quick way\nQuery&lt;Alumno&gt; q=laSesion.createQuery(\"from Alumno\");\n\n// quickest (without type)\nQuery q=laSesion.createQuery(\"from Alumno\");\n\nList&lt;Student&gt; losAlumnos=q.list();\n\nfor (Alumno alumno : losAlumnos) {\n            System.out.println(alumno);\n        }\n</code></pre> <p>If we want to filter or to search for any student, we need to use <code>where</code> clause, as a normal SQL query. Expressions can be:</p> <p></p> <p>When the <code>where</code> filter only one object, we could store it in a List, ant then access it, but is better to get the object directly, as follows:</p> Java<pre><code>Query&lt;Alumno&gt; q = laSesion.createQuery(\"Select a from Alumno a where a.idAlumno=1\");\nAlumno alumno = q.uniqueResult();\nSystem.out.println(alumno);\n</code></pre> <p>notice that we create our query with diamond operator, saying that it will return a student. Then, the query return obvously the student. The alternative is casting the returned object of <code>uniqueResult</code>:</p> Java<pre><code>Query q = laSesion.createQuery(\"Select a from Alumno a where a.idAlumno=1\");\nAlumno alumno = (Alumno)q.uniqueResult();\nSystem.out.println(alumno);\n</code></pre> <p>Careful</p> <p>Be careful when retrieving a unique object and the query returns several. Java<pre><code>Query q=laSesion.createQuery(\"Select a from Student a where a.age=24\");\nAlumno a=(Student) q.uniqueResult();\n// org.hibernate.NonUniqueResultException: query did not return a unique result: 2\n</code></pre></p> <p>When we have lots of results, it is still not convenient to recover them all at once, but to access them by 10 by 10 or similar, just like the search pages of Google or Amazon. We can achieve this by launching smaller queries repeatedly, applying to the query:</p> <ul> <li><code>Q.setFirstResult(int start)</code> \u2192 indicates the first object (row) to return.</li> <li><code>Q.setMaxResult(int howMany)</code> \u2192 indicates how many rows it will return.</li> </ul> <p>With an appropriate designed algorithm, we can perform a loop, shifting the start in each iteration, incrementing it by the number of rows retrieved in the previous iteration. It would involve a lot of small queries versus one big one.</p>"},{"location":"en/UD3_Hibernate/5_HQL/#32-getting-composite-objects","title":"3.2. Getting composite objects","text":"<p>If we need to get more (or less) data than an entire object, we must do it in the <code>select</code> part of the clause, but when we get the data we can't store it in an Object. For this reason, and using the polymorphism property of Java, we get the results in a generic array of objects. Therefore, we must be very careful with the type of each cell, as well as the size of said array, since it will be strongly linked to the query itself. Let's look at the following query: Display name and age of students:</p> Java<pre><code>Query q = laSesion.createQuery(\"Select a.nombre,a.edad from Alumno a\");\n\nList&lt;Object[]&gt; result = q.list();\n\nfor (Object[] objects : result) {\n  System.out.print(\"Alumno: \");\n  for (int i = 0; i &lt; objects.length; i++) {\n    System.out.print(objects[i] + \" \");\n  }\n  System.out.println();\n}\n</code></pre> <p>Notice than if you only want to print the information, no extra work is needed, due to (almost) all objects can be cast to String. If you want to use in another way, be very careful to convert to the accurate data type.</p> <p>Collections</p> <p>We are going to check the name of the students and how many exams they have taken. That information is in the Exam Set, so we'll need to manipulate that collection:</p> Java<pre><code>Query q = laSesion.createQuery(\"Select a.nombre,size(a.examens) from Alumno a\");\nList&lt;Object[]&gt; result = q.list();\n\nfor (Object[] alu : result) {\n  System.out.println(\"Alumno: \" + alu[0] + \" has done \" + alu[1] + \" exams.\");\n}\n</code></pre> <p>As you can see, we have applied the <code>size()</code> function to the collection to see its size. We can therefore apply:</p> <ul> <li><code>size(collection)</code> \u2192 retrieve the size of the collection.</li> <li><code>collection is empty</code> | <code>collection is not empty</code> \u2192 to determine if it is empty. It is equivalent to comparing the size with 0</li> <li>Operators <code>in</code>, <code>all</code> can be combined using the operator <code>elements(collection)</code></li> </ul> <p>As an advanced query, you can use <code>exists</code> and <code>not exists</code> in your queries.</p>"},{"location":"en/UD3_Hibernate/5_HQL/#4-parameters-and-namedqueries","title":"4. Parameters and NamedQueries","text":"<p>Normally most queries will need some parameters, usually for object filtering in the where clause. The benefits of parameterizing queries to avoid SQL injection or similar problems were already discussed in previous unit.</p> <p>The management of parameters is carried out in the same way as with prepared statements (<code>preparedStatements</code>), and can be done through positional or nominal parameters. Let's go to see some examples:</p>"},{"location":"en/UD3_Hibernate/5_HQL/#41-positional-parameters","title":"4.1. Positional parameters","text":"<p>We must add placeholders inside our query, but instead of <code>?</code> we add a number after the question mark. Then we must set the parameter according to the placeholder number we have set before, as follows:</p> Java<pre><code>Query&lt;Alumno&gt; q = laSesion.createQuery(\"Select a from Alumno a where a.edad=?1\");\nq.setParameter(1, 24);\nList&lt;Alumno&gt; losAlumnos = q.list();\n\nfor (Alumno alumno : losAlumnos) {\n  System.out.println(alumno);\n}\n</code></pre> <p>Tip</p> <p>Notice than The <code>setParameter</code> method is overloaded to set every kind of data type.</p>"},{"location":"en/UD3_Hibernate/5_HQL/#42-named-parameters","title":"4.2. Named parameters","text":"<p>The positions are fine, but if we can indicate the parameters in a nominal way, it will be a much readable program. The parameters are indicated with <code>:parameterName</code> and will be assigned with method <code>setParameter(parameterName,value)</code>, indicating the name of the parameter (without the colon):</p>"},{"location":"en/UD3_Hibernate/5_HQL/#43-named-queries","title":"4.3. Named queries","text":"<p>We can write queries in our methods as we need them. However, it is a good practice to create the most important queries or that we have forecast that they will be the most used together with the same class, through the mechanism that is presented below. In this section we create and label our queries, inside a collection of queries, and then we can call it. Is like we create a queries library. </p> <p>Outside the class definition, a <code>@NamedQueries</code> collection will be created, which will contain an array (indicated by braces) of <code>@NamedQuery</code> elements, each of them with a name and a query definition.</p> <p>To invoke them, instead of creating a <code>Query</code> object, we will create it through a <code>NamedQuery</code>, indicating its name, and assigning parameters, if any.</p> <p>In Alumno class:</p> Java<pre><code>@Entity\n@Table(name = \"Alumno\", catalog = \"DocenciaConsultas\")\n@NamedQueries({\n    @NamedQuery(name=\"Repetidores\",\n            query=\"select a from Student a where a.repeater=true \"),\n    @NamedQuery(name=\"AlumnosEntre\",\n            query=\"select a from Student a where a.age between :min and :max\"),\n    @NamedQuery(name=\"AlumnosDescAge\",\n            query=\"select a from Student a order by a.age desc\")\n})\npublic class Alumno implements java.io.Serializable {\n    static final long serialVersionUID=13L;\n  ...\n</code></pre> <p>Whern we want to use it, instead of create a <code>Query</code> we must create a <code>NamedQuery</code>, as follows:</p> Java<pre><code>Query&lt;Alumno&gt; q = laSesion.createNamedQuery(\"Repetidores\", Alumno.class);\nSystem.out.println(\"Alumnos repetidores: \");\nList&lt;Alumno&gt; losAlumnos = q.list();\n\nq = laSesion.createNamedQuery(\"AlumnosEntre\", Alumno.class);\nq.setParameter(\"min\", 23);\nq.setParameter(\"max\", 28);\n\nq = laSesion.createNamedQuery(\"AlumnosDescAge\", Alumno.class);\nSystem.out.println(\"Alumnos de mayor a menor: \");\n</code></pre>"},{"location":"en/UD3_Hibernate/5_HQL/#5-crud","title":"5. CRUD","text":"<p>Finally, we are going to analyze the rest of the CRUD operations. It should be noted that these operations can be performed directly on the objects, which is why they are explained as complementary rather than main. </p>"},{"location":"en/UD3_Hibernate/5_HQL/#51-create-insert","title":"5.1. Create (insert)","text":"<p>If we want to insert a new object in the database, is very easy, as we can remember in first sections of this unit.</p> <p>Java<pre><code>Alumno a=new Alumno();\na.setApellidos(\"Hamilton\");\na.setNombre(\"Lewis\");\na.setEdad(42);\na.setRepetidor(false);\n\nlaSesion.persist(a);\n</code></pre> Simply we create a new object, set its values, via setters or all argument's constructor, and finally store in the database with <code>persist</code> method. You can use <code>save</code> or <code>saveOrUpdate</code> indistinctly. You can see some differences between them here. Both of them fires a <code>insert sql</code> statement.</p> <p>In the same way that SQL, we could insert into a table with the result of a query, as follows:</p> SQL<pre><code>insert into class(properties) select_hql;\n</code></pre>"},{"location":"en/UD3_Hibernate/5_HQL/#52-update","title":"5.2. Update","text":"<p>In order to change the value of one or more object properties, we could load the object from database, change values via getters methods, and the save the changes:</p> Java<pre><code>Alumno a=laSesion.get(Alumno.class, 7L);\na.setEdad(44);\na.setRepetidor(true);\n\nlaSesion.update(a);\nSystem.out.println(a);\n</code></pre> <p>If we want to set a massive update, who affect several records in the database, we could use in the same way to SQL:</p> Java<pre><code>Query q=laSesion.createQuery(\"Update from Alumno a set a.edad=a.edad+1 where a.repetidor=true\");\nint howMany=q.executeUpdate();\n\nSystem.out.println(howMany + \" alumnos actualizados\");\n</code></pre>"},{"location":"en/UD3_Hibernate/5_HQL/#53-deletion","title":"5.3. Deletion","text":"<p>As previous sections, we could delete a single object or a set of records who satisfy a condition. In case of a single object, we need to load it, and then delete it:</p> Java<pre><code>Alumno a=laSesion.get(Alumno.class, 7L);\nlaSesion.delete(a);\n\nSystem.out.println(a);\n</code></pre> <p>Notice that the object remains in memory or until the end of the method, but when the session is commited, the object will be <code>detached</code>. The <code>detached</code> status means that this object is out of any kind of track. We do not have possibility to save or update again this object.</p> <p>To do a massive deletion, in the same way that SQL:</p> Java<pre><code>Query q=laSesion.createQuery(\"delete from Alumno a where a.repetidor=true\");\nint howMany=q.executeUpdate();\n\nSystem.out.println(howMany + \" alumnos borrados\");\n</code></pre> <p>Tip</p> <p>Remember this general tips:</p> <ul> <li>These statements may contain parameters (in sentences that contains <code>where</code> clause).</li> <li>The where is optional, but it will delete or update everything if missing.</li> <li>These queries are all executed using <code>executeUpdate()</code>, because they change the database status, and it will return an integer with the number of affected rows.</li> </ul> <p>You have to pay attention to the deletions, since depending on how we have defined the relationships (deletions in cascade, leaving orphan rows, etc.) they may or may not occur, and throw <code>java.sql.SQLIntegrityConstraintViolationException</code>.</p> <p>As a final comment in this section, remember what was said previously: in the manipulation of objects (deletions, modifications, etc.) we have enough tools to do it without HQL queries. These queries are more suitable for processing large volumes of information without uploading said information to our program to have it processed.</p>"},{"location":"en/UD3_Hibernate/5_HQL/#6-appendix-objects-status","title":"6. Appendix, Objects status","text":"<p>As we have said along this unit, objects are loaded and tracked by the session manager. Each object could have a state inside the session, and it is interesting to now all possibilities. In this picture, you can see all different status, and the method to change the object status.</p> <p></p> <ul> <li>transient \u2192 The object has identity (exist in memory), but it has not a persistent identity, or primary key.</li> <li>persistent \u2192 The object has been marked to be saved (persisted), and the memory identity is related to the database identity. When we load an object from the database this is the initial status.</li> <li>detached \u2192 The object have been persisted recently, but this context is closed, with <code>detach()</code> method. Operations when is detached will not be reflected on the database.</li> <li>removed \u2192 The object has been marked to be deleted (but is not effected yet). When the session is closed it will be removed effectively, but we can reload it and set into a persistent context.</li> </ul> <p>You can get more information here.</p>"},{"location":"en/UD4_BDOO/1_Introduction/","title":"1. Introduction to OO Databases","text":""},{"location":"en/UD4_BDOO/1_Introduction/#1-introduction","title":"1. Introduction","text":"<p>The Relational Databases arise from the relational model as a system that faithfully represents reality, with great solidity due to the underlying relational logic. Said model represents the static perspective of the modeling of the application, and in it all the data is broken down to atomic levels, since as we remember, neither multivalued nor composite values are allowed.</p> <p>This model has suffered from the object-relational gap, in which programming languages evolved structures by adopting the object-oriented methodology. This causes us to design the database on the one hand, following the relational model, and we also need to design the application classes on the other hand. Said designs, which do not usually coincide, can be fitted with the ORM tools studied in the previous unit to mitigate the object-relational mismatch.</p> <p>From this gap arises the need to add a more object-oriented design within the database itself. If we analyze an object-oriented scheme and try to apply normalization theory, we will find that the objects are decomposed into several entities, which causes many tables to appear.</p> <p>This high number of tables causes, as a consequence, an increase in the references between them, considerably increasing the relationships between them and, therefore, a greater number of restrictions that you control (FOREIGN KEY), which means an increase in the number of checks to be carried out by the DBMS.</p> <p>Thus, in the OO BD (Object-Oriented Database) it allows a definition of complex data types compared to the simple ones that the RDBMS incorporates, allowing the definition of structured and even multivalued types. With all this, the OO BD should simply allow design through objects (similar to the UML) indicating the objects that participate, indicating their attributes and methods, and the relationships that affect them, and obviously, inheritances.</p> <p>These OO DB's have not yet taken off, and some solutions that commercial solutions implement is to provide the relational database system with the semantic capabilities of object orientation, thus appearing the BDOR (Object-Relational Databases).</p>"},{"location":"en/UD4_BDOO/1_Introduction/#2-object-relational-dbs","title":"2. Object Relational DB's","text":"<p>The ANSI SQL1999 standard (SQL99 and later SQL2003), as a continuation of SQL92 in which the characteristics of the relational model are adapted, allows adding object-oriented characteristics to the Relational Databases. This allows robust DBMS to have adopted and implemented those features required. Among these features are:</p> <ul> <li>Definition of new types of data by the user.</li> <li>Adaptation to accommodate large binary data types such as images and documents.</li> <li>Ability to store compound elements as arrays.</li> <li>Directly store references to other tables.</li> <li>Defining objects and inheritance.</li> <li>Definition of functions that handle the previously defined structures</li> </ul>"},{"location":"en/UD4_BDOO/2_ORDB/","title":"2. Objet-Relational Databases","text":""},{"location":"en/UD4_BDOO/2_ORDB/#1-or-databases","title":"1. OR Databases","text":"<p>In this section we will work with PostgreSQL database. As the open source relational object database management system, which has had the greatest impact, being a direct rival to the great Oracle.</p> <p>We will focus on the novelties that Postgres offers versus MySQL, as an extension of first year concepts.</p> <p>Important</p> <p>It will be interesting to:</p> <ul> <li>Install your own PostgreSQL server. It's recommended to use it via Docker container</li> <li>Install a client to show your database. We recommend DBeaver.</li> </ul> <p>We will work with this well know sample:</p> <p></p>"},{"location":"en/UD4_BDOO/2_ORDB/#2-defining-types","title":"2. Defining types","text":"<p>In PostgreSQL the usual types found in modern DBMS exists. In addition, special types stand out for storing Internet addresses (Network Address Types), XML and JSON for saving and processing said formats, own types and collections. With this, we can look at the great advances of PostgreSQL, which in a daring we could consider as Object-Relational and Documentary</p>"},{"location":"en/UD4_BDOO/2_ORDB/#21-enumeration","title":"2.1. Enumeration","text":"<p>Enumerated types are types that allow only specific values, usually also known as domains. In PostgreSQL we can create it in the following way:</p> SQL<pre><code>CREATE TYPE enum_name AS ENUM\n    ( [ 'valor' [, ... ] ] );\n</code></pre> <p>for instance:</p> SQL<pre><code>create type basic_colors as enum('#FF0000','#00FF00','#0000FF');\ncreate type street_kind as enum ('Calle','Avenida','Partida');\n</code></pre> <p>This way of defining this type will avoid the value checks (CHECK clauses) existing in some relational DBMS.</p>"},{"location":"en/UD4_BDOO/2_ORDB/#22-structured-types","title":"2.2. Structured types","text":"<p>Structured types are the precursors of the objects themselves. If we remember, in structured programming, from the basic types, we could create data structures:</p> <ul> <li>Where all the elements are the same (vectors, arrays and collections)</li> <li>Where their elements could be of different types. These structures evolved into current objects by adding behavior and other features to them.</li> </ul> <p>In the relational model, since we must respect the atomicity of the data, we could not generate such structures. In Postgres we can create these new structured data types with the following syntax, much like creating a table:</p> SQL<pre><code>CREATE TYPE type_name AS(\n  attribute_name data_type\n  [, ... ]-- one or more\n);\n</code></pre> <p>for instance:</p> SQL<pre><code>create type Punto as(\n    x integer,\n    Y integer \n);\n</code></pre> <p>or, and using previous enumeration:</p> SQL<pre><code>create type Address as(\n    Type street_kind,\n    street varchar,\n    number int\n);\n</code></pre> <p>and finally create the following table:</p> SQL<pre><code>create table person(\n    idPerson serial primary key,\n    name varchar,\n    direction Address\n);\n\ninsert into person(name) values ('joange');\ninsert into person(name,address) values('joange',null);\ninsert into person(name,address) values('joange',('Street','Calvary',1));\n\nselect direction from person;\nselect (address).street from person;\n</code></pre> <p>Note</p> <ul> <li>No NOT NULL, DEFAULT or CHECK restrictions can be applied to the fields that belong to the created types.</li> <li>Typing makes sense on data that does not exist by itself, that needs to be embedded in other structures or tables.</li> <li>When it is used inside a table and manipulating the insertion, it will be done in a block, between parentheses, since it determines a structure</li> <li>To select a subtype, we must enclose the general type in parentheses, otherwise Postgres confuses it with a table and generates an error</li> </ul>"},{"location":"en/UD4_BDOO/2_ORDB/#3-classes-really-tables","title":"3. Classes (really tables)","text":"<p>We are going to create a <code>Figura</code> class, which will be the starting point of an inheritance of the model presented at the beginning of the unit. Let's look at what it incorporates regarding the implementations of the relational model. <code>Figura</code> contains a primary key, and will contain a <code>Punto</code> to locate it in the plane. In addition, it contains a collection of colors, to make possible gradients, saved as an array. Saving collections is also an added capability that does not support the relational model, given the absence of multivalued values.</p> <p>A class is created with the same syntax as a table, since, for practical purposes, from a structural point of view it is the same. Subsequently, inheritance does distinguish that one table \"inherits\" from another</p> SQL<pre><code>create table Figura (\n    fID serial primary key, -- identifier\n    Punto position,  -- position he occupies\n    color TEXT[ ]    -- color(s) of the figure\n);\n</code></pre> <p>To insert new records, keep in mind that:</p> <ul> <li>Elements of type <code>Punto</code> must be stored using a constructor that creates an abstract <code>row</code>, called <code>ROW</code> or the parentheses.</li> <li>For arrays, we also need a constructor called <code>ARRAY</code>, with a list of elements.</li> </ul> SQL<pre><code>insert into Figura(position,color)\n  values(ROW(0,0),ARRAY['#FFFFFF','#00CC00']);\n</code></pre> <p>From there, we'll create new classes to represent the circles, squares, and rectangles from <code>Figura</code> using inheritance. The syntax is as follows:</p> SQL<pre><code>create table sub_table(\n -- definition of table attributes\n) inherits (super_table);\n</code></pre> <p>As we can see we simply add inherits to create the inheritance relationship. For the design we had previously:</p> SQL<pre><code>create table Rectangle(\n    height int,\n    width int \n) inherits (Figure);\n\ncreate table Quadrat(\n    side int\n) inherits (Figure);\n\ncreate table Cercle(\n    radio int\n) inherits (Figure);\n</code></pre> <p>We insert some rows, noting that we have to include the superclass attributes as well.</p> SQL<pre><code>insert into Quadrat(position,color,side) values (ROW(10,10),ARRAY['#00BBCC','#BBCC00'],40);\ninsert into Quadrat(position,color,side) values(ROW(10,fifteen),ARRAY['#AA6633','#CCFF00'],27);\ninsert into Cercle(position,color,radius) values(ROW(30,25),ARRAY['#BBCC','#CCCC00'],20);\ninsert into Cercle(position,color,radius) values(ROW(10,-10),ARRAY['#00BBCC','#CCCC00'],20);\ninsert into Rectangle(position,color,height,width) values(ROW(10,5),ARRAY['#00BBCC','#CCCC00'],20,50);\ninsert into Rectangle(position,color,height,width) values(ROW(30,-10),ARRAY['#00BBCC','#CCCC00'],20,50);\n</code></pre> <p>If we run several <code>Select * from</code>, qe get on Dbeaver:</p> <p></p> <p></p> <p></p> <p></p> <p>As it is logical, it is possible to think that when select data from the general table (<code>Select * from Figura</code>) all the elements of the subclasses will appear. If we wanted to select only those that are Figura, we could do it with (<code>Select * from ONLY Figura</code>).</p> <p>We are going to complete the example by creating a drawing with all the figures we have stored. We will store the drawing in a new class that contains the identification of the drawing, and we will save a collection with the identifiers of the figures that make up the drawing.</p> SQL<pre><code>create table Dibujo(\n    drawingid serial primary key,\n    items int[]\n);\n\ninsert into Drawing (elements) values(ARRAY[2,4,5,6]);\ninsert into Drawing (elements) values(ARRAY(select fid from Figura));\n</code></pre> <p>Comment that the selection of the Figura identifiers can be direct, or by selecting those that we want, through an embedded query within the ARRAY constructor. This can be done when the select returns a single column.</p> <p>We obtain the drawings that we have, this collection of figures is shown. But if we want to deconstruct the vector, in order to access each of the figures there is, we can do it with the <code>unnest</code> function.</p>"},{"location":"en/UD4_BDOO/3_OODB/","title":"3. Object-Oriented Databases","text":""},{"location":"en/UD4_BDOO/3_OODB/#1-oo-databases-objectdb","title":"1. OO Databases. ObjectDB","text":"<p>In this section, as DBMS, ObjectDB has been chosen, since it is very versatile, free and even allows it to be embedded within our Java projects, which allows great simplicity for the development of small applications, due to the elimination of a server</p>"},{"location":"en/UD4_BDOO/3_OODB/#2-installation","title":"2. Installation","text":"<p>ObjectDB does not require installation as such, since all its code is integrated into an API for accessing the database packaged in a jar file. From the official website we can download the ObjectDB Development Kit. At the time of writing this book, the version is 2.9.0. This kit contains, among others:</p> <ul> <li>Dependencies for Java projects</li> <li>Utilities for viewing and consulting the database</li> <li>Server for distributed applications</li> <li>Documentation</li> </ul> <p>Once unzipped, we will only need the Java virtual machine installed on our system to run all the elements. To use ObjectDB in our project we must add the <code>objectdb.jar</code> file to our project dependencies or do it using the maven or gradle dependency manager.</p> <p>At this moment we can connect to the database, the centralization of the connection to the database is done through an instance of an <code>EntityManagerFactory</code> object, from which we can obtain several instances of an <code>EntityManager</code>.</p> <p>From the <code>EntityManager</code> we will be able to carry out the typical CRUD operations, taking into account that whenever there are modifications in it. We must carry out the operation within a transaction to avoid inconsistent situations in it. Here we see a possible class with establishing the connection and getting an <code>EntityManager</code>. This code can be seen in the attached file <code>ConexionOBD.java</code>. Notice that import are from <code>javax.persistence</code>:</p> Java<pre><code>import javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.Persistence;\nimport javax.persistence.PersistenceException;\n\npublic class ConexionOBD {\n\n    private EntityManagerFactory emf;\n    private EntityManager em;\n    private String nombreBD;\n\n    /**\n     * Crea una objeto a la BBDD indicada\n     */\n    public ConexionOBD(String nombre){\n        this.emf=null;\n        this.em=null;\n        this.nombreBD=nombre;\n    }\n\n    /**\n     * M\u00e9todo que realiza la conexi\u00f3n\n     */\n    private void conectar(){  \n        emf = Persistence.createEntityManagerFactory(nombreBD);\n        try{\n            em = emf.createEntityManager();\n        }\n        catch(PersistenceException ex){\n            System.out.println(ex.getMessage());\n        }\n    }\n\n    /**\n     * Metodo que desconecta\n     */\n    public void desconectar(){  \n        this.em.close();\n        this.emf.close();\n        this.em=null;\n        this.emf=null;\n    }\n\n    /**\n     * \n     * @return El EntityManager sobre el que operar\n     */\n    public EntityManager getEM(){\n        if (em==null)\n            conectar();\n        return em;\n    }\n}\n</code></pre>"},{"location":"en/UD4_BDOO/3_OODB/#3-persisting-classes","title":"3. Persisting classes","text":"<p>To persist an object, we will need (regarding Hibernate):</p> <ul> <li>Annotate your class and mark it as <code>@Entity</code></li> <li>Define a field as <code>@Id</code> and optionally auto-increment with <code>@GeneratedValue</code>.</li> <li>The rest of the entity's attributes, by default, are automatically persisted without any type of annotation. In case of not wanting to persist any, we can indicate it with <code>@Transient</code>.</li> </ul> Java<pre><code>@Entity\npublic classes Alumno{ \n  @Id @GeneratedValue\n  private Long idAlumno;\n  private String Name;\n}\n</code></pre> <p>To store a Alumno, it will suffice to create an Alumno and persist it in the database, as seen below, assuming the object with type conexionDB seen in the attached file:</p> Java<pre><code>ConexionOBD con= new ConexionOBD(\"Alumnos.odb\");\nEntityManager em=con.getEM();\nem.getTransaction().begin();\nAlumno alu=new Alumno(\"Antonio Ramos\");\nem.persist(alu);\nem.getTransaction().commit();\n</code></pre> <p>** Embedded classes or Components**</p> <p>In Java there are sometimes classes that do not have their own existence, unless they exist inside another class such as an Address class. It doesn't make sense to create an ad-hoc Address object, instead it does make sense to create it so that an Address exists, for example inside a Student.</p> <p>For these (weak) cases that exist embedded within other classes, we must declare them as embeddable using the <code>@Embeddable</code> annotation and mark them as embedded (<code>@Embedded</code>) within the class that they exist.</p> Java<pre><code>@Embeddable\npublic class Direccion{\n    ...\n}\n\n@Entity\npublic classes Alumno{\n  ...\n  @Embedded\n  private Direccion direction;\n}\n\n// in main\nAlumno alu= new Alumno(\"Joan Gerard\");\nDireccion d= new Direccion(\"calvary street\");\nalu.setDireccion(d);\nem.persist(alu);\n</code></pre> <p>An <code>Alumno</code> entity will be stored in the database, but the <code>Direccion</code> does not exist as an object itself.</p>"},{"location":"en/UD4_BDOO/3_OODB/#4-relationships","title":"4. Relationships","text":""},{"location":"en/UD4_BDOO/3_OODB/#41-one-to-one-relation","title":"4.1. One-to-one relation","text":"<p>The simplest relation is one-to-one, in which one object contains another object. We will mark it as we already did in Hibernate with the <code>@OneToOne</code> modifier indicating that the saving is cascaded (<code>cascade=CascadeType.PERSIST</code>)</p> <p>From now on, when you save an instance of an object, your own instance of the related object will be saved and linked. The linked object will have existence in itself (if it is marked as <code>@Entity</code>). A basic example that a class has a single <code>Tutor</code>:</p> <p>Based on an example that a <code>Clase</code> (of an institute) has a <code>Tutor</code> associated, the example will be the following:</p> Java<pre><code>@Entity\npublic classes Professor{\n  ...\n}\n\n@Entity\npublic class Clase{\n  ...\n  @OneToOne(cascade=CascadeType.PERSIST)\n  private Professor tutor;\n}\n\n\nProfessor p=new Professor(\"Pepe\");\nClase c= new Clase(\"2DAM\");\nc.setTutor(p);\num.persist(c); // when saving the class the tutor is saved\n</code></pre> <p>Attention</p> <p>Remember that, in the same way as hibernate, this relation is unidirectional, but can be done bidirectional</p>"},{"location":"en/UD4_BDOO/3_OODB/#42-one-to-many-relation","title":"4.2. One-to-many relation","text":"<p>We are now going to refer to a classic relationship in which a <code>Profesor</code> is the tutor of several <code>Alumno</code>. These relationships can be one-way or two-way. In this example we will see it bidirectional, in such a way that given a student we can know who is his tutor and given a teacher we can obtain the students he tutors.</p> Java<pre><code>@Entity\npublic class Alumno{\n  ...\n  @ManyToOne(cascade=CascadeType.PERSIST)\n  private Profesor tutor;\n\n}\n\n@Entity\npublic class Profesor{\n  ...\n  @OneToMany(cascade=CascadeType.PERSIST,\n             fetch=FetchType.EAGER)\n  private List&lt;Alumno&gt; theStudents;\n}\n</code></pre> <p>Attention</p> <p>Remember that, in the same way as hibernate, loading the collections could be done immediately, with an <code>EAGER</code> way or when is needed in <code>LAZY</code> mode.</p>"},{"location":"en/UD4_BDOO/3_OODB/#43-many-to-many","title":"4.3. Many-to-many","text":"<p>In many-to-many relationships we can approach them in various ways. Let us give the example of teaching between Profesor and Alumno. If we simply want to indicate who teaches whom, it would sufficient to store a collection of teachers in each student (the teachers who teach that student), and symmetrically, in each teacher a collection of students (the students to whom they teach). class. In this case, it would be bidirectional, since from one class we can navigate to the other, thus remaining:</p> Java<pre><code>@Entity\npublic classes Alumno{\n  ...\n  @ManyToMany(cascade=CascadeType.PERSIST, fetch=FetchType.LAZY)\n  private Set&lt;Profesor&gt; teachers=new Hash Set&lt;&gt;();\n}\n\n@Entity\npublic classes Profesor{\n  ...\n  @ManyToMany(cascade=CascadeType.PERSIST, fetch=FetchType.LAZY)\n  private Set&lt;Alumno&gt; students=new Hash Set&lt;&gt;();;\n}\n</code></pre> <p>Attention</p> <p>If we need to save any information within said relationship, such as the grade that has been received, the student, or the incidents posted, etc. then we must create a new class, which will incorporate the attributes of the relationship, and make one-to-may relationships from each entity (Student/Teacher) to the new entity (Teaching). This assumption is the famous N-M relations generate a table with the attributes they possess of the relational model.</p>"},{"location":"en/UD4_BDOO/3_OODB/#5-queries","title":"5. Queries","text":"<p>We are going to review how we can load the data that we have previously saved in the database. Suppose we have a Student class, mapped with an entity and with an identifier (idStudent). The easiest way to load a Student, knowing its id, is the <code>find(class,id)</code> method, as we did in Hibernate:</p> Java<pre><code>Student a=em.find(Student.classes,2);\n</code></pre> <p>The rest of the loads must be carried out through queries, in a JPQL language (Java Persistence Query Language), again similar to Hibernate's HQL.</p> <p>There are two classes: <code>Query</code> and <code>TypedQuery</code> (the second one inherits from the first one), which are usually used in the first case when we don't know the result of the query, and in the second when we know the result. </p> <p>The first one is polymorphic, so it will dynamically link the results, and the second one verifies the result with the current class. The official documentation recommends the use of the second one, <code>TypedQuery</code> for queries and <code>Query</code> for updates and deletions.</p> Java<pre><code>// creation of Query (q) or TypedQuery (tq)\n\n// unique result\n\n//return a generic object, and we must cast it.\nObject q.getSingleResult();   \n\n// return an specified Object\nT tq.getSingleResult();\n\n// a result set\n\n//return a List of generic object, and we must cast it.\nList q.getResultList(); \n\n// return a list of specified Object\nList&lt;T&gt; tq.getResultList();\n\n// to update or delete\nq.executeUpdate();\n</code></pre> <p>Regarding same as hibernate, we can ask the database as follows:</p> Java<pre><code>TypedQuery&lt;Alumno&gt; tq=em.createQuery(\"Select a from Alumno a where a.ampa=true\", Alumno.class);\nList&lt;Alumno&gt; alumnosAmpa=tq.getResultList();\n</code></pre> <p>or with parameters:</p> Java<pre><code>TypedQuery&lt;Alumno&gt; tq=em.createQuery(\"Select a from Alumno a where a.ampa= :ampa\", Alumno.class);\ntq.setParameter(\"ampa\", true);\nList&lt;Alumno&gt; alumnosAmpa=tq.getResultList();\n</code></pre> <p>or create a specific named queries:</p> Java<pre><code>// on the class\n@NamedQueries({\n    @NamedQuery(query = \"Select a from Alumno a where a.nombre = :name\", name = \"find alu by name\"),\n    @NamedQuery(query = \"Select a from Alumno a\", name = \"get all alu\")\n})\n\n// on main or whatever\nTypedQuery&lt;Alumno&gt; tq=em.createNamedQuery(\"get all alu\",Alumno.class);\nList&lt;Alumno&gt; alumnosAmpa=tq.getResultList();\n</code></pre>"},{"location":"en/UD4_BDOO/3_OODB/#51-delete-and-update","title":"5.1. Delete and Update","text":"<p>Finally, we are going to review the last CRUD operations that we have left. The updates are totally transparent to the user, since any modification that is made within the context of a transaction will be automatically saved when closing it with a <code>commit()</code>. Alternatively, update Queries can be performed</p> <p>For deletes, if the object has been retrieved from the database, and is therefore in the current transaction, it can be removed with <code>em.remove(object)</code>. It will be deleted from the database when the commit is made.</p>"},{"location":"en/UD5_Spring/1_Data_Access_Services/","title":"1. Data Access Services","text":"Version Data Notes Version 1.0 December 2022 Initial version Version 2.0 September 2023 Haetoas Version 3.0 October 2024 Translations <p>\u00a9 Joan Gerard Camarena Estruch</p> <ul> <li>These materials are based on previous years notes created by Joan Gerard Camarena and Jose Alfredo Murcia.</li> <li>Special thanks to Loren Diaz de Haro to share his material and code samples.</li> </ul>"},{"location":"en/UD5_Spring/1_Data_Access_Services/#1-introduction-data-access-services","title":"1. Introduction. Data Access Services","text":"<p>A servlet is an application that runs on an server, prepared to respond to http requests. Later we have JSP (Java Server Pages), which allow combining HTML/XML elements with Java code fragments to generate content dynamically. We must launch an application server and add the application to run it and serve it as another page.</p> <p>We can use Servlets to write a web application, but there are many intrinsic details to control: validation, REST, request / response body for JSON, form binding, etc. This implies that much of our code is devoted to controlling the lower layers of communication.</p> <p>With the Spring framework, it really uses servlets, but it frees the programmer from such a heavy task, managing it automatically. This allows the user to focus on the logic of the application, without having to manage the lower levels of communications. In addition, Spring Boot is defined as a Spring accelerator, allowing us to indicate a series of conventions (behaviors) that perform heavy file configuration tasks for us. Finally, Spring Boot incorporates an embedded web server (usually <code>Tomcat</code>)</p> <p>The term framework or if we try to force its translation into Spanish Marco de trabajo provides us with a set of rules and tools designed to increase the speed of application development</p>"},{"location":"en/UD5_Spring/1_Data_Access_Services/#2-mvc","title":"2. MVC","text":"<p>The Model View Controller (MVC) is an architecture for application development that separates data, interface, and control logic into layers.</p> <p></p> <p>The operation is as follows:</p> <ol> <li>The user is using the client application (usually a browser or client), and makes a request through the http protocol, also known as an HTTP_REQUEST. These requests are received by the controller module. The controller manages a list of operations or events that it can process, determined by its own protocol.</li> <li>In the case of a request that requests a query or modification of the data, we pass the parameters provided in the request to the model layer. This layer accesses the data, performing steps 3 and 4 through DBMS operations. The Model is now in a position to give an answer.</li> <li>Consult the database.</li> <li>Database query recovery.</li> <li>The model transfers the obtained result set to the view.</li> <li>The view is responsible for receiving the data and presenting or formatting it appropriately.</li> <li>The controller returns the presentation generated by the view (which will typically be dynamic HTML) to the client application, via the HTTP_RESPONSE request.</li> </ol>"},{"location":"en/UD5_Spring/1_Data_Access_Services/#3-rest","title":"3. REST","text":"<p>The REST (Representational State Transfer) model allows us to provide our server with a service to easily retrieve and manipulate data on the server. In this model, the part of the view is delegated to the client, leaving the controller and the model on the server. In this model, we will highlight among others:</p> <ul> <li>The protocol follows the stateless client/server model, just like http, a request will only respond according to the information received in the same request.</li> <li>Support of CRUD operations, through the equivalent http specifications: GET (query), POST (create), PUT (modify) and DELETE (delete)</li> <li>Arrangement of the HATEOAS model (Hypermedia As Engine Of The Application State). This principle allows hyperlinks as a resources to be included in responses.</li> </ul> <p>In MVC, and in a simplified way, it would be to remove the layer from the view and return the data processed by the model. Usually REST servers return data in JSON format</p>"},{"location":"en/UD5_Spring/2_Spring_SpringBoot/","title":"2. Introduction to Spring","text":""},{"location":"en/UD5_Spring/2_Spring_SpringBoot/#1-spring-and-spring-boot","title":"1. Spring and Spring Boot","text":"<p>The Spring Framework simplifies the development of Java applications, regardless of whether they are ordinary web applications or offline web applications. Its biggest advantages are a more simplified source code and less difficulty in adjustments. In order to offer the programmer these comforts, the framework is based on the following principles:</p> <ul> <li> <p>Dependency injection (DI): technique or design pattern used as one of the forms of inversion of control (IOC) to promote loose coupling. That is, when a class needs another class (dependency), instead of creating the object within the class itself, Spring supplies or injects it. This form of IOC follows the Hollywood principle (don't call us, we'll call you) in which the application takes control instead of the code, providing the following benefits:</p> <ul> <li>Provides modularity.</li> <li>Scalability of the application without the need to modify the classes.</li> <li>Avoid dependency between classes</li> </ul> </li> <li> <p>Simple development with POJOs (Plan Old Java Objects)</p> </li> <li>Minimize boilerplate code</li> <li>Simplifies data access thanks to ORM (Object Relational Mapping)</li> <li>Aspect Oriented Programming (AOP): Allows a much higher modularization to make a very clear separation of the different tasks that each class must perform in our application.</li> </ul>"},{"location":"en/UD5_Spring/2_Spring_SpringBoot/#11-main-spring-framework-modules","title":"1.1. Main Spring Framework modules","text":"<p>Thanks to its modular structure for the development of the most diverse applications in Java, Spring is the perfect choice, since you can freely choose which of the components you need to use for your applications and which not. In the standard architecture, the different modules are divided into six main categories:</p> <p></p> <ul> <li> <p>Core Container: The core container provides the basic modules:</p> <ul> <li>Core and Beans form the backbone of the framework, containing the dependency injection function and supporting POJO objects. We clarify that a Bean is a POJO, although it has some more features.</li> <li>Context inherits its features from the Beans module and can be complemented with functions for internalizing or loading resources. Additionally, it supports Java Enterprise features such as EJB and JMX (Java Management Extensions). Context-support makes it easy to integrate libraries from other vendors into Spring.</li> <li>Spring-expression contains the Spring Expression Language (SPeL), an extension of the Unified Expression Language of the JSP-2.1 (Java Server Pages) specification.</li> </ul> </li> <li> <p>AOP and instrumentation: To enable aspect-oriented programming, the Spring Framework contains the spring-aop module. The spring-instrument component provides support for the implementation of object loading and handling classes for use on some servers.</p> </li> <li>Messaging: To serve as the basis for message-based applications, the Spring Framework relies on some of the encryption functions from the Spring Integration project, such as Message, MessageChannel, or MessageHandler. This module has the name of spring-messaging.</li> <li> <p>Data Access/Integration: Modules in this category are designed to give Java applications the tools to interact with other applications, as well as control access to data:</p> <ul> <li>spring-jdbc provides an abstraction layer that defines the way a client accesses the database and saves the complicated coding typical of JDBC.</li> <li>spring-orm offers integration layers for accessing relational databases in popular ORM interfaces.</li> <li>spring-tx (supports programmatic transaction management for all classes and POJOs).</li> <li>spring-oxm (abstraction layer for mapping objects or XML).</li> <li>spring-jms, a module with features for message production and processing.</li> </ul> </li> <li> <p>Web: in this category are the specific modules for web applications: spring-web, spring-webmvc and spring-websocket. Additionally, this Java application has added typical web-oriented integration functions such as a multipart upload function or an HTTP client. The spring-webmvc module is also known as a web servlet and is the one that contains the Spring implementations for the execution of the model-view-controller (MVC) architecture pattern and REST web services.</p> </li> <li>Test: the spring-test module allows you to check the functionality of the components of your Java application. Thus, with the help of additional frameworks such as JUnit or TestNG, you can perform unit tests (focusing on a single component) as well as integration tests.</li> </ul>"},{"location":"en/UD5_Spring/2_Spring_SpringBoot/#2-spring-vs-spring-boot","title":"2. Spring vs Spring Boot","text":"<p>Spring Boot appeared a few years ago with the idea of complementing Spring, that is, adding to Spring, not with the idea of replacing it. As can be interpreted in the image below, Spring Boot really works with Spring below, but in an easier way.</p> <p></p> <p>We could define Spring Boot as an accelerator for the creation of Spring projects, which is mainly based on the concept of convention before configuration. Another way to define Spring Boot could be as a Spring project creation accelerator. Therefore, the purpose is to create Spring projects, but in a more agile way, through a series of conventions that prevail over configuration. Saving us from having to waste time making heavy configurations in files.</p> <p>It should be noted that Spring Boot is not considered a Framework as such, on the other hand, Spring does have the privilege of categorizing itself as such. With Spring Boot, we can do the same as with Spring. But in a faster way than if we develop exclusively with Spring only. But with both, we could have the same development, although the difference between the two would be the time invested.</p> <p></p> <p>To explain the differences between the two, it is essential to introduce the concept of configuration convention, which plays such an important role in the field of software engineering.</p>"},{"location":"en/UD5_Spring/2_Spring_SpringBoot/#21-what-is-the-configuration-convention","title":"2.1. What is the configuration convention?","text":"<p>This principle basically specifies/details a series of conventions (set of rules) that will be above the configuration unless otherwise specified. That is, they will be applied by default if we do not specify otherwise.</p> <p>An example of a convention before configuration could be when we create an MVC application with Spring, we have to carry out many configurations, including the port. On the other hand, if we create the application using Spring Boot, thanks to the configuration convention, the default port of the application when starting it will be 8080. But if we want to change it, we only have to modify a file and add a single instruction where we will detail the port, for example, 8888. In this way, we will carry out a more agile development, since we will avoid having to make configurations, except that we want to modify the configuration of some convention.</p>"},{"location":"en/UD5_Spring/2_Spring_SpringBoot/#3-requirements-and-installation","title":"3. Requirements and Installation","text":"<p>Spring works with many embedded technologies (below), so we advise having the following to make sure everything works for us. Requirements are:</p> <ul> <li>Java installed, it is advisable to have version 8, due to its stability. And that Spring doesn't support all some of the newer versions of Java.</li> <li>Apache Maven installed.</li> <li>A compatible IDE (in this case it will be Spring Tool Suite).</li> </ul> <p>Spring Tool Suite 4, which is the one provided to us from the Pivotal website (official page of the creators of maintaining Spring.). It can be downloaded from https://spring.io/tools.</p>"},{"location":"en/UD5_Spring/2_Spring_SpringBoot/#4-first-project-and-execution","title":"4. First project and execution","text":"<p>In order to create a Spring project, we can do it in two ways:</p> <ul> <li>Create a project from Spring Boot Initializer, the web tool provided by Pivotal here https://start.spring.io. This assistant generates a zip file with the structure of the maven project. We need to import this zip file in our IDE to start programming.</li> <li>Create the project from the IDE using the Command Line Tool (CLI), in our case the chosen IDE will be Spring Tool Suite 4. We do not need extra steps to start to program.</li> </ul>"},{"location":"en/UD5_Spring/2_Spring_SpringBoot/#41-initializr","title":"4.1. Initializr","text":"<p>We visit https://start.spring.io and fill the form:</p> <p></p> <p>In dependencies part, we should add the aspects of our program. Initially web app, but we could add Lombok, Thymeleaf, and other aspects</p> <p>Here you will find several screenshots with the process. From STS create a new project:</p> <p></p> <p>And select a Spring starter project:</p> <p></p> <p>Select a maven project, java version installed and write information about artifact version and so:</p> <p></p> <p>And finally select the dependencies. In our initial project, select Spring web.</p> <p></p> <p>And when the process finish you will find a project structure with a pom.xml configured.</p> <p></p> <p>and the structure:</p> <p></p>"},{"location":"en/UD5_Spring/2_Spring_SpringBoot/#42-first-run","title":"4.2. First run","text":"<p>Let's go to take a look what files have been created in our project. As you can see, only a class with a main function:</p> Java<pre><code>import org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class HelloSpringApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(HelloSpringApplication.class, args);\n    }\n\n}\n</code></pre> <p>It will <code>run</code> a <code>SpringApplication</code>, in the same way as running a <code>Thread</code>. This class bootstrap and launch the Spring application, with arguments, if exists.</p> <p>Tip</p> <p>Spring as a web app, does not interact with user, and it will wait and serve to many clients. For this reason it is not a good idea to do interactive programs with users</p> <p>To run our Spring app:</p> <p></p> <p>And it will appear in console a log similar to:</p> <p></p> <p>The first important thing you need to see is the port that tomcat server is listening to. By default is port 8080:</p> Bash<pre><code>... Tomcat started on port(s): 8080 (http) with context path ''\n</code></pre> <p>And when we stop our program:</p> <p></p> <p>Tip</p> <p>Remember that is very useful to read all these messages, specially when something does not work as it is expected</p> <p>To show that our program is working properly, we need to test the specific port, and then, going to our browser and writing <code>http://localhost:8080</code>. </p> <p></p> <p>The error message that we get <code>Whitelabel Error Page</code>, it is not an error at all, due to we have not program any controller, i. e. the server is working, but it is not serving anything.</p>"},{"location":"en/UD5_Spring/2_Spring_SpringBoot/#43-applicationproperties-file","title":"4.3. <code>application.properties</code> file","text":"<p>This file contains lot of useful configurations we will set along our development cycle. We will study as they will appear, but all configurations we set in <code>hibernate.cfg.xml</code> file in unit 3 will be set in this file.</p> <p></p> <p>This file, as all properties file, has an attribute-value pair structure. First important value is to change the port that our server listen. This file is under <code>src/main/resources</code> folder. We must add, for instance:</p> Bash<pre><code># puerto de escucha\nserver.port = 8090\n</code></pre> <p>If we re-run our app, we must change port in browser to access our server.</p> <p>Tip</p> <p>You can view (almost) all properties visiting this webpage</p> <p>We could add any value that we want use, like constants to use in our programs. Then we can load it in our programs. For instance:</p> Bash<pre><code># App name\napp.name=First spring app\n\n#Developer name\ndeveloper.name=Joan Gerard Camarena\n</code></pre> <p>to load in our programs, we need to use <code>@Value</code> annotation:</p> Java<pre><code>@Value(\"${app.name}\")\nprivate String appName;\n\n@Value(\"${developer.name}\")\nprivate String devName;\n</code></pre>"},{"location":"en/UD5_Spring/2_Spring_SpringBoot/#44-springbootapplication-annotation","title":"4.4. <code>@SpringBootApplication</code> annotation","text":"<p>In Spring Boot, it is very common to apply multiple annotations on the main class. But commonly, most developers mainly apply 3 annotations.</p> <ul> <li><code>@Configuration</code>: Available from version 3 of Spring, it offers us the possibility of making a notation that will be in charge of defining the class that owns it as a configuration class. This configuration for the Spring framework will be based on annotations. And not like in its origins, which was based on XML, which made it more complex. Another purpose of this annotation will be to allow dependency injection.</li> <li><code>@EnableAutoConfiguration</code>: Spring Boot Auto Configuration attempts to automatically configure your Spring application based on any jar dependencies you've added. If, for example, if you put an HSQLDB (system database management) is in your classpath, and you haven't manually configured any database connection beans, Spring Boot automatically configures an in-memory database.</li> <li><code>@ComponentScan</code>: It is used together with <code>@Configuration</code> to tell Spring where to look for the components, and it will be within the package that we have annotated. By only having to write it down once, being able to make all the packages be children of the package of the parent class (the one that contains the main). Basically this tells Spring where everyone should look for components.</li> </ul> <p>In order to use this three-pack annotations, Spring Boot offer us <code>@SpringBootApplication</code> as the join of three annotations explained before.</p>"},{"location":"en/UD5_Spring/2_Spring_SpringBoot/#5-mvc-with-spring","title":"5. MVC with Spring","text":""},{"location":"en/UD5_Spring/2_Spring_SpringBoot/#51-controllers","title":"5.1. Controllers","text":"<p>A controller, is responsible for responding to events. Normally, these events are actions (more technically known as requests) that are usually performed by the user, although they can also be more automated requests such as APIS, Ajax front pages, etc.</p> <p>In a real life context, a controller is like a waiter; He or She is waiting behind the bar until a client arrive. The client apply for a coke, and the waiter, if have will serve. Then arrives another client, and applies for a coffee, and then the waiter serves. Another client arrive, and applies for a green tea, and the waiter say that he could not serve, because he has no tea.  Again and again... The waiter will serve all that the client wants, if he could.</p> <p></p> <p>Returning to spring, we must add in our program a module that works as a controller, listening all client requests, and answering (if could) with the data that the client request.</p> <p></p> <p>Remember the error in first Spring execution: Spring App works fine, but we have not a controller yet. Let's go.</p>"},{"location":"en/UD5_Spring/2_Spring_SpringBoot/#52-package-controllers","title":"5.2. Package <code>controllers</code>","text":"<p>We are going to create a controller, but first, we have to create a package, which contains said controller. Earlier we were talking about the <code>@SpringBootApplication</code> annotation that we talked about being equivalent to having 3 annotations. One of them was <code>@ComponentScan</code>. If we don't want to have to tell it to scan several packages (which is usually the best idea), we usually put the entire package structure inside the <code>parent</code> package, which will be the package where we have the main.</p> <p>To do this, right-click on the package that contains main. In this way, when we go to put the name directly we will get the com.example and we will only have to add a <code>.</code> and the name of the child package. If not, we would have to write the full name of the package. As you can see, the white package tell us that is an empty package instead of brown package</p> <p></p> <p>Let's go to create a simple class that control index of our application. For this reason we must call our class like <code>indexController.java</code>. Remember that index refers to our server/app main domain.</p> <p>Tip</p> <p>It is a good practice to set class names following simple rules to understand the class behavior. Thus, a class called <code>clientController</code> is the controller that maps information about <code>Client</code>, and <code>filmController.java</code> is about <code>Films</code>. </p> <p>Once our class has been created, inside package controller, we must set up. Let's go seeing an example of <code>indexController.java</code>:</p> Java<pre><code>@Controller\npublic class indexController {\n\n    @GetMapping(\"/\")\n    @ResponseBody\n    public String helloWorld() {\n        return \"Hello from Spring\";\n    }\n\n}\n</code></pre> <p>Take a look of our anotations:</p> <ul> <li><code>@Controller</code> \u2192 tell Spring that this class is a controller. Is a specialization of <code>@Component</code>, and as Spring explores all classpath, is automatically detected.</li> <li><code>@GetMapping(\"/\")</code> \u2192 is the controller. We define a path (<code>\"/\"</code>) in our server, and we listen <code>GET</code> method. We will speak more next.</li> <li><code>@ResponseBody</code> \u2192 tells the controller to serialize the return value (an String in our sample) to JSON and send it throw <code>http_response</code> to the client that calls the controller.</li> </ul> <p>Now if we try to reload the page in navigator, instead of an error message you will get the returned value by the controller:</p> Before the controllerAfter the controller <p></p> <p></p> <p>Another way to get same result will be:</p> Java<pre><code>@RestController\npublic class indexController {\n\n    @GetMapping(\"/\")\n    public String helloWorld() {\n        return \"Hello from Spring\";\n    }\n\n}\n</code></pre> <p>where:</p> <ul> <li><code>@RestController</code> \u2192 tells that in this class all methods includes <code>@ResponseBody</code> annotation. Be careful, due to all methods will return a JSON object, and exists some cases (when we will send data to views in other format), it is a bad idea.</li> </ul>"},{"location":"en/UD5_Spring/2_Spring_SpringBoot/#53-requests-and-parameters","title":"5.3. Requests and Parameters","text":"<p>Attention</p> <p>To test our request, from now let's go to use POSTMAN https://www.postman.com/downloads/. There is an appendix about using postman.</p> <p>Let's add some intelligence to a controller route, giving it some dynamism through parameter passing. These parameters will be accepted thanks to the <code>@RequestParam</code> annotation. </p> <p>The number of parameters that we will receive will be equal to the number of parameters that we have defined within the <code>@RequestParam</code> annotation of the controller route method, as follows</p> Java<pre><code>@GetMapping(\"/hola\")\n    @ResponseBody\n    public String hola(@RequestParam String name) {\n        return \"Hola \"+ name +\" desde Spring !!!\";\n    }\n</code></pre> <p>It means that a request of <code>GET /hola</code> will need a parameter (<code>name</code>) with its value. For instance <code>http://localhost:9090/hola?name=Joange</code>. </p> <p>Notice that if we do not add the parameter, the request will be wrong. We could solve it, setting this parameter as no required and a default value, as follows:</p> Java<pre><code>@GetMapping(\"/hola\")\n@ResponseBody\npublic String hola(@RequestParam(required = false,defaultValue = \"desconocido\") String name) {\n  return \"Hola \"+ name +\" desde Spring !!!\";\n}\n</code></pre>"},{"location":"en/UD5_Spring/2_Spring_SpringBoot/#54-logger","title":"5.4. Logger","text":"<p>A good idea too, is to use <code>Logger</code> to show what is happen in our server. We can use like we suggest:</p> Java<pre><code>// set up a Logger to my app\nprivate static final Logger myLog=LoggerFactory.getLogger(HelloSpringApplication.class);\n\n// check specific situations\nif (name==null) {\n  myLog.warn(\"Name parameter does not exists\");\n}\nelse {\n  myLog.info(name + \" is here\");\n}\n</code></pre> <p><code>Logger</code> offer us to show each kind of message type:</p> <ul> <li><code>void error(String msg)</code></li> <li><code>void warn(String msg)</code></li> <li><code>void info(String msg)</code></li> </ul>"},{"location":"en/UD5_Spring/2_Spring_SpringBoot/#55-multiple-parameters","title":"5.5. Multiple parameters","text":"<p>Let's go to study how to get several parameters, even though is not recommended more than three or four, because the paths increases a lot, and there better methods to pass data to the server, as objects in the BODY request from forms or data inside paths. A classical sample is like follows:</p> Java<pre><code>@Autowired\nprivate HttpServletRequest context;\n\n@GetMapping(\"/born\")\n@ResponseBody\npublic String born(\n    @RequestParam(required=true,defaultValue = \"unknown\") String name,\n    @RequestParam(required=true,defaultValue = \"1970\") int year         \n    ) {\n  int currentYear = Calendar.getInstance().get(Calendar.YEAR);\n  myLog.info(\"Request from -&gt; \"+context.getRemoteAddr() + \" Port-&gt;\" + context.getRemotePort());\n  return \"Hi \" + name + \" you have \" + (currentYear-year);\n}\n</code></pre> <p>notice that:</p> <ul> <li>Although default values could be integers or numbers, we must set as strings.</li> <li>The <code>HttpServletRequest</code> variable defined is used to get extra information about the http request received.</li> </ul> <p>Important</p> <p>Spring <code>@Autowired</code> is one of the most used annotations. This annotation allows doing dependency injection. This mean that Spring will look for class inside the application context that match with desired bean, create a new instance and inject inside the bean who posses the injection.</p>"},{"location":"en/UD5_Spring/2_Spring_SpringBoot/#56-post-request","title":"5.6. Post request","text":"<p>Apart from GET, we can do POST, PUT, DELETE and more request to our server. We simply have to replace <code>@GetMapping</code> with <code>@PostMapping</code>, with corresponding import. In fact, since they are different routes, even if they are called the same, they could be in the same file without any problem.</p> Java<pre><code>@PostMapping(\"/born\")\n@ResponseBody\npublic String post(\n    @RequestParam(required=true,defaultValue = \"unknown\") String name,\n    @RequestParam(required=true,defaultValue = \"1970\") int year         \n    ) {\n</code></pre> <p>As POST are usually called inside a form, it is a good idea to set the parameter in the body section of request. To do this, we must set the BODY section of POSTMAN, select <code>www-form-urlencoded</code> and set the parameters.</p> <p>If we want an unlimited number of parameters, you can create an array, an create multiple parameters in POSTMAN with same name:</p> Java<pre><code>@PostMapping(\"/lots\")\n@ResponseBody\npublic String lots(@RequestParam String [] params) {\n  String res=\"\";\n  myLog.info(\"POST Request from -&gt; \"+context.getRemoteAddr() + \" Port-&gt;\" + context.getRemotePort());\n  if(params==null || params.length==0)\n    res= \"A POST request without params.\";\n  else {\n    res=\"The list of params is:\\n\";\n    for (String param : params) {\n      res+=param+\"\\n\";\n    }\n    res=res.substring(0, res.length()-1);\n  }\n\n  return res;\n}\n</code></pre> <p></p>"},{"location":"en/UD5_Spring/2_Spring_SpringBoot/#57-variables-in-the-path","title":"5.7. Variables in the path","text":"<p>If we want to get for a specific value, in the form of a vaule in the path, for instance <code>GET films/1</code> instead of <code>GET films?idFilm=1</code>, the way is as follows:</p> Java<pre><code>@GetMapping(\"/who/{idWho}\")\n@ResponseBody\npublic String who(@PathVariable String idWho) {\n  myLog.info(\"GET Request from -&gt; \"+context.getRemoteAddr() + \" Port-&gt;\" + context.getRemotePort());\n  return \"You are looking for \" + idWho;\n}\n</code></pre> <p>The request will be as follows:</p> <p></p> <p>As we can see:</p> <ul> <li>In the java program we set in the path a <code>idWho</code> parameter.</li> <li>In the java controller method we define that parameter as String to access it inside our method</li> <li>When we do the request, the value in the request will be transferred to the parameter.</li> </ul>"},{"location":"en/UD5_Spring/3_API_Rest/","title":"3. Creating API's REST","text":""},{"location":"en/UD5_Spring/3_API_Rest/#1-spring-layers","title":"1. Spring layers","text":"<p>We are learning about some design patterns that we are going to use in our application, and that are necessary to define a correct architecture in a Spring application. Therefore, the first thing we will do is define the layers of our application structure, and once we define it we will define new design patterns that we will integrate our app.</p> <p></p> <p>The idea is to create a package structure that groups the classes into 6 main packages: package that contains the main class, web layer that contains the controllers, data access layer that contains the repository, service layer, data model layer and dto layer. All these are included, basically in 3: web, service and repository.</p> <p>The objective is that, with a well-defined and coupled architecture it is possible to use Dependency Injection, since it will facilitate communication and access between the different layers.</p>"},{"location":"en/UD5_Spring/3_API_Rest/#11-main-class","title":"1.1. Main Class","text":"<p>Every Java application must contain a main class with a main method. Said method, in case of implementing an application with Spring, must call the run method of the <code>SpringApplication</code> class. We will leave this class in the root by default, so that we will always have it in the same place.</p>"},{"location":"en/UD5_Spring/3_API_Rest/#12-web-layer-controller-layer","title":"1.2. Web Layer. Controller Layer","text":"<p>Let's now define the behavior of the application by implementing the rest of the classes. We are going to start with the highest level layer, the controllers layer, where we will expose the application's services. In our application it will be called <code>Controller</code>.</p> <p>This layer will basically work in 3 ways:</p> <ul> <li>Web services consumed by applications (REST or SOAP service).</li> <li>Views implemented with JSP, JSF, Thymeleaf, etc. This is our main case, although we will also create REST services.</li> <li>Views with frameworks such as Vaadin, Wicket, ZK, etc.</li> </ul>"},{"location":"en/UD5_Spring/3_API_Rest/#13-services-layer","title":"1.3. Services Layer","text":"<p>Layer that is responsible for implementing the business logic, that is, all the tasks that our system is capable of performing. </p> <p>This is one of the most important layers since all data validation operations that refer to business logic (for example, checking that a current account has a balance when making a payment) and security will be carried out here. It will be called <code>service</code>.</p> <p>Typically, they access the data stored in the application's database through the repositories, do a series of operations, and send the data to the controller. We can find the following types of service:</p> <ul> <li>Repository Integrity Services: they are in charge of consuming information from the repository. They are easy to implement services (for example, request a list of clients).</li> <li>Business Operability Services: they carry out specific operations for the business flow (they carry out complex operations to complete a transaction, such as a sale, storing an order, etc).</li> <li>Security Services: dedicated to carrying out security operations</li> <li>Management Services: dedicated to generating reports and/or statistics.</li> </ul>"},{"location":"en/UD5_Spring/3_API_Rest/#14-repository-layer","title":"1.4. Repository layer","text":"<p>Repositories are the classes in charge of managing access to data. It typically contains classes that perform CRUD operations using only an entity class from a domain model. It will be called <code>repository</code>.</p>"},{"location":"en/UD5_Spring/3_API_Rest/#15-model-layer","title":"1.5. Model layer","text":"<p>It will contain the mappings of the database tables into classes that represent entities. The layer will be named <code>model</code>.</p>"},{"location":"en/UD5_Spring/3_API_Rest/#16-dto-layer","title":"1.6. DTO layer","text":"<p>Controllers usually handle <code>DTO</code> instead of pojos or beans, due to the structure of the API or rendering in views. Therefore, we will need to implement a two-way conversion between a pojo and a DTO model. Later we will define, in the design patterns, what a DTO is and we will see the bidirectional conversion, called mapping. In addition, these DTO's will be in a separate layer called <code>dto</code>.</p> <p></p>"},{"location":"en/UD5_Spring/3_API_Rest/#2-design-patterns","title":"2. Design patterns","text":"<p>A design pattern is a proven solution that solves a specific type of design problem in software development. There are lots of design patterns that are divided into categories, for example: creation, structural, behavioral, interaction, etc.</p> <p>Why use design patterns?: They allow you to have the code well organized, readable and maintainable, it also allows you to reuse code and increases scalability in your project.</p> <p>In themselves they provide a standard terminology and a set of good practices regarding the solution of software development problems.</p> <p>We are going to explain several of them to begin to understand what design patterns are.</p>"},{"location":"en/UD5_Spring/3_API_Rest/#21-mvc-pattern","title":"2.1. MVC pattern.","text":"<p>We have already explained this pattern in the previous topic, but we are going to give it a little review.</p> <p>It allows separating an application into 3 layers, a way of organizing and making a project scalable. The layers that we can find are:</p> <ul> <li>Model: This layer represents everything that has to do with data access: saving, updating, obtaining data, as well as all the business logic code, basically the Java classes and part of the business logic.</li> <li>View: The view has to do with the data presentation of the model and what the user sees, usually a view is the visual representation of a model (POJO or java class). For example, the user model, which is a class in Java and whose properties are first name and last name, must belong to a view in which final user sees those properties.</li> <li>Controller: The controller is in charge of connecting the model with the views, it works as a bridge between the view and the model, the controller receives events generated by the user from the views and is in charge of directing the respective request to the model. For example, the user wants to see the customers with the last name \u00c1lvarez, the request goes to the controller and it takes care of using the appropriate model and returning that model to the view.</li> </ul> <p>At no time the view will directly interact with the model, this also maintains security in an application.</p> <p>The important thing about this pattern is that it allows you to divide it into parts, which are somehow independent, so if, for example, a change is made to the model, it would not affect the view or if there is a change, it would be minimal.</p>"},{"location":"en/UD5_Spring/3_API_Rest/#22-dto-pattern","title":"2.2. DTO Pattern","text":"<p>With this pattern, one of the transversal layers of architecture is designed. It solves the problem of how to allow a client to exchange data with the server without making multiple calls asking for each piece of data. For example, if we have an entity called Person and an entity called Addresses, when asking for the people and their addresses we have to make multiple calls to the server to ask for the people and the addresses of each person, building the view with this information.</p> <p>DTO solves it by passing a lightweight object to the client with all the necessary data, together. The client can then make local requests to the object it has received.</p> <p>To do this, Java classes are created that encapsulate the data in a package that can be transported over the network (they can implement <code>java.io.Serializable</code>, although it is not mandatory), that is, with the previous example, we would create a Java class that would carry the person and their addresses, all together in the same object.</p> <p>These objects are used in all layers of the application, so the information is carried by all layers of the application. It is recommended to always fill in all DTO fields to avoid <code>NullPointerException</code> errors (an empty string may be better), make DTOs self-describing, use arrays or collections of DTOs when necessary, and consider methods that override <code>equals()</code>.</p> <p>There are two variants of DTO's:</p> <ul> <li>Custom DTOs that represent part of a bean or bundle multiple beans.</li> <li>Domain DTOs called \"entities\". A domain class is not directly accessible by the client, since, due to the separation of the MVC pattern from the view, the entities that map the database (which are the entities) cannot be accessed. For that reason, DTO copies of server domain objects (entities) are made. Clients can operate on local copies improving read and update performance.</li> </ul> <p>With all this, we can summarize that DTO is a very effective pattern to transmit information between a client and a server, since it allows us to create data structures independent of our data model (Entities), which allows us to create as many \"views\" as necessary. From a set of tables or data sources. In addition, it allows us to control the format, name and types of data with which we transmit the data to adjust to a certain requirement. Finally, if for some reason the data model changes (and with it the entities) the client will not be affected, since they will continue to receive the same DTO.</p> <p>Next we will see how to implement the DTO pattern.</p>"},{"location":"en/UD5_Spring/3_API_Rest/#23-dao-pattern","title":"2.3. DAO pattern","text":"<p>The Data Access Object (DAO) pattern, which allows separating the data access logic from the Business Objects, in such a way that the DAO encapsulates all the data access logic to the rest of the application. This proposal proposes to completely separate the business logic from the logic to access the data, in this way, the DAO will provide the necessary methods to insert, update, delete and consult the information; on the other hand, the business layer only cares about business logic and uses the DAO to interact with the data source. In the example that we are going to design below, we will see how to implement the DAO pattern.</p>"},{"location":"en/UD5_Spring/3_API_Rest/#24-facade-pattern","title":"2.4. FACADE pattern","text":"<p>The Facade design pattern simplifies the complexity of a system through a simpler interface. Improves access to our system by allowing other systems or subsystems to use a common access point that reduces complexity, minimizing interactions and dependencies. That is, we will create a Java interface that will have the method headers as a common access point, while there will be Java classes that will implement that interface.</p> <p>Throughout this example we will make use of this pattern.</p>"},{"location":"en/UD5_Spring/3_API_Rest/#3-creating-the-project-and-configuring-hibernate","title":"3. Creating the project and configuring Hibernate","text":"<p>In this section we are going to create a simple Hibernate program with Spring, to apply all we have studied in previous units with Spring. We only have to create a new project, selecting dependencies that we usually use:</p> <p></p> <p>This will generate <code>pom.xml</code> with all we need</p> <p>We need to set the parameters that we set in <code>hibernate.cfg.xml</code> in <code>application.properties</code> file: Bash<pre><code># puerto de escucha\nserver.port = 8090\n\n# Conexi\u00f3n con la BBDD\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\n\n# Datos del SGBD. REVISAR !!!!\nspring.datasource.url = jdbc:mysql://localhost:3308/AD_UD5_Clientes\nspring.datasource.username = root\nspring.datasource.password = root\n\n\n# configuraci\u00f3n de hibernate (simple)\nspring.jpa.show-sql=true\nspring.jpa.properties.hibernate.format_sql=true\nspring.jpa.properties.hibernate.dialect = org.hibernate.dialect.MySQL5InnoDBDialect\n\n# hbm2DDL. values= none, validate, update, create, and create-drop\nspring.jpa.hibernate.ddl-auto=validate\n\n# import.sql file under src/main/resources/\n# or data.sql or schema.sql\n\n# respetar may\u00fasculas y min\u00fasculas\nspring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl\n</code></pre></p> <p>Important</p> <p>All options of database initialization can be found in database initialization.</p>"},{"location":"en/UD5_Spring/3_API_Rest/#31-the-model","title":"3.1. The model","text":"<p>Let's go to use this model to our practice:</p> <p></p> <p>Warning</p> <p>You have a script to create full database linked here. In this unit we do not implement about <code>Movimientos</code>.</p> <p>To create the model we have to create the Beans that we create in unit 3. We can use Lombok to improve our development time. </p> <p>Tip</p> <p>You con mark an attribute with Lombok annotation <code>@ToString.Exclude</code> to avoid participate in <code>toString</code> method, for instance to avoid recursion.</p> <p><code>Cliente</code> DAO in package <code>model</code>:</p> Java<pre><code>@Data\n@Entity\n@Table(name = \"clientes\")\npublic class Cliente {\n\n    @Id\n    @GeneratedValue( strategy=GenerationType.IDENTITY)\n    private Long id;\n\n    @Column(name = \"nif\")\n    private String nif;\n\n    @Column(name = \"nombre\")\n    private String nombre;\n    private String apellidos;\n\n    @Column(name = \"claveseguridad\")\n    private String claveSeguridad;\n    private String email;\n\n    @OneToOne(fetch = FetchType.LAZY, \n            cascade =  CascadeType.ALL, \n            mappedBy = \"cliente\")\n    @ToString.Exclude\n    private Recomendacion recomendacion;\n\n    @OneToMany(fetch = FetchType.LAZY, \n            cascade = CascadeType.ALL, \n            mappedBy = \"cliente\")\n    @ToString.Exclude\n    private List&lt;Cuenta&gt; listaCuentas;\n\n  @ManyToMany(fetch = FetchType.EAGER, cascade = {CascadeType.ALL})\n  @JoinTable(name=\"clientesdirecciones\", \n              joinColumns=@JoinColumn(name=\"idcliente\"),\n              inverseJoinColumns=@JoinColumn(name=\"iddireccion\"))\n  @ToString.Exclude\n  private List&lt;Direccion&gt; listaDirecciones;\n</code></pre>"},{"location":"en/UD5_Spring/3_API_Rest/#32-the-dto","title":"3.2. The DTO","text":"<p>The DTO's (Data Transfer Object) serves to transfer data in our system through transactions carried out by our entities from one operation to another without losing the integrity between the data.</p> <p>For this reason, it is important to define that data access is done only through DAO (Data Access Object) our <code>model</code>, thereby obtaining an abstraction of the data model. The data is only accessed through methods defined in the <code>DAO</code>. The DAOs include another concept that is the DTO (Data Transfer Object). DTO's are a class of objects that serve solely to transport data. DTO contains the properties of the object. Data that may originate from one or more information entities.</p> <p>Another good practice is to mark the classes with the DTO suffix to remember its meaning, so the <code>Client</code> class would remain as <code>ClientDTO</code>.</p> <p>One of the characteristics of the DTO's is that they must be <code>Serializable</code> objects in order to be able to travel through the network. We need to indicate this feature in the DTO's, so we are going to add that they implement the Serializable interface, and with it, the <code>UID</code> property that identifies the version of each transported object. </p> <p>To create a DTO we will create a class with the attributes that we want containing the DTO. It can be more or less than DAO class. Then is important to create methods to convert either between DAO to DTO as DTO to DAO. These methods can be created in a static way.</p> Java<pre><code>// Convierte una entidad DAO a un objeto DTO con todos los datos\npublic static ClienteDTO convertToDTO(Cliente cliente) {\n  // Creamos el clienteDTO y asignamos los valores basicos\n  ClienteDTO clienteDTO = new ClienteDTO();\n  clienteDTO.setIdCliente(cliente.getId());\n  clienteDTO.setNif(cliente.getNif());\n  clienteDTO.setNombre(cliente.getNombre());\n  clienteDTO.setApellidos(cliente.getApellidos());\n\n// rest of attributes\n\n  return clienteDTO;\n}       \n\n    // Convierte de un objeto a un entidad\n    public static Cliente convertToEntity(ClienteDTO clientedto) {\n    Cliente  cliente = new Cliente();\n        cliente.setId(clientedto.getIdCliente());\n        cliente.setNif(clientedto.getNif());\n\n    // rest of attributes\n\n    return cliente;\n</code></pre> <p>As we say, we prevent to access entities from higher layers.</p> <p>More...</p> <p>You can search the internet for information about <code>ModelMapper</code> to manage DTOs.</p>"},{"location":"en/UD5_Spring/3_API_Rest/#321-converting-dto-to-json","title":"3.2.1. Converting DTO to JSON","text":"<p>As we have said, these objects (DTO's ) are parsed to JSON automaticaly, but how? Spring uses Jackson object mapper to transform objects to JSON Objects. In this tutorial you can understand better how it works.</p> <p>Parsing objects to JSON can take us to another infinite recursion problem, when object contains cross-references, like <code>toString()</code> methods. We have learnt how to avoid the <code>StackOverflowException</code> in <code>toString()</code> methods, using Lombok <code>@ToString.Exclude</code>, but how to avoid when parsoing to JSON. The solution is offered with new annotations, as follows:</p> <ul> <li><code>@JsonIgnore</code> \u2192 this field will not be parsed.</li> <li><code>@JsonManagedReference</code> \u2192 tell that we will show this object information in forward way, but not in a backward mode. This annotation will be complemented by:</li> <li><code>@JsonBackReference</code> \u2192 Show the referenced information only, similar of <code>@JsonIgnore</code>.</li> <li><code>@JsonIgnoreProperties(\"property\")</code> \u2192 skip this property in the annotated field.</li> </ul> <p>If we mark:</p> Java<pre><code>class Director{\n  // own attributes\n\n  @JsonManagedReference\n  Set&lt;Film&gt;\n}\n\nclass Film{\n  // own attributes\n\n  @JsonBackReference\n  Director;\n}\n</code></pre> <p>We will show the Film information of a Director without recurssion (only own attributes)</p> <p>You can find more information here</p>"},{"location":"en/UD5_Spring/3_API_Rest/#33-the-repository","title":"3.3. The repository","text":"<p>The repository layer is responsible for managing access to data. This makes it possible to separate the business logic from the data access, thus allowing, for example, to be able to modify the system database without affecting the logic.</p> <p>In this layer we must distinguish two types of access:</p> <ul> <li>Access to data from the system's own data model that will be done through DAO (Data Access Object) access. For this type of access, we will use the JPA (Java Persistence API) framework through Spring Data.</li> <li>Access to external systems through connectors (webservices, APIs, etc.)</li> </ul> <p>For this reason we are going to create an interface in which we have the operations that we are going to expose. This interface will be <code>ClientRepository.java</code> and will be created in the <code>repository</code> package.</p> <p>With Spring, we will save a lot of work, since we will simply define a working interface, in which we will indicate the type of repository that we want to create, the class on which it is going to work and the type of data that works as an identifier of said class:</p> <p>Spring provides the Repository Interface, from which it inherits <code>CrudRepository</code>, which includes the definition of the basic CRUD operations. From the latter it inherits <code>PagingAndSortingRepository</code>, which adds paging and ordering functions, and finally we have <code>JPARepository</code>, which includes specific operations for JPA.</p> <p>The importance of the generic definition of <code>Repository&lt;Class,Type&gt;</code> is that all the objects it will retrieve are of that class, and the type indicates the type of the primary key of that class. Following our example, the repository definition would be:</p> Java<pre><code>@Repository\n@Transactional\npublic interface ClienteRepository extends JpaRepository&lt;Cliente, Long&gt; {\n\n}\n</code></pre> <p>With this, Spring already allows us to access the database and perform basic operations. The following methods are implemented by default, and we will not need to implement them, just define them:</p> <ul> <li>Recover data:</li> <li><code>findAll()</code>, <code>findById(Id)</code>, <code>findById(Iterable&lt;Id&gt;)</code>:retrieves one, or all, occurrences of an identifier or a collection of identifiers.</li> <li>Delete data:</li> <li><code>delete(Object)</code>, <code>deleteAll()</code>, <code>deleteById(Id)</code>, <code>deleteAllById(Iterable&lt;Id&gt;)</code>:delete by object, identifier or all.</li> <li>count and check:</li> <li><code>count()</code>, <code>existsById()</code></li> <li>save objects:</li> <li><code>save(Object)</code>, <code>save(Iterable&lt;Object&gt;)</code>:save the object(s)</li> </ul> <p>Tip</p> <p>If we need another method, we must define it, and then create a new class to implement this interface and implement the method.</p>"},{"location":"en/UD5_Spring/3_API_Rest/#34-the-service","title":"3.4. The service","text":"<p>The service layer manages the business logic of our application. This business logic is separate from the web logic, which is in the controller.</p> <p>When we define classes that implement services for business logic, the following rules must be followed:</p> <ol> <li>Define an interface that will have the headers of the methods that you want to publish. In this way we make use of the Facade pattern and expose the methods of the service to use.</li> <li>We define a class (bear in mind that an interface can have several classes that implement it) that implements the interface, so that we can implement all the service methods following the required business logic.</li> <li>The <code>@Service</code> annotation tells Spring to recognize the class as a service (similar to the <code>@Controller</code> annotation that we have studied in previous section).</li> <li>We will use <code>@Autowired</code> to inject the service into the controller (we will see later).</li> <li>We will use <code>@Autowired</code> to inject DAO with which we are going to work into the service.</li> <li>Keep in mind that a service method will define a business level operation, eg giving a welcome message. Service methods will be made up of other smaller operations, which will be defined in the repository layer.</li> </ol> <p>With all this, we are going to begin to define the service layer. So we start by creating an interface called <code>ClientService.java</code> in the <code>service</code> package. </p> Java<pre><code>public interface ClienteService {\n\n    void saveCliente(ClienteDTO clienteDTO);\n    ClienteDTO getClienteById(Long id);\n    List&lt;ClienteDTO&gt; listAllClientes();\n    void deleteCliente(Long id);\n\n}\n</code></pre> <p>Notice that we define in this case 4 basic operations with <code>ClienteDTO</code>, due to is the objects will manage the controller.</p> <p>Once we have the interface, we create a new class called <code>ClientServiceImpl.java</code>, which will be in charge of implementing the methods that are declared in the interface. After that, we make the new class extend the created interface and after that we make it implement all the methods of the interface by default. We also indicate the <code>@Service</code> annotation to the class. It will be as follows:</p> Java<pre><code>@Service\npublic class ClienteServiceImpl implements ClienteService{\n\n    @Autowired\n    private ClienteRepository clienteRepository;\n\n    @Override\n    public void saveCliente(ClienteDTO clienteDTO) {\n        Cliente cliente = ClienteDTO.convertToEntity(clienteDTO);\n        clienteRepository.save(cliente);\n    }\n\n    @Override\n    public ClienteDTO getClienteById(Long id) {\n        Optional&lt;Cliente&gt; cliente = clienteRepository.findById(id);\n        if(cliente.isPresent()) {\n            return ClienteDTO.convertToDTO(cliente.get());\n        }else {\n            return null;            \n        }\n    }\n\n    @Override\n    public List&lt;ClienteDTO&gt; listAllClientes() {\n        List&lt;Cliente&gt; lista = clienteRepository.findAll();\n        List&lt;ClienteDTO&gt; listaResultado = new ArrayList&lt;ClienteDTO&gt;();\n        for (int i = 0; i &lt; lista.size(); ++i) {\n            listaResultado.add(ClienteDTO.convertToDTO(lista.get(i)));\n        }\n        return listaResultado;\n    }\n\n    @Override\n    public void deleteCliente(Long id) {\n        clienteRepository.deleteById(id);\n    }\n}\n</code></pre> <p>As you can see, the service is in charge of invoking the repository methods, and performing some checks if necessary. Furthermore, we get <code>Cliente</code> objects and transform it to <code>ClienteDTO</code>, in order to use it to return to the controller.</p> <p>Important</p> <p><code>findClienteById()</code> method returns a new wrapper class <code>Optional&lt;Cliente&gt;</code>. This class wraps an Object that will exist or no, providing methods to check it and act in consequence:</p> <ul> <li><code>isPresent()</code> \u2192 returns a boolean.</li> <li><code>orElse(anotherObject)</code> \u2192 if not exists, return another Object instead of Optional.</li> <li><code>get()</code> \u2192 returns existing object.</li> </ul> <p>The main goal is to avoid famous <code>NullPointerException</code>. More information can be found here</p>"},{"location":"en/UD5_Spring/3_API_Rest/#35-the-controller","title":"3.5. The controller","text":"<p>We are now going to define the highest level layer, the controllers layer, where we will expose the application's services.</p> <p>The controller will be in charge of responding to user requests with the application. It will include the services, and in case of creating an MVC application, it will be able to invoke template engines, such as Thymeleaf. As we have commented here we will implement it in a single class (without following the previous pattern).</p> <p>The controller will invoke the service associated with said request and return the data obtained or the response to the same client. We must mark the class with the <code>@Controller</code> stereotype. In the case of REST services, we must also indicate that the returns of the class methods are serialized to JSON, and we achieve this with <code>@ResponseBody</code>. Since Spring 4, the two annotations have been merged into one, via <code>@RestController</code>. We will only leave <code>@Controller</code> for projects where we return a view (HTML + CSS + JS).</p> <p>The service that we are going to create will have a complete behavior in terms of <code>Cliente</code> maintenance, as well as their recommendation, so we can list customers, view their information, register customers, update customer data and delete customers, or be the CRUD operations that are known.</p> <p>So we'll start by creating a controller called <code>ClienteController.java</code>. This controller will implement the 4 operations corresponding to CRUD: create, read, update and delete. Apart from these 4 we will create an operation that will show the initial page of the application, with a link to customer maintenance.</p> Java<pre><code>@RestController\npublic class ClienteController {\n\n    @Autowired\n    private ClienteService clienteService;\n\n  // mapping the requests. One method per route/request\n</code></pre> <p>The controller normally defines four CRUD operations, but we can add all that we need. Let's go to see it.</p>"},{"location":"en/UD5_Spring/3_API_Rest/#351-index","title":"3.5.1. Index","text":"<p>This method maps the root index of our webapp, For instance, we can send name of the application and module. These variables could be defined in our <code>application.properties</code> and can be loaded with <code>@Value</code> annotation and a String <code>${property_name}</code> inside.</p> Java<pre><code>@Autowired\n    private HttpServletRequest context;\n\n    @Value(\"${app.name}\")\n    private String appName;\n\n    @Value(\"${developer.name}\")\n    private String devName;\n</code></pre> <p>The index controller normally shows general information about the main page, as follows:</p> Java<pre><code>@GetMapping(\"/\")\npublic String index() {\n  String res=\"Hello from Spring\\n\";\n  res+=\"You are running \" +appName+\"\\n\";\n  res+=\"Developed by \" +devName;\n  return res;\n}\n</code></pre>"},{"location":"en/UD5_Spring/3_API_Rest/#4-read-operations-get","title":"4. Read operations (GET)","text":"<p>It's time to retrieve data from our server, and normally <code>GET</code> operations are the most demanded methods. We are going to implement several methods, that could return one or many objects of the desired class, in our notes, <code>Cliente</code> class.</p>"},{"location":"en/UD5_Spring/3_API_Rest/#41-get-all","title":"4.1. Get All","text":"<p>No filter option is needed, because we want to get all clients. When we get this get request, we must call to <code>listAll</code> method in our service, who calls, indeed to <code>findAll</code> in our repository.</p> Java<pre><code>@GetMapping(\"/clientes\")\n  public List&lt;ClienteDTO&gt; listClientes(){\n    myLog.info(context.getMethod() + \" from \" + context.getRemoteHost());\n    List&lt;ClienteDTO&gt; losClientes=clienteService.listAllClientes();\n    return losClientes;\n} \n</code></pre> <p>Apart from log message, we simply retrieve data from the service and return it to the response.</p>"},{"location":"en/UD5_Spring/3_API_Rest/#42-get-one","title":"4.2. Get One","text":"<p>This is the most specific version, and normally in the request we look for an object from its ID. Then, we must get a parameter in our request, and we will use the ID in the path, using <code>@PathVariable</code> annotation.</p> Java<pre><code>@GetMapping(\"/clientes/{idCliente}\")\npublic ClienteDTO showClienteById(@PathVariable Long idCliente){\n  myLog.info(context.getMethod() + \" from \" + context.getRemoteHost());\n  ClienteDTO elCliente=clienteService.getClienteById(idCliente);\n  return elCliente;\n} \n</code></pre> <p>The request will be <code>/clientes/7</code>, for instance, and then, in our controller method the parameter <code>idCliente</code>will be set with 7 value. We call <code>getClienteById(7)</code> and, obviously we get the <code>ClienteDTO</code> encapsulating the requested <code>Cliente</code>, if exists.</p> <p>We can improve the methods for the case that there are no results (<code>Cliente</code> does not exists) or an error has occurred, returning and encapsulating the results in a <code>ResponseEntity&lt;Cliente&gt;</code>. This wrapper class returns the result to the request, but allows adding an argument that will be the http status code. This code can be captured on the client application for error handling. The algorithm will be something like this:</p> Java<pre><code>public ResponseEntity&lt;results&gt;controllerMethod(){\n  // collect the data from the service/repository\n  if(!mistake) {\n    return new ResponseEntity&lt;&gt;(Results,HttpStatus.OK); // ALL GOOD\n  }\n    return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND); // SOMETHING IS WRONG\n  }\n</code></pre> <p>applied to our sample application, and merging last two code samplers, will get as follows:</p> Java<pre><code>@GetMapping(\"/clientes/{idCliente}\")\npublic ResponseEntity&lt;ClienteDTO&gt; showClienteById(@PathVariable Long idCliente){\n  myLog.info(context.getMethod() + context.getRequestURI() + \" from \" + context.getRemoteHost());\n  ClienteDTO elCliente=clienteService.getClienteById(idCliente);\n  if (elCliente==null)\n    return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND);\n  else\n    return new ResponseEntity&lt;&gt;(elCliente,HttpStatus.OK);\n} \n</code></pre>"},{"location":"en/UD5_Spring/3_API_Rest/#43-handling-exceptions","title":"4.3. Handling exceptions","text":"<p>The controller handle several exceptions, and the program continues running unless a big crush occurs. Now we present a method that will give a response when an exception happens. We will annotate this method with <code>@ExceptionHandler</code>, passing the exception class that we must catch</p> Java<pre><code>@ExceptionHandler(MethodArgumentTypeMismatchException.class)\npublic ResponseEntity&lt;String&gt; handleError(MethodArgumentTypeMismatchException e) {\n  myLog.warn(\"Method Argument Type Mismatch\", e);\n  String message = String.format(\"Method Argument Type Mismatch: %s\", e.getName());\n  return new ResponseEntity&lt;&gt;(message,HttpStatus.BAD_REQUEST);\n}\n</code></pre> <p>We can handle several exceptions in one unique method, marking it with a collection of exceptions, for instance as:</p> Java<pre><code>@ExceptionHandler({\n    MissingServletRequestParameterException.class,\n    MethodArgumentTypeMismatchException.class,\n    InvalidStreamDefinitionException.class\n})\npublic ResponseEntity&lt;String&gt; handleError(Exception e) {\n  // method body\n} \n\n// i aquest quan no es troba una entrada al controlador\n@ExceptionHandler(NoHandlerFoundException.class)\npublic ResponseEntity&lt;Map&lt;String, Object&gt;&gt; handleNotFoundError(NoHandlerFoundException ex) {\n    Map&lt;String, Object&gt; response = new HashMap&lt;&gt;();\n    response.put(\"error\", \"404 Not Found\");\n    response.put(\"message\", \"El recurso solicitado no existe.\");\n    response.put(\"path\", ex.getRequestURL());\n\n    return new ResponseEntity&lt;&gt;(response, HttpStatus.NOT_FOUND);\n}\n</code></pre>"},{"location":"en/UD5_Spring/3_API_Rest/#5-save-operations-post","title":"5. Save operations (POST)","text":"<p>First operation we need to do is to store new <code>Cliente</code> on our database. Let's go to explain by example. The controller will receive a new DTO object sent by the client app (we will use Postman, as you can view in Appendix 1):</p> Java<pre><code>//@PostMapping(value=\"/clientes\",consumes={\"application/json\"})\n@PostMapping(\"/clientes\")\npublic ResponseEntity&lt;ClienteDTO&gt; addDirector(@RequestBody ClienteDTO newCliente) { \n  myLog.info(context.getMethod() + context.getRequestURI()); \n  ClienteDTO elCliente= clienteService.saveCliente(newCliente);\n    if (elCliente==null)\n      return new ResponseEntity&lt;&gt;(HttpStatus.BAD_REQUEST);\n    else\n    return new ResponseEntity&lt;&gt;(elCliente,HttpStatus.OK);\n}\n</code></pre> <p>notice that:</p> <ul> <li>The request is mapped with <code>@PostMapping</code>. Here you have a comment with extra options.</li> <li>The object received by the app is inside a JSON object in the request body, marked as <code>@RequestBody</code>. In this unit we are going to suppose that the data arrives well formatted.</li> <li>Data received is passed to service and a new (stored) <code>Cliente</code> is returned. </li> <li>This client is returned to the client</li> </ul> <p>In this picture you can view data sent to API and returned value. Notice that <code>Cuentas</code> and <code>Direcciones</code> are not present in that data. We will see later how to add this additional data.</p> <p></p> <p>Warning</p> <p>There is a lot of validations to do in order to verify data integrity. Here you can find an article about ho to validate data recieved from client applications.</p>"},{"location":"en/UD5_Spring/3_API_Rest/#6-update-operations-put","title":"6. Update operations (PUT)","text":"<p>To update an object of the database, we need to receive the update (and complete) object in the request. We can not save it immediately, because it could not exist. For this reason we must check the existence, and if this is positive, then save the object received, that will update previous version in the database. Let's go to see the sample:</p> Java<pre><code>@PutMapping(\"/clientes\")\npublic ResponseEntity&lt;ClienteDTO&gt; updateCliente(@RequestBody ClienteDTO updCliente) {   \n    myLog.info(context.getMethod() + context.getRequestURI());\n    // buscamos si existe previamente\n    ClienteDTO elCliente= clienteService.getClienteById(updCliente.getIdCliente());\n      if (elCliente==null)\n          return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND);\n      else {\n        // como ya sabemos que existe, save actualiza\n        ClienteDTO elClienteUPD= clienteService.saveCliente(updCliente);\n        return new ResponseEntity&lt;&gt;(elClienteUPD,HttpStatus.OK);\n      }\n}\n</code></pre>"},{"location":"en/UD5_Spring/3_API_Rest/#7-delete-operations-delete","title":"7. Delete operations (DELETE)","text":"<p>Delete is very simple operation, because we only need the object's identifier that we want to delete, and then we could get from the path, inside the path variable. Then, we must call th delete operation of the service.</p> Java<pre><code>@DeleteMapping(\"/clientes/{idCliente}\")\npublic ResponseEntity&lt;String&gt; deleteCliente(@PathVariable Long idCliente){\n  clienteService.deleteCliente(idCliente);\n  return new ResponseEntity&lt;&gt;(\"Cliente borrado satisfactoriamenet\",HttpStatus.OK);\n} \n</code></pre>"},{"location":"en/UD5_Spring/3_API_Rest/#8-exercise-complete-the-server","title":"8. Exercise. Complete the server","text":"<p>We have finished creating our controller about <code>Cliente</code> class, but we can improve our application adding more services and configurations to the server. This concepts will be studied in next sections.</p> <p>We recommend completing <code>Cuenta</code> and <code>Direccion</code> controller, services and repositories with default operations.</p> <p>Furthermore, you can add options to add a <code>Cuenta</code> to a <code>Cliente</code> or remove, and same as <code>Direccion</code></p>"},{"location":"en/UD5_Spring/4_Spring_Security/","title":"4. Security","text":""},{"location":"en/UD5_Spring/4_Spring_Security/#1-https","title":"1. HTTPS","text":"<p>Nowadays, we need to add all we can do to secure our applications. We are going to study about tokens in order to authorize and authenticate our request, but we need an extra layer, https.</p> <p>In this webpage https://tiptopsecurity.com/how-does-https-work-rsa-encryption-explained/ you can find how https works</p>"},{"location":"en/UD5_Spring/4_Spring_Security/#11-certificate","title":"1.1. Certificate","text":"<p>Firstly, we need to generate certificates, or buy it. We will use <code>keytool</code> tool included with java development kit in order to generate. This command generates a pair (public and private) certificate.</p> Bash<pre><code>keytool -genkeypair -alias joange -keyalg RSA -keysize 2048\n-storetype PKCS12 -keystore jgce.p12 -validity 3650\n</code></pre> <p>After running this command, we must answer about who we are, as follows:</p> <p></p>"},{"location":"en/UD5_Spring/4_Spring_Security/#12-configure-spring","title":"1.2. Configure Spring","text":"<p>Once the process has finished, we must add the certificate inside our project. For instance inside <code>/resources/keystore</code>. Finally, we must load the certificate and enable SSL, simply adding this lines on <code>application.properties</code>:</p> Bash<pre><code># The format used for the keystore.\nserver.ssl.key-store-type=PKCS12\n# The path to the keystore containing the certificate\nserver.ssl.key-store=classpath:keystore/jgce.p12\n# The password used to generate the certificate\nserver.ssl.key-store-password=joangeca\n# The alias mapped to the certificate\nserver.ssl.key-alias=joange\n\n# Use HTTPS instead of HTTP\nserver.ssl.enabled=true\n</code></pre> <p></p> <p>And it is all, when Spring starts we will see that is working with <code>https</code> protocol:</p> Bash<pre><code>2023-01-13 08:29:37.267  INFO 83291 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 9091 (https)\n</code></pre> <p></p> <p>and in the request probably browsers will not trust with our certificate (we must add a confidence exception):</p> <p></p>"},{"location":"en/UD5_Spring/4_Spring_Security/#2-spring-security","title":"2. Spring Security","text":"<p>Spring Security is an umbrella project that group all mechanisms referent to security. We need to add:</p> XML<pre><code>&lt;dependency&gt;\n&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n&lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; \n&lt;/dependency&gt;\n</code></pre> <p>and magically:</p> <ul> <li>The default configuration is enabled, through a filter, called <code>SpringSecurityFilterChain</code>.</li> <li>A bean of type <code>UserDetailsService</code> is created with a user named user and a random password that is printed by the console.</li> <li>The filter is registered in the servlet container for all requests.</li> </ul> <p>Although you have not configured much, it has many consequences:</p> <ul> <li>Requires authentication to interact with our application</li> <li>Generates a default login form.</li> <li>Generates a logout mechanism</li> <li>Protect password storage with <code>BCrypt</code>.</li> <li>Provides against CSRF attacks, Session Fixation, Clickjacking...</li> </ul> <p>We can create a configuration class, with this content:</p> Java<pre><code>@Configuration\npublic class SecurityConfig {\n\n}\n</code></pre> <p>Note</p> <p>We will come back to this class to add more configurations. Most interesting is method configure, and creation of several Beans used by another classes.</p>"},{"location":"en/UD5_Spring/4_Spring_Security/#21-users-data-for-authentication-and-authorization-models","title":"2.1. Users Data for Authentication and Authorization (Models)","text":"<p>Important</p> <p>From now, this sample is based from a famous webpage https://www.bezkoder.com. We explain all necessary from the sample who you can view here.</p> <p>In this section we are going to prepare our application to identify users, with several roles. With these roles, we could grant access or not to several resources.</p>"},{"location":"en/UD5_Spring/4_Spring_Security/#22-user-roles","title":"2.2. User &amp; Roles","text":"<p>To do this, we net to create a <code>User</code> class, to store this information in our database. This user could have a collection of roles. We can do it with a many-to-many relationship.</p> Java<pre><code>public enum ERole {\n  ROLE_USER,\n  ROLE_MODERATOR,\n  ROLE_ADMIN\n}\n</code></pre> <p>based on this enumeration, we will do a <code>Role</code> class to store the roles that our application will support:</p> Java<pre><code>@Data\n@Entity\n@Table(name = \"roles\")\npublic class Role {\n  private Integer id;\n  private ERole name;\n}\n</code></pre> <p>finally, then a <code>User</code> class as follows. We add new annotations of validation:</p> Java<pre><code>@Entity\n@Table(name = \"users\", \n    uniqueConstraints = { \n      @UniqueConstraint(columnNames = \"username\"),\n      @UniqueConstraint(columnNames = \"email\") \n    })\npublic class User {\n  @Id\n  @GeneratedValue(strategy = GenerationType.IDENTITY)\n  private Long id;\n\n  @NotBlank\n  @Size(max = 20)\n  private String username;\n\n  @NotBlank\n  @Size(max = 50)\n  @Email\n  private String email;\n\n  @NotBlank\n  @Size(max = 120)\n  private String password;\n\n  @ManyToMany(fetch = FetchType.LAZY)\n  @JoinTable( name = \"user_roles\", \n        joinColumns = @JoinColumn(name = \"user_id\"), \n        inverseJoinColumns = @JoinColumn(name = \"role_id\"))\n  private Set&lt;Role&gt; roles = new HashSet&lt;&gt;();\n\n  public User() {\n  }\n\n  public User(String username, String email, String password) {\n    this.username = username;\n    this.email = email;\n    this.password = password;\n  }\n\n}\n</code></pre>"},{"location":"en/UD5_Spring/4_Spring_Security/#23-user-roles-repository","title":"2.3. User &amp; Roles Repository","text":"<p>We need to create our repos about last entities, creating interfaces like we normally create.</p> Java<pre><code>@Repository\npublic interface RoleRepository extends JpaRepository&lt;Role, Long&gt; {\n  Optional&lt;Role&gt; findByName(ERole name);\n}\n\n@Repository\npublic interface UserRepository extends JpaRepository&lt;User, Long&gt; {\n  Optional&lt;User&gt; findByUsername(String username);\n\n  Boolean existsByUsername(String username);\n\n  Boolean existsByEmail(String email);\n}\n</code></pre> <p>We also add methods to check User existance by name and email, and methods to find by name, either <code>User</code> and <code>Role</code></p>"},{"location":"en/UD5_Spring/4_Spring_Security/#24-userdetails","title":"2.4. UserDetails","text":"<p>Spring needs that someone implements <code>UserDetails</code> interface, very important because Spring Security will use a <code>UserDetails</code>. <code>UserDetails</code> contains necessary information to build an <code>Authentication</code> object from DAOs or other source of security data. We create a class, called <code>UserDetailsImpl</code>, who:</p> <ul> <li>Must have <code>username</code> and <code>passsord</code> fields, and getters. You must respect names, any changes is prohibited. These methods will be used by authentication classes.</li> <li>Override methods from <code>UserDetails</code>, for instance <code>getAuthorities()</code> and several methods to control if the user is blocked, expired, etc.</li> </ul> <p>Full class:</p> Java<pre><code>public class UserDetailsImpl implements UserDetails {\n  private static final long serialVersionUID = 1L;\n\n  private Long id;\n  private String username;\n  private String email;\n\n  @JsonIgnore\n  private String password;\n\n  private Collection&lt;? extends GrantedAuthority&gt; authorities;\n\n  public UserDetailsImpl(Long id, String username, String email, String password,\n      Collection&lt;? extends GrantedAuthority&gt; authorities) {\n    this.id = id;\n    this.username = username;\n    this.email = email;\n    this.password = password;\n    this.authorities = authorities;\n  }\n\n  public static UserDetailsImpl build(User user) {\n    List&lt;GrantedAuthority&gt; authorities = user.getRoles().stream()\n        .map(role -&gt; new SimpleGrantedAuthority(role.getName().name()))\n        .collect(Collectors.toList());\n\n    return new UserDetailsImpl(\n        user.getId(), \n        user.getUsername(), \n        user.getEmail(),\n        user.getPassword(), \n        authorities);\n  }\n\n  @Override\n  public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() {\n    return authorities;\n  }\n\n\n  @Override\n  public boolean isAccountNonExpired() {\n    return true;\n  }\n\n  @Override\n  public boolean isAccountNonLocked() {\n    return true;\n  }\n\n  @Override\n  public boolean isCredentialsNonExpired() {\n    return true;\n  }\n\n  @Override\n  public boolean isEnabled() {\n    return true;\n  }\n\n}\n</code></pre> <p>Notice than:</p> <ul> <li>We use <code>private Collection&lt;? extends GrantedAuthority&gt; authorities;</code> to store the authorities (i.e. roles) in format who is understood by Spring Security.</li> <li>Instead of create a constructor, we create a <code>builder()</code>, who recieve a <code>User</code>, extract the information from it and transform the <code>List&lt;Role&gt;</code> into authorities, and then, the builder call to constructor.</li> </ul> <p>Instead of create a User and Role <code>Service</code>, we will create a <code>UserDetailSeriveImpl</code> (who implements Spring's <code>UserDetailService</code>), in order to recover a User from repository, and then returns a <code>UserDetailImpl</code>, as follows:</p> Java<pre><code>@Service\npublic class UserDetailsServiceImpl implements UserDetailsService {\n  @Autowired\n  UserRepository userRepository;\n\n  @Override\n  @Transactional\n  public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n    User user = userRepository.findByUsername(username)\n        .orElseThrow(() -&gt; new UsernameNotFoundException(\"User Not Found with username: \" + username));\n\n    return UserDetailsImpl.build(user);\n  }\n\n}\n</code></pre>"},{"location":"en/UD5_Spring/4_Spring_Security/#25-payloads-dtos","title":"2.5. Payloads DTO's","text":"<p>In this section we are going to see the necessary classes who store information to:</p> <ul> <li>Signup a new User, to receive information from client and store a new user. This class is <code>SignupRequest</code></li> <li>Signin a User, to login in our system. This class is <code>LoginRequest</code></li> <li>JwtResponse, related as response to the signin request. This response will contain a JWT Token, used to Authorize subsequent request. This class is <code>JwtResponse</code></li> </ul>"},{"location":"en/UD5_Spring/4_Spring_Security/#26-signuprequest","title":"2.6. SignupRequest","text":"<p>This class contains information who register a new user. Is contains validation annotations. </p> Java<pre><code>public class SignupRequest {\n  @NotBlank\n  @Size(min = 3, max = 20)\n  private String username;\n\n  @NotBlank\n  @Size(max = 50)\n  @Email\n  private String email;\n\n  private Set&lt;String&gt; role;\n\n  @NotBlank\n  @Size(min = 6, max = 40)\n  private String password;\n\n  // get and set\n</code></pre> <p>To send this information, the json object will be something like:</p> JSON<pre><code>{\n    \"username\":\"joange\",\n    \"email\":\"jg.camarenaestruch@edu.gva.es\",\n    \"password\":\"123456\",\n    \"role\":[\"admin\",\"user\"]\n}\n</code></pre>"},{"location":"en/UD5_Spring/4_Spring_Security/#27-loginrequest","title":"2.7. LoginRequest","text":"<p>Very easy class:</p> Java<pre><code>public class LoginRequest {\n    @NotBlank\n  private String username;\n\n    @NotBlank\n    private String password;\n</code></pre> <p>and the json object is something like:</p> JSON<pre><code>{\n    \"username\":\"joange\",\n    \"password\":\"123456\"\n}\n</code></pre> <p>Note</p> <p>In this class we could mark fields as requireds, with annotation <code>@NotBlank</code> from <code>javax.validation.constraints.NotBlank</code>. You must add: XML<pre><code>    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n</code></pre></p>"},{"location":"en/UD5_Spring/4_Spring_Security/#28-jwtresponse","title":"2.8. JwtResponse","text":"<p>This DTO class is the class that is returned as a login request. It should contain little information about our user and must important think, a JWT token. This token will be used to authorize us, as we will study in next section.</p> Java<pre><code>public class JwtResponse {\n  private String token;\n  private String type = \"Bearer\";\n  private Long id;\n  private String username;\n  private String email;\n  private List&lt;String&gt; roles;\n</code></pre> <p>Be notice than:</p> <ul> <li>Fields on this clase will be populated from <code>User</code> class, like a DTO.</li> <li>We have changed role format, from <code>Role</code> class to <code>String</code>, with a better management in clients.</li> <li>The <code>String token</code> is where the JWT token is stored. In fact a token is a String, as we will show now.</li> </ul>"},{"location":"en/UD5_Spring/4_Spring_Security/#31-what-is-a-token","title":"3.1. What is a token?","text":"<p>JSON Web Tokens (JWT) have been introduced as a method of secure communication between two parties. It was introduced with the RFC 7519 specification by the Internet Engineering Task Force (IETF). Although we can use <code>JWT</code> with any kind of communication method, nowadays, JWT is very popular for handling authentication and authorization over HTTP.</p> <p>First, you'll need to know some features of HTTP:</p> <ul> <li>HTTP is a stateless protocol, which means that an HTTP request does not maintain state. The server is not aware of any previous requests sent by the same client.</li> <li>HTTP requests should be standalone. They must include information about previous requests that the user made in the same request.</li> </ul> <p>There are a few ways to do this, but the most popular way is to set a session_id, which is a reference to the user's information:</p> <ul> <li>The server will store this session ID in memory or in a database. The client will send each request with this session ID.</li> <li>The server can then obtain information about the client using this reference.</li> <li>Normally, this session ID is sent to the user as a cookie.</li> </ul> <p>Here is the diagram of how session-based authentication works.</p> <p></p> <p>On the other hand, with JWT, when the client sends an authentication request to the server, it will send a token (token) JSON to the client, which includes all the information about the user along with the response.</p> <p>The client will submit this token with all subsequent requests. Therefore, the server will not have to store any information about the session. But there is a problem with this approach. Anyone can send a fake request with a fake JSON token and pretend to be someone they're not.</p> <p>For example, let's say that after authentication, the server returns a JSON object to the client with the username and expiration time. So, since the JSON object is readable, anyone can edit this information and submit a request for it. The problem is that there is no way to validate this request.</p> <p>This is where the witness signature comes in. So instead of just sending a normal JSON token, the server will send a signed token, which can verify that the information doesn't change.</p> <p></p>"},{"location":"en/UD5_Spring/4_Spring_Security/#32-structure-of-jwt","title":"3.2. Structure of JWT","text":"<p>Let's talk about the structure of a JWT through a sample token:</p> <p></p> <p>As you can see, there are three sections to this JWT, each separated by a dot.</p> <p>Note</p> <p><code>Base64</code> encoding is a way to ensure that the data is not corrupted, as they do not compress or encrypt the data, but simply encode it in a way that most systems can understand. You can read any Base64 encoded text simply by decoding them.</p> <p>First section of the JWT is a header, which is a Base64-encoded string. If you decode the header, it would look something like this:</p> JSON<pre><code>{\n     \"alg\":\"HS256\"\n     \"type\":\"JWT\"\n}\n</code></pre> <p>The header section contains the hash algorithm, which was used to generate the token's sign and type.</p> <p>The second section is the payload containing the JSON object that was sent back to the user. Since it is only Base64 encoded, anyone can easily decode it. It is mandatory not to include sensitive data in JWTs, such as passwords or personally identifiable information.</p> <p>Typically, the body of the JWT will look something like this, although it doesn't necessarily apply:</p> JSON<pre><code>{\n   \"sub\": \"1234567890\",\n   \"name\": \"John Doe\",\n   \"iat\": 1516239022\n}\n</code></pre> <p>Note</p> <p>Most of the time, the <code>sub</code> property will contain the user ID, the <code>iat</code> (issued at) property, abbreviated as <code>issued at</code>, is the token's issuance timestamp.  You may also see some common properties, such as <code>eat</code> or <code>exp</code>, which is the token's expiration time.</p> <p>All these properties are the claims of the token, the information.</p> <p>The final section is the token signature. This is generated by hashing the string created with previous two sections and a secret password, using the algorithm mentioned in the header section.</p> <p>You can visit https://www.javainuse.com/jwtgenerator and https://jwt.io to generate tokens and test with several data, secrets and hashes.</p>"},{"location":"en/UD5_Spring/4_Spring_Security/#33-jwt-library-class","title":"3.3. JWT Library class","text":"<p>We must update our <code>pom.xml</code> with dependencies:</p> XML<pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;\n  &lt;artifactId&gt;jjwt-api&lt;/artifactId&gt;\n  &lt;version&gt;0.10.7&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;\n  &lt;artifactId&gt;jjwt-impl&lt;/artifactId&gt;\n  &lt;version&gt;0.10.7&lt;/version&gt;\n  &lt;scope&gt;runtime&lt;/scope&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;\n  &lt;artifactId&gt;jjwt-jackson&lt;/artifactId&gt;\n  &lt;version&gt;0.10.7&lt;/version&gt;\n  &lt;scope&gt;runtime&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre> <p>This class is who generate and checks token integrity. Let's go to show this class and what elements it needs. This class will be a library class with methods to create token, validate it and extract information from it. We will find this class with names like <code>JWTUtils</code> or <code>JWTTokenProvider</code>. This class skeleton is like follows:</p> <ul> <li>Loading or definition of token constants</li> <li>Method to generate JWT from a <code>Authentication</code> object</li> <li>Methods to get information from the token</li> <li>Method to validate token (signature)</li> </ul> Java<pre><code>// constants and secrets\n\n  public String generateJwtToken(Authentication authentication);\n\n  public boolean validateJwtToken(String authToken);\n\n  public String getUserNameFromJwtToken(String token);\n\n  // another methods.\n</code></pre>"},{"location":"en/UD5_Spring/4_Spring_Security/#34-token-generation","title":"3.4. Token generation","text":"<p>Let's go to see each method. Firt, we find an <code>Authentication</code> object. We need to now that this object represents another token (not our JWT) with the credentials of the object we want to identify.</p> Java<pre><code>public String generateJwtToken(Authentication authentication) {\n\n    UserDetailsImpl userPrincipal = (UserDetailsImpl) authentication.getPrincipal();\n\n    return Jwts.builder()\n        .setSubject((userPrincipal.getUsername()))\n        .setIssuedAt(new Date())\n        .setExpiration(new Date((new Date()).getTime() + jwtExpirationMs))\n        .signWith(SignatureAlgorithm.HS512, jwtSecret)\n        .compact();\n  }\n</code></pre> <p>We see that:</p> <ul> <li>We recieve an <code>Authentication</code> objects, whom we have saved a <code>UserDetailsImpl</code> inside it. As all user details implementations, we could get username, and we use it to set the token subject.</li> <li>We set IAT tho the current time stamp.</li> <li>We establish the expiration time.</li> <li>We set the cipher algorithm and the secret word, and the token is ready to...</li> <li>the compact() method creates and transform the token to String</li> </ul> <p>Note</p> <p>The <code>jwtSecret</code> is the password we nedd. It is a good idea to store it inside <code>application.properties</code> and recover it to a variable, as <code>jwtExpiration</code>. We could use <code>@Value</code> annotation:</p> Java<pre><code>  @Value(\"${app.jwtSecret}\")\n  private String jwtSecret;\n\n  @Value(\"${app.jwtExpirationMs}\")\n  private int jwtExpirationMs;\n</code></pre>"},{"location":"en/UD5_Spring/4_Spring_Security/#35-token-validation","title":"3.5. Token validation","text":"<p>Very easy method:</p> Java<pre><code>public boolean validateJwtToken(String authToken) {\n    try {\n      Jwts.parser().setSigningKey(jwtSecret).parseClaimsJws(authToken);\n      return true;\n    } catch (SignatureException e) {\n      logger.error(\"Invalid JWT signature: {}\", e.getMessage());\n    } catch (MalformedJwtException e) {\n      logger.error(\"Invalid JWT token: {}\", e.getMessage());\n    } catch (ExpiredJwtException e) {\n      logger.error(\"JWT token is expired: {}\", e.getMessage());\n    } catch (UnsupportedJwtException e) {\n      logger.error(\"JWT token is unsupported: {}\", e.getMessage());\n    } catch (IllegalArgumentException e) {\n      logger.error(\"JWT claims string is empty: {}\", e.getMessage());\n    }\n</code></pre> <p>In this method we check if it is a valida token. We use <code>parseClaimsJws(String token)</code>, after assign secret password to get the claims. If exists any problem with the token integrity, could appear a Exception. We get the claims inside a <code>try-catch</code> block and inform if something happens. We will return <code>true</code> if no Exception was catched.</p> <p>Note</p> <p>Remember that the claims are the content of the token payload. We do not need in this method the claims, only check if all is good</p>"},{"location":"en/UD5_Spring/4_Spring_Security/#4-authentication-controller","title":"4. Authentication Controller","text":"<p>Now we also know how to create tokens and the <code>User</code> structure in our database, is time to expose our path in order to register and login users. And so, only two methods are mandatory. The class could be something like:</p> Java<pre><code>@CrossOrigin(origins = \"*\", maxAge = 3600)\n@RestController\n@RequestMapping(\"/api/auth\")\npublic class AuthController {\n    ...\n}\n</code></pre> <ul> <li><code>@CrossOrigin</code> Annotation for permitting cross-origin requests on specific handler classes and/or handler methods. Processed if an appropriate HandlerMapping is configured. Cross-Origin Resource Sharing (CORS) is a security concept that allows restricting the resources implemented in web browsers. It prevents the JavaScript code producing or consuming the requests against different origin. For example, your web application is running on 8080 port and by using JavaScript you are trying to consume RESTful web services from 9090 port. Under such situations, you will face the Cross-Origin Resource Sharing security issue on your web browsers.</li> <li><code>@RequestMapping(\"/api/auth\")</code> tells that all controllers are inside <code>/api/auth</code> path.</li> </ul> <p>Let's go to see them, but before studying methods, this class has these required variables:</p> <ul> <li><code>@Autowired AuthenticationManager authenticationManager;</code> \u2192 used to create an <code>Authentication</code> token, used by Spring security context and by token generator.</li> <li><code>@Autowired UserRepository userRepository;</code> \u2192 used to access and save users.</li> <li><code>@Autowired RoleRepository roleRepository;</code> \u2192 to check if the roles that come in the request are valids.</li> <li><code>@Autowired PasswordEncoder encoder;</code>  \u2192 used to encrypt user password</li> <li><code>@Autowired JwtUtils jwtUtils;</code> \u2192 used to create JWT tokens.</li> </ul> <p>Now that we have presented the actors, let's go to the function</p>"},{"location":"en/UD5_Spring/4_Spring_Security/#41-signup-new-user","title":"4.1. Signup (new user)","text":"<p>The method in charge to create new users, will receive a <code>SignupRequest</code> with this data:</p> JSON<pre><code>{\n    \"username\":\"joange\",\n    \"email\":\"jg.camarenaestruch@edu.gva.es\",\n    \"password\":\"123456\",\n    \"role\":[\"admin\",\"user\"]\n}\n</code></pre> <p>the method body is following, and let we see by blocks:</p> Java<pre><code>@PostMapping(\"/signup\")\n  public ResponseEntity&lt;?&gt; registerUser(@Valid @RequestBody SignupRequest signUpRequest) {\n    if (userRepository.existsByUsername(signUpRequest.getUsername())) {\n      return ResponseEntity\n          .badRequest()\n          .body(new MessageResponse(\"Error: Username is already taken!\"));\n    }\n\n    if (userRepository.existsByEmail(signUpRequest.getEmail())) {\n      return ResponseEntity\n          .badRequest()\n          .body(new MessageResponse(\"Error: Email is already in use!\"));\n    }\n    // Create new user's account\n    User user = new User(signUpRequest.getUsername(), \n               signUpRequest.getEmail(),\n               encoder.encode(signUpRequest.getPassword()));\n</code></pre> <p>In this first part:</p> <ul> <li>We check if any user exists with same username or email, asking our repository. If any error appears, we will return a <code>ResponseEntity</code> as a bad request with a description message. </li> <li>Finally, we create a ner User with username, email and an encrypted password.</li> </ul> <p>Next block is responsible to get the roles (stored in a String's JSONArray) and transform to a <code>Set&lt;Role&gt;</code>. </p> Java<pre><code>    Set&lt;String&gt; strRoles = signUpRequest.getRole();\n    Set&lt;Role&gt; roles = new HashSet&lt;&gt;();\n\n    if (strRoles == null) {\n      Role userRole = roleRepository.findByName(ERole.ROLE_USER)\n          .orElseThrow(() -&gt; new RuntimeException(\"Error: Role is not found.\"));\n      roles.add(userRole);\n    } else {\n      strRoles.forEach(role -&gt; {\n        switch (role) {\n        case \"admin\":\n          Role adminRole = roleRepository.findByName(ERole.ROLE_ADMIN)\n              .orElseThrow(() -&gt; new RuntimeException(\"Error: Role is not found.\"));\n          roles.add(adminRole);\n\n          break;\n        case \"mod\":\n          Role modRole = roleRepository.findByName(ERole.ROLE_MODERATOR)\n              .orElseThrow(() -&gt; new RuntimeException(\"Error: Role is not found.\"));\n          roles.add(modRole);\n\n          break;\n        default:\n          Role userRole = roleRepository.findByName(ERole.ROLE_USER)\n              .orElseThrow(() -&gt; new RuntimeException(\"Error: Role is not found.\"));\n          roles.add(userRole);\n        }\n      });\n    }\n\n    user.setRoles(roles);\n</code></pre> <p>Let's go to see:</p> <ul> <li>First we check if the role set is empty. If true, we set a new <code>Role</code> with <code>ERole.ROLE_USER</code> by default.</li> <li>Otherwise, we must loop over all roles we get, checking each role in database and creating as appropiate <code>Role</code> object.</li> </ul> <p>Finally, we set the <code>Set&lt;Role&gt;</code> to the user created in first block, and in the third block we only need to store new user with <code>UserRepositoy</code> and send an ok response to client.</p> Java<pre><code>    userRepository.save(user);\n\n    return ResponseEntity.ok(new MessageResponse(\"User registered successfully!\"));\n  }\n</code></pre>"},{"location":"en/UD5_Spring/4_Spring_Security/#42-signin-register-or-signin","title":"4.2. Signin (register or signin)","text":"<p>Note</p> <p>In spanish:</p> <ul> <li>Signin: registrarse, acceder al login.</li> <li>Signup: inscribirse, darse de alta.</li> </ul> <p>This controller is used to create login a user in our app. As we have studied, the DTO that we recieve in the <code>HTTP_POST</code> is <code>LoginRequest</code> class, like this:</p> JSON<pre><code>{\n    \"username\":\"joange\",\n    \"password\":\"123456\"\n}\n</code></pre> <p>And the method in charge is:</p> Java<pre><code>@PostMapping(\"/signin\")\n  public ResponseEntity&lt;?&gt; authenticateUser(@Valid @RequestBody LoginRequest loginRequest) {\n\n    Authentication authentication = authenticationManager.authenticate(\n        new UsernamePasswordAuthenticationToken(loginRequest.getUsername(), loginRequest.getPassword()));\n\n    SecurityContextHolder.getContext().setAuthentication(authentication);\n    String jwt = jwtUtils.generateJwtToken(authentication);\n\n    UserDetailsImpl userDetails = (UserDetailsImpl) authentication.getPrincipal();  \n\n    List&lt;String&gt; roles = userDetails.getAuthorities().stream()\n        .map(item -&gt; item.getAuthority())\n        .collect(Collectors.toList());\n\n    return ResponseEntity.ok(new JwtResponse(jwt, \n                         userDetails.getId(), \n                         userDetails.getUsername(), \n                         userDetails.getEmail(), \n                         roles));\n  }\n</code></pre> <p>Take into account:</p> <ul> <li><code>@Valid</code> annotation check that json object match with <code>LoginRequest</code> class (take a look to this attribute class annotations).</li> <li>We create an <code>Authentication</code> token (this is not the JWT Token !!!) with username and password recieved. Password is not encripted yet.</li> <li>Last <code>Authentication</code> token is setted to the <code>SecurityContextHolder</code>, and object that contains a minimum security in a thread level. In this step is when Spring security subsystem works, asking <code>UserDetailService</code> for a user with this username and password in our database, and it is stored in a <code>UserDetails</code> Bean in memory. If any credential is wrong, it will throw an Exception, that itwill be managed by our system (we will study this later).</li> <li>With this token (authentication) we generate our token. Remember that inside <code>jwtUtils</code>, we only get username in order to generate our token subject.</li> <li>We get the <code>UserDetails</code> object with <code>getPrincipal()</code> method, and</li> <li>Transform the List of authorities into a List of String (have you studied how to map lists? And filter? And reduce?)</li> <li>Finally, we create and return a <code>ResponseEntity</code>, with http_Status ok, with a <code>JwtResponse</code> inside it. Token plus attributes.  A sample of JWTrespone is:</li> </ul> JSON<pre><code>{\n    \"id\": 1,\n    \"username\": \"joange\",\n    \"email\": \"joange.sales@edu.gva.es\",\n    \"roles\": [\n        \"ROLE_USER\",\n        \"ROLE_ADMIN\"\n    ],\n    \"accessToken\": \"eyJhbGciOiJIUzUxMiJ9.\n    eyJzdWIiOiJqb2FuZ2UiLCJpYXQiOjE2NzM2MjY1OTYsImV4cCI6MTY3MzcxMjk5Nn0.\n    6yMcAYYvHsQ4XKmmT6tr0PmkpJKfPusxnMVHDmIl4WJQ_KtaY08vbt27KdvJHkWCZPO\n    4dA2a2HtnAq13vMKAPw\",\n    \"tokenType\": \"Bearer\"\n}\n</code></pre> <p>Note</p> <p>Last token has extra newlines in order to avoid exit out of paper width, is one full String</p> <p>if the username is not found on database the following response is created by our system:</p> JSON<pre><code>{\n    \"path\": \"/api/auth/signin\",\n    \"error\": \"Unauthorized\",\n    \"message\": \"Bad credentials\",\n    \"status\": 401\n}\n</code></pre>"},{"location":"en/UD5_Spring/4_Spring_Security/#5-tokens-working","title":"5. Tokens working","text":"<p>Now that user registration and login are implemented, let's ask a question, What do the client application does with the JWTResponse he has received afetr login process? User data is normally used to interface (full name, avatar, etc.). But what happens with tokens? </p> <p>The answer, as we will study later is store it, and then send to the server in each request as Authorization and Authentication method.</p>"},{"location":"en/UD5_Spring/4_Spring_Security/#51-sending-tokens","title":"5.1. Sending tokens","text":"<p>To send a token, we need to attach it in the <code>Header</code> section, creating an <code>Authorization</code> parameter with value <code>Bearer token_recieved</code>, as you can see on this Postman screenshot:</p> <p></p> <p>Important</p> <p>Remember: word <code>Bearer</code> plus white space plus the whole token recieved (as String)</p> <p>Ok thus the client application will send us the token through the request, but, how does our server to get and check the token. The answer is than we have to say it in a filter way. </p>"},{"location":"en/UD5_Spring/4_Spring_Security/#6-security-config","title":"6. Security Config","text":"<p>The class that configure security is <code>WebSecurityConfig</code>. Let's go to explain it by blocks again. This class is composed by a set of Beans who will be used in all project (remember code injection). We will explain only necessary.</p> Java<pre><code>@Configuration\n@EnableGlobalMethodSecurity(\n    prePostEnabled = true)\npublic class WebSecurityConfig { \n\n}\n</code></pre> <p>This <code>@Configuration</code> tells Spring to load this class. We say that Spring allow to pre and post filters annotations (let's study later)</p> Java<pre><code>  @Autowired\n  UserDetailsServiceImpl userDetailsService;\n\n  @Autowired\n  private AuthEntryPointJwt unauthorizedHandler;\n\n  @Bean\n  public AuthTokenFilter authenticationJwtTokenFilter() {\n    return new AuthTokenFilter();\n  }\n</code></pre> <p>These beans will be explained later. In a few words are responsible for manage errors as Exception handler and how to apply filter chains to authenticate users.</p> Java<pre><code>  @Bean\n  public DaoAuthenticationProvider authenticationProvider() {\n      DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();\n\n      authProvider.setUserDetailsService(userDetailsService);\n      authProvider.setPasswordEncoder(passwordEncoder());\n\n      return authProvider;\n  }\n</code></pre> <p>This Bean use the <code>UserDetailService</code> and <code>PasswordEncoder</code> to do the authentication process. This mean access the database and check user and password (with the same encoder we use to store users). Next Beans create AuthenticationManager and encoder.</p> Java<pre><code>  @Bean\n  public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig) throws Exception {\n    return authConfig.getAuthenticationManager();\n  }\n\n  @Bean\n  public PasswordEncoder passwordEncoder() {\n    return new BCryptPasswordEncoder();\n  }\n</code></pre> <p>And finally one of the most important (and hard to understand) configuration, the security filter chain. Filter chain are code that we put in the middle between client and server. These filters intercepts the request, analyze it and then, dependeding the result of the filter, simple pass the control to the server or send a response to the client. This filter could change the request, adding or removing information that will be used by the server.</p> Java<pre><code>  @Bean\n  public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n    http.cors().and().csrf().disable()\n        .exceptionHandling().authenticationEntryPoint(unauthorizedHandler).and()\n        .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()\n        .authorizeRequests().antMatchers(\"/api/auth/**\").permitAll()\n        .antMatchers(\"/api/test/**\").permitAll()\n        .anyRequest().authenticated();\n\n    http.authenticationProvider(authenticationProvider());\n\n    http.addFilterBefore(authenticationJwtTokenFilter(), UsernamePasswordAuthenticationFilter.class);\n\n    return http.build();\n  }\n</code></pre> <p>Take notice that we:</p> <ul> <li>Enable CORS (Cross-Origin Requests) and disble CSRF (Cross Site Request Forgery)</li> <li>Set the authenticationEntryPoint</li> <li>Allow access to all paths in <code>/api/auth/**</code></li> <li>Allow access to all paths in <code>/api/auth/**</code></li> <li>Any onther request will need to be authenticated</li> </ul> <p>Finaly we add the before filter and the authenticationprovider. </p> <p>In a relaxed view, to understand it, filters are combined with anotations that where and when we have to check Authentication and Authorization.</p> <p></p>"},{"location":"en/UD5_Spring/4_Spring_Security/#61-authtokenfilter","title":"6.1. AuthTokenFilter","text":"<p>This class contains the process of the token received from clients. It must implement <code>OncePerRequestFilter</code> and override <code>doFilterInternal()</code>. </p> Java<pre><code>@Override\n  protected void doFilterInternal(\n    HttpServletRequest request, \n    HttpServletResponse response, \n    FilterChain filterChain) throws ServletException, IOException {\n    try {\n      String jwt = parseJwt(request);\n      if (jwt != null &amp;&amp; jwtUtils.validateJwtToken(jwt)) {\n        String username = jwtUtils.getUserNameFromJwtToken(jwt);\n\n        UserDetails userDetails = userDetailsService.loadUserByUsername(username);\n        UsernamePasswordAuthenticationToken authentication =\n            new UsernamePasswordAuthenticationToken(\n                userDetails,\n                null,\n                userDetails.getAuthorities());\n        authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));\n\n        SecurityContextHolder.getContext().setAuthentication(authentication);\n      }\n    } catch (Exception e) {\n      logger.error(\"Cannot set user authentication: {}\", e);\n    }\n\n    filterChain.doFilter(request, response);\n  }\n</code></pre> <p>In our word this method will be executed when a request is done. and:</p> <ul> <li>Extract token from the request, returning only relevant information (removes <code>Bearer</code>).</li> <li>The check that the token is valid, and:</li> <li>Extract the username (is in the token's payload) and</li> <li>Get that <code>UserDetails</code> and create a <code>UsernamePasswordAuthenticationToken</code> to be injected throw rest of the request-response, obviously with authorities.</li> <li>Finally, it continues with next filter, if exists, calling <code>filterChain.doFilter(req,res)</code>. If not filter were, then the dispatcher pass control to the controller requested.</li> </ul>"},{"location":"en/UD5_Spring/4_Spring_Security/#62-authentrypoint","title":"6.2. AuthEntryPoint","text":"<p>This class contains code that will be executed when an Exception appears. Then it creates a generic body into the response and create to set an accurate answer to client.</p>"},{"location":"en/UD5_Spring/4_Spring_Security/#7-controller-authorization","title":"7. Controller Authorization","text":"<p>We only rest to say what request need to be Authorized. Remember that with other classes we prepare the Authentication, Who are you?. Now we need to ask What can you do?</p> <p>As we mark in our <code>filterChain</code> we <code>addFilterBefore</code>, to check roles. But, where must we say the roles who catch each request? The answer is easy: the controllers. Let's take a look a test controller with Authorization filter:</p> <p>Java<pre><code>@CrossOrigin(origins = \"*\", maxAge = 3600)\n@RestController\n@RequestMapping(\"/api/test\")\npublic class TestController {\n  @GetMapping(\"/all\")\n  public String allAccess() {\n    return \"Public Content.\";\n  }\n\n  @GetMapping(\"/user\")\n  @PreAuthorize(\"hasRole('USER') or hasRole('MODERATOR') or hasRole('ADMIN')\")\n  public String userAccess() {\n    return \"User Content.\";\n  }\n\n  @GetMapping(\"/mod\")\n  @PreAuthorize(\"hasRole('MODERATOR')\")\n  public String moderatorAccess() {\n    return \"Moderator Board.\";\n  }\n\n  @GetMapping(\"/admin\")\n  @PreAuthorize(\"hasRole('ADMIN')\")\n  public String adminAccess() {\n    return \"Admin Board.\";\n  }\n}\n</code></pre> If:</p> <ul> <li>No annotation appears: all roles can ask for this request</li> <li><code>@PreAuthorize(\"hasRole('role')\")</code> \u2192 This annotation tells the role who is authorized to get this request. You can combine more than one role with <code>or</code></li> </ul>"},{"location":"en/UD5_Spring/4_Spring_Security/#8-exercise-how-to-use-this-project","title":"8. Exercise. How to use this project?","text":"<p>You probably have a API rest unsecured. Now you have the task to merge your API Rest with this secure project, in order to secure and authorize only registered users. It's a hard work, but the results will be very grateful.</p>"},{"location":"en/UD5_Spring/5_Spring_Hateoas/","title":"5. Spring Hateoas","text":""},{"location":"en/UD5_Spring/5_Spring_Hateoas/#1-hateoas","title":"1. HATEOAS","text":"<p>Hateoas (Hypermedia as the engine of application state) is a RESTful API principle defined by Roy Fielding. It mainly means that, client can move by full application only from general ID URI's in hypermedia format. The principle implies that the API should guide the client through the application by returning relevant information about the next potential steps, along with each response.</p> <p>For the connection between the server and the client, Fielding defines these four characteristics:</p> <ul> <li>Unique identification of all resources: all resources must be able to be identified with a URI (Unique Resource Identifier).</li> <li>Interaction with resources through representations: If a client needs a resource, the server sends it a representation (eg, HTML, JSON, or XML) so that the client can modify or delete the original resource.</li> <li>Explicit messages: each message exchanged between the server and the client must contain all the data necessary to understand each other.</li> <li>HATEOAS: This principle also integrates a REST API. This hypermedia-based structure makes it easy for customers to access the application, since they do not need to know anything else about the interface to be able to access and navigate through it.</li> </ul> <p>HATEOAS is, in short, one of the most basic properties of REST APIs and as such, essential in any REST service.</p> <p>A returned value without HATEOAS, with a client data:</p> JSON<pre><code>{\n    \"idCliente\": 3,\n    \"nif\": \"33333333C\",\n    \"nombre\": \"Vicente\",\n    \"apellidos\": \"Mondrag\u00f3n\",\n    \"claveSeguridad\": \"1234\",\n    \"email\": \"vicente.mondragon@tia.es\",\n    \"recomendacion\": {\n      \"idRecomendacion\": 3,\n      \"observaciones\": \"Realiza muchos pedidos\"\n    },\n    \"listaCuentas\": [\n      {\n        \"idCuenta\": 8,\n        \"banco\": \"1001\",\n        \"sucursal\": \"1001\",\n        \"dc\": \"11\",\n        \"numeroCuenta\": \"1000000008\",\n        \"saldoActual\": 7500.0,\n        \"links\": [\n\n        ]\n      },\n      {\n        \"idCuenta\": 10,\n        \"banco\": \"1001\",\n        \"sucursal\": \"1001\",\n        \"dc\": \"11\",\n        \"numeroCuenta\": \"1000000010\",\n        \"saldoActual\": -3500.0,\n        \"links\": [\n\n        ]\n      }\n    ],\n    \"listaDirecciones\": [\n      {\n        \"idDireccion\": 5,\n        \"descripcion\": \"calle de la creu, 2\",\n        \"pais\": \"Espa\u00f1a\",\n        \"cp\": \"46701\"\n      }\n    ]\n  }\n</code></pre> <p>Notice that:</p> <ul> <li>We have got all client data</li> <li>We don't know how to get data from specific related fields, like <code>Direccion</code> or <code>Cuenta</code></li> </ul> <p>The same request with HATEOAS:</p> JSON<pre><code>{\n  \"idCliente\": 3,\n  \"nif\": \"33333333C\",\n  \"nombre\": \"Vicente\",\n  \"apellidos\": \"Mondrag\u00f3n\",\n  \"claveSeguridad\": \"1234\",\n  \"email\": \"vicente.mondragon@tia.es\",\n  \"links\": [\n    {\n      \"rel\": \"self\",\n      \"href\": \"http://localhost:9090/clientes/3\"\n    },\n    {\n      \"rel\": \"listaDirecciones\",\n      \"href\": \"http://localhost:9090/clientes/3/direcciones\"\n    },\n    {\n      \"rel\": \"listaCuentas\",\n      \"href\": \"http://localhost:9090/clientes/3/cuentas\"\n    }\n  ]\n}\n</code></pre> <p>As you can see:</p> <ul> <li>Only data from a client is sent</li> <li>We have links, with clear URI's to get specific information of that client</li> </ul> <p>and most important If the server changes its structure, it will send updated links, and client will work without any problems</p>"},{"location":"en/UD5_Spring/5_Spring_Hateoas/#2-adding-hateoas","title":"2. Adding HATEOAS","text":""},{"location":"en/UD5_Spring/5_Spring_Hateoas/#21-libraries","title":"2.1. Libraries","text":"<p>Note</p> <p>In this text, we are going to add HATEOAS capabilities to a RESTfull api developed along the unit.</p> <p>We only need to add this dependency to our <code>pom.xml</code>, supposing we have use a spring starter project:</p> XML<pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n  &lt;artifactId&gt;spring-boot-starter-hateoas&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre> <p>And it is done.</p>"},{"location":"en/UD5_Spring/5_Spring_Hateoas/#22-wrappers","title":"2.2. Wrappers","text":""},{"location":"en/UD5_Spring/5_Spring_Hateoas/#221-starting-point","title":"2.2.1. Starting point","text":"<p>Remember that we have done to our starter project:</p> <ul> <li>Model or DAO classes \u2192 prepared to save information in database. The are mapped with hibernate and are base for our repositories. For instance <code>Cliente</code></li> <li>DTO classes \u2192 prepared to transfer data from and into our model. </li> <li>This class wraps the DAO (adding or removing fields).</li> <li>These classes have method to convert from/to between DAO and DTO.</li> <li>Is service who does the conversion</li> <li>Client will send us information in this DTO classes</li> <li>These classes can be use by either an API Rest or MVC web application.</li> </ul>"},{"location":"en/UD5_Spring/5_Spring_Hateoas/#222-hateoas-wrapper","title":"2.2.2. HATEOAS wrapper","text":"<p>We need to define a new class to wrap our HATEOAS response. </p> <p>Starting from DTO's, it contains all information from a class, own and related (Cliente plus Direccion plus Cuentas). With HATEOAS, as we showed recently, only need Cliente own information and need to generate links to related entities. Then we need to add to the client information the capability to generate and store links. The class that allow it is <code>RepresentationModel&lt;base_class&gt;</code> (full docs here). This will add to our classes:</p> <ul> <li>Structure to store links</li> <li>Methods to add, check and get links</li> </ul> <p>The way to done it is:</p> Java<pre><code>@Data @AllArgsConstructor\npublic class ClienteHATEOAS \n    extends RepresentationModel&lt;ClienteDTO&gt;\n    implements Serializable{\n\n    private static final long serialVersionUID = 1L;\n    private long idCliente;\n    private String nif;\n    private String nombre;\n    private String apellidos;\n    private String claveSeguridad;\n    private String email;\n\n    public static ClienteHATEOAS fromClienteDTO2HATEOAS(ClienteDTO clienteDTO) {\n        return new ClienteHATEOAS(\n                clienteDTO.getIdCliente(),\n                clienteDTO.getNif(),\n                clienteDTO.getNombre(),\n                clienteDTO.getApellidos(),\n                clienteDTO.getClaveSeguridad(),\n                clienteDTO.getEmail());\n    }\n} \n</code></pre> <p>Important</p> <ul> <li>As we have a base API rest working with <code>ClienteDTO</code> we have done this wrapper class from it. </li> <li>Due to HATEOAS is only a response format, you can create it from <code>Cliente</code> as base class, but you must define your service to return <code>Cliente</code> too.</li> <li>Very important to create a conversion method <code>fromClienteDTO2HATEOAS</code>, staying for necessary fields.</li> </ul> <p>Then, we will use <code>add(Link)</code> method in our <code>ClienteHATEOAS</code> wrapper to add as many <code>Link</code> is necessary.</p>"},{"location":"en/UD5_Spring/5_Spring_Hateoas/#3-links","title":"3. Links","text":"<p>Now, the question is how to generate our <code>Link</code> objects in our wrapper classes. We could do it in a creative way, manipulating paths in strings and composing with complicated substring and concatenate methods. </p> <p>But as we now what method is called to each reference, is better to create links obtaining references to the path from methods themselves. To do it, we must use these methods and static calls:</p> Java<pre><code>import org.springframework.hateoas.Link;\nimport static org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.linkTo;\nimport static org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.methodOn;\n\nLink self=linkTo(methodOn(controller_class.class)\n            .methodName(args))\n            .withSelfRel(); // or .withRel(String Link)\n</code></pre> <ul> <li><code>linkTo</code> \u2192 static method who creates a <code>Link</code> from</li> <li><code>methodOn(class)</code> \u2192 search from a controller class for a method</li> <li><code>.methodName(args)</code> \u2192 get a real call for this method</li> <li>And to label the link:</li> <li><code>.withSelfRel()</code> \u2192 create a link called <code>self</code></li> <li><code>.withRel(String Link)</code> \u2192 create a link with given name.</li> </ul> <p>Samples from our <code>Cliente controller</code> in next section </p>"},{"location":"en/UD5_Spring/5_Spring_Hateoas/#31-self-links","title":"3.1. Self links","text":"Java<pre><code>ClienteDTO elCliente=clienteService.getClienteById(idCliente);\n\nLink self=linkTo(methodOn(ClienteController.class)\n            .showClienteById(elCliente.getIdCliente()))\n            .withSelfRel();\n</code></pre> <p>This sample:</p> <ul> <li>Loads a <code>ClienteDTO</code> from current <code>ClienteService</code>. </li> <li>Then looks in <code>ClienteController</code> class for a method called <code>showClienteById</code>.</li> <li>Do an internall call and search for the path and bind argument to the path (do you remember <code>@PathVariable</code>)</li> <li>Finally, it gets the full path with argument and store in the Link with <code>self</code> reference</li> </ul> <p>The result will be something like:</p> JSON<pre><code>{\n  \"rel\": \"self\",\n  \"href\": \"http://localhost:9090/clientes/3\"\n}\n</code></pre>"},{"location":"en/UD5_Spring/5_Spring_Hateoas/#32-reference-links","title":"3.2. Reference links","text":"Java<pre><code>ClienteDTO elCliente=clienteService.getClienteById(idCliente);\n\nLink cuentas=linkTo(methodOn(CuentaController.class)\n                .listCuentasCliente(elCliente.getIdCliente()))\n                .withRel(\"listaCuentas\");\n</code></pre> <p>This sample:</p> <ul> <li>Loads a <code>ClienteDTO</code> from current <code>ClienteService</code>. </li> <li>Then looks in <code>CuentaController</code> class for a method called <code>listCuentasCliente</code>.</li> <li>Do an internall call and search for the path and bind argument to the path (do you remember <code>@PathVariable</code>?)</li> <li>Finally, it gets the full path with argument and store in the Link with <code>self</code> reference</li> </ul> <p>The result will be something like: JSON<pre><code>{\n  \"rel\": \"listaCuentas\",\n  \"href\": \"http://localhost:9090/clientes/3/cuentas\"\n}\n</code></pre></p>"},{"location":"en/UD5_Spring/5_Spring_Hateoas/#33-adding-links-to-our-wrapper-and-full-sample","title":"3.3. Adding links to our wrapper and full sample","text":"<p>Once we have created links, we need to add to our last wrapper class. Simply we will use <code>add()</code> method to do it. In next method it receives a <code>ClienteHATEOAS</code> wrapper (with only data from <code>ClienteDTO</code>) and add as many links as we want:</p> Java<pre><code>private void addLinks(ClienteHATEOAS elCliente) {\n  // self\n  Link self=linkTo(methodOn(ClienteController.class)\n    .showClienteById(elCliente.getIdCliente()))\n    .withSelfRel();\n\n  elCliente.add(self);\n\n  // direcciones\n  Link direcciones=linkTo(methodOn(DireccionController.class)\n      .listDireccionesCliente(elCliente.getIdCliente()))\n      .withRel(\"listaDirecciones\");\n  elCliente.add(direcciones);\n\n  //cuentas\n  Link cuentas=linkTo(methodOn(CuentaController.class)\n      .listCuentasCliente(elCliente.getIdCliente()))\n      .withRel(\"listaCuentas\");\n  elCliente.add(cuentas);\n}\n</code></pre> <p>The controller method to get a <code>Cliente</code> will be (commented):</p> Java<pre><code>@GetMapping(\"/clientes/{idCliente}\")\n  public ResponseEntity&lt;ClienteHATEOAS&gt; showClienteById(@PathVariable Long idCliente){\n\n    // get DTO from Service\n    ClienteDTO elCliente=clienteService.getClienteById(idCliente);\n\n    // if not exists return not found\n    if (elCliente==null)\n      return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND);\n    else {\n\n      // create a ClienteHATEOAS from DTO calling static method\n      ClienteHATEOAS returnCliente=ClienteHATEOAS.fromClienteDTO2HATEOAS(elCliente);\n\n      // add links to ClienteHATEOAS\n      addLinks(returnCliente);\n\n      // return    \n      return new ResponseEntity&lt;&gt;(returnCliente,HttpStatus.OK);\n    }\n  } \n</code></pre> <p>and the result si something like:</p> JSON<pre><code>{\n  \"idCliente\": 3,\n  \"nif\": \"33333333C\",\n  \"nombre\": \"Vicente\",\n  \"apellidos\": \"Mondrag\u00f3n\",\n  \"claveSeguridad\": \"1234\",\n  \"email\": \"vicente.mondragon@tia.es\",\n  \"links\": [\n    {\n      \"rel\": \"self\",\n      \"href\": \"http://localhost:9090/clientes/3\"\n    },\n    {\n      \"rel\": \"listaDirecciones\",\n      \"href\": \"http://localhost:9090/clientes/3/direcciones\"\n    },\n    {\n      \"rel\": \"listaCuentas\",\n      \"href\": \"http://localhost:9090/clientes/3/cuentas\"\n    }\n  ]\n}\n</code></pre>"},{"location":"en/UD5_Spring/5_Spring_Hateoas/#4-pending-work","title":"4. Pending work","text":"<p>Now, getting a simple <code>Cliente</code> request you have access to all information and further actions can be taken based on the metadata in the response representation.</p> <p>This allows the server to change its URI scheme without breaking the client. Also, the application can advertise new capabilities by putting new links or URIs in the representation.</p> <p>You are invited to complete the project develop in class adding necessary wrapper and adding HATEOAS models.</p>"},{"location":"en/UD5_Spring/6_Postman_Swagger/","title":"6. Test. Postman and Swagger","text":""},{"location":"en/UD5_Spring/6_Postman_Swagger/#appendix-postman","title":"Appendix: Postman.","text":"<p>This is free software and, through Postman we can make requests:</p> <ul> <li>GET, to a route, indicating the parameters in all their possibilities, in the Query of the route, as identifiers in the route.</li> <li>POST and PUT, allowing in a very comfortable way to edit the JSON objects in the body (Body) of the request</li> <li>DELETE, to carry out deletions.</li> </ul> <p>Let's see how we can work with the queries to our newly created API. The first step to take is to create a workspace or Workspace, where we will add our requests</p> <p></p> <p>Then, we could start to create <code>http_request</code>: </p> <p></p> <p>we could change the request type in the left selector:</p> <p></p> <p>we could set parameters adding <code>?name=value</code> in the request</p> <p></p> <p>And we can set values of variables in the path simply adding to the request (as a text in the path). Remember that this correspond with <code>PathVariable</code>.</p> <p></p> <p>If we want to send data, in form of JSON object, as forms do, we must set up inside body as <code>raw</code> data as json in a POST or PUT request:</p> <p></p> <p></p> <p>Finally, here you have a <code>DELETE</code> request:</p> <p></p>"},{"location":"en/UD5_Spring/6_Postman_Swagger/#apendix-2-swagger","title":"Ap\u00e8ndix 2: Swagger","text":"<p>In this webpage https://www.baeldung.com/spring-rest-openapi-documentation you can find how to add en emmbedded API test pages to work with the API you are generating easily.</p>"},{"location":"en/UD6_MongoDB/1_NoSQL/","title":"1. NoSQL databases","text":"Version Data Notes Version 1.0 January 2023 Initial version Version 1.0 December 2024 Transaltion and minor changes <p>\u00a9 Joan Gerard Camarena Estruch</p> <p>These materials are based on previous years notes created by Joan Gerard Camarena and Jose Alfredo Murcia</p> <p>The NoSQL movement (Not Only SQL) contemplates all those alternatives to traditional relational database management systems. Object-oriented databases, could be a first approach to these NoSQL databases. However, there are other models, with a totally different approach. These are databases based on documents, on key-value pairs or on graphs.</p> <p>Although some of the characteristics posed by these paradigms are being incorporated into SQL standards and relational DBMS, the current reality is that this type of database is growing considerably in many areas. At the beginning of the 2000s, web 2.0 emerged, which meant the conversion of users into content generators. Subsequently, with web 3.0 or semantic web, the Internet becomes a large database, and access to it is no longer exclusive to web applications, but to all kinds of applications and apps. Currently, we are facing the rise of artificial intelligence and web 4.0, as an evolution of all the above. With all this, we can imagine the huge amount of data that servers must store, and that requires a more delocalized, distributed and sufficiently efficient storage to support millions of daily queries.</p> <p>In this unit we are going to focus on document-type databases, specifically MongoDB, a database based on JSON documents, very popular on the web.</p>"},{"location":"en/UD6_MongoDB/1_NoSQL/#11-database-kind","title":"1.1. Database kind","text":"<p>We could find</p> <ol> <li> <p>Key-Value Databases \u2192 It is a fairly simple and popular database model, where each element is identified by a unique key, following the Hash table model, so that the data is recovered very quickly. Objects are generally stored as binary objects (BLOBs). Some databases of this type are Cassandra (Apache), Bigtable (Google), or Dynamo (Amazon).</p> </li> <li> <p>Documentary databases \u2192 This model stores the information in the form of documents, generally <code>XML</code> or <code>JSON</code>, and a unique key is used for each record, so key-value searches are allowed. The difference with respect to previous key-value databases is that here the value is the document itself, not binary data. As we will see later, they are very versatile, so we don't even need to have a common structure for the documents we save. The maximum exponent of this type of database is MongoDB.</p> </li> <li> <p>Databases in Graphs \u2192 A graph is a set of vertices or nodes joined by edges, which allow us to represent relationships between them. Graph databases attempt to follow this model, so that the information is represented as nodes in a graph, and the relationships between them are represented by edges. In this way, taking advantage of graph theory, we can go through the information in an optimal way. Some examples of this type of database are Amazon Neptune, JanusGraph (Apache), SQL Server (Miscrosoft) or Neo4j.</p> </li> </ol>"},{"location":"en/UD6_MongoDB/2_MongoDB/","title":"2. MongoDB","text":"<p>MongoDB is a document-oriented database, based on storing its data structures in JSON-type documents with a dynamic schema. Although it began being developed by the 10gen company, today it is an open source project, with a large user community.</p> <p>A MongoDB server can contain several databases, and each of them made up of a set of collections, which we could compare to the tables of a relational database. Each collection stores a set of JSON documents, made up of key-value attributes, which would be the records of a relational database.</p> <p>Broadly speaking, we could establish the following comparisons:</p> Relational model MongoDB Relational DB Document-oriented DB Table Collection Record/Row JSON Documents Table columns and values Key:Value pairs"},{"location":"en/UD6_MongoDB/2_MongoDB/#21-setup-and-first-run","title":"2.1. Setup and first run","text":"<p>MongoDB covers a wide range of possibilities, from local database servers to cloud databases. On its website https://www.mongodb.com, we can discover the different products and services that are offered, among which we find:</p> <ul> <li>MongoDB DB server, with its two versions, the Community, free and community version, and the Enterprise, its commercial version aimed at the business world and with additional features that improve performance and support. In addition to the server itself, the server prepared for use in containers is also offered on the web, through Kubernetes operators. The server is available on various platforms: Linux, Solaris, MacOS X and Windows.</li> <li>We can use the mongo shell or compass  or Robo3T graphical as a client, installed in our system</li> <li>MongoDB Atlas, the MongoDB platform in the cloud (DBaaS or DataBase as a Service), which allows its deployment in services such as AWS, Azure or Google Cloud.</li> <li>Realm, a data service designed for mobile and web applications, and which includes, in addition to DB in the cloud, several fully managed backend services.</li> </ul> <p>We are going to use, as current course, all servers via docker containers. We could download docker image via:</p> Bash<pre><code>docker pull mongo\n</code></pre> <p>and then create a server in a working container with</p> Bash<pre><code>docker run --name mongodb-srv \n    -e MONGO_INITDB_ROOT_USERNAME=\"root\" \n    -e MONGO_INITDB_ROOT_PASSWORD=\"toor\" \n    -p 27017:27017 \n    -d mongo\n</code></pre> <p>We can connect with compass to work with graphic interface</p>"},{"location":"en/UD6_MongoDB/3_ShellOperations/","title":"3. Working with MongoDB: Basic shell operations","text":""},{"location":"en/UD6_MongoDB/3_ShellOperations/#31-collections-and-documents","title":"3.1. Collections and Documents","text":"<p>As we already know, the basic unit of information that MongoDB works with is the document, which would be the equivalent of a record in a relational model. These are JSON documents, made up of key-value pairs, and which represent the information in a fairly intuitive way. MongoDB servers, for their part, will store this data in BSON (Binary JSON) format, a binary serialization format.</p> <p>Regarding JSON documents for MongoDB, some aspects must be taken into account:</p> <ul> <li>Regarding the keys:</li> <li>They cannot be null.</li> <li>They can consist of any UTF-8 character, except the characters <code>.</code> or <code>$</code>.</li> <li>Are case-sensitive.</li> <li>They must be unique within the same document.</li> <li>Regarding your values:</li> <li>They can be of any type allowed.</li> <li>Regarding the document:</li> <li>It must have an <code>_id</code> field, with a unique value, which will act as a document identifier. </li> <li>If we do not specify this key, MongoDB will generate it automatically, with an object of type <code>ObjectId</code>.</li> </ul> <p>If the documents are the equivalent of the records, the collections are the equivalent of the tables, with the difference that the collections have a dynamic schema, with which documents of the same collection can present different keys or data types between them.</p> <p>Collection names will be subject to the following restrictions:</p> <ul> <li>They cannot be the empty string (<code>\"\"</code>), nor the <code>null</code> character, nor contain the symbol <code>$</code>.</li> <li>We can use the period (<code>.</code>) in collection names to add prefixes to it, but collections cannot be created with the prefix by <code>system.</code>, since this is used for collections internal to the system. For example <code>db.system.test</code> would not be valid, but <code>db.systema.test</code> would.</li> </ul>"},{"location":"en/UD6_MongoDB/3_ShellOperations/#32-basic-operations-with-mongodb","title":"3.2. Basic operations with MongoDB","text":"<p>In the following, we are going to see some of the basic operations that we can perform on MongoDB:</p> <ul> <li><code>insertOne(document)</code> \u2192 Add a document to the collection:</li> <li><code>db.collection.insertOne({ a:1 })</code></li> <li><code>insertMany(documents)</code> \u2192 Add a set of document to the collection:</li> <li><code>db.collection.insertOne([{ a:1 },{ a:2 },{ a:3,b:5 }])</code></li> <li><code>find(criteria)</code> \u2192  Gets all the documents in a collection that match the specified pattern.</li> <li><code>db.collection.find({a:1})</code>. Note that the patter will be a json object too.</li> <li><code>findOne(Criterion)</code> Gets an element of the collection matching the pattern</li> <li><code>db.collection.findOne()</code></li> <li><code>updateOne(Criterion, Operation, [options])</code> and <code>updateMany(Criterion, Operation, [options])</code> \u2192 Updates one (or several in the case of updateMany) documents in the collection. It requires two parameters: </li> <li>the search criteria of the document to update and</li> <li>the update operation. </li> <li>Supports an optional third parameter for options. <ul> <li><code>db.collection.updateOne({a:1}, {$set: {a:2}})</code></li> </ul> </li> <li><code>deleteOne(Criterion)</code> and <code>deleteMany(Criterion)</code> \u2192 Deletes the documents from a collection that match the criteria </li> <li><code>db.collection.deleteOne({a:1})</code></li> </ul> <p>In the following sections we will delve into the different operations.</p>"},{"location":"en/UD6_MongoDB/3_ShellOperations/#33-data-types","title":"3.3. Data types","text":"<p>The data types that MongoDB works with are similar to those that we can find in JavaScript and Java. MongoDB supports the basic types described in the following table:</p> <ul> <li><code>null</code> \u2192 Represents both the null value and a field that does not exist</li> <li><code>boolean</code> \u2192 Allows the values true and false</li> <li><code>number</code> \u2192 Represent floating point numeric values. If we want to use integer or long integer types, we must use our own classes: NumberInt (32 bits) or NumberLong (64 bits)</li> <li><code>String</code> \u2192 Represents any valid UTF-8 text string.</li> <li><code>Date</code> \u2192 Represents dates, expressed in milliseconds.</li> <li><code>array</code> \u2192 Lists of values that are represented as vectors</li> <li><code>Embedded documents</code> \u2192 Documents can have other documents embedded in them</li> <li><code>ObjectId</code> \u2192 This is the default type for <code>_id</code> fields, and is designed to easily generate globally unique values. </li> </ul>"},{"location":"en/UD6_MongoDB/3_ShellOperations/#331-date","title":"3.3.1. Date","text":"<p>Mongo uses the JavaScript <code>Date</code> type. When we generate a new object of type Date, we must use the <code>New</code> operator, since otherwise we would obtain a representation of the date in the form of a string. For example, if we define the variables <code>a</code> and <code>b</code> as follows:</p> JavaScript<pre><code>test&gt; let a=Date()\n\ntest&gt; let b=new Date()\n</code></pre> <p>We can see that the results are quite different:</p> JavaScript<pre><code>test&gt; a\nSun May 08 2022 06:46:01 GMT+0200 (Central European Summer Time)\ntest&gt; typeof(a)\nstring\n\ntest&gt;b\nISODate(\"2022-05-08T04:46:09.371Z\")\n\ntest&gt; typeof(b)\nobject\n</code></pre>"},{"location":"en/UD6_MongoDB/3_ShellOperations/#332-arrays","title":"3.3.2. Arrays","text":"<p>Arrays can be used to represent either ordered collections, such as lists or queues, or unordered collections, such as sets. As in JavaScript, and unlike other languages, such as Java, each element of the vector can have a different data type, including other objects of vector types.</p> <p>Let's see some examples about vectors in Javascript and therefore in MongoDB:</p> JavaScript<pre><code>// array creation\ntest&gt; let v={objetos: [\"casa\", 10, {texto: \"hola\"}, false] }\n\n// ask for objects components\ntest&gt; v\n{ objetos: [ 'casa', 10, { texto: 'hola' }, false ] }\n\ntest&gt; v.objetos\n[ 'casa', 10, { texto: 'hola' }, false ]\n\n// ask for array cells\ntest&gt; v.objetos[1]\n10 \n\ntest&gt; v.objetos[2]\n{ texto: 'hola' }\n\n// change values\ntest&gt; v.objetos[3]=!v.objetos[3]\ntrue \n\ntest&gt; v\n{ objetos: [ 'casa', 10, { texto: 'hola' }, true ] }\n</code></pre>"},{"location":"en/UD6_MongoDB/3_ShellOperations/#333-embedded-documents","title":"3.3.3. Embedded documents","text":"<p>A key-value pair in one document can have another document as value. This is known as embedded documents, and would be when using a JSON object inside another. For example:</p> JavaScript<pre><code>&gt; let peli={ \n        titulo: \"Rogue One. A Star Wars Story.\",\n        anyo: 2016,\n      director: {\n          nombre: \"Gareth\",\n          apellidos:  \"Edwards\",\n          anyo_nacimiento: 1975,\n          nacionalidad: \"brit\u00e1nica\"\n      }\n   }\n</code></pre> <p>As we can see, the document itself contains information about the film and its director. In a relational model, we would normally have two tables related to each other. In this case, it is possible that if we want to keep specific information about the directors, we end up with redundant information.</p>"},{"location":"en/UD6_MongoDB/3_ShellOperations/#334-about-objectids","title":"3.3.4. About OBjectIds","text":"<p>The ObjectId class uses 12 bytes, organized as follows:</p> <p></p> <ul> <li>Timestamp (bytes 0-3) \u2192 The timestamp in seconds since January 1, 1970.</li> <li>Machine ID (bytes 4-6)\u2192 Unique identifier of the machine, usually a hash of its hostname,</li> <li>PID (bytes 7-8) \u2192 Identifier of the process that generates the ObjectID, to guarantee uniqueness within the same machine,</li> <li>Increment (bytes 9-11)\u2192 Auto-incremental value, to guarantee uniqueness in the same second, machine and process.</li> </ul> <p>As we can see, it is a more robust mechanism than an auto-incremental field like in MySQL. This corresponds to the distributed nature of MongoDB, so that objects can be generated in a multi-hosted environment.</p>"},{"location":"en/UD6_MongoDB/3_ShellOperations/#34-adding-information-to-collections","title":"3.4. Adding information to collections","text":"<p>Natural way to add elements to the database is through the different insert methods, available in all collections.</p>"},{"location":"en/UD6_MongoDB/3_ShellOperations/#341-insertone","title":"3.4.1. <code>insertOne()</code>","text":"<p>Allow to insert one document in the collection. For instance to insert las peli object created in last section we can do:</p> JavaScript<pre><code>test&gt; db.misPelis.insertOne(peli)\n{\n  acknowledged: true,\n  insertedId: ObjectId(\"6277510ab54867b80b742ddf\")\n}\n</code></pre> <p>As we can see, response is a JSON document that contains a boolean value indicating whether the operation was successful, and an ObjectID, with the automatically assigned ID.</p> <p>Important</p> <p>Take into account:</p> <ul> <li>If the collection to which we add a document does not exists, it is created automatically.</li> <li>Regarding the <code>_id</code> field, as we can see, it was generated automatically. However, we can indicate this identifier, without it being an ObjectId type, the only restriction is that it be unique, to avoid duplicates.</li> <li>We have not used any schema for the collection, since each document that we insert can have a different schema.</li> </ul>"},{"location":"en/UD6_MongoDB/3_ShellOperations/#342-insertmany","title":"3.4.2. <code>insertMany()</code>","text":"<p>Allow adding several documents into a collection. Then we need to provide a document array:</p> JavaScript<pre><code>// we create three objects\ntest&gt; let peli2={titulo: \"Star Wars. A new Hope\", anyo: 1977};\ntest&gt; let peli3={titulo: \"Empire Strikes Back\", anyo: 1981};\ntest&gt; let peli4={titulo: \"Return of the Jedi\", anyo: 1984};\n\n// insert them, in array way\ntest&gt; db.misPelis.insertMany([peli2, peli3, peli4])\n{\n  acknowledged: true,\n  insertedIds: {\n'0': ObjectId(\"627759a5b54867b80b742de0\"),\n'1': ObjectId(\"627759a5b54867b80b742de1\"),\n'2': ObjectId(\"627759a5b54867b80b742de2\")\n  }\n}\n</code></pre> <p>Important</p> <p>If an error appears during the insertion, neither document that provokes error neither next documents will be inserted into the collection.</p>"},{"location":"en/UD6_MongoDB/3_ShellOperations/#35-removing-information","title":"3.5. Removing information","text":"<p>To delete documents from a collection we will use the <code>deleteOne()</code>, <code>deleteMany()</code> or <code>findOneAndDelete()</code> commands, providing them as a parameter a JSON with a condition that we want the document or documents to be deleted to meet.</p> <ul> <li>The deleteOne order will only delete the first element that matches the criteria, so if we want to delete a specific document, we must use criteria that correspond to unique identifiers, such as the <code>_id</code>.</li> <li>The deleteMany command will delete all documents matching the criteria.</li> </ul> <p>Both deleteOne and deleteMany return a document with a boolean, indicating whether the operation has been performed, as well as the number of deleted elements (deletedCount).</p> <p>For its part, findOneAndDelete also deletes a document, based on selection and ordering criteria, but also returning the document that has been deleted.</p> <p>For example, we create a collection with several elements:</p> JavaScript<pre><code>db.pruebas.insertMany([{x:1}, {x:2}, {x:3}, {x:4}, {x:5}, {x:6}, {x:7}]);\n\n// to delete one document\ntest&gt; db.pruebas.deleteOne({})\n{ acknowledged: true, deletedCount: 1 }\n\n// as no confition is set, is satisfied by all documents, \n// then first document will be deleted\n\n// to delete several documents, for instance its x's value greather than 3\ntest&gt; db.pruebas.deleteMany({x:{$gt:3}})\n{ acknowledged: true, deletedCount: 4 }\n\n// delete and return a document\ntest&gt; db.pruebas.findOneAndDelete({x:2})\n{ _id: ObjectId(\"6277687fb54867b80b742deb\"), x: 2 }\n</code></pre> <p>If we want to delete all document's collection, we could use <code>drop</code> order instead, but be very carefull, due to it will remove some metainformation.</p> JavaScript<pre><code>test&gt; db.pruebas.drop() \n</code></pre>"},{"location":"en/UD6_MongoDB/3_ShellOperations/#36-documents-update","title":"3.6. Documents update","text":"<p>To update documents, we can either opt for replacement updates, using the <code>replaceOne()</code> method, or make modifications to existing documents, using the <code>updateOne()</code>, <code>updateMany()</code> and <code>findOneAndUpdate()</code> methods. These methods will receive two arguments: the first will be the criteria or condition that the documents to be updated must meet, and the second will be a document with either the new document or the updates to be applied.</p>"},{"location":"en/UD6_MongoDB/3_ShellOperations/#361-replace-update-replace","title":"3.6.1. Replace Update (replace)","text":"<p>The replacement operation, as its name indicates, replaces an entire document that meets the update criteria with another new document. For example, we create a new calendar collection, to store contacts, with information about telephones:</p> JavaScript<pre><code>test&gt; db.agenda.insertOne({nombre:\"Jose\", telefonos:[{trabajo:\"55512345\", casa:\"555111222\"}]}\n)\n{\n  acknowledged: true,\n  insertedId: ObjectId(\"627783dbb54867b80b742df8\")\n}\n</code></pre> <p>As we can see, this method returns the <code>_id</code> of the object, through which we will be able to unequivocally identify this document. So, we could replace this document with another by:</p> JavaScript<pre><code>test&gt; db.agenda.replaceOne({\"_id\":ObjectId(\"62778439b54867b80b742df9\")},\n  {nombre: \"Jose\", \n  correos:[{trabajo: \"jose@empresa.com\"}, \n  {personal: \"jose@proveedor.com\"}]} )\n\n// and the response is\n{\n  acknowledged: true,\n  insertedId: null,\n  matchedCount: 1,\n  modifiedCount: 1,\n  upsertedCount: 0 \n}\n</code></pre> <p>As we can see, it is about replacing the entire document, with which we can even modify its structure. updates.</p> <p>As we have anticipated, the modifications are made using the <code>updateOne()</code>, <code>updateMany()</code> and <code>findOneAndUpdate()</code> methods. Similar to the delete operations, the <code>updateOne()</code> method will modify only the first document that matches the given criteria and the <code>updateMany()</code> method, all those that match the criteria. For its part, the <code>findOneAndUpdate()</code> method modifies the document and returns the original document by default, although this is configurable through options. </p>"},{"location":"en/UD6_MongoDB/3_ShellOperations/#3611-modifiers","title":"3.6.1.1. Modifiers","text":"<p>Modifiers are special keys that allow us to specify more complex update operations. Normally, we will not need to replace the entire document, as in the previous case, but rather add or modify specific fields:</p> <ul> <li><code>$set</code> \u2192 Assigns a value to a field in the document. If it doesn't exist, it will create it.</li> <li><code>db.collection.updateOne({criteria}, {$set: {field:value} });</code></li> <li><code>$unset</code> \u2192 Removes a field from one or more documents. Since we need to introduce a key-value pair, we'll add a boolean as a value.</li> <li><code>db.collection.updateMany({criteria}, {$unset: {field:true} });</code></li> <li><code>$inc</code> \u2192 Increments or decrements the numeric value of a key (does not refer to the identifier), creating a new one if it does not exist.</li> <li><code>db.collection.updateOne({criteria}, {$inc: {field:increment} });</code></li> <li><code>$push</code> \u2192 Adds elements to an array. If the array does not exist, it creates it, with the elements that we indicate in the push, whereas if it already exists, it adds them to the end of it.</li> <li><code>db.collection.update({criteria}, {$push: {array_name:{list_of_values} } });</code></li> <li><code>$pull</code> \u2192 Remove elements from an array based on some criteria.</li> <li><code>db.collection.update({criteria},{$pull:{vector:element}})</code>.</li> <li><code>$pop</code> \u2192 Removes elements from an array treated as a stack or queue, ie removing the first (-1) or last (1) element.</li> <li><code>db.collection.update({criteria},{$pop:{vector: [ -1 | 1 ] }})</code></li> </ul> <p>Information</p> <p>This modifiers work with both <code>updateOne</code> or <code>updateMany</code>.</p>"},{"location":"en/UD6_MongoDB/3_ShellOperations/#3612-upserts","title":"3.6.1.2. Upserts","text":"<p>When no document matching the criteria for an update is found, as expected, no change occurs to the collection. On the other hand, sometimes, we may wish that if a document with certain criteria does not exist when we want to modify it, it is created. This is achieved through special updates, called <code>upserts</code>. With this operation, we save ourselves from searching the collection first, to know if we have to perform an insert (if it doesn't exist) or modify (if it does) operation.</p> <p>To perform an upsert, we will use the third argument of updates, which consists of a document with different options in key-value format, adding the upsert key to true.</p> JavaScript<pre><code>db.collection.updateOne({criteria},{modification}, {upsert:true});\n</code></pre>"},{"location":"en/UD6_MongoDB/4_Queries/","title":"4. Mongo Queries","text":""},{"location":"en/UD6_MongoDB/4_Queries/#41-find","title":"4.1. find()","text":"<p>The find command allows us to retrieve the documents from a collection that match a specified criteria as a JSON document. Its basic syntax is as follows:</p> JavaScript<pre><code>db.collection.find({criteria_in_JSON_format});\n</code></pre> <p>We must take into account aspects such as the types of data that we use, which is important, since the document <code>{edad:20}</code> is not the same as <code>{edad:\"20\"}</code>.</p> <p>On the other hand, we must also consider that the empty document <code>{}</code> matches all documents, so that the query  <code>db.collection.find({})</code> would return all the objects in the collection.</p>"},{"location":"en/UD6_MongoDB/4_Queries/#411-what-keys-to-retrieve","title":"4.1.1. What keys to retrieve?","text":"<p>The find command returns the complete documents that match the selection criteria. If we don't want to get all the keys, we can specify which keys we want to query for, by enclosing them in a second parameter:</p> JavaScript<pre><code>db.collection.find({query_document}, {key_1:1, key_2:1});\n</code></pre> <p>As we can see, this second parameter is also expressed in JSON format (again) and is made up of two keys (<code>key_1</code> and <code>key_2</code>), both with a value of 4. This numerical value is also interpreted with the value <code>true</code>. That is, we specify here which are the fields that we want to show. In case we want to show all the fields and hide some, we would use the same syntax, but now using a 0 for those fields that we want to hide.</p>"},{"location":"en/UD6_MongoDB/4_Queries/#412-comparison-operations","title":"4.1.2. Comparison operations","text":"<p>MongoDB allows us to perform comparisons with numeric data, always using the JSON document format  <code>db.collection.find({key: {$operator:value} });</code></p> <p>The comparison operators that we can use in MongoDB are:</p> <ul> <li><code>$lt</code> \u2192 Less Than</li> <li><code>$lte</code> \u2192 Less than or equal to</li> <li><code>$gt</code> \u2192 Greater than</li> <li><code>$gte</code> \u2192 Greater than or equal to</li> </ul>"},{"location":"en/UD6_MongoDB/4_Queries/#413-or-operation","title":"4.1.3. OR operation","text":"<p>If we want to perform a filter or query where several conditions are met (an AND operation), we will only have to separate them by commas in the same JSON document that we use as criteria. On the other hand, if what we want is to carry out an OR operation, we must use a special operator.</p>"},{"location":"en/UD6_MongoDB/4_Queries/#414-in-and-nin-operators","title":"4.1.4. <code>$IN</code> and <code>$NIN</code> operators","text":"<p>A special case of OR is when we want to check if a field is within a specific set of values. That is, if it is one or another value. For this we use the <code>$in</code> operator, as follows:</p> JavaScript<pre><code>db.collection.find({key:{$in:[vector_of_values]}})\n</code></pre> <p>Similarly, there is the operator <code>$nin</code> (Not In), which gets the documents, where the specified value is not found in the list. We must bear in mind that in this last case those documents that have a null value for the key will also be shown.</p>"},{"location":"en/UD6_MongoDB/4_Queries/#415-the-or-operator","title":"4.1.5. The <code>$OR</code> operator","text":"<p>When we want to perform the OR operation on different fields of the document, we will use the <code>$OR</code> operator, to which we pass a vector of possible conditions, as follows:</p> JavaScript<pre><code>db.collection.find({$or:[condition1, condition2,...]})\n</code></pre> <p>Attention</p> <p>Any of last condition is a json condition</p>"},{"location":"en/UD6_MongoDB/4_Queries/#416-the-not-operator","title":"4.1.6. The <code>$NOT</code> operator","text":"<p>The <code>$NOT</code> operator is a metaconditional operator, that is, it is always applied to another criterion, inverting its certainty value. Your syntax would be:</p> JavaScript<pre><code>db.collection.find({key:{$not: {criterion}}}).pretty();\n</code></pre>"},{"location":"en/UD6_MongoDB/4_Queries/#the-exists-operator","title":"The <code>$EXISTS</code> operator","text":"<p>Let's remember that in MongoDB, the documents do not have a common structure or schema, so it is possible that there are keys defined in only some of them. The <code>$exists</code> operator is used to check the existence or not of a certain key. The syntax to use would be:</p> JavaScript<pre><code>db.collection.find({key:{ $exists: true|false }})\n</code></pre> <p>With which we obtain the documents for which the key exists or not, depending on whether we have indicated true or false in the query.</p>"},{"location":"en/UD6_MongoDB/4_Queries/#42-query-results-and-data-types","title":"4.2. Query results and data types","text":"<p>Data types in MongoDB can have some special behaviors. We are going to see some cases, to know what to do in certain situations.</p>"},{"location":"en/UD6_MongoDB/4_Queries/#421-null-values","title":"4.2.1. null values","text":"<p>The null value matches the following situations:</p> <ul> <li>When the value of the key is null, or</li> <li>When the key does not exist in the document (in this case, it is usually said that the field is not informed)</li> </ul>"},{"location":"en/UD6_MongoDB/4_Queries/#422-regular-expressions-and-character-strings","title":"4.2.2. Regular expressions and character strings","text":"<p>When we apply a document filter by a text field, we may not know exactly the value of the field we want to filter by. Regular expressions offer a very powerful mechanism for matching strings.</p> <p>MongoDB allows us to use these expressions in several ways, either by using regular Javascript expressions or by using the <code>$regex</code> operator, which uses Perl Compatible Regular Expressions (PCRE). Javascript regular expressions are expressed using the following syntax:</p> JavaScript<pre><code>{ key: /pattern/&lt;options&gt; }\n</code></pre> <p>As we can see, we use a pattern similar to a text string, but using the slash <code>/</code> as the delimiter instead of the quotes (<code>'</code>). For its part, if we use the <code>$regex</code> operator, we can use the following syntax:</p> JavaScript<pre><code>{ key: { $regex: /pattern/, $options: '&lt;options&gt;' } }\n{ key: { $regex: 'pattern', $options: '&lt;options&gt;' } }\n{ key: { $regex: /pattern/&lt;options&gt; } }\n</code></pre> <p>We could find several options for regular expressions:</p> <ul> <li><code>i</code> \u2192 Matches are case-insensitive:</li> <li><code>{name:/john/i}</code></li> <li><code>{name: { $regex: 'john',$options: 'i'}}</code></li> <li><code>m</code> \u2192 Allows you to include characters such as <code>^</code> or <code>$</code>, to match at the beginning or end, in strings with multiple lines. </li> <li><code>{name:/^John/m}</code></li> <li><code>{name: { $regex: 'John', $options: 'm'}}</code></li> <li><code>x</code> Ignores whitespace in the <code>$regex</code> pattern, as long as it is not escaped or included in a character class</li> <li><code>{name: { $regex: ' J oh n',$options: 'x'}}</code></li> <li><code>s</code> Allows the period character (<code>.</code>) to represent any character, including the new line character. </li> <li><code>{name:/ju.n/s}</code></li> <li><code>{name: { $regex: 'thu.n',$options: 's'}}</code></li> </ul> <p>You can find more information regarding regular expressions and particular cases in which it is recommended to use one type of expression or another in the official MongoDB documentation about <code>$regex</code> here.</p>"},{"location":"en/UD6_MongoDB/4_Queries/#43-query-data-type-considerations","title":"4.3. Query data type considerations","text":""},{"location":"en/UD6_MongoDB/4_Queries/#431-queries-with-arrayas","title":"4.3.1. Queries with arrayas","text":"<p>To search for matching elements within an array, we proceed with the same syntax as if it were any other key, using the query document <code>{key:value}</code>, the key being an array, and the value, either n value that must contain the array, or another ordered vector that we want it to match exactly.</p> <p>For instance:</p> <ul> <li><code>db.collection.find({ my_vector : value })</code> \u2192  It matches all the documents in whose vector <code>my_vector</code> appears, in the position that is the indicated value.</li> <li><code>db.users.find({roles:\"admin\"})</code> show users that in <code>roles</code> array has admin role (or others).</li> <li><code>db.collection.find({ my_vector : [value] })</code> \u2192 Matches all documents whose vector <code>my_vector</code> appears only the indicated value.</li> <li><code>db.users.find({roles:[\"admin\"]})</code>show users who has exactely admin role.</li> </ul> <p>In addition, we can also use regular expressions or the rest of the operators that we have seen as conditions.</p> <p>On the other hand, we can also refer to a specific element of the vector by its index, using the dot notation and between quotes:</p> <ul> <li><code>db.collection.find({\"my_vector.position\" :[value]})</code></li> <li><code>db.users.find({\"roles.2\":[\"admin\"]})</code> show user who third role is admin</li> </ul>"},{"location":"en/UD6_MongoDB/4_Queries/#432-the-all-operator","title":"4.3.2. The <code>$all</code> operator","text":"<p>With <code>$all</code> we can specify more than one matching element within the array:</p> <ul> <li><code>db.collection.find({ my_vector : {$all:[value1, value2,...]}})</code></li> <li><code>db.users.find({roles:{$all:[\"mod\",\"admin\"]}})</code> show users who have mod and admin role (and possibly more).</li> </ul>"},{"location":"en/UD6_MongoDB/4_Queries/#433-the-size-operator","title":"4.3.3. The <code>$size</code> operator","text":"<p>Using <code>$size</code> we can include conditions on the length of the vectors:</p> <ul> <li><code>db.collection.find({ my_vector : {$size:size} })</code></li> </ul>"},{"location":"en/UD6_MongoDB/4_Queries/#434-the-slice-operator","title":"4.3.4. The <code>$slice</code> operator","text":"<p>The slice operator allows us to obtain a subset of the elements of the vector, with the following syntax:</p> <ul> <li><code>key: {$slice: x}</code>:</li> <li>if x&gt;0 gets the first x elements</li> <li>if x&lt;0, get the last x elements</li> <li><code>key: {$slice: [ x , y ] }</code> Gets y elements from the element at position x embedded document</li> </ul> <p>To query embedded documents, simply specify the full key path, enclosed in quotes and separated by dots: <code>db.collection.find({\"path.to.key\":value_or_condition})</code></p>"},{"location":"en/UD6_MongoDB/4_Queries/#44-cursors","title":"4.4. Cursors","text":"<p>When we perform a query, MongoDB returns the results using cursors, which are pointers to the query results, like connectors in unit 2. Clients using Mongo iterate over these cursors to retrieve the results, and offer a set of functionality, such as limiting the results, etc.</p> <p>When we perform a query on a database with many results, the client (<code>mongosh</code>) returns only 20 results and the message <code>Type \"it\" for more</code>, to continue iterating the cursor.</p>"},{"location":"en/UD6_MongoDB/4_Queries/#limit-skip-and-sort","title":"Limit, Skip and Sort","text":"<p>MongoDB allows us to make certain limitations on the results. Among them, we can highlight:</p> <ul> <li><code>limit</code> \u2192 To limit the number of results</li> <li><code>skip</code> \u2192  Skips a specific number of results.</li> <li><code>sort</code> \u2192  Sorts the results. You need a JSON object with the keys to sort, and a value of 1 to sort ascending or -1 to sort descending.</li> </ul>"},{"location":"en/UD6_MongoDB/4_Queries/#45-introduction-to-the-aggregation-framework","title":"4.5. Introduction to the Aggregation Framework","text":"<p>The aggregation queries that we performed with operators such as <code>GROUP BY</code>, <code>SUM</code>, or <code>COUNT</code> in SQL can be performed with the MongoDB Aggregation Framework. Aggregate queries have the following syntax:</p> JavaScript<pre><code>db.collection.aggregate( [&lt;pipeline&gt;] )\n</code></pre> <p>The pipeline or pipe has a concept similar to Unix pipes: the results of an order are passed as input to another, to obtain results jointly.</p> <p>The operations that we can perform within these aggregate queries are:</p> <ul> <li><code>$project</code> \u2192 To perform a projection on an input data set, adding, removing or recalculating fields so that the output is different.</li> <li><code>$match</code> \u2192 Filters the input to reduce the number of documents, leaving only those that meet certain conditions.</li> <li><code>$limit</code> \u2192 Restricts the number of results.</li> <li><code>$skip</code> \u2192 Skip a certain number of records.</li> <li><code>$unwind</code> \u2192 Converts an array to return it separated in documents.</li> <li><code>$group</code> \u2192 Groups documents according to a certain condition.</li> <li><code>$sort</code> \u2192 Sorts a set of documents, according to the specified field.</li> <li><code>$geoNear</code>\u2192 It is used as geospatial data, returning the documents ordered by proximity according to a geospatial point.</li> </ul> <p>To perform calculations on the data produced by the pipes, we will use expressions. Expressions are functions that perform a certain operation on a group of documents, vector or specific field. Some of these expressions are <code>$max</code>, <code>$min</code>, <code>$divide</code>, or <code>$substr</code>.</p> <p>You can find much more information about the Aggregation Framework in the official MongoDB documentation.</p>"},{"location":"en/UD6_MongoDB/4_Queries/#46-exercises","title":"4.6. Exercises","text":"<p>We are still working on the movie collection. In this case, we are going to use the mongosh terminal (or robo3t as you prefeer), and perform the following queries on this collection.</p> <ol> <li>Obtain all the productions that either premiered in <code>2015</code> or are of the <code>series</code> type.</li> <li>Get all the movies NOT released between the years <code>2000</code> and <code>2002</code>.</li> <li>Get all movies for which the \"directors\" key is not defined</li> <li>Get the title of all movies that start with the string <code>star wars</code>, regardless uppercase.</li> <li>Get the title of all movies that contain the comedy genre (<code>Comedy</code>)</li> <li>Show the title and genres of the movies that contain either the comedy genre (<code>Comedy</code>) or adventure (<code>Adventure</code>).</li> <li>Get the title and genres of movies that have three genres.</li> <li>Get the movies whose <code>Rotten Tomatoes</code> rating is higher than <code>4</code></li> <li>Make the same query as before, but limiting the number of documents to 10.</li> <li>Now shows the title and rating of those movies with more than a 4 rating, ordered by rating (highest to lowest) and limiting the results to 10.</li> </ol>"},{"location":"en/UD6_MongoDB/5_Mongo_Java/","title":"5. MongoDB and Java","text":"<p>Let's go to view hot to acces MongoDB from our Java programs. Firtsly, as we view in unit 2, we study how to acces directly and then with elements like ORM.</p>"},{"location":"en/UD6_MongoDB/5_Mongo_Java/#51-drivers","title":"5.1. Drivers","text":"<p>As we already know, to connect from our applications to a database we need a controller or driver. MongoDB offers official drivers for a multitude of platforms, including C, C++, C#, NodeJS, Python, and of course, Java, among many others.</p> <p>Focusing on Java, MongoDB offers us two drivers: </p> <ul> <li>The Java driver for synchronous applications.</li> <li>The Reactive Streams driver for processing asynchronous Streams.</li> </ul> <p>Although currently there is a trend towards reactive programming, we are going to work with the Java synchronous driver to make it easier to understand and focus on the actual access to the data.</p>"},{"location":"en/UD6_MongoDB/5_Mongo_Java/#511-the-java-driver","title":"5.1.1. The Java driver","text":"<p>Using the MongoDB Driver for Java we can connect to both a local or remote database, as well as a MongoDB Atlas cluster. This driver (MongoDB Java Driver) can be found in the Maven repositories, and provides a large number of classes and interfaces to facilitate working with MongoDB from Java.</p> <p>In a Gradle project we should use:</p> Bash<pre><code>implementation group: 'org.mongodb', name: 'mongo-java-driver', version: '3.12.10'\n</code></pre> <p>whereas in a Maven project:</p> XML<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.mongodb&lt;/groupId&gt;\n    &lt;artifactId&gt;mongo-java-driver&lt;/artifactId&gt;\n    &lt;version&gt;3.12.10&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"en/UD6_MongoDB/5_Mongo_Java/#52-connection-to-a-database","title":"5.2. Connection to a database","text":"<p>To connect and communicate with a database we need a client. In the case of the Java driver for MongoDB, the client is implemented through the <code>MongoClient</code> class.</p> <p>The <code>MongoClient</code> class represents a set of connections to a MongoDB server. These connections are thread-safe, that is, several threads of execution can safely access them.</p> <p>The way to create <code>MongoClient</code> instances is through the <code>MongoClients.create()</code> method. Also, generally, we only need one instance of this class, even in multi-threaded applications. The <code>MongoClients</code> create method takes as an argument a <code>Connection String</code>, with the following simplified format (the clearer parameters are optional):</p> Bash<pre><code>mongodb:// [user:password @] host[:port] /?options\n</code></pre> <p>So, a way to obtain, for example, a connection to the local server would be:</p> Java<pre><code>String uri = \"mongodb://localhost:27017\";\nMongoClient mongoClient = MongoClients.create(uri);\n</code></pre> <p>The MongoClient class, among others, supports the following methods:</p> <ul> <li><code>getDatabase(String name)</code> \u2192 Gets a reference to a database whose name is passed as an argument.</li> <li><code>listDatabaseNames()</code> Gets a list of Strings (<code>MongoIterable</code> interface) with the names of the server's databases.</li> <li><code>close()</code> Closes the connection to the server. It should always be done when it is no longer going to be used.</li> </ul>"},{"location":"en/UD6_MongoDB/5_Mongo_Java/#521-mongodatabase","title":"5.2.1. MongoDatabase","text":"<p>The <code>getDatabase()</code> method of the <code>MongoClient</code> class returns a reference to an object that implements the <code>MongoDatabase</code> interface, which represents a connection to a database. This interface defines the following methods:</p> <ul> <li><code>getCollection(String name)</code> \u2192 Gets a reference to the collection.</li> <li><code>listCollectionNames()</code> \u2192 Gets a list of Strings (<code>MongoIterable interface</code>) with the names of the collections in the database.</li> <li><code>listCollections()</code> \u2192 Gets a list of references (<code>MongoCollection</code>) to the collections in the database.</li> <li><code>createCollection(String name)</code> \u2192 Creates a new collection with the specified name in the database</li> <li><code>drop()</code> \u2192 Drops the database</li> </ul> <p>Here you will find a sample of connection and list of database and collections of a given server:</p> Java<pre><code>public MongoClient connectServer(){\n  String uri = \"mongodb://root:toor@localhost:27017\";\n  MongoClient mongoClient = MongoClients.create(uri);\n  return mongoClient;\n}\n\npublic void disConnect(MongoClient client){\n  client.close();\n}\n\npublic void getInfo(MongoClient client) {\n  // get list of databases\n  for (String dbname : client.listDatabaseNames()) {\n      // Write its name\n      System.out.println(\"Database: \" + dbname);\n\n      // Get a database reference\n      MongoDatabase db = client.getDatabase(dbname);\n\n      // Get database collections\n      MongoIterable&lt;String&gt; colecciones = db.listCollectionNames();\n\n      // show collections name\n      for (String coleccion : colecciones) {\n          System.out.println(\"\\t\\t &gt; \" + coleccion);\n      }\n  }\n}\n</code></pre>"},{"location":"en/UD6_MongoDB/5_Mongo_Java/#53-queries","title":"5.3. Queries","text":"<p>The <code>getCollection()</code> method of <code>MongoDatabase()</code> provides us with a <code>Document</code> collection (<code>MongoCollection&lt;Document&gt;</code>), on which we will be able to perform queries using the <code>find()</code> method. This method, which we already know from the MongoDB shell, will allow us to filter documents based on certain criteria.</p> <p>These criteria are expressed as filters (query filters in the documentation), and can contain several query operators on some fields that will determine which documents in the collection are included as results.</p> <p>The <code>Filter</code> class provides us with factory methods to perform these queries, similar to how we worked with the MongoDB shell. This class gives us:</p> <ul> <li>Empty query, with <code>Filters.empty()</code>.</li> <li>Comparison operators: To perform queries based on values in the collection: </li> <li><code>Filters.eq(key, value)</code>, <code>Filters.gt(key, value)</code>, <code>Filters.gte(key, value)</code>, <code>Filters.lt(key, value)</code> or <code>Filters.lte(key, value)</code>.</li> <li>Logical operators: To perform logical operations on the result of other queries: <code>Filter.and(other_filters)</code>, <code>Filter.or(other_folters)</code>, etc.</li> <li>Array operators: They allow us to perform queries based on the value or number of elements of a vector: <code>Filters.size(vector, size)</code>.</li> <li>Other operators, such as <code>Filter.exists()</code> or <code>Filter.regex()</code>, to check for the existence of a key or perform a regular expression search.</li> </ul> <p>In addition to filters, we will also be able to include aggregation operations, through the <code>aggregate()</code> method of a <code>MongoCollection</code> instance. You can check the documentation about aggregations in the MongoDB aggregation operations guide.</p> <p>On the other hand, the MongoDB driver API also allows us to perform field projections using the <code>Projections</code> class, which offers the <code>Projections.fields()</code>, <code>Projections.include()</code> or <code>Projections.excludeID()</code> methods.</p> <p>Sample of find films from a given year, only 10 resuts:</p> Java<pre><code>public void getPelisAnyo(MongoClient client, int anyo) {\n\n    // get collection from database\n    MongoDatabase db=client.getDatabase(\"mflix\");\n\n    // get documents from that colection\n    MongoCollection&lt;Document&gt; colPelis = db.getCollection(\"movies\");\n\n    // And now, we apply a filter and limit\n    FindIterable&lt;Document&gt; docsPelis = colPelis\n            .find(Filters.eq(\"year\", anyo))\n            .limit(10);\n\n    // we show it\n    for (Document doc : docsPelis) {\n        System.out.println(doc.toString());\n    }\n}\n</code></pre> <p>Remember</p> <p><code>Document</code> class have several method to work like Json Documents in unit 1. We can get each field by given key, getting its value</p> <p>Another sample with filters and projections:</p> Java<pre><code>public void getPelisEntre(MongoClient client, int anyo1, int anyo2) {\n\n    // check anyo values\n    if (anyo1&gt;anyo2){\n        int tmp=anyo1;\n        anyo1=anyo2;\n        anyo2=tmp;\n    }\n\n    // get document collection\n    MongoDatabase db=client.getDatabase(\"mflix\");\n    MongoCollection&lt;Document&gt; colPelis = db.getCollection(\"movies\");\n\n    // Creamos el filtro\n    Bson filter=Filters.and(\n        Filters.gte(\"year\", anyo1),\n        Filters.lte(\"year\", anyo2)\n    );\n\n    // Create projecction\n    Bson projection=Projections\n            .fields(Projections.include(\"title\", \"year\"),\n                    Projections.excludeId());\n\n    // Run the filters\n    FindIterable&lt;Document&gt; DocsPelis = colPelis\n            .find(filter)\n            .projection(projection);\n\n    // Show the films\n    for (Document doc : DocsPelis) {\n        System.out.println(doc.toString());\n    }\n}\n</code></pre>"},{"location":"en/UD6_MongoDB/6_Spring_MongoDB/","title":"6. Spring Data MongoDB y API REST","text":"<p>As we know, the Spring Data project, included in the Spring platform, provides a framework to simplify data access and persistence over different information repositories. Within this project is Spring Data MongoDB, which provides integration with MongoDB databases, through a model centered on POJOs that interact with document collections and provides a data access repository.</p> <p>In this section, and taking over from the previous unit, we are going to address the development of data access components through Spring Data, as well as microservices that offer this data through a REST API, all of this, following the MVC pattern that we already know.</p>"},{"location":"en/UD6_MongoDB/6_Spring_MongoDB/#61-defining-the-model-document","title":"6.1. Defining the Model \u2013 Document","text":"<p>A MongoDB database is made up of <code>Document</code> collections. Although these Documents may have different structures from each other or different types of data, the model does require a static structure. So, the first thing we must do is create a class that represents this Main Document for MongoDB, which will be the one returned by the queries that are made.</p> <p>In this context, there are two main annotations that we will use:</p> <ul> <li><code>@Document</code> \u2192 to indicate that a class corresponds to a domain object (domain object) that can be mapped in the database to offer persistence. This annotation for MongoDB would be the equivalent of <code>@Entity</code> in JPA. If nothing is indicated, the name of the collection to be used will be interpreted as corresponding to the name of the class in lower case. So, if we have the class <code>com.jaume.ad.Person</code>, the collection <code>person</code> will be used. However, we can indicate the collection we are working with, either through the value or collection attributes, with the following syntax:</li> <li><code>@Document(value=\"collection\")</code></li> <li><code>@Document(\"collection\")</code></li> <li><code>@Document(collection=\"collection\")</code></li> <li><code>@Id</code> It is applied to a field, and it is used to indicate that the field will be used as an identifier. As we know, every document in MongoDB requires an identifier. If one is not provided, the controller will assign an <code>ObjectID</code> automatically. It is important to note that the types of data that we can use as identifiers can be both <code>Strings</code> or <code>BigInteger</code>, since Spring will take care of converting them to the ObjectID type.</li> </ul> <p>Important</p> <p>It exists an anotation <code>@DocumentReference</code> to relate Documents one inside other, for instance when we store in a class objects from another classes, like relationships on SQL databases. </p> <p>In addition to these, there are other more specific annotations that we can use. If you wish, you can consult them in the Spring Data MongoDB reference documentation here.</p>"},{"location":"en/UD6_MongoDB/6_Spring_MongoDB/#62-defining-the-repository","title":"6.2. Defining the Repository","text":"<p>As we know, the repository is the interface in charge of managing access to data. In the case of MongoDB, this will derive from <code>MongoRepository</code>, which will be an interface parameterized by two arguments: </p> <ul> <li><code>MongoRepository&lt;T, Id&gt;</code>, who:</li> <li><code>T</code> \u2192 The type of document, which will correspond to the class defined in the model, and</li> <li><code>Id</code>\u2192 The data type to which the identifier will belong.</li> </ul> <p>The MongoRepository interface, as we have said, will be specific to MongoDB, and will derive from the <code>CrudRepository</code> and <code>PagingAndSortingRepository</code> interfaces, from which it will inherit all its methods. In this way, in the repository we will only have to declare those methods that are more specific for our application, since all the methods to implement CRUD operations, as well as <code>findAll()</code> and <code>findById()</code> will be inherited from <code>MongoRepository</code>.</p> <p>To define our own queries in the repository, we will use the <code>@Query</code> annotation, providing the query in question as a value:</p> Java<pre><code>@Query(value=\"{ parameterized_query}\")   // regarding to repository's base class \nList&lt;DocumentType&gt; methodName(list_parameters);\n</code></pre> <p>To supply parameters to the query, these are received as arguments to the method, and are referenced by their order in the query: <code>?0</code> for the first argument, <code>?1</code> for the second, etc. MAybe in newer version can be parameters in a nominal way, as <code>:parameter_name</code></p>"},{"location":"en/UD6_MongoDB/6_Spring_MongoDB/#63-defining-the-service","title":"6.3. Defining the service","text":"<p>The services take care of the business layer of our application, and access the data through the repository, sending the results to the controller. These services, in general, are characterized by:</p> <ul> <li>Use the <code>@Service</code> annotations, to indicate to Spring that a service is being implemented</li> <li>On the one hand, the Service interface is usually defined and, on the other hand, the implementation is carried out through the <code>ServiceImpl</code> class.</li> <li>The <code>@Autowired</code> annotation is used in references to repositories to link or inject the service in question with said repository.</li> <li>Once it gets the data from the repository, it sends it data  to the controller.</li> </ul>"},{"location":"en/UD6_MongoDB/6_Spring_MongoDB/#64-defining-the-controller","title":"6.4. Defining the controller","text":"<p>Finally, we are left with the controller implementation, which we already know from Spring. Let's remember the main characteristics of this one:</p> <ul> <li>Use the <code>@RestController</code> annotation at the class level to indicate that you are dealing with a REST controller</li> <li>Use the <code>@RequestMapping</code> annotation at the class level to specify the base path for the service endpoints,</li> <li>Use the <code>@Autowired</code> annotation in the properties that refer to the service, to inject it automatically,</li> <li>Use the <code>@GetMapping</code>, <code>@PostMapping</code>, <code>@PutMapping</code>, <code>@DeleteMapping</code> annotations on the methods that will implement GET, POST, PUT or DELETE type requests, specifying their Endpoint.</li> <li>Use the <code>@PathVariable</code> or <code>@RequestParam</code> or <code>@RequestBody</code> annotation on the arguments of the above methods to get the values from path, request or body.</li> </ul>"},{"location":"en/UD6_MongoDB/6_Spring_MongoDB/#2-swagger","title":"2. Swagger","text":"<p>Until now, we are testing our api rest with Postman, but now we offer a tool that integrates with Spring and Tomcat in order to test our API quickly and easily.</p> <p>Swagger (https://swagger.io) is very simple to start:</p> <ol> <li>Add dependencies.</li> <li>Add a configuration class, who scans our controllers to find what entry points are defined.</li> <li>Create automoticaly a User Interface, who show what entries are defined and tools to test</li> </ol>"},{"location":"en/UD6_MongoDB/6_Spring_MongoDB/#21-dependency","title":"2.1. Dependency","text":"<p>You must add at your <code>pom.xml</code>:</p> XML<pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;io.springfox&lt;/groupId&gt;\n  &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;\n  &lt;version&gt;2.9.2&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"en/UD6_MongoDB/6_Spring_MongoDB/#22-configuration-class","title":"2.2. Configuration class","text":"<p>We need to create a class like this:</p> Java<pre><code>package com.jaumeii.moviesapi.swagger;\n\nimport java.util.Collections;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\nimport springfox.documentation.service.Contact;\nimport springfox.documentation.builders.PathSelectors;\nimport springfox.documentation.builders.RequestHandlerSelectors;\n\nimport springfox.documentation.service.ApiInfo;\nimport springfox.documentation.spi.DocumentationType;\nimport springfox.documentation.spring.web.plugins.Docket;\nimport springfox.documentation.swagger2.annotations.EnableSwagger2;\n\n@Configuration\n@EnableSwagger2\npublic class SwaggerConfig {\n\n    @Bean\n    public Docket apiDocket() {\n        return new Docket(DocumentationType.SWAGGER_2)\n                .select()\n                .apis(RequestHandlerSelectors.basePackage(\"com.jaumeii.moviesapi.controller\"))\n                .paths(PathSelectors.any())\n                .build()\n                .apiInfo(getApiInfo());\n    }\n\n    private ApiInfo getApiInfo() {\n        return new ApiInfo(\n                \"Movies controller\",\n                \"Tools for testing movies API\",\n                \"1.0\",\n                \"http://www.ieseljust.com\",\n                new Contact(\"admin\", \"https://ieseljust.com\", \"admin@ieseljust.com\"),\n                \"LICENSE\",\n                \"LICENSE URL\",\n                Collections.emptyList()\n                );\n    }\n}\n</code></pre> <p>Two methods need to be implemented:</p> <ul> <li><code>Docket apiDocket()</code> \u2192 who createa a <code>Docket</code>. This <code>Docket</code> contains references to work and test our API</li> <li><code>ApiInfo getApiInfo()</code> \u2192 who create an <code>ApiInfo</code>, and its name tells, is basic information about what is this API created for.</li> </ul> <p>Attention</p> <p>In las sample we have our controllers defindd in <code>com.jaumeii.moviesapi.controller</code>, and it is all that we could do.</p>"},{"location":"en/UD6_MongoDB/6_Spring_MongoDB/#23-testing","title":"2.3. Testing","text":"<p>When our spring project starts, we could see the log information:</p> Text Only<pre><code>2023-01-29 08:37:16.400  INFO 61951 --- [  restartedMain] pertySourcedRequestMappingHandlerMapping : Mapped URL path [/v2/api-docs] onto method [springfox.documentation.swagger2.web.Swagger2Controller#getDocumentation(String, HttpServletRequest)]\n</code></pre> <p>It means that we have a new entry point <code>/v2/api-docs</code>. If we test this entry point, we get something like:</p> JavaScript<pre><code>  \"swagger\": \"2.0\",\n  \"info\": {\n    \"description\": \"Tools for testing movies API\",\n    \"version\": \"1.0\",\n    \"title\": \"Movies controller\",\n    \"termsOfService\": \"http://www.ieseljust.com\",\n    \"contact\": {\n      \"name\": \"admin\",\n      \"url\": \"https://ieseljust.com\",\n      \"email\": \"admin@ieseljust.com\"\n    },\n    \"license\": {\n      \"name\": \"LICENSE\",\n      \"url\": \"LICENSE URL\"\n    }\n  },\n  \"host\": \"localhost:8080\",\n  \"basePath\": \"/\",\n  \"tags\": [\n    {\n      \"name\": \"movie-controller\",\n      \"description\": \"Movie Controller\"\n    }\n  ],\n  \"paths\": {\n    \"/api/v1/movie/byNumDirectors/{how_many}\": {\n      \"get\": {\n        \"tags\": [\n          \"movie-controller\"\n        ],\n        \"summary\": \"findByYear\",\n        \"operationId\": \"findByYearUsingGET\",\n        \"produces\": [\n          \"*/*\"\n  ...\n</code></pre> <p>It is a json document who describes our API. But to work in a comfortable way, we can request <code>/swagger-ui.html</code>, and we get:</p> <p></p> <p>This UI page contains the basic information we set in <code>getApiInfo()</code> method. At the bottom we can see more element. If we open, we get:</p> <p></p> <p>We could see information about entry points and models that the API returns. Additionally, we could enter on each entry point to get information about parameters, and finally execute it. </p>"},{"location":"en/UD6_MongoDB/6_Spring_MongoDB/#3-appendix-solution-to-exercise-about-mongo-queries","title":"3. Appendix. Solution to exercise about mongo queries","text":"<ol> <li>Obtain all the productions that either premiered in <code>2015</code> or are of the <code>series</code> type.</li> </ol> <p>Tip</p> <p>We need to use <code>$or</code> operator, with a condition array.</p> JavaScript<pre><code>db.movies.find({$or:[{year:2015}, {type:\"series\"}]})\n</code></pre> <ol> <li>Get all the movies NOT released between the years <code>2000</code> and <code>2002</code>.</li> </ol> <p>Tip</p> <p>We need to use <code>$not</code> operator, with a condition to deny.</p> JavaScript<pre><code>db.movies.find({year:{$not: {$gte: 2000, $lte: 2002}}}).pretty();\n</code></pre> <ol> <li>Get all movies for which the \"directors\" key is not defined</li> </ol> <p>Tip</p> <p>We need to use <code>$exists</code> operator or checking for a <code>null</code> field.</p> JavaScript<pre><code>db.movies.find({directors:{$exists:false}})\n\nor\n\ndb.movies.find({directors:null})\n</code></pre> <ol> <li>Get the title of all movies that start with the string <code>star wars</code>, regardless uppercase.</li> </ol> <p>Tip</p> <p>It is interesting using regular expressions. Remembre to use <code>i</code> option to inlude a non case sensitive check.</p> JavaScript<pre><code>db.movies.find({\"title\":/^star wars/i},{title:1})\n\nor\n\ndb.movies.find({\"title\": {$regex:'^star wars', $options:'i'}},{title:1})\n</code></pre> <ol> <li>Get the title of all movies that contain the comedy genre (<code>Comedy</code>)</li> </ol> <p>Tip</p> <p>We look in the <code>genres</code> array for a given genre</p> JavaScript<pre><code>db.movies.find({genres:\"Comedy\"}, {genres:1})\n</code></pre> <ol> <li>Show the title and genres of the movies that contain either the comedy genre (<code>Comedy</code>) or adventure (<code>Adventure</code>).</li> </ol> <p>Tip</p> <p>We need to prove that film math <code>$all</code> given genres.</p> JavaScript<pre><code>db.movies.find(\n  {genres:{ $all: [\"Comedy\", \"Adventure\"]}},\n  {title:1, genres:1})\n</code></pre> <ol> <li>Get the title and genres of movies that have three genres.</li> </ol> <p>Tip</p> <p>We look for a <code>genres</code> array with three genres: <code>$size</code> operator.</p> JavaScript<pre><code>db.movies.find({ genres : {$size:3} }, {title: 1, genres:1})\n</code></pre> <ol> <li>Get the movies whose <code>Rotten Tomatoes</code> rating is higher than <code>4</code></li> </ol> <p>Tip</p> <p>We need to check into embedded documents, via dot notation inside a String :::</p> JavaScript<pre><code>db.movies.find({\"tomatoes.viewer.rating\":{$gt:4}})\n</code></pre> <ol> <li>Make the same query as before, but limiting the number of documents to 10.</li> </ol> <p>Tip</p> <p>We need to <code>limit</code> results.</p> JavaScript<pre><code>db.movies.find({\"tomatoes.viewer.rating\":{$gt:4}}).limit(10)\n</code></pre> <ol> <li>Now shows the title and rating of those movies with more than a 4 rating, ordered by rating (highest to lowest) and limiting the results to 10.</li> </ol> <p>Tip</p> <p>And now adding an ordering filter</p> JavaScript<pre><code>db.movies.find(\n    {\"tomatoes.viewer.rating\":{$gt:4}},\n    {title:1, \"tomatoes.viewer.rating\":1})\n    .sort({\"tomatoes.viewer.rating\":-1})\n    .limit(10)\n</code></pre>"}]}