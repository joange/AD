{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"about/","title":"Sobre mi","text":"<p>Joan Gerard Camarena Estruch.</p> <p>Pendent de resum</p>"},{"location":"","title":"Acc\u00e8s a Dades","text":""},{"location":"#desenvolupament-daplicacions-multiplataforma","title":"Desenvolupament d'aplicacions multiplataforma","text":""},{"location":"#2024-2025","title":"2024 - 2025","text":"<p>Professor:</p> <ul> <li>Joan Gerard Camarena Estruch jg.camarenaestruch at edu.gva.es</li> </ul>"},{"location":"license/","title":"Llic\u00e8ncia","text":"<p>Aquest treball est\u00e0 llicenciat sota una Llic\u00e8ncia Internacional de Creative Commons Reconeixement-NoComercial-CompartirIgual 4.0.</p> <p>Ets lliure de:</p> <ul> <li>Compartir: copiar i redistribuir el material en qualsevol format o mitj\u00e0.</li> <li>Adaptar: remesclar, transformar i crear a partir del material.</li> </ul> <p>Sota els seg\u00fcents termes:</p> <ul> <li>Reconeixement: has de donar el cr\u00e8dit adequat, proporcionar un enlla\u00e7 a la llic\u00e8ncia i indicar si s'han realitzat canvis. Ho pots fer de qualsevol manera raonable, per\u00f2 no d'una manera que suggereixi que el llicenciador et dona suport o avala l'\u00fas que en fas.</li> <li>NoComercial: no pots utilitzar el material amb fins comercials.</li> <li>CompartirIgual: si remescles, transformes o crees a partir del material, has de distribuir les teves contribucions sota la mateixa llic\u00e8ncia que l'original.</li> </ul> <p>Per a m\u00e9s detalls, consulta el text complet de la llic\u00e8ncia a https://creativecommons.org/licenses/by-nc-sa/4.0/legalcode.</p>"},{"location":"Practiques/APAC1/","title":"1. Entorn i execuci\u00f3 del programa","text":"<p>En aquesta primera Activitat de Pr\u00e0ctica d'Avaluaci\u00f3 Continuada (APAC1), implementarem la part de persist\u00e8ncia de fitxers d'un projecte de figures geom\u00e8triques parcialment fet.</p> <p>Disposeu d'un fitxer comprimit amb el projecte Gradle APAC1_AD, amb la implementaci\u00f3 de la jerarquia de figures i altres utilitats.</p> <p>El projecte ha estat creat amb <code>gradle init</code>, que crea una petita estructura de directoris i fitxers per a nosaltres, com ara els llan\u00e7adors <code>gradlew</code> i <code>gradlew.bat</code> (que no utilitzarem).</p> <p>Per construir el projecte, farem:</p> Bash<pre><code>$ gradle build\nBUILD SUCCESSFUL in 1 s\n5 actionable tasks : 5 up-to-date\n</code></pre> <p>i per a executar-lo:</p> Bash<pre><code>gradle run --console plain\n</code></pre> <p>l'opci\u00f3  <code>--console plain</code> evita missatges per consola de l'execuci\u00f3 del programa. Adem\u00e9s, per a passar arguments al programa (tamany de l'\u00e0rea de dibuix) ho indicarem com segueix <code>--args=\"500 500\"</code>. </p> <p>Un cop el programa en execuci\u00f3, ens apareixer\u00e0 a la consola:</p> Text Only<pre><code># Figura: \n</code></pre> <p>Aquest programa ens permet dibuixar una escena formada per diverses figures. Les opcions disponibles compatibles amb la versi\u00f3 actual s\u00f3n:</p> <ul> <li><code>dimensions ample alt</code>: Estableix l'al\u00e7ada i l'amplada del canvas o llen\u00e7ol.</li> <li><code>cercle x y radi #color</code>: Afegeix un cercle a l'escena actual. El cercle es col\u00b7locar\u00e0 a les coordenades <code>x, y</code>, amb el radi especificat i un color en format <code>#RRGGBB</code>. Aquest color \u00e9s validat per una funci\u00f3 d'utilitat implementada a les llibreries.</li> <li><code>rectangle x y altura amplada #color</code>: Afegeix un rectangle col\u00b7locat a les coordenades <code>x, y</code>, amb les mesures especificades i un color.</li> <li><code>linia x1 y1 x2 y2 #color</code>: Afegeix una l\u00ednia des del punt d'inici <code>(x1, y1)</code> fins al punt final <code>(x2, y2)</code> i amb el color especificat. El programa estableix un gruix fixat de 3 p\u00edxels per a la l\u00ednia.</li> <li><code>draw</code>: Obre una finestra JavaFX i dibuixa totes les figures emmagatzemades i introdu\u00efdes en un canvas. Quan tanquem la finestra, l'aplicaci\u00f3 finalitzar\u00e0.</li> </ul>"},{"location":"Practiques/APAC1/#2-noves-funcionalitats","title":"2. Noves funcionalitats","text":"<p>Per tal de millorar el programa base, hem d'afegir la persist\u00e8ncia de dades, afegint funcions per emmagatzemar i recuperar escenes. Les ordres que hem de implementar s\u00f3n:</p> <ul> <li><code>import [fitxer.txt | fitxer.obj]</code> \\(\\rightarrow\\) Importar\u00e0 de disc les configuracions de les escenes (el dibuix), emmagatzemades en fitxers de text o fitxers d'objectes. El programa decidir\u00e0 el format tenint en compte l'extensi\u00f3 del fitxer.</li> <li><code>export [fitxer.txt | fitxer.obj | fitxer.svg | fitxer.json]</code> \\(\\rightarrow\\) Exportar\u00e0 a disc la configuraci\u00f3 actual de l'escena, guardant-la en fitxers de text, fitxers d'objectes, format svg (un format xml especial) o format json. El programa decidir\u00e0 el format tenint en compte l'extensi\u00f3 del fitxer.</li> </ul> <p>Nota</p> <p>Tots els fitxers es guardaran a l'arrel del programa</p>"},{"location":"Practiques/APAC1/#21-fitxers-dexemples","title":"2.1. Fitxers d'exemples","text":"<p>Fitxer de Text</p> <p>Text Only<pre><code>dimensions 500 500\nrectangle 10 10 480 480 #ccccee \ncercle 250 250 100 #aaaaaa\nlinia 50 250 450 250 #aaaaaa\nlinia 50 50 50 450 #aaaaaa\nlinia 450 40 450 450 #aaaaaa\n</code></pre> Arxiu SVG</p> XML<pre><code>&lt;?xmlversion=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?&gt;\n&lt;svg height=\"500\" width=\"500\"&gt;\n  &lt;rect fill=\"#ccccee\" height=\"480\" width=\"480\" x=\"10\" y=\"10\"/&gt;\n  &lt;circle cx=\"250\" cy=\"250\" fill=\"#aaaaaa\" r=\"100\"/&gt;\n  &lt;line stroke=\"#aaaaaa\" stroke-width=\"3\" x1=\"50\" x2=\"450\" y1=\"250\" y2=\"250\"/&gt;\n  &lt;line stroke=\"#aaaaaa\" stroke-width=\"3\" x1=\"50\" x2=\"50\" y1=\"50\" y2=\"450\"/&gt;\n  &lt;line stroke=\"#aaaaaa\" stroke-width=\"3\" x1=\"450\" x2=\"450\" y1=\"40\" y2= \"450\"/&gt;\n&lt;/svg&gt;\n</code></pre> <p>Nota</p> <p>Aquest tipus d'XML es fa perqu\u00e8 despr\u00e9s d'exportar aquesta escena, pots obrir-la amb Inkscape. Pots utilitzar-lo per comprovar que ho has fet b\u00e9.</p> <p>Format JSON</p> JSON<pre><code>{\"escena\": {\n    \"width\": 320,\n    \"height\": 320\n    \"figuras\": [\n        {\"cercle\": {\n            \"r\": \"26\",\n            \"cx\": \"166\",\n            \"cy\": \"105\",\n            \"fill\": \"#94c147\"\n        }},\n        {\"rectangle\": {\n            \"x\": \"137\",\n            \"width\": \"58\",\n            \"y\": \"108\",\n            \"fill\": \"#ffffff\",\n            \"height\": \"58\"\n        }},\n        {\"rectangle\": {\n            \"x\": \"139\",\n            \"width\": \"52\",\n            \"y\": \"111\",\n            \"fill\": \"#94c147\",\n            \"height\": \"52\"\n        }}\n     ],\n}}\n</code></pre>"},{"location":"Practiques/APAC1/#3-estructura-del-projecte","title":"3. Estructura del Projecte","text":"<p>Primer, tenim el fitxer <code>build.gradle</code>, amb informaci\u00f3 sobre la construcci\u00f3 del projecte, amb llibreries de gr\u00e0fics i JSON. En la nostra estructura de projecte, tenim:</p> <p>Text Only<pre><code>main\n  |-- java\n  |   `--com\n  |      `-- ieseljust\n            `-- ad\n                `-- figures\n                    |-- App.java\n                    |-- cercle.java\n                    |-- escena.java\n                    |-- figura.java\n                    |-- FileManager.java\n                    |-- HexColorValidator.java\n                    |-- Linia.java\n                    |-- punt.java\n                    `-- Rectangle.java\n</code></pre> Com a podeu veure, dins de la carpeta src, podem tenir en compte:</p> <ul> <li>App \\(\\rightarrow\\) classe principal. Mostra el prompt i crea el canvas. No cal que modifiquis aquesta classe.</li> <li>figura, cercle, linia, rectangle, punt \\(\\rightarrow\\) aquestes classes formen l'arbre d'her\u00e8ncia (excepte punt). Tenen els atributs i m\u00e8todes necessaris. Probablement necessitar\u00e0s afegir m\u00e8todes per obtenir la representaci\u00f3 d'aquesta classe en text, json o xml. Tamb\u00e9 cal que facis les classes necess\u00e0ries serialitzables.</li> <li>escena \\(\\rightarrow\\) cont\u00e9 alguns atributs i la col\u00b7lecci\u00f3 de figures.</li> <li>FileManager \\(\\rightarrow\\) classe que s'encarrega del proc\u00e9s d'emmagatzematge. Hem de fer la feina principal en aquesta classe, com es mostra al seg\u00fcent punt.</li> </ul>"},{"location":"Practiques/APAC1/#4-classe-filemanager","title":"4. Classe <code>FileManager</code>","text":"<p>Com ja hem explicat, aqu\u00ed \u00e9s on has de guardar i recuperar la informaci\u00f3 en diversos formats.</p>"},{"location":"Practiques/APAC1/#41-metode-exists","title":"4.1. M\u00e8tode <code>exists</code>","text":"Java<pre><code>public Boolean Exists(String file)\n</code></pre> <p>Retornar\u00e0 un valor l\u00f2gic en funci\u00f3 de l'exist\u00e8ncia del fitxer o no.</p>"},{"location":"Practiques/APAC1/#42-metode-importfromtext","title":"4.2. M\u00e8tode <code>importFromText</code>","text":"<p>Java<pre><code>public Escena importFromText(String file)\n</code></pre> Importa una escena en format de text, en el format indicat al principi d'aquest document. Tens un parell d'imatges per provar. Com pots veure, rep la ruta del fitxer en format de cadena i retornar\u00e0 un objecte de tipus Escena.</p> <p>Cal tenir en compte que, a m\u00e9s de les figures, pot apar\u00e8ixer la comanda <code>dimensions</code>, que indicar\u00e0 que haurem de modificar les dimensions de l'Escena.</p>"},{"location":"Practiques/APAC1/#43-metode-importfromobj","title":"4.3. M\u00e8tode <code>importFromObj</code>","text":"Java<pre><code>public Escena importFromObj(String file)\n</code></pre> <p>Importar una escena serialitzada en format d'objecte, en el format indicat al principi d'aquest document. A la carpeta imgs, tens un parell d'imatges per provar. Com pots veure, rep la ruta del fitxer en format de cadena i retornar\u00e0 un objecte de tipus Escena.</p>"},{"location":"Practiques/APAC1/#44-metode-exporttext","title":"4.4. M\u00e8tode <code>exportText</code>","text":"<p>Java<pre><code>public Boolean exportText(Escena escena, String file)\n</code></pre> Aquest m\u00e8tode exportar\u00e0 una escena donada a un fitxer de text, en el format especificat anteriorment, per poder-les llegir amb <code>importFromText</code>.</p> <p>El m\u00e8tode rebr\u00e0 l'objecte Escena i una cadena amb el nom del fitxer a desar, amb l'extensi\u00f3 <code>.txt</code>.</p> <p>Per implementar aquest m\u00e8tode, et ser\u00e0 \u00fatil implementar un m\u00e8tode anomenat <code>getAsText</code> (o similar) en cada tipus de figura, que retorni la pr\u00f2pia figura en el format desitjat. D'aquesta manera, per exportar l'escena, recorrerem les diferents figures i obtindrem la representaci\u00f3 de cadascuna d'elles.</p>"},{"location":"Practiques/APAC1/#45-metode-exportobj","title":"4.5. M\u00e8tode <code>exportObj</code>","text":"Java<pre><code>public Boolean exportObj(Escena escena, String file)\n</code></pre> <p>Aquest m\u00e8tode exportar\u00e0 una escena donada a un fitxer d'objectes, per poder-lo llegir amb <code>importFromObj</code>.</p> <p>El m\u00e8tode rebr\u00e0 l'objecte Escena i una cadena amb el nom del fitxer a desar, amb l'extensi\u00f3 <code>.obj</code>.</p> <p>Atenci\u00f3</p> <p>Recorda utilitzar el modificador <code>Serializable</code> en les classes necess\u00e0ries.</p>"},{"location":"Practiques/APAC1/#46-metode-exportsvg","title":"4.6. M\u00e8tode <code>exportSVG</code>","text":"Java<pre><code>public Boolean exportSVG(Escena escena, String file)\n</code></pre> <p>Aquest m\u00e8tode exportar\u00e0 una escena donada a un fitxer <code>svg</code>, en el format xml especificat anteriorment a les p\u00e0gines anteriors. El m\u00e8tode rebr\u00e0 l'objecte Escena i una cadena amb el nom del fitxer a desar, amb l'extensi\u00f3 <code>.svg</code>.</p> <p>Alguns detalls del format:</p> <ul> <li>Inclourem <code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?&gt;</code> sempre.</li> <li>L'element arrel \u00e9s l'etiqueta <code>&lt;svg&gt;</code>, amb dos atributs width i height.</li> <li>Cada figura heretada ser\u00e0 l'equivalent a l'etiqueta <code>rect</code>, <code>circle</code> i <code>line</code>. Mira l'exemple del document.</li> <li>Per obtenir una posici\u00f3 correcta del cercle, has d'afegir el radi a la posici\u00f3 de la figura: <code>this.posicio.getX()+this.radi</code> i <code>this.posicio.getY()+this.radi</code></li> </ul> <p>Important</p> <p>Per obtenir una implementaci\u00f3 correcta d'aquest m\u00e8tode (i altres que vindran), \u00e9s interessant seguir els seg\u00fcents passos:</p> <ul> <li>Declara un m\u00e8tode abstracte a la classe Figura. <code>getAsSVG()</code>, per exemple.</li> <li>Implementa aquest m\u00e8tode a cada classe descendents.</li> </ul>"},{"location":"Practiques/APAC1/#47-metode-exportjson","title":"4.7. M\u00e8tode <code>exportJSON</code>","text":"Java<pre><code>public Boolean exportJSON(Escena escena,String filename)\n</code></pre> <p>Aquest m\u00e8tode crear\u00e0 una representaci\u00f3 JSON de l'escena que rep el m\u00e8tode. Com es va mencionar a la nota anterior, \u00e9s una pr\u00e0ctica interessant crear el m\u00e8tode <code>getAsJson()</code> a la classe superior i implementar-lo a les classes inferiors.</p> <p>Atenci\u00f3</p> <p>Per treballar de manera m\u00e9s eficient, implementa els m\u00e8todes de la seg\u00fcent manera:</p> <ul> <li><code>importFromText</code>, per importar una escena completa i poder-la dibuixar.</li> <li><code>exportToText</code>, per comprovar que la teva escena sigui igual que l'original.</li> <li><code>exportToObj</code>, per desar una escena importada des de text.</li> <li><code>importFromObj</code>, per comprovar que l'exportada s'ha fet correctament.</li> <li>Finalment, la resta d'exports, a SVG i JSON.</li> </ul>"},{"location":"Practiques/APAC1/#5-entrega-de-la-practica","title":"5. Entrega de la pr\u00e0ctica","text":"<p>Per fer l'enviament de la pr\u00e0ctica, heu de seguir els seg\u00fcents passos:</p> <ul> <li>Executeu <code>gradle clean</code> per netejar tots els paquets i llibreries.</li> <li>Comprimiu la carpeta del projecte. El format zip \u00e9s obligatori.</li> <li>Pugeu la pr\u00e0ctica a la plataforma aules, evitant correus electr\u00f2nics o altres eines de comunicaci\u00f3.</li> </ul>"},{"location":"Practiques/APAC2/","title":"1. Visi\u00f3 General","text":"<p>Anem a crear un client de SGBD, com el MySQL Workbench, per\u00f2 en una versi\u00f3 de consola amb una shell i un prompt. El nostre client ens permet connectar-nos a un servidor, seleccionar una base de dades i finalment executar diverses consultes SQL.</p>"},{"location":"Practiques/APAC2/#11-mode-de-servidor","title":"1.1. Mode de servidor","text":"<p>En iniciar el nostre programa, demanar\u00e0 les dades del servidor.</p> Bash<pre><code>gradle run --console plain\n...\n$ Server: 127.0.0.1\n$ Port: 3308\n$ Username: root\n$ Password:\n$ (root) on 127.0.0.1:3308&gt;\n</code></pre> <p>Com podeu veure a l'\u00faltima l\u00ednia, el prompt \u00e9s <code>(usuari) a IP:port&gt;</code>. El nostre client mostra sempre on estem connectats.</p> <p>La llista d'ordres que el nostre client acceptar\u00e0 quan estigui connectat \u00e9s (mode servidor):</p> <ul> <li><code>show database</code> o <code>show db</code> \\(\\rightarrow\\) mostra una llista amb totes les bases de dades del nostre SGBD.</li> <li><code>info</code> \\(\\rightarrow\\) mostra informaci\u00f3 sobre el SGBD i la configuraci\u00f3 de la connexi\u00f3.</li> <li><code>import nom_del_script</code> \\(\\rightarrow\\) permet carregar un script SQL des d'un fitxer.</li> <li><code>use nom_de_la_bd</code> \\(\\rightarrow\\) canvia el nostre programa al mode base de dades.</li> <li><code>quit</code> \\(\\rightarrow\\) finalitza el nostre programa.</li> </ul>"},{"location":"Practiques/APAC2/#12-mode-de-base-de-dades","title":"1.2. Mode de Base de Dades","text":"<p>Un cop estiguem connectats a un servidor i haguem seleccionat una base de dades, el nostre client entrar\u00e0 en el mode de base de dades:</p> Bash<pre><code>$ (root) on 127.0.0.1:3308&gt;use Ciclismo\n$ (root) on 127.0.0.1:3308[Ciclismo]&gt;\n</code></pre> <p>Pots veure que el nom de la base de dades s'afegeix al prompt i ara el programa est\u00e0 esperant ordres per a la base de dades. Has d'implementar aquestes comandes:</p> <ul> <li><code>sh tables</code> \\(\\rightarrow\\) mostra totes les taules de la base de dades seleccionada.</li> <li><code>describe nom_de_la_taula</code> \\(\\rightarrow\\) mostra la descripci\u00f3 d'aquesta taula: camps, tipus de dades i claus prim\u00e0ries com a m\u00ednim.</li> <li><code>insert Nom_de_la_Taula</code> \\(\\rightarrow\\) de manera interactiva, demana a l'usuari el valor de cada camp i insereix una nova fila.</li> <li><code>sql</code> \\(\\rightarrow\\) executa qualsevol consulta a la base de dades seleccionada.</li> <li><code>quit</code> \\(\\rightarrow\\) torna al mode SGBD.</li> </ul>"},{"location":"Practiques/APAC2/#2-estructura-del-projecte-i-consells","title":"2. Estructura del projecte i consells","text":"<p>El projecte cont\u00e9 les seg\u00fcents classes:</p> <p></p> <p>Anem a revisar les funcions de classe</p>"},{"location":"Practiques/APAC2/#21-servermanager","title":"2.1. ServerManager","text":"<p>Cont\u00e9 el main, i quan s'inicia, demana a l'usuari la informaci\u00f3 del servidor. A continuaci\u00f3, inicia la classe <code>ConnectionManager</code> amb els valors proporcionats.</p>"},{"location":"Practiques/APAC2/#22-connectionmanager","title":"2.2. ConnectionManager","text":"<p>Gestiona la consola principal del programa i t\u00e9 com a atributs:</p> Java<pre><code>String server;\nString port;\nString user;\nString pass;\n</code></pre> <p>i com a m\u00e8todes:</p> <ul> <li><code>ConnectionManager()</code> \\(\\rightarrow\\) constructor per defecte.</li> <li><code>ConnectionManager(String server, String port, String user, String pass)</code> \\(\\rightarrow\\) constructor general.</li> <li><code>public Connection connectDBMS()</code> \\(\\rightarrow\\) inicia i retorna una connexi\u00f3.</li> <li><code>public void showInfo()</code> \\(\\rightarrow\\) mostra la informaci\u00f3 del servidor.</li> <li><code>public void showDatabases()</code> \\(\\rightarrow\\) mostra les taules del servidor.</li> <li><code>public void importScript(String script)</code> \\(\\rightarrow\\) carrega i executa un script.</li> <li><code>public void startShell()</code> \\(\\rightarrow\\) inicia la consola del servidor. Aquesta consola ja est\u00e0 gaireb\u00e9 implementada.</li> </ul>"},{"location":"Practiques/APAC2/#23-gestor-de-base-de-dades","title":"2.3. Gestor de Base de Dades","text":"<p>Gestiona la consola del mode base de dades i necessita un atribut addicional respecte al Gestor de Connexi\u00f3:</p> Java<pre><code>String server;\nString port;\nString user;\nString pass;\nString dbname;\n</code></pre> <p>i com a m\u00e8todes:</p> <ul> <li><code>DatabaseManager()</code> \\(\\rightarrow\\) constructor per defecte.</li> <li><code>DatabaseManager(String server, String port, String user, String pass,String dbname)</code> \\(\\rightarrow\\) constructor general.</li> <li><code>public Connection connectDatabase()</code> \\(\\rightarrow\\) inicia i retorna una connexi\u00f3 a la base de dades actual.</li> <li><code>public void insertIntoTable(String table)</code> \\(\\rightarrow\\) inicia l'assistent d'inserci\u00f3 per a la taula donada.</li> <li><code>public void showDescTable(String table)</code> \\(\\rightarrow\\) mostra la metadades de la taula.</li> <li><code>public void executeSelect(String query)</code> \\(\\rightarrow\\) executa una consulta donada (de qualsevol tipus) i mostra els resultats a la pantalla, si n'hi ha.</li> <li><code>public void startShell()</code> \\(\\rightarrow\\) inicia la consola del mode base de dades. Has de fer una implementaci\u00f3 completa.</li> </ul>"},{"location":"Practiques/APAC2/#3-insercions-a-les-taules","title":"3. Insercions a les taules.","text":"<p>El m\u00e8tode <code>insertIntoTable</code> \u00e9s probablement el m\u00e9s dif\u00edcil de la tasca, ja que cal demanar primer les metadades de la taula per con\u00e8ixer els camps i els tipus de dades de la taula, i despr\u00e9s demanar a l'usuari els valors i els formats.</p> <p>El consell que es donar\u00e0 \u00e9s crear tres llistes amb:</p> <ol> <li>Llista de camps que cal inserir.</li> <li>Llista de valors que s'assignaran.</li> <li>Llista de tipus de cada camp.</li> </ol> <p>A m\u00e9s, cal generar una llista o cadena de marcadors de posici\u00f3 amb tants <code>?</code> com sigui necessari.</p> <p>Consell</p> <p>Recorda que, en demanar les metadades de la taula, les columnes que necessites s\u00f3n:</p> Text Only<pre><code>- Columna 4: nom de la columna\n- Columna 6: tipus de dades de la columna\n- Columna 18: nullable o no. Aquest camp \u00e9s obligatori si no \u00e9s nullable.\n- Columna 23: incremental o no. No necessites aquest camp si \u00e9s incremental.\n</code></pre> <p>Finalment, verifica l'ajust dels placeholders, ja que depenen del tipus de dades. Tindre en compte que:</p> <ul> <li>Les dades <code>int</code> faran servir <code>setInt()</code></li> <li>Les dades <code>datetime</code> faran servir <code>setDate()</code>, amb un casting a <code>java.sql.Date</code> en compte de <code>java.Date</code></li> <li>Per defecte el <code>setString</code> i confiar que el casting autom\u00e0tic fa\u00e7a la seua feina.</li> </ul> <p>\u00a9 Joan Gerard Camarena, October-2022</p> <p>\u00a9 \u00daltima revisi\u00f3, October-2024</p>"},{"location":"Practiques/APAC3/","title":"Pr\u00e0ctica 3","text":"<p>Notes sobre l'enunciat i pr\u00e0ctica</p> <p>Aquesta pr\u00e0ctica \u00e9s d'enunciat obert. Has de crear la teua pr\u00f2pia tasca, amb certes limitacions, com comprendr\u00e0s. Has de fer un programa que fa\u00e7a el manteniment d'una base de dades a la teua elecci\u00f3: podr\u00e0s crear-la de zero o escollir-ne alguna que conegues o cercar a internet.</p>"},{"location":"Practiques/APAC3/#1-la-base-de-dades","title":"1. La base de dades","text":"<p>Les restriccions de la base de dades s\u00f3n:</p> <ul> <li>Ha de contenir com a m\u00ednim tres entitats.</li> <li>Ha de contenir com a m\u00ednim tres relacions, una de cada classe: <code>1-1</code>, <code>1-M</code> i <code>N:M</code>. Si vols, pots crear una relaci\u00f3 reflexiva.</li> <li>Utilitza MySQL</li> </ul>"},{"location":"Practiques/APAC3/#2-el-programa","title":"2. El programa","text":""},{"location":"Practiques/APAC3/#21-estructura","title":"2.1. Estructura","text":"<p>Crea un programa Hibernate amb l'objectiu de realitzar les operacions b\u00e0siques de CRUD a la base de dades (Create, Read, Update i Delete). Mapeja totes les entitats i relacions de la base de dades.</p>"},{"location":"Practiques/APAC3/#22-crud","title":"2.2. CRUD","text":"<p>Com tot el treball de cada entitat \u00e9s el mateix (canviant el nom de l'entitat), nom\u00e9s has de crear un CRUD complet per a una entitat. A continuaci\u00f3, crea m\u00e8todes per inserir, eliminar, actualitzar i seleccionar informaci\u00f3 d'una entitat.</p>"},{"location":"Practiques/APAC3/#23-relacions","title":"2.3. Relacions","text":"<p>Imagina que tenim una relaci\u00f3 <code>1:M</code>, un <code>Autor</code> escriu diversos <code>Llibres</code>. Amb les teves pr\u00f2pies relacions, fes el mateix de la seg\u00fcent manera:</p>"},{"location":"Practiques/APAC3/#231-tasca-1","title":"2.3.1. Tasca 1","text":"<p>Has de mostrar registres d'una entitat, per exemple <code>mostra Autor</code>. Aquesta comanda mostrar\u00e0 tots els autors de la base de dades. Per\u00f2 si la comanda \u00e9s <code>mostra -r Autor</code>, mostrar\u00e0 per a cada autor els llibres que ha escrit. (<code>r</code> significa recursivament)</p>"},{"location":"Practiques/APAC3/#232-tasca-2","title":"2.3.2. Tasca 2","text":"<p>Quan vulguis inserir un nou Llibre, pots executar <code>afegir Llibre</code>, i despr\u00e9s, de manera interactiva, el programa demanar\u00e0 els valors del llibre i el crear\u00e0 i emmagatzemar\u00e0, establint l'Autor com a <code>null</code>. Per\u00f2 si executes <code>afegir -r Llibre</code>, el programa mostrar\u00e0 tots els autors de la base de dades. L'usuari en seleccionar\u00e0 un, i aquest Autor es configurar\u00e0 com a autor del llibre.</p> <p>En el proc\u00e9s de selecci\u00f3 de l'Autor, hi haur\u00e0 una opci\u00f3 addicional (Autor 0, per exemple) quan l'autor del llibre no estigui a la base de dades, i crearem un nou Autor i despr\u00e9s l'assignarem al Llibre. Tant l'Autor com el Llibre es desaran.</p>"},{"location":"Practiques/APAC3/#3-tasca","title":"3. Tasca.","text":"<p>Per pujar la tasca a la plataforma, nom\u00e9s cal que escriguis un enlla\u00e7 a un repositori privat de GitHub de l'estudiant. Has d'afegir l'usuari del teu professor com a convidat del teu repositori (<code>joange</code> - jgcamarena@ieseljust.com). La tasca es presentar\u00e0 amb els seg\u00fcents punts.</p> <p>En la carpeta del teu treball has de tenir:</p> <ol> <li>Un script amb la creaci\u00f3 de taules de la base de dades i alguna dada d'exemple. Has de generar-ho amb MySQL Workbench sql dump.</li> <li>Una imatge de l'estructura de la teva base de dades, creada amb MySQL Workbench reverse engineering.</li> <li>Un projecte Maven que implementi els requisits d'aquest text.</li> <li>Fitxer <code>Readme.md</code> amb documentaci\u00f3 sobre el teu programa.</li> </ol>"},{"location":"Practiques/APAC3/#31-punt-de-control-1-la-base-de-dades","title":"3.1. Punt de control 1. La base de dades.","text":"<p>En aquesta tasca has de presentar el teu repositori quan hagis acabat les parts 1 i 2. El professor ho marcar\u00e0 com a <code>OK</code> abans de comen\u00e7ar a programar la part 3.</p>"},{"location":"Practiques/APAC3/#32-punt-de-control-2-el-programa","title":"3.2. Punt de control 2. El programa.","text":"<p>Quan hagis acabat la tasca, presenta el teu repositori.</p> <p>(c) Joan Gerard Camarena Estruch, novembre 2022</p>"},{"location":"UD1_Files/1_File_System/","title":"1. Sistema de fitxers","text":""},{"location":"UD1_Files/1_File_System/#11-introduccio","title":"1.1. Introducci\u00f3","text":"<p>En els inicis de la inform\u00e0tica, els fitxers eren l'\u00fanic mecanisme per emmagatzemar informaci\u00f3. Avui en dia, els sistemes operatius gestionen els dispositius d'emmagatzematge de manera gaireb\u00e9 transparent per a l'usuari. Sense entrar en detalls de les tecnologies de emmagatzematge subjacents, ens ofereixen una abstracci\u00f3 mitjan\u00e7ant la qual nom\u00e9s hem de preocupar-nos de dos conceptes: fitxers i directoris.</p> <ul> <li>Fitxer \u2192 contenidors d'informaci\u00f3 (de tot tipus i format).</li> <li>Directoris \u2192 organitzadors de fitxers, i poden contenir fitxers i altres directoris.</li> </ul> <p>Seguint amb la informaci\u00f3 (el contingut del fitxer), podem trobar una classificaci\u00f3 cl\u00e0ssica:</p> <ul> <li>Fitxer de text \u2192 la informaci\u00f3 s'emmagatzema en fitxers, de manera que es pot veure o obrir amb qualsevol editor de text pla, com ara vi, nano o notepad.</li> <li>Fitxer binari \u2192 la informaci\u00f3 s'emmagatzema codificada en format binari. Com ja sap l'estudiant, qualsevol tipus d'informaci\u00f3 (text, n\u00fameros, fotos, etc.) es pot traduir a 0 i 1. En el nostre cas (programadors), podem transformar objectes i variables de diferents maneres.</li> </ul> <p>Cal tenir en compte que...</p> <ul> <li>Tot i que emmagatzemem informaci\u00f3 en fitxers de text, apareix un nou concepte: estructura. Si organitzem la informaci\u00f3 de diferents maneres, podem parlar de fitxers csv, fitxers xml, fitxers json. Els fitxers csv, xml i json s\u00f3n estructures, perqu\u00e8 al cap i a la fi, tots ells s\u00f3n fitxers de text.</li> <li>La gent pensa que els fitxers de text s\u00f3n febles per emmagatzemar informaci\u00f3, per\u00f2 no \u00e9s cert. Les t\u00e8cniques criptogr\u00e0fiques ens ofereixen m\u00e8todes per emmagatzemar informaci\u00f3 de manera segura dins dels fitxers de text. Per exemple, <code>htpasswd</code> a apache o <code>/etc/shadoW</code> en sistemes Linux. A sota podeu veure un exemple de clau p\u00fablica PGP, emmagatzemada en un fitxer de text.</li> </ul> Bash<pre><code>-----BEGIN PGP PUBLIC KEY BLOCK-----\nComment: Alice's OpenPGP certificate\nComment: https://www.ietf.org/id/draft-bre-openpgp-samples-01.html\n\nmDMEXEcE6RYJKwYBBAHaRw8BAQdArjWwk3FAqyiFbFBKT4TzXcVBqPTB3gmzlC/U\nb7O1u120JkFsaWNlIExvdmVsYWNlIDxhbGljZUBvcGVucGdwLmV4YW1wbGU+iJAE\n...\nDAAKCRDyMVUMT0fjjlnQAQDFHUs6TIcxrNTtEZFjUFm1M0PJ1Dng/cDW4xN80fsn\n0QEA22Kr7VkCjeAEC08VSTeV+QFsmz55/lntWkwYWhmvOgE=\n=iIGO\n-----END PGP PUBLIC KEY BLOCK-----\n</code></pre>"},{"location":"UD1_Files/1_File_System/#12-accedint-al-sistema-de-fitxers-en-java","title":"1.2. Accedint al sistema de fitxers en Java","text":"<p><code>Java</code> ens ofereix diverses maneres d'accedir al sistema de fitxers. Aquesta manera \u00e9s independent del dispositiu subjacent que emmagatzema la informaci\u00f3. El dispositiu pot ser un disc dur, un disc ssd, una unitat \u00f2ptica, etc. La classe que ens ofereix aquesta possibilitat \u00e9s la classe File. Repassarem els principals aspectes d'aquesta classe i despr\u00e9s revisarem alguns exemples.</p> <ul> <li> <p>El constructor de la classe est\u00e0 sobrecarregat, com la majoria de les classes de Java. Podem utilitzar:</p> <ul> <li><code>File(File parent, String child)</code> \u2192 Crea una nova inst\u00e0ncia de File a partir d'un directori pare abstracte i una cadena de directori fill.</li> <li><code>File(String pathname)</code> \u2192 Crea una nova inst\u00e0ncia de File convertint la cadena de directori donada en un directori abstracte.</li> <li><code>File(String parent, String child)</code> \u2192 Crea una nova inst\u00e0ncia de File a partir d'una cadena de directori pare i una cadena de directori fill.</li> <li><code>File(URI uri)</code> \u2192 Crea una nova inst\u00e0ncia de File convertint el file: URI donat en un directori abstracte.</li> </ul> </li> <li> <p>Per accedir al fitxer hem d'utilitzar un nom de ruta. Aquesta \u00e9s la ruta, i tenim dues possibilitats:</p> <ul> <li>Ruta absoluta \u2192 la ruta des del directori arrel del sistema fins al fitxer que volem, comen\u00e7ant amb <code>/</code> en sistemes Linux o <code>letra:</code> en sistemes Windows. Recorda utilitzar <code>/</code> per separar carpetes en Linux i <code>\\\\</code> en Windows. No \u00e9s un error, ja que la barra invertida \u00e9s un s\u00edmbol amb un significat propi, hem d'escapar-la, duplicant-la per obtenir el significat que volem.</li> <li>Ruta relativa \u2192 suposem que el fitxer que volem es troba a la mateixa carpeta que el projecte/programa que estem executant. En aquest cas, nom\u00e9s proporcionem el nom del fitxer, sense cap carpeta al principi de la ruta.</li> </ul> </li> </ul> Java<pre><code>// absolute paths\nFile f=new File(\"/home/joange/texto.md\") //  Linux\nFile f=new File(\"C:\\\\Usuarios\\\\joange\\\\Dektop\\\\texto.md\") //  Windows\n...\n// relative paths\nFile f=new File(\"texto.md\") //  Linux\nFile f=new File(\"docs\\\\texto.md\") //  Windows\n</code></pre> <ul> <li>La mateixa classe <code>File</code> s'utilitza per accedir tant a un fitxer regular com a un directori. \u00c9s tasca del programador diferenciar-los mitjan\u00e7ant els m\u00e8todes de fitxer, aix\u00ed com comprovar si un fitxer existeix. Per fer aix\u00f2, podem utilitzar diversos m\u00e8todes com:<ul> <li><code>boolean exists()</code> \u2192 retorna true si l'objecte de fitxer existeix i false en cas contrari.</li> <li><code>boolean isFile()</code> i <code>isDirectory()</code> \u2192 retorna true si l'objecte \u00e9s un fitxer regular o un directori. \u00d2bviament, aquests m\u00e8todes s\u00f3n exclusius.</li> </ul> </li> </ul>"},{"location":"UD1_Files/1_File_System/#13-creant-fitxers","title":"1.3. Creant fitxers","text":"<p>Si volem crear una carpeta o un fitxer regular, podem utilitzar aquests m\u00e8todes:</p> <ul> <li><code>boolean createNewFile()</code> \u2192 Crea de manera at\u00f2mica un nou fitxer buit amb el nom especificat si i nom\u00e9s si un fitxer amb aquest nom encara no existeix.</li> <li><code>static FilecreateTempFile(String prefix, String suffix)</code> \u2192 Crea un fitxer buit al directori temporal per defecte, utilitzant el prefix i el sufix especificats per generar el seu nom.</li> <li><code>boolean mkdir()</code> \u2192 Crea el directori amb el nom especificat.</li> <li><code>boolean mkdirs()</code> \u2192 Crea el directori amb el nom especificat, incloent qualsevol directori pare necessari per\u00f2 que no existeixi.</li> <li><code>boolean renameTo(File dest)</code> \u2192 Canvia el nom del fitxer especificat.</li> <li><code>boolean delete()</code> \u2192 Elimina el fitxer o directori especificat.</li> </ul> <p>Atenci\u00f3</p> <ul> <li>En les seccions seg\u00fcents estudiarem com crear fitxers quan hi guardem contingut. En altres paraules, no cal crear el fitxer ad hoc i despr\u00e9s omplir-lo. Hi ha mecanismes per crear el fitxer de manera automatitzada.</li> <li>La difer\u00e8ncia entre mkdir i mkdirs \u00e9s que la segona opci\u00f3 crear\u00e0 tots els directoris entre el sistema de fitxers arrel i el directori actual, mentre que la primera requereix que la ruta ja existeixi.</li> </ul>"},{"location":"UD1_Files/1_File_System/#14-demanant-propietats-del-fitxer","title":"1.4. Demanant propietats del fitxer","text":"<p>Normalment obrim fitxers per escriure o llegir el seu contingut, per\u00f2 a vegades necessitem demanar les propietats del fitxer, com ara la mida, els permisos, etc. La classe File ens ajudar\u00e0 de nou.</p> <p>Informaci\u00f3 general:</p> <ul> <li><code>boolean exists()</code> \u2192 Comprova si el fitxer o directori indicat per aquesta ruta abstracta existeix.</li> <li><code>long lastModified()</code> \u2192 Retorna el temps en qu\u00e8 es va modificar per \u00faltima vegada el fitxer indicat per aquesta ruta abstracta.</li> <li><code>long length()</code> \u2192 Retorna la mida del fitxer indicat per aquesta ruta abstracta.</li> </ul> <p>Informaci\u00f3 sobre els permisos. Aquesta informaci\u00f3 \u00e9s la mateixa que l'usuari pot obtenir amb <code>ls -la</code> en el format de <code>chmod</code>:</p> <ul> <li><code>boolean canExecute()</code> \u2192 Comprova si l'aplicaci\u00f3 pot executar el fitxer indicat per aquesta ruta abstracta.</li> <li><code>boolean canRead()</code> \u2192 Comprova si l'aplicaci\u00f3 pot llegir el fitxer indicat per aquesta ruta abstracta.</li> <li><code>boolean canWrite()</code> \u2192 Comprova si l'aplicaci\u00f3 pot modificar el fitxer indicat per aquesta ruta abstracta.</li> </ul> <p>Contingut d'un directori:</p> <ul> <li><code>String[] list()</code> \u2192 Retorna un array de cadenes amb els noms dels fitxers i directoris del directori indicat per aquesta ruta abstracta.</li> <li><code>File[] listFiles()</code> \u2192 Retorna un array de rutes abstractes que indiquen els fitxers del directori indicat per aquesta ruta abstracta.</li> <li><code>String[] list(FilenameFilter filter)</code> \u2192 Retorna un array de cadenes amb els noms dels fitxers i directoris del directori indicat per aquesta ruta abstracta que compleixen el filtre especificat.</li> <li><code>File[] listFiles(FilenameFilter filter)</code> \u2192 Retorna un array de rutes abstractes que indiquen els fitxers i directoris del directori indicat per aquesta ruta abstracta que compleixen el filtre especificat.</li> </ul> <p>Consell</p> <p>Suggerim a l'estudiant que busqui informaci\u00f3 sobre la classe FilenameFilter.</p>"},{"location":"UD1_Files/1_File_System/#141-exercici-resolt","title":"1.4.1. Exercici resolt","text":"<p>Analitza i explica el seg\u00fcent bloc de codi Java<pre><code>public static void main(String[] args) {\n        String ruta = args[0];\n        File f = new File(ruta);\n\n        if (f.exists()) {\n            if (f.isFile()) {\n                System.out.println(\"El tama\u00f1o es de \" + f.length());\n                System.out.println(\"Puede ejecturase: \" + f.canExecute());\n                System.out.println(\"Puede leerse: \" + f.canRead());\n                System.out.println(\"Puede escribirse: \" + f.canWrite());\n            } else {\n                String[] losArchivos = f.list();\n                System.out.println(\"El directorio \" + ruta + \" contiene:\");\n                for (String archivo : losArchivos) {\n                    System.out.println(\"\\t\" + archivo);\n                }\n            }\n\n        } else {\n            System.out.println(\"El fichero o ruta no existe\");\n        }\n}\n</code></pre></p> <p>Soluci\u00f3</p> <ol> <li>Aquest programa llegeix des de la l\u00ednia de comandes una ruta i crea un objecte File.</li> <li>A continuaci\u00f3, comprova si la ruta existeix o no al sistema de fitxers. En cas que no existeixi, el programa finalitza.</li> <li>Si la ruta existeix, el seg\u00fcent pas \u00e9s verificar si \u00e9s un fitxer:<ol> <li>Llegim algunes propietats trivials com la mida i els permisos.</li> </ol> </li> <li>Si la ruta apuntada pel fitxer \u00e9s un directori, obtenim el contingut d'aquest directori i el mostrem a la pantalla.</li> </ol>"},{"location":"UD1_Files/2_Reading_and_writing_files/","title":"1. Lectura i escriptura de fitxers","text":"<p>Java ofereix una gran varietat de maneres de manipular el contingut dels fitxers, aportant gran poder per\u00f2 tamb\u00e9 complexitat al mateix temps.</p> <p>La lectura i escriptura de fitxers en Java es fa a trav\u00e9s de fluxos de dades o <code>streams</code>, que poden ser orientats a bytes o considerats com un conjunt de car\u00e0cters. El concepte de fitxer, que \u00e9s est\u00e0tic, ha de diferenciar-se del concepte de flux, que t\u00e9 un car\u00e0cter din\u00e0mic: un fitxer es guarda al disc, per\u00f2 des del punt de vista de l'aplicaci\u00f3, ens interessa la transfer\u00e8ncia d'aquesta informaci\u00f3 des del fitxer al nostre programa. Una comparaci\u00f3 cl\u00e0ssica: els fluxos serien com canonades d'aigua, mentre que els fitxers serien dip\u00f2sits. El concepte de flux de dades, a part de l'\u00e0mbit dels fitxers, tamb\u00e9 ser\u00e0 aplicable a la transfer\u00e8ncia d'informaci\u00f3, per exemple a trav\u00e9s de la xarxa o entre processos.</p> <p>Els fluxes es poden classificar en:</p> <ul> <li><code>flux d'entrada</code>: Aquells que van des d'una font (per exemple, un fitxer) al programa.</li> <li><code>flux de sortida</code>: Aquells que surten del programa cap a una destinaci\u00f3 (per exemple, un fitxer).</li> </ul> <p>Quan llegim i emmagatzemem dades, hem de tenir molt de compte amb els tipus de dades amb els quals treballem, ja que la mateixa seq\u00fc\u00e8ncia de bits al disc representa informaci\u00f3 diferent segons el tipus de dades utilitzat. Inclos quan es tracta del mateix tipus de dades, com en el cas dels car\u00e0cters, cal tenir cura especial, ja que diferents sistemes poden utilitzar diferents codificacions. Java, per exemple, per al tipus char utilitza Unicode de 16 bits (UTF-16), per\u00f2 podem intentar accedir a fitxers codificats, per exemple, amb UTF-8 o ASCII.</p> <p>Les superclasses pare per al maneig de corrents orientats a bytes s\u00f3n <code>InputStream</code> i <code>OutputStream</code>. D'elles en deriven altres, per\u00f2 per a la gesti\u00f3 de fitxers ens interessen dues: <code>FileInputStream</code> i <code>FileOutputStream</code>.</p>"},{"location":"UD1_Files/2_Reading_and_writing_files/#11-fileinputstream","title":"1.1. FileInputStream","text":"<p>La classe <code>FileInputStream</code> s'utilitza per accedir a fitxers per a la lectura i t\u00e9 dos constructors principals:</p> <ul> <li><code>FileInputStream (File f)</code> \u2192 Rep un objecte de tipus <code>File</code>, que far\u00e0 refer\u00e8ncia a l'objecte que llegirem.</li> <li><code>FileInputStream (String name)</code> \u2192 Rep una cadena amb el nom o la ruta de la ubicaci\u00f3 del fitxer a llegir.</li> </ul> <p>Els principals m\u00e8todes que tenim per a aquesta classe s\u00f3n:</p> <ul> <li><code>int read()</code> \u2192 M\u00e8tode de lectura seq\u00fcencial abstracte: Retorna un enter corresponent al seg\u00fcent byte d'un flux d'entrada (fitxer, vector de bytes...). Si arriba al final de la seq\u00fc\u00e8ncia, retorna <code>-1</code>. En cas d'error, llan\u00e7ar\u00e0 una excepci\u00f3 de tipus <code>IOException</code>.</li> <li><code>int read(byte[] buffer)</code> \u2192 Llegeix un nombre determinat de bytes de l'entrada (tant com el tamany del buffer), els guarda al buffer i retorna el nombre de bytes llegits efectivament, que com a m\u00e0xim ser\u00e0 igual al tamany del buffer. Si no hi ha bytes disponibles, retorna <code>-1</code>.</li> <li><code>int available()</code> \u2192 Indica els bytes disponibles per a la lectura.</li> <li><code>long skip(long des)</code> \u2192 Salta tants bytes com indica el par\u00e0metre. El valor de retorn \u00e9s el nombre de bytes que s'han descartat efectivament (pot ser menor que el que hem indicat si arribem al final, per exemple).</li> <li><code>int close()</code> \u2192 Tanca el flux de dades.</li> </ul>"},{"location":"UD1_Files/2_Reading_and_writing_files/#12-fileoutputstream","title":"1.2. FileOutputStream","text":"<p>La classe <code>FileOutputStream</code> s'utilitza per accedir a fitxers per a l'escriptura. T\u00e9 els seg\u00fcents constructors:</p> <ul> <li><code>FileOutputStream (File f)</code> \u2192 Rep un objecte de tipus <code>File</code> i l'obre en mode escriptura. En cas que no existeixi, es crear\u00e0, i si ja existeix, es sobreescriur\u00e0.</li> <li><code>FileOutputStream (String name)</code> \u2192 Rep una cadena amb el nom o la ruta de la ubicaci\u00f3 del fitxer a escriure, i l'obre en mode escriptura. En cas que no existeixi, es crear\u00e0, i si ja existeix, es sobreescriur\u00e0.</li> <li><code>FileOutputStream (File f, boolean append)</code> \u2192 Rep un objecte de tipus <code>File</code> i l'obre en mode afegir, per escriure al final. Si no existeix, es crear\u00e0, i si ja existeix, s'escriur\u00e0 darrere (nom\u00e9s si append est\u00e0 establert a <code>True</code>).</li> <li><code>FileOutputStream (String name, boolean append)</code> \u2192 Rep una cadena amb el nom o la ruta de la ubicaci\u00f3 del fitxer a escriure i l'obre en mode afegir, per escriure al final. Si no existeix, es crear\u00e0, i si ja existeix, s'escriur\u00e0 darrere (nom\u00e9s si append est\u00e0 establert a <code>True</code>).</li> </ul> <p>Els principals m\u00e8todes de la classe s\u00f3n:</p> <ul> <li><code>write(int byte)</code> \u2192 Escriu el byte al flux de sortida. Encara que aquest par\u00e0metre \u00e9s un enter, nom\u00e9s s'escriu un byte. Si hi ha un error, es llan\u00e7ar\u00e0 una excepci\u00f3 de tipus <code>IOException</code>.</li> <li><code>void write(byte[] buffer)</code> \u2192 Escriu el contingut del buffer (vector de bytes) al fitxer. Si el buffer \u00e9s nul, llan\u00e7ar\u00e0 una excepci\u00f3.</li> <li><code>void write(byte[] buffer, int pos, int length)</code> \u2192 Escriu el contingut del <code>buffer</code> (vector de bytes) des de la posici\u00f3 <code>pos</code>, i tants bytes com s'indiquin en <code>length</code>.</li> <li><code>void flush()</code> \u2192 For\u00e7a l'escriptura dels bytes restants a la mem\u00f2ria cau al fitxer de sortida.</li> <li><code>void close()</code> \u2192 Tanca el flux de sortida i allibera els recursos.</li> </ul>"},{"location":"UD1_Files/2_Reading_and_writing_files/#121-exercici-resolt","title":"1.2.1. Exercici resolt","text":"<p>Crea un programa senzill en Java que copie un fitxer a un altre fitxer byte a byte. El fitxer origen i el fitxer dest\u00ed s'indicaran a trav\u00e9s de la l\u00ednia de comandes.</p> <p>Soluci\u00f3</p> Java<pre><code>class FileCopy {\n    /*\n    Class to test FileInputStream and FileOutputStream. \n\n    Copy byte to byte of files\n\n    Sintaxi:\n        FileCopy sourceFile destinationFile.\n\n    */\n    public static void main(String[] args) throws Exception {\n        // Byte readed from source\n        int bytes;        \n        // Bytes (effectively) writen to dest\n        long bytesCopied=0; \n\n        // Streams \n\n        FileInputStream fis= null;\n        FileOutputStream fos=null;\n\n        // To provide information about source\n        File f; \n\n\n        // Are the arguments ok?\n        if(args.length!=2){\n            System.out.println(\"Nombre d'arguments erroni. Sintaxi:\\n FileCopy fitxerOrigen fitxerDesti\");\n            return;\n        }\n\n        try{\n\n            // show source size\n            f=new File(args[0]);\n            System.out.println(\"Total: \"+f.length()+\" bytes\");\n\n            // Create streams          \n            fis=new FileInputStream(args[0]);\n            fos=new FileOutputStream(args[1]);\n\n            do {\n                // read one byte from source\n                bytes=fis.read();                 \n                // write in destination\n                if (bytes!=-1)\n                    fos.write(bytes);\n                // Update number of bytes\n                bytesCopied++;                    \n\n                // Show progress (think alternatives as exercise)\n                System.out.print(\"\\rCopiats \"+(bytesCopied-1)+\" bytes...\");\n            }while (bytes!=-1);\n            System.out.println(\"Done it!\");\n\n\n        }catch (IOException exc){\n            System.out.println(\"Error d'entrada i eixida: \"+exc);\n        }finally {\n            // At the end, we have to close the files, either an error exists or not.\n            try {\n                if (fis!=null) fis.close();\n            }catch (IOException exc){\n                System.out.println(\"Error en tancar el fitxer d'origen.\");\n            }\n            try {\n                if(fos!=null) fos.close();\n            }catch (IOException exc){\n                System.out.println(\"Error en tancar el fitxer dest\u00ed.\");\n            }\n        }\n    }\n}\n</code></pre> <p>Pensa i comprova</p> <p>Amb el programa d'exemple que hem vist, podr\u00edem copiar fitxers de tot tipus: text, \u00e0udio, v\u00eddeo. Prova-ho tu mateix i comprova que el contingut \u00e9s el mateix.</p> <p>Repte</p> <p>Intenta canviar l'\u00faltim programa per llegir les dades en blocs de 32 bytes, utilitzant els m\u00e8todes adequats de les classes. Comparteix la teva soluci\u00f3 al f\u00f2rum.</p>"},{"location":"UD1_Files/2_Reading_and_writing_files/#13-fitxers-de-text","title":"1.3. Fitxers de text","text":"<p>Com s'ha dit, Java permet gestionar fluxos amb orientaci\u00f3 a bytes o amb orientaci\u00f3 a car\u00e0cters. Les classes abstractes per a la gesti\u00f3 de fluxos orientats a car\u00e0cters s\u00f3n <code>Reader</code> i <code>Writer</code>. Aquestes classes deriven d'altres, per\u00f2 per a la gesti\u00f3 de fitxers ens centrem en <code>FileReader</code> i <code>FileWriter</code>.</p>"},{"location":"UD1_Files/2_Reading_and_writing_files/#131-filereader","title":"1.3.1. <code>FileReader</code>","text":"<p>La classe <code>FileReader</code> serveix per accedir a fitxers per a la lectura i t\u00e9 dos constructors:</p> <ul> <li><code>FileReader (File f)</code> \u2192 Rep un objecte de tipus <code>File</code>, que far\u00e0 refer\u00e8ncia a l'objecte del qual s'obtindr\u00e0 la informaci\u00f3.</li> <li><code>FileReader (String name)</code> \u2192 Rep una cadena amb el nom o la ruta del fitxer.</li> </ul> <p>Els m\u00e8todes que tenim per a aquesta classe s\u00f3n molt semblants als que tenim per a <code>FileInputStream</code>, amb la difer\u00e8ncia que ara llegim car\u00e0cters en comptes de bytes. Un aspecte a tenir en compte \u00e9s que aquests car\u00e0cters es representaran en el format del sistema operatiu amfitri\u00f3 (UTF-8 en el cas de Linux), a difer\u00e8ncia de l'UTF-16 utilitzat per altres classes d'emmagatzematge intern:</p> <ul> <li><code>int read()</code> \u2192 Llegeix el seg\u00fcent car\u00e0cter del flux d'entrada i el retorna com a enter. Si no queden car\u00e0cters, retorna -1, i si hi ha un error, llan\u00e7a una excepci\u00f3 de tipus IOException.</li> <li><code>int read(char[] buffer)</code> \u2192 Omple el buffer amb tants car\u00e0cters de l'entrada com tingui (com a m\u00e0xim). Retorna el nombre de car\u00e0cters llegits efectivament. Aquest nombre ser\u00e0 la longitud del buffer o menys si no hi ha prou car\u00e0cters per llegir. Si no n'hi ha cap, retorna -1.</li> <li><code>int available()</code> \u2192 Retorna el nombre de car\u00e0cters disponibles per a la lectura.</li> <li><code>long skip(long des)</code> \u2192 Salta tants car\u00e0cters com indica el par\u00e0metre. El valor de retorn \u00e9s el nombre de car\u00e0cters que s'han descartat efectivament (pot ser menor que el que hem indicat si arribem al final, per exemple).</li> <li><code>int close()</code> \u2192 Tanca el flux de dades.</li> </ul>"},{"location":"UD1_Files/2_Reading_and_writing_files/#132-filewriter","title":"1.3.2. <code>FileWriter</code>","text":"<p>La classe FileWriter seria l'equivalent de <code>FileOutputStream</code> en la versi\u00f3 de fluxes orientats a car\u00e0cters. Els constructors de la classe s\u00f3n:</p> <ul> <li><code>FileWriter (File f)</code> \u2192 Obre el fitxer especificat per <code>File</code> per a l'escriptura. Si el fitxer no existeix, es crear\u00e0, i si ja existeix, es borraran els continguts.</li> <li><code>FileWriter (String name)</code> \u2192 Obre el fitxer especificat per una cadena amb el nom i la ruta en mode escriptura. Si no existeix, es crear\u00e0, i si ja existeix, es borraran els continguts.</li> <li><code>FileWriter (File f, boolean append)</code> \u2192 Rep un objecte de tipus <code>File</code> i l'obre en mode afegir, per escriure al final. Si no existeix, es crear\u00e0, i si ja existeix, s'escriur\u00e0 darrere.</li> <li><code>FileWriter (String name, boolean append)</code> \u2192 Rep una cadena amb el nom o la ruta de la ubicaci\u00f3 del fitxer a escriure i l'obre en mode afegir, per escriure al final. Si no existeix, es crear\u00e0, i si ja existeix, s'escriur\u00e0 darrere.</li> </ul> <p>Els principals m\u00e8todes de la classe <code>FileWriter</code> s\u00f3n molt similars als de <code>OutputStream</code>:</p> <ul> <li><code>write(int character)</code> \u2192 Escriu el car\u00e0cter al flux de sortida, amb la codificaci\u00f3 pr\u00f2pia del sistema operatiu. Si hi ha un error, es llan\u00e7a una excepci\u00f3 de tipus <code>IOException</code>.</li> <li><code>void write(char[] buffer)</code> \u2192 Escriu el contingut del buffer (vector de car\u00e0cters) al fitxer. Si el buffer \u00e9s nul, llan\u00e7ar\u00e0 una excepci\u00f3.</li> <li><code>void write(char[] buffer, int pos, int length)</code> \u2192 Escriu el contingut del buffer (array de car\u00e0cters) des de la posici\u00f3 pos, i tants bytes com s'indiquin en length.</li> <li><code>void flush()</code> \u2192 For\u00e7a l'escriptura dels bytes restants a la mem\u00f2ria cau al fitxer de sortida.</li> <li><code>void close()</code> \u2192 Tanca el flux de sortida i allibera els recursos.</li> <li><code>void write(String text)</code> \u2192 Escriu tot el contingut de text al fitxer.</li> </ul>"},{"location":"UD1_Files/2_Reading_and_writing_files/#133-exercici-resolt","title":"1.3.3. Exercici resolt","text":"<p>Crea un programa senzill en Java que fusioni tots els fitxers dins d'una carpeta en un \u00fanic fitxer. La carpeta d'origen i el fitxer de destinaci\u00f3 s'indicaran en la crida del programa. Suposem que tots els fitxers dins d'aquesta carpeta s\u00f3n fitxers de text.</p> <p>Soluci\u00f3</p> Java<pre><code>class FusionaTextos {\n// Codi del programa\n}\n```     /*\n\n\n    Sintax:\n        MergeTexts DirectoriOrigen FitxerDest\u00ed\n\n    */\n    public static void main(String[] args) throws Exception {\n\n        File dir; // Source dir\n        // Collection of files from that dir\n        File[] files; \n\n        // readed characters\n        int characters;\n\n        // Input and Output Streams \n        FileReader fin=null;\n        FileWriter fout=null;\n\n        // Check the args\n        if(args.length!=2){\n            System.out.println(\"Nombre d'arguments erroni. Sintaxi:\\n mergeTexts DirectoriOrigen fitxerDesti\");\n            return;\n        }\n\n        try{\n\n            // We get the list of Files\n            dir=new File(args[0]);\n            files=dir.listFiles();\n\n\n            // Open and close output stream (in order to create the file)\n            fout=new FileWriter(args[1]);\n            fout.close();\n\n            // Re-open it\n            fout=new FileWriter(args[1], true);\n\n            // Iterate among the list\n            for (int i=0; i&lt;files.length; i++){\n                // open input stream\n                fin=new FileReader(args[0]+\"/\"+files[i].getName());\n                System.out.println(\"Merging \"+args[0]+\"/\"+files[i].getName());\n                // and merge to the output one\n                do {\n                    characters=fin.read();                 \n                    if (characters!=-1)\n                        fout.write(characters);\n                }while (characters!=-1);\n                fin.close(); //close the file merged\n\n            }\n            fout.close(); //close the output file\n\n        }catch (Exception exc){\n            // Catch all the exception (we coud improve it)\n            System.out.println(\"Input/Output error: \"+exc);\n        }\n    }\n}\n</code></pre> <p>Millora el teu codi</p> <p>Intenta millorar el codi anterior creant una funci\u00f3 <code>merge()</code>. Haur\u00edem de cridar-la dins del bucle principal.</p>"},{"location":"UD1_Files/2_Reading_and_writing_files/#14-decoradors","title":"1.4. Decoradors","text":"<p>Patr\u00f3 de disseny decorador</p> <p>Les classes de decorador s\u00f3n aquelles que hereten d'una certa classe i proporcionen funcionalitats afegides a l'original. En el cas dels fluxos d'entrada i sortida, tenim decoradors que ens permeten llegir o escriure l\u00ednies completes en comptes de byte a byte, o guardar en un cert format de dades. Simplifica la nostra feina, afegint una manera m\u00e9s natural i amigable per a utilitzar les classes base.</p> <p>La classe <code>InputStream</code> t\u00e9 diversos decoradors, per\u00f2 ens centrarem en els seg\u00fcents:</p> <ul> <li><code>DataInputStream</code> \u2192 Permet llegir dades de qualsevol tipus (enter, l\u00f2gic, etc.)</li> <li><code>ObjectInputStream</code> \u2192 Afegeix la opci\u00f3 de llegir un objecte sencer</li> </ul> <p>D'altra banda, la classe <code>OutputStream</code> tamb\u00e9 t\u00e9 diferents decoradors, entre els quals destaquem:</p> <ul> <li><code>DataOutputStream</code> \u2192 Permet escriure dades de qualsevol tipus (enter, l\u00f2gic, etc.)</li> <li><code>PrintStream</code> \u2192 Permet escriure dades de qualsevol tipus i tamb\u00e9 accepta els m\u00e8todes <code>printf</code> i <code>println</code></li> <li><code>ObjectOutputStream</code> \u2192 Permet escriure (serialitzar) objectes</li> </ul> <p>Pel que fa a les classes de decorador per a fluxos orientats a car\u00e0cters, tenim, d'una banda, els decoradors de <code>Reader</code> (m\u00e9s destacats):</p> <ul> <li><code>BufferedReader</code> \u2192 Crea un buffer d'entrada, permetent, per exemple, llegir una l\u00ednia completa</li> </ul> <p>I per a l'escriptura:</p> <ul> <li><code>BufferedWriter</code> \u2192 Crea un buffer de sortida, permetent, per exemple, escriure una l\u00ednia completa</li> <li><code>PrintWriter</code> \u2192 Permet escriure dades de diferents tipus i t\u00e9 m\u00e8todes com <code>printf</code> i <code>println</code></li> </ul> <p>La classe <code>BufferedReader</code>, entre altres, t\u00e9 el m\u00e8tode <code>readLine()</code>, que permet llegir una l\u00ednia sencera del fitxer fins al final de la l\u00ednia, molt \u00fatil en fitxers de text.</p> <p>Per la seva banda, la classe <code>BufferedWriter</code> proporciona el m\u00e8tode <code>newLine()</code> per introduir el car\u00e0cter de retorn de carro i el m\u00e8tode <code>write(String cadena, int inici, int longitud)</code> per escriure una cadena o una part espec\u00edfica.</p> <p>L'altre decorador per a l'escriptura \u00e9s el <code>PrintWriter</code>, que ens ofereix els m\u00e8todes <code>print(dades)</code>, <code>println(dades)</code> i <code>printf()</code> per a la formataci\u00f3.</p> <p>Alternatives a...</p> <p>\u00d2bviament, podr\u00edeu:</p> <ul> <li>concatenar <code>\\n</code> al final de cada cadena en cada m\u00e8tode <code>print()</code> en comptes de cridar <code>newLine()</code>.</li> <li>utilitzar <code>println()</code> en comptes de cridar <code>newLine()</code>.</li> </ul>"},{"location":"UD1_Files/2_Reading_and_writing_files/#141-exercici-resolt","title":"1.4.1. Exercici resolt","text":"<p>Crea un programa per copiar un fitxer de text afegint el n\u00famero de l\u00ednia al principi de cada l\u00ednia.</p> <p>Soluci\u00f3</p> Java<pre><code>public class NumberLines {\n    public static void main(String[] args) throws Exception {\n\n        // Input and Output\n        BufferedReader fin;\n        PrintWriter fout;\n\n        // line counter\n        int num_linia;\n        // readed line\n        String linia;\n\n        // check args\n        if (args.length != 2) {\n            System.out.println(\"Nombre d'arguments erroni. Sintaxi:\\n numberLines fitxer eixida\");\n            return;\n        }\n\n        // Creare decorators\n        fin = new BufferedReader(new FileReader(args[0]));\n        fout = new PrintWriter(new FileWriter(args[1]));\n\n        num_linia = 1;\n        do {\n            // Read the line\n            linia = fin.readLine();\n            if (linia != null) {\n                fout.println(num_linia + \". \" + linia);\n            }\n            num_linia++;\n        } while (linia != null); // until we can't read\n\n        // close all\n        fin.close();\n        fout.close();\n\n    }\n}\n</code></pre>"},{"location":"UD1_Files/2_Reading_and_writing_files/#15-fitxers-binaris","title":"1.5. Fitxers Binaris","text":"<p>En aquesta secci\u00f3 i les seg\u00fcents veurem com emmagatzemar diferents tipus de dades i objectes en fitxers de diferents formats: fitxers binaris, fitxers XML o JSON. Ara ens centrarem en els fitxers binaris, tant per emmagatzemar dades estructurades, d'una banda, com objectes, de l'altra, en un proc\u00e9s conegut com a serialitzaci\u00f3.</p>"},{"location":"UD1_Files/2_Reading_and_writing_files/#151-emmagatzemar-dades-estructurades-en-fitxers-binaris","title":"1.5.1. Emmagatzemar dades estructurades en fitxers binaris","text":"<p>En la secci\u00f3 anterior vam veure com treballar amb fitxers de car\u00e0cters i de bytes. En el cas dels fitxers de bytes, hem vist com llegir-los i escriure'ls seq\u00fcencialment, byte a byte fins al final del fitxer. Ara veurem com emmagatzemar dades estructurades en fitxers binaris i com poder-les llegir.</p> <p>Imaginem que volem guardar la seg\u00fcent taula, que combina dades de diferents tipus. Aquest exemple apareixer\u00e0 a les seg\u00fcents seccions.</p> Modul Hores Qualificaci\u00f3 Acc\u00e9s a Dades 6 8.45 Programaci\u00f3 de serveis i processos 3 9.0 Desenvolupament d'interf\u00edcies 6 8.0 Programaci\u00f3 Multim\u00e8dia i dispositius m\u00f2bils 5 7.34 Sistemes de Gesti\u00f3 Empresarial 5 8.2 Empresa i iniciativa emprenedora 3 7.4 <p>Com podem veure, tenim dades de text, dades num\u00e8riques enteres i reals. Si volem mantenir els tipus, els fluxos orientats a car\u00e0cters com <code>Reader</code> o <code>Writer</code> no seran \u00fatils, aix\u00ed que haur\u00edem d'utilitzar <code>InputStream</code> i <code>OutputStream</code>. El desavantatge \u00e9s que seria necessari saber exactament quantes dades ocupa cada tipus de dada.</p> <p>Per tal de desar aquestes estructures eficientment, podem fer servir les classes <code>DataInputStream</code> i <code>DataOutputStream</code>, que s\u00f3n decoradors de fluxos i que ens ofereixen els seg\u00fcents m\u00e8todes per desar o recuperar dades de diferents tipus, sense haver de preocupar-nos de quant ocupen internament. Com podeu veure, hi ha m\u00e8todes rec\u00edprocs per llegir i escriure cada tipus de dada b\u00e0sic.</p> <code>DataInputStream</code> <code>DataOutputStream</code> Descripci\u00f3 <code>byte readByte()</code> <code>void writeByte(int)</code> un byte <code>short readShort()</code> <code>void writeShort(short)</code> enter curt <code>int readInt()</code> <code>void writeInt(int)</code> un enter <code>long readLong()</code> <code>void writeLong(long)</code> un enter llarg <code>float readFloat()</code> <code>void writeFloat(float)</code> real de precisi\u00f3 simple <code>double readDouble()</code> <code>void writeDouble(double)</code> real doble <code>char readChar()</code> <code>void writeChar(int)</code> un car\u00e0cter Unicode <code>String readUTF()</code> <code>void writeUTF(String)</code> \u00a0un String UTF-8 <p>Tip</p> <p>Una cadena <code>UTF-8</code> \u00e9s diferent d'una String. Quan es guarda una cadena, com \u00e9s evident, es guarda tots els car\u00e0cters. En desar-la com a cadena UTF-8, s'afegeix informaci\u00f3 sobre la longitud de la cadena, i aquesta informaci\u00f3 \u00e9s essencial per tallar aquestes cadenes quan es llegeixin en el futur.</p> <p>Imagina que guardes dues cadenes, \"euro\" i \"sport\". El resultat ser\u00e0, al final, \"eurosport\". Quan alg\u00fa obri aquest fitxer en el futur, com sabr\u00e0 el nombre de cadenes emmagatzemades (\"euro\", \"sport\" o simplement \"eurosport\" (canal de televisi\u00f3))?</p> <p>En desar-ho com a UTF-8, quan guardes \"euro\" i \"sport\", el resultat \u00e9s \"4euro5sport\". Quan alg\u00fa intenti llegir-ho, primer veur\u00e0 un '4' i llegir\u00e0 \"euro\". Despr\u00e9s, veur\u00e0 un '5' i llegir\u00e0 \"sport\".</p> <p>Cal destacar que si es guarda \"eurosport\", el resultat ser\u00e0 \"9eurosport\". Prova d'escriure un programa d'exemple amb aquesta cadena, obrint el fitxer resultant amb un editor hexadecimal.</p>"},{"location":"UD1_Files/2_Reading_and_writing_files/#152-exercici-resolt","title":"1.5.2. Exercici resolt","text":"<p>Escriu un programa que tingui les dades emmagatzemades en tres arrays paral\u00b7lels, que emmagatzemen les dades dels m\u00f2duls de DAM. Escriu dues funcions, una per escriure aquestes dades en un fitxer i una altra per llegir-les. Considera emmagatzemar les dades agrupades per m\u00f2dul, en comptes de nom, hores i qualificaci\u00f3.</p> <p>Soluci\u00f3</p> Java<pre><code>public class Moduls{\n\n    // several arrays with modules data\n    String[] moduls={\"Acc\u00e9s a Dades\", \"Programaci\u00f3 de serveis i processos\", \"Desenvolupament d'interf\u00edcies\", \"Programaci\u00f3 Multim\u00e8dia i dispositiud m\u00f2bils\", \"Sistemes de Gesti\u00f3 Empresarial\", \"Empresa i iniciativa emprenedora\"};\n    int[]  hores={6, 3, 6, 5, 5, 3};\n    double[] notes={8.45, 9.0, 8.0, 7.34, 8.2, 7.4};\n\n    public void readFiLe(String name) throws IOException {\n        // Per lleginr el fitxer binari, creem un DataInputStream\n        // a partir del FileInputStream creat a partir del nom\n        DataInputStream f = new DataInputStream(new FileInputStream(name));\n\n        // Mentre el DataInputStream tinga dades disponibles\n        while (f.available()&gt;0){\n            // Llegirem del fitxer cada dada, amb l'ordre corresponent\n            // en funci\u00f3 del tipus\n            // (per tant, hem de saber l'ordre en qu\u00e8 guardem!)\n            System.out.println(\"M\u00f2dul: \" + f.readUTF());\n            System.out.println(\"Hores: \" + f.readInt());\n            System.out.println(\"Notes: \" + f.readDouble());\n            System.out.println();\n        }\n        f.close();\n    }\n\n    public void writeFile(String name) throws IOException{\n        // Per escriure el fitxer, fem \u00fas de DataOutputStream\n        DataOutputStream f = new DataOutputStream(new FileOutputStream(name));\n\n        // Recorrerem qualsevol dels vectors (tots haurien de tindre)\n        // la mateixa longitud\n        for (int i=0;i&lt;this.moduls.length;i++){\n            // I per a cada posici\u00f3, escriurem en funci\u00f3 del tipus de dada\n            f.writeUTF(this.moduls[i]);\n            f.writeInt(this.hores[i]);\n            f.writeDouble(this.notes[i]);\n\n        }\n        f.close();\n    }\n\n    public static void main(String[] args) throws IOException {\n\n        // Comprovem els arguments\n        if (args.length!=2){\n            System.out.println(\"Nombre d'arguments incorrecte.\\n\\nSintaxi: \\n\\t java Moduls [read | write] fitxer.dat\");\n            System.exit(0);\n        }\n\n        // Defining the class\n        Moduls moduls=new Moduls();\n\n        // Depending the args, we will proceed\n        if (args[0].equals(\"read\")) \n        moduls.readFiLe(args[1]);\n        else if (args[0].equals(\"write\")) \n        moduls.writeFile(args[1]);\n        else \n        System.out.println(\"No entenc l'ordre \"+args[0]+\"\\n\");\n    }\n}\n</code></pre>"},{"location":"UD1_Files/2_Reading_and_writing_files/#16-serialitzant-objectes","title":"1.6. Serialitzant Objectes","text":"<p>Java proporciona un sistema gen\u00e8ric de serialitzaci\u00f3 d'objectes: un sistema recursiu que itera sobre cada objecte contingut en una inst\u00e0ncia, fins arribar als tipus primitius, que s'emmagatzemen com un array de bytes. A part d'aquesta informaci\u00f3 dels tipus primitius, tamb\u00e9 s'emmagatzema informaci\u00f3 addicional o metadades espec\u00edfiques de cada classe, com ara el nom o els atributs, entre d'altres. Gr\u00e0cies a aquestes metadades, que descriuen els objectes que guardem, podem automatitzar la serialitzaci\u00f3 de manera gen\u00e8rica, assegurant-nos que posteriorment podrem llegir els objectes.</p> <p>El desavantatge d'aquest m\u00e8tode \u00e9s que quan canviem la definici\u00f3 de la classe (per exemple, afegint un atribut m\u00e9s o canviant el seu tipus), les metadades es modifiquen i no podr\u00edem llegir els objectes serialitzats amb versions anteriors de la classe. A m\u00e9s, tamb\u00e9 cal tenir en compte que aquest \u00e9s un mecanisme espec\u00edfic de Java i que no podrem consultar aquests objectes des d'altres llenguatges.</p> <p>Per tot aix\u00f2, altres t\u00e8cniques s\u00f3n preferibles per a l'emmagatzematge permanent d'objectes, que veurem m\u00e9s endavant, per\u00f2 la serialitzaci\u00f3 pot ser \u00fatil per a l'emmagatzematge temporal, dins de la mateixa execuci\u00f3 de l'aplicaci\u00f3.</p> <p>Qu\u00e8 \u00e9s aix\u00f2?</p> <p>Investigaci\u00f3: intenta trobar informaci\u00f3 sobre SerialVersionUID i per a qu\u00e8 \u00e9s important.</p>"},{"location":"UD1_Files/2_Reading_and_writing_files/#161-la-interficie-serializable-i-els-decorators","title":"1.6.1. La interf\u00edcie <code>Serializable</code> i els <code>Decorators</code>","text":"<p>Si volem que una classe sigui serializable, ha de implementar la interf\u00edcie <code>Serializable</code>, la qual t\u00e9 com a \u00fanic prop\u00f2sit actuar com a marcador per indicar al JVM que la classe pot ser serialitzada, per tant, aquesta classe no tindr\u00e0 m\u00e8todes.</p> <p>Cal dir que totes les classes corresponents als tipus b\u00e0sics ja implementen la interf\u00edcie Serializable, aix\u00ed com la classe String, contenidors i Arrays. En el cas de les col\u00b7leccions, dep\u00e8n dels seus continguts, si els seus elements s\u00f3n serialitzables, la col\u00b7lecci\u00f3 tamb\u00e9 ho ser\u00e0. Si l'objecte que volem serialitzar o els seus objectes no implementen la interf\u00edcie Serializable, es llan\u00e7ar\u00e0 l'excepci\u00f3 <code>NotSerializableException</code>.</p> <p>Els decoradors <code>ObjectInputStream</code> i <code>ObjectOutputStream</code> ens ofereixen la capacitat de serialitzar qualsevol objecte deserialitzable. Per escriure un objecte, farem \u00fas del m\u00e8tode <code>writeObject</code> de <code>ObjectOutputStream</code>, i per llegir-lo farem \u00fas de <code>readObject</code> de <code>ObjectInputStream</code>.</p> <p>Ovelles amb ovelles</p> <p>Cal tenir en compte que la lectura d'objectes s'ha de fer en inst\u00e0ncies de la mateixa classe que es va guardar. En cas contrari, es llan\u00e7ar\u00e0 una excepci\u00f3 <code>ClassCastException</code>. A m\u00e9s, cal tenir el codi compilat de la classe per evitar l'excepci\u00f3 <code>ClassNotFoundException</code>.</p> <p>A m\u00e9s, <code>readObject</code> retorna un Object, i necessitem un objecte d'una classe espec\u00edfica. Per aquest motiu, cal fer una conversi\u00f3 de Object a la classe necess\u00e0ria. Els conceptes d'her\u00e8ncia s\u00f3n molt importants per garantir programes robustos.</p>"},{"location":"UD1_Files/2_Reading_and_writing_files/#162-exercici-resolt","title":"1.6.2. Exercici resolt","text":"<p>Comen\u00e7ant amb la mateixa base de la classe <code>Moduls</code> de l'exercici anterior, crearem una classe <code>Modul</code> per emmagatzemar un \u00fanic m\u00f2dul. Aquest tipus de classes es coneixen com a POJO (Plain Old Java Objects) i estan dissenyades nom\u00e9s per emmagatzemar informaci\u00f3. (Apareixer\u00e0 m\u00e9s endavant, juntament amb les classes BEAN).</p> <p>Un cop creada la classe <code>Modul</code>, escriu un programa per desar objectes directament en un fitxer. Despr\u00e9s, escriu la funci\u00f3 complement\u00e0ria per llegir tots els objectes emmagatzemats en aquest fitxer.</p> <p>Soluci\u00f3</p> Java<pre><code>/**\n    Class to storage a single module in memory\n*/\n\nclass Modul implements Serializable{\n    String nom;\n    int hores;\n    double nota;\n\n    public Modul(){\n        // Constructor buit\n    }\n\n    public Modul(String nom, int hores, double nota){\n        this.nom=nom;\n        this.hores=hores;\n        this.nota=nota;\n    }\n\n    public String getModul() {return this.nom;}\n    public int getHores() {return this.hores;}\n    public double getNota() {return this.nota;}\n} \n\n/**\n    Write and Read modules to/from file\n*/\n\npublic class Moduls2 {\n\n    // Arrays with source data\n    String[] moduls = {\"Acc\u00e9s a Dades\", \"Programaci\u00f3 de serveis i processos\", \"Desenvolupament d'interf\u00edcies\", \"Programaci\u00f3 Multim\u00e8dia i dispositiud m\u00f2bils\", \"Sistemes de Gesti\u00f3 Empresarial\", \"Empresa i iniciativa emprenedora\"};\n    int[] hores = {6, 3, 6, 5, 5, 3};\n    double[] notes = {8.45, 9.0, 8.0, 7.34, 8.2, 7.4};\n\n    public void EscriuObjecte(String nom) throws IOException {\n\n        //destination file\n        ObjectOutputStream f = new ObjectOutputStream(new FileOutputStream(nom));\n\n        Modul m; // Single object\n\n        // loop along the arrays\n        for (int i = 0; i &lt; this.moduls.length; i++) {\n            m = new Modul(this.moduls[i], this.hores[i], this.notes[i]);\n            f.writeObject(m);\n        }\n\n        // close the file\n        f.close();\n\n    }\n\n    public void LligObjecte(String nom) throws IOException, ClassNotFoundException {\n\n        // input file\n        ObjectInputStream f = new ObjectInputStream(new FileInputStream(nom));\n\n        Modul m;\n        // we don't know how many objects exists in the file.\n        try {\n            while (true) { // forever\n\n                m = (Modul) f.readObject();\n\n                // show the module\n                System.out.println(\"Modul: \" + m.getModul());\n                System.out.println(\"Hores: \" + m.getHores());\n                System.out.println(\"Nota: \" + m.getNota());\n                System.out.println();\n\n            }\n        } catch (EOFException ex) {\n            f.close();\n        }\n\n    }\n\n    public static void main(String[] args) throws IOException, ClassNotFoundException {\n\n        // test the args\n        if (args.length != 2) {\n            System.out.println(\"Nombre d'arguments incorrecte.\\n\\nSintaxi: \\n\\t java Moduls2 [ read | write ] fitxer.obj\");\n            System.exit(0);\n        }\n\n        Moduls2 moduls = new Moduls2();\n\n        // depending the args\n        if (args[0].equals(\"read\")) {\n            moduls.LligObjecte(args[1]);\n        } else if (args[0].equals(\"write\")) {\n            moduls.EscriuObjecte(args[1]);\n        } else {\n            System.out.println(\"No entenc l'ordre \" + args[0] + \"\\n\");\n        }\n\n    }\n\n}\n</code></pre> <p>Less work, but the same in the end</p> <p>You probably will think about it: If all in Java inherits from Object, an ArrayList is an Object...Can I save or load an entire ArrayList in one unique call?. Try it as an improvement of the last exercise.</p>"},{"location":"UD1_Files/3_XML_Files/","title":"1. Arxius XML","text":""},{"location":"UD1_Files/3_XML_Files/#11-perque-xml","title":"1.1. Perqu\u00e8 XML?","text":"<p>Quan volem desar dades que puguin ser llegides per diferents aplicacions i plataformes, \u00e9s millor utilitzar formats d'emmagatzematge est\u00e0ndard que m\u00faltiples aplicacions puguin entendre (portabilitat). Un cas molt espec\u00edfic s\u00f3n els llenguatges de marcatge, i el m\u00e9s conegut \u00e9s l'est\u00e0ndard XML (eXtensible Markup Language).</p> <p>Amb els documents XML, estructuram la informaci\u00f3 inserint marques o etiquetes entre la informaci\u00f3. Aquestes etiquetes tenen un inici i un final, i poden niuar-se dins d'altres, aix\u00ed com contenir informaci\u00f3 textual. Com que la informaci\u00f3 ser\u00e0 textual, no tenim el problema de la representaci\u00f3 de dades diferents, ja que qualsevol dada, de qualsevol tipus, es convertir\u00e0 en text. Per evitar tamb\u00e9 el problema dels diferents sistemes d'codificaci\u00f3 de text, XML permet incloure a l'encap\u00e7alament del document la codificaci\u00f3 utilitzada per desar el document.</p> <p>La manera de desar informaci\u00f3 en XML, de manera jer\u00e0rquica, \u00e9s molt similar a la manera com ho fan els objectes en una aplicaci\u00f3, de manera que aquests es poden traduir de manera relativament convenient en un document XML. Comencem amb el nostre exemple anterior:</p> Module Hours Qualificaci\u00f3 Acc\u00e9s a Dades 6 8.45 Programaci\u00f3 de serveis i processos 3 9.0 Desenvolupament d'interf\u00edcies 6 8.0 Programaci\u00f3 Multim\u00e8dia i dispositius m\u00f2bils 5 7.34 Sistemes de Gesti\u00f3 Empresarial 5 8.2 Empresa i iniciativa emprenedora 3 7.4 <p>pot representar-se en etiquetes <code>xml</code>:</p> XML<pre><code>&lt;curs&gt;\n    &lt;modul&gt;\n      &lt;nom&gt;Acc\u00e9s a Dades&lt;/nom&gt;\n      &lt;hores&gt;6&lt;/hores&gt;\n      &lt;qualificacio&gt;8.45&lt;/qualificacio&gt;\n    &lt;/modul&gt;\n    &lt;modul&gt;\n      &lt;nom&gt;Programaci\u00f3 de serveis i processos&lt;/nom&gt;\n      &lt;hores&gt;3&lt;/hores&gt;\n      &lt;qualificacio&gt;9.0&lt;/qualificacio&gt;\n    &lt;/modul&gt;\n    &lt;modul&gt;\n      &lt;nom&gt;Desenvolupament d'interf\u00edcies&lt;/nom&gt;\n      &lt;hores&gt;6&lt;/hores&gt;\n      &lt;qualificacio&gt;8.0&lt;/qualificacio&gt;\n    &lt;/modul&gt;\n    &lt;modul&gt;\n      &lt;nom&gt;Programaci\u00f3 Multim\u00e8dia i dispositiud m\u00f2bils&lt;/nom&gt;\n      &lt;hores&gt;5&lt;/hores&gt;\n      &lt;qualificacio&gt;7.34&lt;/qualificacio&gt;\n    &lt;/modul&gt;\n    &lt;modul&gt;\n      &lt;nom&gt;Sistemes de Gesti\u00f3 Empresarial&lt;/nom&gt;\n      &lt;hores&gt;5&lt;/hores&gt;\n      &lt;qualificacio&gt;8.2&lt;/qualificacio&gt;\n    &lt;/modul&gt;\n    &lt;modul&gt;\n      &lt;nom&gt;Empresa i iniciativa emprenedora&lt;/nom&gt;\n      &lt;hores&gt;3&lt;/hores&gt;\n      &lt;qualificacio&gt;7.4&lt;/qualificacio&gt;\n    &lt;/modul&gt;\n&lt;/curs&gt;\n</code></pre> <p>o pot ser representat amb etiquetes i atributs:</p> <p>XML<pre><code>&lt;curs&gt;\n    &lt;modul nom=\"Acc\u00e9s a Dades\" hores=\"6\" qualificacio=\"8.45\" &gt;\n    &lt;modul nom=\"Programaci\u00f3 de serveis i processos\" \"hores\"=3 qualificacio=\"9.0\" &gt;\n    &lt;modul nom =\"Desenvolupament d'interf\u00edcies\" hores=\"6\" qualificacio=\"8.0\" &gt;\n    &lt;/modul&gt;\n    &lt;modul nom=\"Programaci\u00f3 Multim\u00e8dia i dispositiud m\u00f2bils\" hores=\"5\" qualificacio=\"7,34\"&gt;\n    &lt;modul nom=\"Sistemes de Gesti\u00f3 Empresarial\" hores=\"5\" \"qualificacio\"=8.2 /&gt;\n    &lt;modul nom=\"Empresa i iniciativa emprenedora\"  hores=\"3\" qualificacio=\"7.4\" /&gt;\n    &lt;/modul&gt;\n&lt;/curs&gt;\n</code></pre> Un analitzador XML \u00e9s una classe que permet analitzar un fitxer XML i extreure informaci\u00f3 d'ell, relacionant-la segons la seva posici\u00f3 en la jerarquia. Els analitzadors, segons la seva forma de funcionar, poden ser:</p> <ul> <li>Analitzadors seq\u00fcencials o sint\u00e0ctics, que extreuen el contingut a mesura que es descobreixen les etiquetes d'obertura i tancament. S\u00f3n molt r\u00e0pids, per\u00f2 tenen el problema que cal llegir tot el document per accedir a una part espec\u00edfica. En Java hi ha el parser SAX (Simple API for XML) com a analitzador seq\u00fcencial.</li> <li>Analitzadors jer\u00e0rquics, que s\u00f3n els m\u00e9s utilitzats i que guarden totes les dades del document XML a la mem\u00f2ria, en forma d'una estructura jer\u00e0rquica (DOM o Document Object Model), sent els preferits per a aplicacions que han de llegir les dades de manera m\u00e9s cont\u00ednua.</li> </ul>"},{"location":"UD1_Files/3_XML_Files/#12-el-model-dobjectes-de-document-dom","title":"1.2. El Model d'Objectes de Document (DOM)","text":"<p>El DOM (Document Object Model) \u00e9s l'estructura especificada per la W3C on s'emmagatzema la informaci\u00f3 dels documents XML. El DOM s'ha relacionat principalment amb el m\u00f3n web, amb HTML i Javascript com a principals impulsors. En Java, el DOM s'implementa utilitzant interf\u00edcies.</p> <p>La interf\u00edcie principal del DOM a Java \u00e9s <code>Document</code>, i representa el document XML complet. Com que \u00e9s una interf\u00edcie, es pot implementar en diverses classes.</p> <p>Cal tenir en compte que...</p> <p>Una interf\u00edcie \u00e9s una mena de plantilla per construir classes i generalment est\u00e0 composta per un conjunt de declaracions de cap\u00e7alera de m\u00e8todes no implementats que especifiquen com es comporten una o m\u00e9s classes. A m\u00e9s, una classe pot implementar una o m\u00e9s interf\u00edcies. En aquest cas, la classe haur\u00e0 de declarar i definir tots els m\u00e8todes de cada una de les interf\u00edcies o declarar-se com a classe abstracta.</p> <p>Cal tenir en compte que una interf\u00edcie no s'ha de confondre amb una classe abstracta, ja que hi ha algunes difer\u00e8ncies. Per exemple, una interf\u00edcie t\u00e9 tots els m\u00e8todes abstractes, no pot declarar variables d'inst\u00e0ncia, una classe pot implementar diverses interf\u00edcies per\u00f2 no heretar de diverses superclasses, i una interf\u00edcie no ha de pert\u00e0nyer a cap jerarquia, de manera que les classes que no tenen cap relaci\u00f3 d'her\u00e8ncia poden implementar la mateixa interf\u00edcie.</p> <p>A part de <code>Document</code>, la W3C tamb\u00e9 defineix la classe abstracta <code>DocumentBuilder</code>, que permet crear el DOM a partir de l'XML. A m\u00e9s, s'especifica la classe <code>DocumentBuilderFactory</code>, que ens permet fabricar <code>DocumentBuilders</code>, ja que, al ser abstracta, no es pot instanciar directament.</p> <p>Cal dir, com a advert\u00e8ncia, que Java ofereix moltes llibreries des de les quals importar Document. Les llibreries que utilitzarem per analitzar XML seran:</p> <ul> <li>La llibreria <code>java.xml.parsers.*</code>, que oferir\u00e0 les classes <code>DocumentBuilderFactory</code> i <code>DocumentBuilder</code>, i</li> <li>La llibreria <code>org.w3c.dom.*</code> per a la classe <code>Document</code>.</li> </ul>"},{"location":"UD1_Files/3_XML_Files/#121-documentbuilder-i-documentbuilderfactory","title":"1.2.1. <code>DocumentBuilder</code> i <code>DocumentBuilderFactory</code>","text":"<p>Com s'ha dit, <code>DocumentBuilder</code> defineix una API per obtenir inst\u00e0ncies DOM d'un document XML. Per obtenir una inst\u00e0ncia de la classe, s'ha d'utilitzar la classe <code>DocumentBuilderFactory</code>, i concretament el m\u00e8tode <code>newDocumentBuilder()</code>:</p> <p>D'altra banda, per llegir i interpretar el document XML, la classe <code>DocumentBuilderFactory</code> proporciona el m\u00e8tode <code>parse()</code>, que analitza un XML indicat per un fitxer i retorna un objecte <code>Document</code>.</p> <p>Veurem tot aix\u00f2 amb un exemple. Continuem emmagatzemant dades sobre els m\u00f2duls del curs, per\u00f2 ara amb XML. El seg\u00fcent m\u00e8tode ens servir\u00e0 per obrir un document XML, analitzar-lo i retornar el DOM generat en un <code>Document</code>. El podem utilitzar en qualsevol lloc dels nostres programes, ja que la tasca \u00e9s sempre similar:</p> Java<pre><code>public Document OpenXML(String name) throws IOException,SAXException, ParserConfigurationException, FileNotFoundException {\n\n    // Create an instance of DocumentBuilderFactory\n    DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n    // Using the DocumentBuilderFactory instance we create a DocumentBuilder\n    DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n    //And we use DocumentBuilder's \"parse\" method to get the document\n    Document doc = dBuilder.parse(new File(name));\n\n    return document;\n}\n</code></pre> <p>S'ha de dir que la funci\u00f3 anterior es podria simplificar sense utilitzar les declaracions interm\u00e8dies, per\u00f2 est\u00e0 una mica ofuscada.</p> Java<pre><code>public Document OpenXML(String name) throws IOException,SAXException, ParserConfigurationException, FileNotFoundException {\n     return DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(name);\n}\n</code></pre> <p>D'altra banda, la classe <code>DocumentBuilder</code> tamb\u00e9 ens permet crear un nou DOM amb el m\u00e8tode <code>newDocument()</code>. Aix\u00f2 ens servir\u00e0 m\u00e9s endavant per emmagatzemar els nous documents XML. El procediment \u00e9s el seg\u00fcent:</p> <ul> <li>Primer de tot, hem de crear un nou DOM amb <code>newDocument()</code>.</li> <li>Afegir els elements i,</li> <li>Despr\u00e9s emmagatzemar-ho en un fitxer.</li> </ul> <p>En seccions posteriors, veurem com fer tot aix\u00f2. Per ara, ens centrarem en interpretar i llegir el DOM.</p> <p>Per a m\u00e9s informaci\u00f3, pots consultar les classes DocumentBuilder i DocumentBuilderFactory al API de OpenJDK.</p>"},{"location":"UD1_Files/3_XML_Files/#13-classes-i-metodes-de-dom","title":"1.3. Classes i M\u00e8todes de DOM","text":"<p>Fins ara hem vist com obrir i analitzar un document XML amb <code>DocumentBuilder</code> per crear un objecte de tipus <code>Document</code>. En aquesta secci\u00f3 veurem com treballar amb aquest document per accedir als diferents elements. Com sabem, el DOM t\u00e9 una estructura jer\u00e0rquica, formada per nodes. Els diferents tipus de nodes que podem trobar s\u00f3n:</p> <ul> <li><code>Document</code> \u2192 que \u00e9s el node principal i representa tot l'XML.</li> <li><code>Element</code> \u2192 que representa les diferents etiquetes (incloent l'etiqueta arrel). En altres paraules, totes les etiquetes s\u00f3n Elements, unes dins d'altres.</li> <li><code>TextElement</code> \u2192 que representa el contingut d'una etiqueta de text.</li> <li><code>Attribute</code> \u2192 que representa els atributs.</li> </ul> <p>Totes aquestes interf\u00edcies deriven de la interf\u00edcie <code>Node</code>, per tant, heretaran els seus atributs i m\u00e8todes, i a m\u00e9s, proporcionaran els seus propis atributs i m\u00e8todes.</p> <p>A continuaci\u00f3, veurem els m\u00e8todes m\u00e9s importants de cada interf\u00edcie:</p>"},{"location":"UD1_Files/3_XML_Files/#131-metodes-de-node","title":"1.3.1. M\u00e8todes de Node","text":"<p>M\u00e8todes relacionats amb l'obtenci\u00f3 d'informaci\u00f3</p> <ul> <li><code>String getNodeName()</code> \u2192 Obt\u00e9 el nom del node actual</li> <li><code>short getNodeType()</code> \u2192 Obt\u00e9 el tipus de node (ELEMENT_NODE, ATTRIBUTE_NODE, TEXT_NODE...)</li> <li><code>String getNodeValue()</code>\u2192 Obt\u00e9 el valor del node</li> <li><code>NodeList getChildNodes()</code> \u2192 Obt\u00e9 una llista amb els nodes fills</li> <li><code>Node getFirstChild()</code> \u2192 Retorna el primer fill</li> <li><code>Node getLastChild()</code> \u2192 Retorna l'\u00faltim fill</li> <li><code>NamedNodeMap getAttributes()</code> \u2192 Retorna una llista amb els atributs del node</li> <li><code>Node getParentNode()</code> \u2192 Retorna el node pare</li> <li><code>String getTextContent()</code> \u2192 Retorna el text contingut en l'element i els seus descendents</li> <li><code>boolean hasChildNodes()</code> \u2192 Retorna <code>true</code> si el node t\u00e9 algun fill</li> <li><code>boolean hasAttributes()</code> \u2192 Retorna <code>true</code> si el node t\u00e9 algun atribut</li> </ul> <p>M\u00e8todes relacionats amb l'escriptura</p> <ul> <li><code>Node appendChild(Node node)</code> \u2192 Afegeix un nou node com a \u00faltim fill.</li> <li><code>void removeChild(Node node)</code> \u2192 Elimina el node especificat dels nodes fills.</li> </ul>"},{"location":"UD1_Files/3_XML_Files/#132-metodes-de-la-interficies-element","title":"1.3.2. M\u00e8todes de la interf\u00edcies Element:","text":"<p>M\u00e8todes relacionats amb l'obtenci\u00f3 d'informaci\u00f3</p> <ul> <li><code>String getAttribute(String name)</code> \u2192 Retorna el valor de l'atribut donat pel nom.</li> <li><code>NodeList getElementsByTagName(String name)</code> \u2192 Retorna una llista de nodes fills que coincideixen amb el nom donat.</li> <li><code>boolean hasAttribute(String name)</code> \u2192 Retorna true si l'element t\u00e9 l'atribut donat.</li> </ul> <p>M\u00e8todes relacionats amb l'escriptura</p> <ul> <li><code>void setAttribute(String name, String value)</code> \u2192 Afegeix un atribut a l'element, amb el nom i valor donats.</li> <li><code>void removeAttribute(String name)</code> \u2192 Elimina l'atribut indicat pel nom.</li> </ul>"},{"location":"UD1_Files/3_XML_Files/#133-metodes-de-la-interficie-document","title":"1.3.3. M\u00e8todes de la interf\u00edcie Document:","text":"<p>M\u00e8todes relacionats amb l'obtenci\u00f3 d'informaci\u00f3</p> <ul> <li><code>Element getDocumentElement()</code> \u2192 Retorna l'element arrel del document.</li> <li><code>NodeList getElementsByTagName(String name)</code> \u2192 Retorna una llista de nodes fills que coincideixen amb el nom donat.</li> </ul> <p>M\u00e8todes relacionats amb l'escriptura</p> <ul> <li><code>Element createElement(String name)</code> \u2192 Crea un nou element amb el nom donat.</li> <li><code>Text createTextNode(String text)</code> \u2192 Crea un nou element de text.</li> <li><code>Node appendChild(Node node)</code> \u2192 Afegeix un nou node fill.</li> </ul> <p>Els objectes de tipus <code>NodeList</code>, que representen una llista de nodes, ofereixen el m\u00e8tode <code>item(int index)</code> per accedir als diferents nodes de la llista, indicant el seu ordre.</p>"},{"location":"UD1_Files/3_XML_Files/#14-lectura-de-fitxers-xml","title":"1.4. Lectura de fitxers XML","text":"<p>Anem a repassar tots els conceptes d'aquesta secci\u00f3 amb una pr\u00e0ctica. Crearem una classe que inclogui tots els m\u00e8todes necessaris per obrir, llegir, mostrar i escriure fitxers XML. Treballarem amb el document de la secci\u00f3 anterior.</p> <p>Per comen\u00e7ar a llegir el document, el primer que haurem de fer \u00e9s obtenir l'element arrel del document amb <code>getDocumentElement()</code>, que retorna un objecte de tipus <code>Element</code>. Recorda que la variable doc cont\u00e9 tot el DOM, llegit amb el m\u00e8tode explicat anteriorment:</p> Java<pre><code>Element root = doc.getDocumentElement();\n</code></pre> <p>Amb aquest element arrel, ja podem mostrar tot el contingut amb <code>getTextContent()</code>. Es mostrar\u00e0 a la pantalla en format de text, nom\u00e9s s'imprimir\u00e0:</p> Java<pre><code>System.out.println(root.getTextContent());\n</code></pre> <p>Per\u00f2 el que ens interessa \u00e9s rec\u00f3rrer tot el DOM i accedir als seus elements. Per fer-ho, a partir d'aquest element arrel, seguirem els seg\u00fcents passos:</p> <ol> <li>Cerquem tots els tags <code>&lt;modul&gt;</code> amb <code>getElementsByTagName</code>. Aquest m\u00e8tode ens retorna una llista de nodes (objecte de tipus <code>NodeList</code>).</li> <li>Ser\u00e0 necessari rec\u00f3rrer la llista de nodes (<code>NodeList</code>) per accedir a cada element. Per fer-ho, cal utilitzar el m\u00e8tode <code>item(int index)</code>, que retornar\u00e0 un element de tipus <code>Node</code>, i que s'ha de convertir expl\u00edcitament a <code>Element</code> amb una operaci\u00f3 de cast.</li> <li>Per a cada element, accedirem al nom del node per mostrar el nom i l'ordre, utilitzant <code>getNodeName()</code>.</li> <li>Cerquem les diferents etiquetes trobades dins de cada m\u00f2dul ('nom', 'hores' i 'qualificacio') amb <code>getElementsByTagName()</code>. Aquest m\u00e8tode ens tornar\u00e0 una NodeList per a cada tipus d'etiqueta. Com nom\u00e9s tindrem un element, nom\u00e9s cal accedir a l'element \u00fanic, representat per <code>item(0)</code>.</li> <li>Cal destacar que amb el que hem vist fins ara tindrem la primera (i \u00fanica) etiqueta 'nom', 'hores' o 'qualificacio' del m\u00f2dul, per\u00f2 encara no estem en el contingut, ja que aix\u00f2 \u00e9s un element de tipus <code>TEXT_NODE</code>. Per accedir-hi, haurem d'accedir al primer fill de l'etiqueta (<code>getFirstChild()</code>) i obtenir el seu valor amb <code>getNodeValue()</code>.</li> </ol> Java<pre><code>    // We will get a list of nodes (Step 1)\n    NodeList modules = root.getElementsByTagName(\"modul\");\n\n    // For each node (Step 2)\n    for (int i = 0; i &lt; modules.getLength(); i++) {\n        Element el = (Element) modules.item(i);\n\n        // Display the node name (Step 3)\n        System.out.println(el.getNodeName() + \" \" + (i + 1));\n\n        // And we show the value of the different tags \n        System.out.println(\"Nom: \" + el.getElementsByTagName(\"nom\").item(0).getFirstChild().getNodeValue());\n        System.out.println(\"Hores: \" + el.getElementsByTagName(\"hores\").item(0).getFirstChild().getNodeValue());\n        System.out.println(\"Qualificaci\u00f3: \" + el.getElementsByTagName(\"qualificacio\").item(0).getFirstChild().getNodeValue());\n        System.out.println();\n    }\n}\n</code></pre>"},{"location":"UD1_Files/3_XML_Files/#15-escriure-fitxers-xml","title":"1.5. Escriure fitxers XML","text":"<p>Ara anem a la part d'escriptura dels documents XML. Per aix\u00f2, partirem d'un fitxer que ja cont\u00e9 la informaci\u00f3 en format binari dels m\u00f2duls (per exemple, de la secci\u00f3 anterior), el llegirem i importarem la seva informaci\u00f3 en format XML.</p> <p>El primer que hem de fer \u00e9s llegir el fitxer d'objectes utilitzant un <code>ObjectInputStream</code>:</p> Java<pre><code>ObjectInputStream f = new ObjectInputStream(new FileInputStream(file));\n</code></pre> <p>I crearem un document buit amb les classes <code>DocumentBuilder</code> i <code>DocumentBuilderFactory</code>:</p> Java<pre><code>Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n</code></pre> <p>Un cop tenim el document buit, creem l'element arrel (curs) i l'afegim al document:</p> Java<pre><code>Element root = doc.createElement(\"curso\");\ndoc.appendChild(root);\n</code></pre> <p>Recorda que accedirem al fitxer d'objectes, aix\u00ed que haurem de saber exactament com \u00e9s la classe que volem llegir i accedir als m\u00e8todes corresponents per obtenir informaci\u00f3 sobre ella. Per aix\u00f2, primer, has de definir un objecte de tipus <code>Modul</code>, i llegirem el fitxer d'objectes amb el m\u00e8tode <code>readObject</code> de <code>File</code>. Un cop h\u00e0gim llegit un objecte, crearem l'etiqueta que engloba cadascun d'ells: l'etiqueta <code>modul</code>:</p> Java<pre><code>Modul m = (Modul) f.readObject();\nElement modul = doc.createElement(\"modul\");\n</code></pre> <p>And inside it, as we extract the different properties of the Modul object, we will create child nodes and add them to the module. For example, for the module name:</p> Java<pre><code>Element name = doc.createElement(\"nom\");\nname.appendChild(doc.createTextNode(m.getNom()));\nmodule.appendChild(name);\n</code></pre> <p>Com podem veure, hem creat un objecte de tipus Element amb l'etiqueta 'nom', i hem afegit com a fill un node de tipus text (TEXT_NODE), que hem extret directament de l'objecte <code>Modul m</code> amb la seva pr\u00f2pia funci\u00f3 <code>getModul()</code>. A m\u00e9s, hem afegit aquesta etiqueta a l'etiqueta <code>&lt;modul&gt;</code>, amb <code>appendChild</code>.</p> <p>Haurem de fer el mateix per a les hores de cada m\u00f2dul i la qualificaci\u00f3, per\u00f2 per aix\u00f2, haurem de tenir en compte que els m\u00e8todes getHores i getNota no retornen una cadena de text, sin\u00f3 un enter i un decimal, de manera que hauran de ser convertits a text:</p> Java<pre><code>Element hours = doc.createElement(\"hores\");\nhours.appendChild(doc.createTextNode(Integer.toString(m.getHores())));\nmodule.appendChild(hours);\n\nElement qualification = doc.createElement(\"qualificacio\");\nqualification.appendChild(doc.createTextNode(Double.toString(m.getNote())));\nmodule.appendChild(grade);\n</code></pre> <p>Posarem tot aquest procediment dins d'un bucle que recorrer\u00e0 tot el fitxer d'objectes. Un cop h\u00e0gim llegit cada un dels m\u00f2duls, haurem d'afegir-los a l'element arrel amb:</p> Java<pre><code>root.appendChild(module);\n</code></pre> <p>And we will already have our XML document at the root. Now we would have to convert this object of type <code>Element</code> into a text string in order to be able to write it to the disk. For this, we will make use of the <code>Transformer</code> utility.</p>"},{"location":"UD1_Files/3_XML_Files/#151-transformer","title":"1.5.1. Transformer","text":"<p>Java ens ofereix l'utilitat <code>Transformer</code> per convertir informaci\u00f3 entre diferents formats jer\u00e0rquics, com ara l'objecte Document que cont\u00e9 el DOM del nostre XML, a un fitxer de text XML.</p> <p>La classe <code>Transformer</code>, com <code>DocumentBuilder</code>, tamb\u00e9 \u00e9s una classe abstracta, per la qual cosa tamb\u00e9 requereix una f\u00e0brica per ser instanciada. La classe Transformer treballa amb dos tipus d'adaptadors. Els adaptadors s\u00f3n classes que fan compatibles diferents jerarquies. Aquests adaptadors s\u00f3n <code>Source</code> i <code>Result</code>. Les classes que implementen aquests adaptadors seran les encarregades de fer compatibles els diferents tipus de contenidors amb el que requereix la classe Transformer. Aix\u00ed, i per aclarir-ho, tenim les classes <code>DOMSource</code>, <code>SAXSource</code> o <code>StreamSource</code>, que s\u00f3n adaptadors del contenidor d'origen de la informaci\u00f3 per a DOM, SAX o Stream; i <code>DOMResult</code>, <code>SAXResult</code> i <code>StreamResult</code> com a adaptadors equivalents per al contenidor de destinaci\u00f3.</p> <p>En el nostre cas, ja que tenim un DOM i volem convertir-lo en un Stream, necessitarem un <code>DomSource</code> i un <code>StreamResult</code>. Veurem el codi necessari per fer-ho:</p> Java<pre><code>Transformer trans = TransformerFactory.newInstance().newTransformer();\nDOMSource source = new DOMSource(doc);\nStreamResult result = new StreamResult(new FileOutputStream(file+\".xml\"));\n</code></pre> <p>El primer que hem fet \u00e9s crear un objecte de tipus <code>Transformer</code> amb el m\u00e8tode <code>newTransformer()</code> d'una inst\u00e0ncia (newInstance()) de la f\u00e0brica de Transformers TransformerFactory. A continuaci\u00f3, hem definit la font (source) i el resultat (resultat) per a la transformaci\u00f3, sent la font un DomSource creat a partir del doc que cont\u00e9 el nostre document, i el resultat un StreamResult, que escriur\u00e0 el flux al disc a trav\u00e9s d'un FileOutputStream.</p> <p>Finalment, fem la transformaci\u00f3 d'un element a un altre, que generar\u00e0 autom\u00e0ticament el fitxer XML de sortida:</p> Java<pre><code>trans.transform(source, result);\n</code></pre>"},{"location":"UD1_Files/3_XML_Files/#16-tecniques-avancades-vinculacio-xml","title":"1.6. T\u00e8cniques avan\u00e7ades: vinculaci\u00f3 XML","text":"<p>La t\u00e8cnica de vinculaci\u00f3 consisteix en generar classes Java amb formats espec\u00edfics, com ara XML, de manera que cada etiqueta o atribut XML correspongui a una propietat d'una determinada classe. Aquesta correspond\u00e8ncia s'anomena mapeig.</p> <p>En Java, hi ha diferents llibreries per a la vinculaci\u00f3 o mapeig: JAXB, JuBX, XMLBinding, etc. JAXB (Java Architecture for XML Binding) \u00e9s una potent llibreria que s'ha incl\u00f2s en l'est\u00e0ndard des de JDK 6, per\u00f2 s'ha eliminat a la versi\u00f3 11 i es suggereix incloure-la com a paquet extern. JAXB fa servir anotacions per obtenir la informaci\u00f3 necess\u00e0ria per al mapeig de la vinculaci\u00f3. Les anotacions s\u00f3n indicacions especials de Java que permeten associar informaci\u00f3 i funcionalitat als objectes, sense interferir en l'estructura del model de dades. Les anotacions es poden associar amb un paquet, una classe, un atribut o un par\u00e0metre, i es declaren amb el s\u00edmbol <code>@</code> davant del nom de l'anotaci\u00f3. Quan el compilador detecta una anotaci\u00f3, crea una inst\u00e0ncia i l'injecta a l'element afectat, sense interferir en la classe mateixa. Quan una aplicaci\u00f3 necessita la informaci\u00f3 de les anotacions, pot obtenir la inst\u00e0ncia injectada.</p> <p>Per exemple, a la classe <code>Modul</code> que hav\u00edem definit, far\u00edem servir l'anotaci\u00f3 <code>@XmlRootElement</code> per indicar l'element arrel del m\u00f2dul, i les anotacions <code>@XmlElement</code> per indicar que els setters de la classe tamb\u00e9 escriuran elements XML.</p> Java<pre><code>@XmlRootElement\nclass Modul {\n\n    String nom;\n    int hores;\n    double nota;\n\n    public String getNom() { return nom; }\n    @XmlElement\n    public void setNom(String nom) { this.nom = nom; }\n\n\n    public int getHores() { return hores; }\n    @XmlElement\n    public void setHores(int hores) { this.hores = hores; }\n\n    public double getNota() { return nota; }\n    @XmlElement\n    public void setNota(double nota) { this.nota = nota;}\n\n\n}\n</code></pre> <p>Amb aix\u00f2 tindr\u00edem nom\u00e9s la classe amb les anotacions preparades per desar un m\u00f2dul com a document XML. Per desar tota la jerarquia haur\u00edem de crear la classe <code>Curs</code>, que contindria un <code>ArrayList</code> de m\u00f2duls.</p> <p>Pel que fa a aquest curs, no aprofundirem m\u00e9s en aquesta t\u00e8cnica, ja que per als nostres prop\u00f2sits, l'an\u00e0lisi XML que hem vist a les seccions anteriors \u00e9s suficient.</p> <p>Cada vegada m\u00e9s</p> <p>Utilitzarem moltes anotacions en aquest curs, mantingueu la calma...</p>"},{"location":"UD1_Files/4_JSON_Files/","title":"1. Arxius JSON","text":"<p>JSON \u00e9s un altre format de text lleuger per a l'intercanvi de dades. JSON significa JavaScript Object Notation i \u00e9s un subconjunt de la notaci\u00f3 literal d'objectes del llenguatge, que s'ha adoptat juntament amb XML com un dels principals est\u00e0ndards per a l'intercanvi i emmagatzematge de dades.</p> <p>Una de les avantatges de JSON respecte a XML \u00e9s la facilitat d'escriure analitzadors, per\u00f2 el que \u00e9s m\u00e9s important \u00e9s que expressa la mateixa cosa que XML per\u00f2 d'una manera molt m\u00e9s concreta i concisa, per la qual cosa s'utilitza habitualment en entorns on el flux de dades \u00e9s important, com \u00e9s el cas dels servidors de Google, Yahoo, etc., que atenen milions d'usuaris.</p>"},{"location":"UD1_Files/4_JSON_Files/#11-format-json","title":"1.1. Format JSON","text":"<p>La especificaci\u00f3 completa es pot veure aqu\u00ed</p> <p>Els tipus de dades que podem representar en JSON s\u00f3n:</p> <ul> <li>Nombres, tant enters com decimals.</li> <li>Cadenes de text, expressades entre cometes i amb la possibilitat d'incloure seq\u00fc\u00e8ncies d'escapament.</li> <li>Booleans, per representar els valors <code>true</code> i <code>false</code>.</li> <li>Null, per representar el valor <code>null</code>.</li> <li>Array, per representar llistes de zero o m\u00e9s valors, de qualsevol tipus, tancades entre claud\u00e0tors i separades per comes.</li> <li>Objectes, com a col\u00b7leccions de parells <code>&lt;clau&gt;:&lt;valor&gt;</code>, separats per comes i entre claus, i de qualsevol tipus de valor.</li> </ul> <p>Ho veurem millor amb un exemple ben conegut: el dels m\u00f2duls amb els quals estem treballant:</p> JSON<pre><code>{\n  \"curs\": [\n        {\n          \"nom\": \"Acc\u00e9s a Dades\",\n          \"hores\": 6,\n          \"qualificacio\":  8.45\n        },\n        {\n          \"nom\": \"Programaci\u00f3 de serveis i processos\",\n          \"hores\": 3,\n          \"qualificacio\": 9.0\n        },\n        {\n          \"nom\": \"Desenvolupament d'interf\u00edcies\",\n          \"hores\": 6,\n          \"qualificacio\": 8.0\n        },\n        {\n          \"nom\": \"Programaci\u00f3 Multim\u00e8dia i dispositius m\u00f2bils\",\n          \"hores\": 5,\n          \"qualificacio\": 7.34\n        },\n        {\n          \"nom\": \"Sistemes de Gesti\u00f3 Empresarial\",\n          \"hores\": 5,\n          \"qualificacio\": 8.2\n        },\n        {\n          \"nom\": \"Empresa i iniciativa emprenedora\",\n          \"hores\": 3,\n          \"qualificacio\": 7.4\n        }\n      ]\n}\n</code></pre> <p>Veurem com <code>curs</code> \u00e9s un array o una llista de m\u00f2duls (encara que ara no utilitzem l'etiqueta \"modul\"), que en aquest cas s\u00f3n objectes amb tres elements: el nom, que \u00e9s una cadena de car\u00e0cters, les hores, que \u00e9s un enter, i la qualificaci\u00f3, que es representa com un nombre decimal. Cal destacar que, com en XML, tamb\u00e9 necessitem un objecte arrel, en aquest cas l'element \"curs\".</p> <p>Internet est\u00e0 ple de serveis que ofereixen informaci\u00f3 en format JSON. Per exemple, podeu visitar:</p> <ul> <li>https://arkhamdb.com/api/public/card/01001</li> <li>https://swapi.dev/api/films/1/</li> <li>http://hp-api.herokuapp.com/api/characters</li> </ul> <p>Hi ha una \u00e0mplia gamma de llibreries de Java per manipular documents JSON (GSON, Jackson, JSON.simple...). En el nostre cas, utilitzarem la llibreria <code>org.json</code>, que podem consultar al repositori Maven: https://mvnrepository.com/artifact/org.json/json</p> <p>A la seg\u00fcent secci\u00f3 comentarem la funcionalitat de la llibreria, i en un document adjunt, veurem com incorporar-la als nostres projectes mitjan\u00e7ant el gestor de depend\u00e8ncies Gradle.</p>"},{"location":"UD1_Files/4_JSON_Files/#12-orgjson","title":"1.2. <code>org.JSON</code>","text":"<p>La biblioteca proporciona un conjunt de classes per analitzar documents JSON en Java, aix\u00ed com convertidors entre JSON i XML. Entre les classes que ofereix, podr\u00edem destacar:</p> <ul> <li><code>JSONObject</code> \u2192 Emmagatzema parells clau-valor de forma desordenada. Els valors poden ser Boolean, JSONArray, Number, String, JSONObject i <code>NULL</code>. Els constructors prenen diferents representacions (String, mapes, beans) i els emmagatzemen com un conjunt d'elements clau-valor.</li> <li><code>JSONTokener</code> \u2192 Analitza una cadena JSON i s'utilitza internament per JSONObject i altres classes per analitzar cadenes JSON.</li> <li><code>JSONArray</code> \u2192 Emmagatzema una seq\u00fc\u00e8ncia de valors i representa un array JSON.</li> <li><code>JSONWriter</code> \u2192 Proporciona una forma de produir text JSON. T\u00e9 un m\u00e8tode <code>append(String)</code> que afegeix m\u00e9s text a un objecte JSON de tipus text, a m\u00e9s dels m\u00e8todes <code>key(String)</code> i <code>value(String)</code> per afegir claus i valors a una cadena JSON. La classe tamb\u00e9 permet escriure un array.</li> </ul>"},{"location":"UD1_Files/4_JSON_Files/#13-creacio-de-fitxers-json","title":"1.3. Creaci\u00f3 de fitxers JSON","text":"<p>Els nostres exemples es basen en les dades dels m\u00f2duls de DAM vistos a les seccions anteriors. Considera aquest bloc de codi com a punt de partida on es crea un array <code>Curs</code> i s'omple amb m\u00f2duls:</p> Java<pre><code>private void creaCurs() {    \n    // Aquest m\u00e8tode inicializa l'objecte \"Curs\" de la classe JSONLib\n    // que no \u00e9s m\u00e9s que un vector de m\u00f2duls\n\n    // Definim els vectors per inicialitzar dades\n    String[] moduls={\"Acc\u00e9s a Dades\", \"Programaci\u00f3 de serveis i processos\", \"Desenvolupament d'interf\u00edcies\", \"Programaci\u00f3 Multim\u00e8dia i dispositiud m\u00f2bils\", \"Sistemes de Gesti\u00f3 Empresarial\", \"Empresa i iniciativa emprenedora\"};\n    int[]  hores={6, 3, 6, 5, 5, 3};\n    double[] notes={8.45, 9.0, 8.0, 7.34, 8.2, 7.4};\n\n    // Recorrem els vectors, creant els objectes\n    // de tipus Modul i guardant-los en Curs\n    for (int i=0;i&lt;moduls.length;i++){\n        Modul m = new Modul(moduls[i], hores[i], notes[i]);\n        this.Curs.add(m);\n    }\n}\n</code></pre> <p>Per crear el fitxer JSON complet, hem de crear JSON individuals que representin cada objecte. A causa que aquest objecte obt\u00e9 la informaci\u00f3 dels objectes, \u00e9s una bona idea crear m\u00e8todes dins de l'objecte del m\u00f2dul per obtenir la representaci\u00f3 JSON de cada objecte:</p> Java<pre><code>public JSONObject getModulJSON(){\n    JSONObject modul = new JSONObject();\n\n    modul.put(\"nom\", this.nom);        \n    modul.put(\"hores\", this.hores);\n    modul.put(\"nota\",  this.nota);\n\n    // Si volguerem afegir un element nul, \n    // hauriem de fer:\n    // modul.put(\"atribut\", JSONObject.NULL);\n\n    return modul;\n\n};\n</code></pre> <p>Un cop resolt el JSON individual, hem de crear el JSON principal, aquell que cont\u00e9 tots els m\u00f2duls. \u00c9s f\u00e0cil de suposar que l'element principal ser\u00e0 un array, que contindr\u00e0 tots els objectes de m\u00f2dul a l'interior.</p> Java<pre><code>private JSONObject creaJSON() {\n\n        // root element \"Curs\"\n        JSONObject curs = new JSONObject();\n\n        // who is a JSONArray\n        JSONArray jsarray = new JSONArray();\n\n        // we populate the array with individual modules\n        for (Modul m : this.Curs) {\n            JSONObject modul_json = m.getModulJSON();\n            jsarray.put(modul_json);\n        }\n\n        // Create the curs element with the array\n        curs.put(\"curs\", jsarray);\n\n        return (curs);\n    }\n</code></pre> <p>Finalment, necessitem guardar-ho en un fitxer de text al disc. Aquest bloc de codi emmagatzema un JSONObject utilitzant un FileWriter amb una indentaci\u00f3 espec\u00edfica:</p> Java<pre><code>private void escriuJSON(String filename, JSONObject jso){\n\n    try {\n        FileWriter file = new FileWriter(filename);\n        file.write(jso.toString(4)); // 4 s\u00f3n els espais d'indentaci\u00f3\n        file.close();\n\n    } catch (IOException e) {\n        System.out.println(\"Error, no es pot crear el fitxer \"+filename);\n    }\n}\n</code></pre>"},{"location":"UD1_Files/4_JSON_Files/#14-lectura-de-fitxers-json","title":"1.4. Lectura de fitxers JSON","text":"<p>Per tal de llegir fitxers JSON, hem de dividir la tasca en dues parts. En primer lloc, i molt senzill, \u00e9s llegir del fitxer a una cadena de text i cridar al constructor de JSONObject amb aquesta cadena. Despr\u00e9s, hem de processar-la.</p> Java<pre><code>private JSONObject LligJSON(String filename){\n    try {\n        // Amb FileReader llegirem car\u00e0cter a \n        // car\u00e0cter el fitxer i l'afegim al string myJson\n        FileReader file = new FileReader(filename); \n        String myJson=\"\";\n\n        int i;\n        while ((i=file.read()) != -1) \n            myJson=myJson+((char) i);\n\n        //System.out.println(myJson);\n        file.close();\n\n        // I fem \u00fas del constructor de JSONObject\n        // al que li passem un string amb el JSON:\n        return (new JSONObject(myJson));\n\n\n    } catch (Exception e)\n    {\n        System.out.println(\"Error llegint el fitxer\");\n        return null;\n    }\n\n}\n</code></pre> <p>Un cop tenim el principal <code>JSONObject</code>, necessitem recuperar el <code>JSONArray</code> (anomenat curs). Podem utilitzar el m\u00e8tode length() per rec\u00f3rrer tots els m\u00f2duls amb un bucle <code>for</code>. Per obtenir els objectes individuals d'un JSONObject, s'utilitza el m\u00e8tode <code>get(string label)</code>, que retorna l'objecte etiquetat. Cal tenir cura del tipus i fer conversions quan sigui necessari. En l'exemple anterior, nom\u00e9s mostrem el JSON, en lloc de crear objectes a la mem\u00f2ria.</p> Java<pre><code>private void MostraJson(JSONObject json){\n\n    // amb el m\u00e8tode getJSONArray obtenim el primer\n    // element \"curs\", que era una llista\n    JSONArray jsa=json.getJSONArray(\"curs\");\n\n    // I ara recorrem aquesta llista:\n    for (int i = 0; i &lt; jsa.length(); i++) {\n        // Agafem cada element de l'array amb \"get\"\n        JSONObject modul=(JSONObject)jsa.get(i);\n        // Amb el get anterior tindrem objectes JSON \n        // de m\u00f2duls, tipus:\n        // {\"nom\": \"Modul\", \"hores\": hores, \"nota\": nota }\n        // Als valors d'aquests parells tamb\u00e9 accedirem amb get:\n        System.out.println(\"Modul: \"+ modul.get(\"nom\"));\n        System.out.println(\"Hores: \"+ modul.get(\"hores\"));\n\n        System.out.println(\"Nota: \"+modul.get(\"nota\"));\n\n        /*\n        En esta funci\u00f3 escrivim els objectes JSON. Si volgu\u00e9rem\n        crear de nou l'estructura d'objectes, crear\u00edem cadascun \n        dels m\u00f2duls amb:\n            Modul m=new Modul(modul.get(\"nom\"), modul.get(\"hores\"), modul.get(\"nota\"));\n        */\n    }\n}\n</code></pre>"},{"location":"UD1_Files/5_Extra_Formats/","title":"1. Extra formats","text":"<p>En aquesta secci\u00f3 estudiarem dos tipus de fitxers de text que s'utilitzen \u00e0mpliament en inform\u00e0tica i la forma de treballar amb ells.</p>"},{"location":"UD1_Files/5_Extra_Formats/#11-fitxers-csv","title":"1.1. Fitxers CSV","text":"<p>Un fitxer de valors separats per comes (CSV) \u00e9s un fitxer de text est\u00e0ndard que utilitza una coma (<code>,</code>) per separar els valors. Cada l\u00ednia del fitxer consisteix en un o m\u00e9s camps separats per comes. Cada camp pot o no estar tancat entre cometes dobles. A m\u00e9s, diversos formats utilitzen diferents car\u00e0cters com a separador, com el punt i coma (<code>;</code>) o el s\u00edmbol de numeral (<code>#</code>). El RFC 4180 defineix el format o les definicions d'un fitxer CSV o fitxer de text/csv.</p> <p>En cas que el s\u00edmbol utilitzat com a separador aparegui dins dels valors, \u00e9s una bona idea tancar el contingut entre cometes. Es pot veure un exemple de fitxer CSV aqu\u00ed:</p> Text Only<pre><code>Chevrolet Chevelle Concours (sw);0;8;350.0;165.0;4142.;11.5;70;US\nFord Torino (sw);0;8;351.0;153.0;4034.;11.0;70;US\nPlymouth Satellite (sw);0;8;383.0;175.0;4166.;10.5;70;US\nAMC Rebel SST (sw);0;8;360.0;175.0;3850.;11.0;70;US\nDodge Challenger SE;15.0;8;383.0;170.0;3563.;10.0;70;US\nPlymouth Cuda 340;14.0;8;340.0;160.0;3609.;8.0;70;US\nFord Mustang Boss 302;0;8;302.0;140.0;3353.;8.0;70;US\n</code></pre> <p>La manera de processar un fitxer CSV en Java \u00e9s:</p> <ol> <li>Obrir el fitxer com a fitxer de text per a la lectura. Hem de llegir l\u00ednia per l\u00ednia, ja que cada l\u00ednia \u00e9s un registre. Llegir una l\u00ednia en una variable de tipus <code>String</code>.</li> <li>Processar els registres individuals:<ol> <li>Podem separar cada camp. Una bona opci\u00f3 \u00e9s utilitzar el m\u00e8tode <code>split(char)</code> de la classe String. Obtinguem un array de cadenes amb els valors dels camps individuals.</li> <li>Processar cada valor de camp segons les necessitats.</li> </ol> </li> </ol> <p>Atenci\u00f3</p> <p>\u00c9s una bona idea comen\u00e7ar a utilitzar les classes abstractes <code>Files</code> i <code>Paths</code>. Aquestes classes milloren l'\u00fas de la classe File i les seves classes derivades, oferint m\u00e8todes \u00fatils que ens permeten realitzar operacions r\u00e0pides amb menys l\u00ednies de codi. Per exemple, la seg\u00fcent l\u00ednia, a partir del <code>filename</code>, l'obre i despr\u00e9s llegeix tot el fitxer, retornant una llista amb les l\u00ednies separades en cada element de la col\u00b7lecci\u00f3.</p> Java<pre><code>List&lt;String&gt; lines=Files.readAllLines(Paths.get(filename));\n</code></pre> <p>More info in:</p> <ul> <li>Files</li> <li>Paths</li> </ul>"},{"location":"UD1_Files/5_Extra_Formats/#12-fitxers-de-propietats","title":"1.2. Fitxers de propietats","text":""},{"location":"UD1_Files/5_Extra_Formats/#121-fitxer-de-propietats","title":"1.2.1. Fitxer de propietats","text":"<p>Finalment, per\u00f2 no menys important, us mostrarem un tipus de fitxer de text important, que s\u00f3n els fitxers de propietats. Aquests fitxers emmagatzemen, com ja sabeu, diverses propietats que s'utilitzen durant l'execuci\u00f3 del programa. Quan el programa s'inicia, carrega aquestes propietats i ajusta diverses opcions. Exemples d'aquests fitxers s\u00f3n <code>my.conf</code> a MySQL, <code>php.ini</code> a PHP, etc.</p> <p>L'aspecte d'aquest fitxer consisteix en diverses l\u00ednies (una per propietat) i cada l\u00ednia t\u00e9 el format <code>atribut=valor</code>. Per exemple, un suposat fitxer:</p> Text Only<pre><code># properties of my program\nport=1234\nvolume=90\nbright=56\nload_on_start=true\n</code></pre> <p>La manera de processar un fitxer de propietats en Java \u00e9s similar a un CSV:</p> <ol> <li>Obrir com a fitxer de text per a la lectura. Hem de llegir l\u00ednia per l\u00ednia, ja que cada l\u00ednia \u00e9s una propietat diferent. Llegir una l\u00ednia en una variable de tipus <code>String</code>.</li> <li>Processar els registres individuals:<ol> <li>Podem separar cada camp. Una bona opci\u00f3 \u00e9s utilitzar el m\u00e8tode <code>split(char)</code> de la classe String. Obtinguem un array de cadenes amb els valors dels camps individuals. Els separadors normalment s\u00f3n <code>=</code>, <code>:</code>.</li> <li>L'esquerra del separador \u00e9s el nom de la propietat.</li> <li>La dreta del separador \u00e9s el valor de la propietat.</li> <li>Cal tenir en compte que si una l\u00ednia comen\u00e7a amb barra (<code>#</code>), \u00e9s un comentari i s'ignorar\u00e0.</li> </ol> </li> </ol>"},{"location":"UD1_Files/5_Extra_Formats/#122-propietats-de-java","title":"1.2.2. Propietats de Java","text":"<p>Java t\u00e9 un objecte molt \u00fatil per gestionar aquest tipus d'informaci\u00f3. Amb els objectes preperties de Java, podem emmagatzemar un conjunt de propietats amb una taula de hash (b\u00e0sicament una parella clau-valor). T\u00e9 m\u00e8todes preparats per carregar i desar des de i cap a fluxos de text o, fins i tot, fitxers XML. Alguns m\u00e8todes interessants per a les propietats s\u00f3n:</p> <p>Lectura des de fitxer (text o XML)</p> <ul> <li><code>void load(InputStream inStream)</code> \u2192 Llegeix un conjunt de propietats (parelles clau-element) des del flux d'entrada de bytes.</li> <li><code>void load(Reader reader)</code> \u2192 Llegeix un conjunt de propietats (parelles clau-element) des del flux d'entrada de car\u00e0cters en un format senzill orientat a l\u00ednies.</li> <li><code>void loadFromXML(InputStream in)</code> \u2192 Carrega totes les propietats representades pel document XML en el flux d'entrada especificat en aquesta taula de propietats.</li> </ul> <p>Escriptura en fitxer (text o XML)</p> <ul> <li><code>void store(OutputStream out, String comments)</code> \u2192 Escriu aquest conjunt de propietats (parelles clau-element) en aquesta taula de propietats al flux de sortida en un format adequat per carregar-lo en una taula de propietats utilitzant el m\u00e8tode load(InputStream).</li> <li><code>void store(Writer writer, String comments)</code> \u2192 Escriu aquest conjunt de propietats (parelles clau-element) en aquesta taula de propietats al flux de car\u00e0cters de sortida en un format adequat per utilitzar el m\u00e8tode load(Reader).</li> <li><code>void storeToXML(OutputStream os, String comment)</code> \u2192 Emmet un document XML que representa totes les propietats contingudes en aquesta taula.</li> </ul> <p>Treball amb propietats (heretat de HashTable)</p> <ul> <li><code>Set&lt;K&gt; keySet()</code> \u2192 Retorna una vista de conjunt de les claus contingudes en aquest mapa.</li> <li><code>V get(Object key)</code> \u2192 Retorna el valor (<code>V</code>) al qual s'assigna la clau especificada, o <code>null</code> si aquest mapa no cont\u00e9 cap assignaci\u00f3 per a la clau.</li> <li><code>boolean  containsKey(Object key)</code> Comprova si l'objecte especificat \u00e9s una clau d'aquesta taula de hash.</li> <li><code>V put(K key, V value)</code> \u2192 Assigna la clau especificada al valor especificat en aquesta taula de hash.</li> <li><code>V remove(Object key)</code> \u2192 Elimina la clau (i es retorna el valor corresponent) d'aquesta taula de hash.</li> </ul>"},{"location":"UD1_Files/5_Extra_Formats/#123-programa-dexemple","title":"1.2.3. Programa d'exemple","text":"<p>En el seg\u00fcent programa, podeu veure un exemple de lectura i creaci\u00f3 de fitxers de propietats en Java.</p> Java<pre><code>    /**\n     * Load the file specified and show its properties in different ways\n     * @param filename \n     */\n    private void loadAndShowProperties(String filename) {\n\n        Properties properties = new Properties();\n\n        try {\n            properties.load(new FileInputStream(new File(filename)));\n\n            System.out.println(\"Whole set: \" + properties);\n\n            properties.list(System.out);\n\n            Set&lt;Object&gt; keys = properties.keySet( );\n\n            System.out.println(\"My listing: \");\n            for (Object key : keys) {\n                System.out.println(key + \" - \" + properties.getProperty((String) key));\n            }\n\n        } catch (FileNotFoundException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (IOException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n\n    }\n\n    /**\n     * Create a properties object, populated with samples and stores into a \n     * text file and a XML file\n     * @throws IOException \n     */\n    private void writeProperties() throws IOException {\n        Properties props = new Properties();\n\n        props.put(\"Color\", \"Green\");\n        props.put(\"Range\", \"123\");\n        props.put(\"Visible\", \"false\");\n        props.put(\"Size\", \"Big\");\n        props.put(\"Status\", \"functional\");\n        props.put(\"Value\", \"345.24\");\n\n        props.store(new FileWriter(new File(\"propis.properties\")), \"Sample props file\");\n\n        props.storeToXML(new FileOutputStream(new File(\"propis.xml\")), \"Sample XML Props\");\n    }\n</code></pre>"},{"location":"UD1_Files/5_Extra_Formats/#13-entorn-arxius-env-i-dot_env","title":"1.3. Entorn, arxius <code>.env</code> i <code>dot_env</code>","text":""},{"location":"UD1_Files/5_Extra_Formats/#131-per-que-utilitzar-variables-dentorn","title":"1.3.1. Per qu\u00e8 utilitzar variables d'entorn?","text":"<p>Les variables d'entorn s\u00f3n un aspecte crucial per configurar i gestionar aplicacions en diferents entorns, com ara desenvolupament, proves i producci\u00f3. Proporcionen una manera de passar din\u00e0micament dades de configuraci\u00f3 a les aplicacions sense codificar valors directament al codi font. Aquest enfocament millora la flexibilitat, portabilitat i seguretat de les aplicacions.</p> <p>En Java, accedir a les variables d'entorn \u00e9s senzill, gr\u00e0cies a la classe <code>System</code>, que proporciona m\u00e8todes per obtenir les variables d'entorn. Aquesta capacitat \u00e9s especialment \u00fatil per a:</p> <ul> <li>Configurar par\u00e0metres de l'aplicaci\u00f3 com ara URL de bases de dades, claus d'API i rutes de fitxers.</li> <li>Gestionar configuracions espec\u00edfiques de l'entorn sense alterar el codi font.</li> <li>Mantenir informaci\u00f3 sensible, com ara contrasenyes i tokens, fora del codi font.</li> </ul> <p>Entenent com utilitzar de manera efectiva les variables d'entorn en Java, els desenvolupadors poden crear aplicacions m\u00e9s adaptables i segures.</p>"},{"location":"UD1_Files/5_Extra_Formats/#132-obtenir-variables-dentorn","title":"1.3.2. Obtenir variables d'entorn","text":"<p>Per accedir a les variables d'entorn en Java, podeu utilitzar el m\u00e8tode <code>System.getenv()</code>. Aquest m\u00e8tode est\u00e0 sobrecarregat i pot ser:</p> <ul> <li><code>System.getenv()</code> \u2192 retorna un objecte <code>Map</code> que cont\u00e9 totes les variables d'entorn i els seus valors corresponents.</li> <li><code>System.getenv(String)</code> \u2192 retorna una <code>String</code> amb el valor de la variable d'entorn espec\u00edfica o null si no existeix.</li> </ul> <p>Com recuperar les variables d'entorn en Java:</p> Java<pre><code>Map&lt;String, String&gt; env = System.getenv();\n\n// Accedir a una variable d'entorn espec\u00edfica\nString value = env.get(\"NOM_VARIABLE\");\n\n// Imprimir totes les variables d'entorn\nfor (Map.Entry&lt;String, String&gt; entry : env.entrySet()) {\n    System.out.println(entry.getKey() + \" = \" + entry.getValue());\n}\n</code></pre> <p>Tingueu en compte que:</p> <ul> <li>La classe Map retorna una col\u00b7lecci\u00f3 d'entrades amb parelles clau-valor.</li> <li>Les variables d'entorn distingeixen entre maj\u00fascules i min\u00fascules, aix\u00ed que assegureu-vos d'utilitzar les maj\u00fascules de manera correcta en accedir-hi.</li> </ul>"},{"location":"UD1_Files/5_Extra_Formats/#133-lalternativa-dot-env","title":"1.3.3. L'alternativa <code>dot-env</code>","text":"<p>Emmagatzemar la configuraci\u00f3 a l'entorn \u00e9s un dels principis d'una aplicaci\u00f3 de dotze factors. Qualsevol cosa que pugui canviar entre els entorns de desplegament, com ara els recursos de les bases de dades o les credencials dels serveis externs, s'ha d'extreure del codi i emmagatzemar en variables d'entorn.</p> <p>Per\u00f2 no sempre \u00e9s pr\u00e0ctic establir variables d'entorn en m\u00e0quines de desenvolupament o servidors d'integraci\u00f3 cont\u00ednua on s'executen diversos projectes. <code>Dotenv</code> carrega les variables d'un fitxer <code>.env</code> a l'entorn quan s'inicia.</p> <p>Desafortunadament, Java no admet de forma nativa la c\u00e0rrega de fitxers <code>.env</code>, per\u00f2 podeu utilitzar llibreries externes per aconseguir aquesta tasca. Una de les llibreries populars per a aquest prop\u00f2sit \u00e9s <code>dotenv-java</code>. Aquesta llibreria us permet carregar f\u00e0cilment les variables d'entorn d'un fitxer .env a la vostra aplicaci\u00f3 Java. https://github.com/cdimascio/dotenv-java</p> <p>Afegiu la depend\u00e8ncia</p> <p>Primer, heu d'afegir la llibreria <code>dotenv-java</code> al vostre projecte. Si feu servir Maven, afegiu la seg\u00fcent depend\u00e8ncia al fitxer pom.xml:</p> XML<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.github.cdimascio&lt;/groupId&gt;\n    &lt;artifactId&gt;java-dotenv&lt;/artifactId&gt;\n    &lt;version&gt;5.2.2&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Si feu servir Gradle, afegiu el seg\u00fcent al fitxer build.gradle:</p> Text Only<pre><code>implementation 'io.github.cdimascio:java-dotenv:5.2.2'\n</code></pre> <p>Creeu el fitxer <code>.env</code></p> <p>El fitxer .env \u00e9s com un fitxer de configuraci\u00f3. Podeu emmagatzemar-lo a la ruta arrel de la vostra aplicaci\u00f3</p> Text Only<pre><code>DATABASE_URL=jdbc:mysql://localhost:3306/testdb\nDATABASE_USER=root\nDATABASE_PASSWORD=password\n</code></pre> <p>Carregueu la configuraci\u00f3</p> Java<pre><code>import io.github.cdimascio.dotenv.Dotenv;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Load the .env file\n        Dotenv dotenv = Dotenv.load();\n\n        // Retrieve environment variables\n        String databaseUrl = dotenv.get(\"DATABASE_URL\");\n        String databaseUser = dotenv.get(\"DATABASE_USER\");\n        String databasePassword = dotenv.get(\"DATABASE_PASSWORD\");\n\n        // Print the values\n        System.out.println(\"Database URL: \" + databaseUrl);\n        System.out.println(\"Database User: \" + databaseUser);\n        System.out.println(\"Database Password: \" + databasePassword);\n\n        // Use the variables as needed\n        // For example, establish a database connection using these variables\n    }\n}\n</code></pre> <p>Atenci\u00f3</p> <p>Tingueu en compte que amb la llibreria java dotenv, utilitzareu <code>dotenv.get()</code> en comptes del m\u00e8tode <code>System.getenv()</code>, ja que esteu accedint a un fitxer local.</p>"},{"location":"UD2_Connectors/1_Object_relational_impedance_mismatch/","title":"1. Desfassament objecte-relacional","text":"<p>Els Sistemes de Gesti\u00f3 de Bases de Dades (SGBD) es basen principalment en el model Entitat-Relaci\u00f3 (E/R), on la informaci\u00f3 s'emmagatzema en diverses taules relacionades entre si. \u00c9s una tecnologia senzilla i eficient, que ha resistit al pas dels anys i que encara \u00e9s el model utilitzat per la majoria de bases de dades i SGBD actualment. Malgrat el seu \u00e8xit, el model t\u00e9 algunes limitacions, com la representaci\u00f3 de informaci\u00f3 mal estructurada o complexa.</p> <p>Els models conceptuals ens ajuden a modelar una realitat complexa i es basen en un proc\u00e9s d'abstracci\u00f3 de la realitat. Cada model t\u00e9 una manera de capturar aquesta realitat, per\u00f2 tots ells estan m\u00e9s propers a la mentalitat humana que a la mem\u00f2ria d'un ordinador.</p> <p>Quan modelitzem una base de dades, fem servir el model conceptual d'Entitat-Relaci\u00f3 i posteriorment fem un proc\u00e9s de transformaci\u00f3 en taules i normalitzaci\u00f3 d'aquest model per obtenir un model de dades relacional.</p> <p>En el cas de la programaci\u00f3 orientada a objectes, intentem representar la realitat mitjan\u00e7ant objectes i les relacions entre ells. Aquest \u00e9s un altre tipus de model conceptual, per\u00f2 que t\u00e9 com a objectiu representar la mateixa realitat que el model relacional.</p> <p>Aix\u00ed doncs, tenim dues aproximacions diferents per representar la realitat d'un problema: el Model Relacional de la base de dades i el model Orientat a Objectes de les nostres aplicacions.</p>"},{"location":"UD2_Connectors/1_Object_relational_impedance_mismatch/#11-representacio-de-la-informacio-amb-el-model-relacional","title":"1.1. Representaci\u00f3 de la informaci\u00f3 amb el model relacional","text":"<p>El model relacional es basa en taules i la relaci\u00f3 entre elles:</p> <ul> <li>Cada taula t\u00e9 tantes columnes com atributs volem representar i tantes files com registres o elements d'aquest tipus cont\u00e9.</li> <li>Les taules tenen una clau prim\u00e0ria, que identifica cada un dels registres, i pot estar formada per un o m\u00e9s atributs.</li> <li>La relaci\u00f3 entre taules es representa mitjan\u00e7ant claus externes, que consisteixen en incloure en una taula la clau prim\u00e0ria d'una altra taula, com a refer\u00e8ncia a aquesta. Quan s'elimina un registre d'una taula, la clau prim\u00e0ria del qual \u00e9s referenciada per un altre, s'ha de garantir que es mant\u00e9 la integritat referencial de la base de dades. Aleshores, abans d'aquesta eliminaci\u00f3 d'una clau prim\u00e0ria, podem:<ul> <li>No permetre l'eliminaci\u00f3 (NO ACTION),</li> <li>Realitzar l'eliminaci\u00f3 en cascada, eliminant tamb\u00e9 tots els registres que feien refer\u00e8ncia a la clau prim\u00e0ria del registre eliminat (CASCADE),</li> <li>Establir a null (SET NULL), de manera que la clau externa que feia refer\u00e8ncia a la clau prim\u00e0ria de l'altra taula prengui el valor de <code>NULL</code>.</li> </ul> </li> <li>Els diferents camps de les taules tamb\u00e9 poden tenir certes restriccions associades, com ara:<ul> <li>Restricci\u00f3 de valor no nul, de manera que el camp no pot ser nul en cap cas,</li> <li>Restricci\u00f3 d'unicitat en un o diversos camps, de manera que el valor ha de ser \u00fanic a tota la taula.</li> <li>Restricci\u00f3 de domini, o el que \u00e9s el mateix, pot tenir un conjunt de valors possibles per defecte.</li> </ul> </li> </ul> <p>Atenci\u00f3</p> <p>Primary keys have both properties: non-null value and uniqueness.</p>"},{"location":"UD2_Connectors/1_Object_relational_impedance_mismatch/#111-exemple","title":"1.1.1. Exemple","text":"<p>Una base de dades per emmagatzemar informaci\u00f3 sobre jugadors, jocs, etc., pot ser aix\u00ed:</p> <p></p> <p>Implementada amb el SGBD <code>MySQL</code>:</p> SQL<pre><code>CREATE SCHEMA IF NOT EXISTS `BDJocs` DEFAULT CHARACTER SET utf8 ;\nUSE `BDJocs` ;\n\nCREATE TABLE IF NOT EXISTS `BDJocs`.`jugador` (\n  `id` INT NOT NULL,\n  `nick` VARCHAR(45) NULL,\n  `dataRegistre` DATETIME NULL,\n  PRIMARY KEY (`id`))\nENGINE = InnoDB;\n\nCREATE TABLE IF NOT EXISTS `BDJocs`.`Genere` (\n  `id` INT NOT NULL,\n  `nom` VARCHAR(45) NULL,\n  `descripci\u00f3` VARCHAR(256) NULL,\n  PRIMARY KEY (`id`))\nENGINE = InnoDB;\n\nCREATE TABLE IF NOT EXISTS `BDJocs`.`Joc` (\n  `id` INT NOT NULL,\n  `nom` VARCHAR(45) NULL,\n  `descripci\u00f3` VARCHAR(256) NULL,\n  `Genere_id` INT NOT NULL,\n  PRIMARY KEY (`id`),\n  INDEX `fk_Joc_Genere1_idx` (`Genere_id` ASC),\n  CONSTRAINT `fk_Joc_Genere1`\n    FOREIGN KEY (`Genere_id`)\n    REFERENCES `BDJocs`.`Genere` (`id`)\n    ON DELETE NO ACTION\n    ON UPDATE NO ACTION)\nENGINE = InnoDB;\n\nCREATE TABLE IF NOT EXISTS `BDJocs`.`Puntuacions` (\n  `jugador_id` INT NOT NULL,\n  `Joc_id` INT NOT NULL,\n  `puntuacio` INT NULL,\n  PRIMARY KEY (`jugador_id`, `Joc_id`),\n  INDEX `fk_jugador_has_Joc_Joc1_idx` (`Joc_id` ASC),\n  INDEX `fk_jugador_has_Joc_jugador1_idx` (`jugador_id` ASC),\n  CONSTRAINT `fk_jugador_has_Joc_jugador1`\n    FOREIGN KEY (`jugador_id`)\n    REFERENCES `BDJocs`.`jugador` (`id`)\n    ON DELETE NO ACTION\n    ON UPDATE NO ACTION,\n  CONSTRAINT `fk_jugador_has_Joc_Joc1`\n    FOREIGN KEY (`Joc_id`)\n    REFERENCES `BDJocs`.`Joc` (`id`)\n    ON DELETE NO ACTION\n    ON UPDATE NO ACTION)\nENGINE = InnoDB;\n</code></pre>"},{"location":"UD2_Connectors/1_Object_relational_impedance_mismatch/#12-representacio-de-la-informacio-amb-el-model-orientat-a-objectes","title":"1.2. Representaci\u00f3 de la informaci\u00f3 amb el model orientat a objectes","text":"<p>Com l'entitat-relaci\u00f3, el model orientat a objectes \u00e9s un model de dades conceptual, per\u00f2 que d\u00f3na import\u00e0ncia a la modelitzaci\u00f3 dels objectes.</p> <p>Un objecte pot representar qualsevol element conceptual: entitats, processos, accions... Un objecte no nom\u00e9s representa les caracter\u00edstiques o propietats, sin\u00f3 que tamb\u00e9 es centra en els processos que pateixen. En termes del model orientat a objectes, diem que un objecte \u00e9s dades m\u00e9s operacions o comportament.</p> <p>A la unitat introduct\u00f2ria ja vam revisar la programaci\u00f3 orientada a objectes, aix\u00ed que ens limitarem a una breu revisi\u00f3 dels conceptes principals:</p> <ul> <li>Un objecte \u00e9s una entitat amb certes propietats i cert comportament.</li> <li>En termes de POO, les propietats es coneixen com a atributs, i el conjunt dels seus valors determina l'estat de l'objecte en un moment donat.</li> <li>El comportament est\u00e0 determinat per una s\u00e8rie de funcions i procediments que anomenem m\u00e8todes, i que modifiquen l'estat de l'objecte.</li> <li>Un objecte tamb\u00e9 tindr\u00e0 un nom amb el qual s'identifica.</li> <li>Una classe \u00e9s una abstracci\u00f3 d'un conjunt d'objectes, i un objecte ha de pert\u00e0nyer necess\u00e0riament a alguna classe.</li> <li>Les classes defineixen els atributs i m\u00e8todes que els objectes d'aquesta classe tindran.</li> <li>Un objecte es diu que \u00e9s una inst\u00e0ncia d'una classe.</li> </ul> <p>El mateix exemple que hem representat recentment, amb una representaci\u00f3 orientada a objectes podria ser:</p> <p></p> <p>Com podem veure, t\u00e9 una estructura similar, a la qual tamb\u00e9 hem afegit alguns m\u00e8todes com ara getters i setters. A m\u00e9s, les diferents classes no tenen un atribut identificador, ja que cada objecte s'identifica a si mateix. Aqu\u00ed tenim una petita aproximaci\u00f3 de com implementar\u00edem aquesta jerarquia en Java.</p> <p>La classe <code>Genere</code> \u00e9s una classe POJO, que nom\u00e9s emmagatzema informaci\u00f3 (nom i descripci\u00f3 del tipus de joc) i implementa getters i setters.</p> Java<pre><code>public class Genere {\n    protected String nom;\n    protected String descripcio;\n\n    public Genere(String nom, String descripcio) {\n        this.nom = nom;\n        this.descripcio = descripcio;\n    }\n\n    public String getNom() {return nom;}\n    public void setNom(String nom) {this.nom = nom;}\n\n    public String getDescripcio() {return descripcio;}\n    public void setDescripcio(String descripcio) {\n        this.descripcio = descripcio;\n    }\n}\n</code></pre> <p>La classe <code>Joc</code> emmagatzema el nom, la descripci\u00f3 i el g\u00e8nere del joc. A difer\u00e8ncia del model relacional, on el que s'emmagatzema seria una clau externa al g\u00e8nere, ja que aqu\u00ed no tenim claus externes, emmagatzemem l'objecte mateix (la refer\u00e8ncia).</p> Java<pre><code>public class Joc {\n\n    protected String nom;\n    protected String descripcio;\n    protected Genere genere;\n\n    public Joc(String nom, String descripcio, Genere genere) {\n        this.nom = nom;\n        this.descripcio = descripcio;\n        this.genere = genere;\n\n    }\n\n    public String getNom() {return this.nom;}\n    public void setNom(String nom) {this.nom = nom;}\n\n    public String getDescripcio() {return this.descripcio;}\n    public void setDescripcio(String descripcio) {\n        this.descripcio= descripcio;\n    }\n\n    public Genere getGenere() {return this.genere;}\n\n    public void setGenere(Genere genere) {this.genere = genere;}\n}\n</code></pre> <p>La classe <code>Registre</code> presenta la relaci\u00f3 entre <code>Jugador</code> i <code>Joc</code> (quan un jugador juga a un joc) i emmagatzema els punts i una refer\u00e8ncia al joc.</p> Java<pre><code>public class Registre {\n    private int puntuacio;\n    private Joc joc;\n\n    public Registre(int puntuacio, Joc joc) {\n        this.puntuacio = puntuacio;\n        this.joc = joc;\n    }\n\n    public int getPuntuacio() {return puntuacio;}\n    public void setPuntuacio(int puntuacio) {\n        this.puntuacio = puntuacio;\n    }\n\n    public Joc getJoc() {return joc;}\n\n    public void setJoc(Joc joc) {this.joc = joc;}   \n}\n</code></pre> <p>I finalment, la classe <code>Jugador</code> emmagatzema el sobrenom i la data de registre per a cada jugador, i despr\u00e9s, un array amb tots els jocs que el jugador ha jugat:</p> Java<pre><code>public class Jugador {\n\n    private String nick;\n    private Date dataRegistre;\n    private Set&lt;Registre&gt; puntuacions;\n\n    public Jugador(String nick, Date dataRegistre) {\n        this.nick = nick;\n        this.dataRegistre = dataRegistre;\n    }\n\n    public String getNick() {return nick;}\n    public void setNick(String nick) {this.nick = nick;}\n\n    public Date getDataRegistre() {return dataRegistre;}\n    public void setDataRegistre(Date dataRegistre) {\n        this.dataRegistre = dataRegistre;\n    }\n\n    public Set getPuntuacions() {return this.puntuacions;}\n    public void setPuntuacio(Joc joc, int puntuacio) {\n        Registre registre = new Registre(puntuacio, joc);\n        this.puntuacions.add(registre);\n    }\n}\n</code></pre> <p>La interf\u00edcie <code>Set</code> i la classe <code>HashSet</code></p> <p><code>Set</code> \u00e9s una interf\u00edcie del paquet <code>java.util</code> que tracta una col\u00b7lecci\u00f3 o conjunt d'elements sense desordre i sense duplicats.</p> <p>D'altra banda, <code>HashSet</code> \u00e9s una classe que implementa la interf\u00edcie <code>Set</code> i que es basa en una taula de hash, una estructura de dades que permet localitzar objectes basant-se en una clau que indica la posici\u00f3 a la taula, permetent l'acc\u00e9s directe a l'element, el que els fa ideals per a cerques, insercions i eliminacions.</p>"},{"location":"UD2_Connectors/1_Object_relational_impedance_mismatch/#13-model-relacional-vs-model-orientat-a-objectes","title":"1.3. Model Relacional vs Model Orientat a Objectes","text":"<p>Conceptualment, el model orientat a objectes \u00e9s un model din\u00e0mic, que es centra en els objectes i en els processos que aquests experimenten, per\u00f2 que no t\u00e9 en compte, des del principi, la seva persist\u00e8ncia. Hem de ser capa\u00e7os, per tant, de guardar els estats dels objectes de manera permanent i carregar-los quan l'aplicaci\u00f3 els necessiti, aix\u00ed com mantenir la consist\u00e8ncia entre aquestes dades emmagatzemades i els objectes que les representen a l'aplicaci\u00f3.</p> <p>Una manera d'oferir aquesta persist\u00e8ncia als objectes seria utilitzar un SGBD Relacional, per\u00f2 ens trobarem amb algunes complicacions. La primera, des d'un punt de vista conceptual, \u00e9s que el model Entitat-Relaci\u00f3 es centra en les dades, mentre que el model orientat a objectes es centra en els objectes, entesos com a grups de dades i les operacions realitzades sobre ells.</p> <p>Una altra difer\u00e8ncia, for\u00e7a important, \u00e9s la vinculaci\u00f3 dels elements entre un model i un altre. D'una banda, el model relacional afegeix informaci\u00f3 addicional a les taules en forma de clau externa, mentre que en el model orientat a objectes no necessitem aquesta dada externa, sin\u00f3 que la vinculaci\u00f3 entre objectes es fa a trav\u00e9s de refer\u00e8ncies entre ells. Un objecte, per exemple, no necessitar\u00e0 una clau prim\u00e0ria, ja que l'objecte s'identifica per si mateix.</p> <p>Com hem vist a l'exemple de les seccions anteriors, les taules en el model relacional tenien una clau prim\u00e0ria per identificar els objectes i claus externes per expressar les relacions, mentre que en el model orientat a objectes aquestes desapareixen, expressant les relacions entre objectes mitjan\u00e7ant refer\u00e8ncies. A m\u00e9s, la manera com s'expressen aquestes relacions tamb\u00e9 \u00e9s diferent. En el model relacional, per exemple, el registre de puntuacions \u00e9s una taula que enlla\u00e7a la taula de jugadors amb la taula de jocs i afegeix la puntuaci\u00f3 del jugador en el joc. D'altra banda, en la implementaci\u00f3 en Java que hem fet, tenim objectes de tipus <code>Registre</code> que emmagatzemen una puntuaci\u00f3 i una refer\u00e8ncia al joc, per\u00f2 \u00e9s la classe Jugador la que mant\u00e9 el conjunt de registres de les seves puntuacions.</p> <p>D'altra banda, en manipular les dades, cal tenir en compte que el model relacional disposa de llenguatges (principalment SQL) dissenyats exclusivament per a aquest prop\u00f2sit, mentre que en un llenguatge orientat a objectes funciona de manera diferent, per la qual cosa ser\u00e0 necessari incorporar mecanismes que permetin fer aquestes consultes des del llenguatge de programaci\u00f3. A m\u00e9s, quan obtenim els resultats de la consulta, tamb\u00e9 ens trobem amb un altre problema, i \u00e9s la conversi\u00f3 dels resultats. Quan es fa una consulta a una base de dades, sempre es retorna un resultat en forma de taula, per la qual cosa ser\u00e0 necessari transformar aquests resultats en estats dels objectes de l'aplicaci\u00f3.</p> <p>Totes aquestes difer\u00e8ncies impliquen el que es coneix com a desfassament relacional-objecte, i que ens obligar\u00e0 a fer determinades conversions entre objectes i taules quan volem guardar la informaci\u00f3 en un SGBD. En aquesta unitat i en les seg\u00fcents, veurem com superar aquest retard des de diferents enfocaments.</p>"},{"location":"UD2_Connectors/2_Connectors/","title":"1. Connectors","text":""},{"location":"UD2_Connectors/2_Connectors/#11-larquitectura-client-servidor-en-sgbd","title":"1.1. L'arquitectura client-servidor en SGBD","text":"<p>Un cop coneixem el retard relacional-objecte, centrem-nos en com accedir a bases de dades relacionals des dels llenguatges de programaci\u00f3. Els SGBD, es van popularitzar als anys 80, i s\u00f3n els m\u00e9s estesos actualment. Llevat d'algunes excepcions, funcionen seguint una arquitectura client-servidor, de manera que tenim un servidor on executa el SGBD i diversos clients que es connecten al servidor i fan les peticions corresponents.</p> <p>Els SGBD oferien els seus propis llenguatges de programaci\u00f3, per\u00f2 estaven molt lligats a ells, i el manteniment de l'aplicaci\u00f3 era molt car. Per aquest motiu, la tend\u00e8ncia era desacoblar (separar) els SGBD del llenguatge de programaci\u00f3, i fer \u00fas d'est\u00e0ndards de connexi\u00f3 entre ells.</p> <p>Gr\u00e0cies a l'arquitectura client-servidor, els SGBD van poder separar les dades d'una banda i els programes per accedir-hi per altres. Aquesta versatilitat tenia un petit inconvenient, i \u00e9s que calia desenvolupar d'una banda el servidor, per\u00f2 de l'altra, tamb\u00e9 la part del client per poder connectar-se als servidors. Aquestes connexions entre clients i servidors requeriran protocols i llenguatges espec\u00edfics. Aqu\u00ed neix el concepte de middleware, ent\u00e8s com una capa interm\u00e8dia de persist\u00e8ncia, formada per biblioteques, llenguatges i protocols ubicats al client i al servidor i que permeten connectar la base de dades amb les aplicacions.</p> <p>Tot i que inicialment cada SGBD va implementar solucions espec\u00edfiques, es van imposar est\u00e0ndards, entre els quals trobem el llenguatge de consulta SQL (Structured Query Language), i que va suposar un gran avan\u00e7, ja que va unificar la manera d'accedir a les bases de dades, encara que les aplicacions van continuar requereixen una API per fer \u00fas de SQL.</p>"},{"location":"UD2_Connectors/2_Connectors/#12-protocols-dacces-a-bases-de-dades","title":"1.2. Protocols d'acc\u00e9s a bases de dades","text":"<p>Quan parlem de protocols d'acc\u00e9s a bases de dades, ens trobem amb dues regles principals de connexi\u00f3:</p> <ul> <li>ODBC (Open Data Base Connectivity): Aquesta \u00e9s una API (Application Program Interface) desenvolupada per Microsoft per a sistemes Windows que permet afegir diferents connectors a diverses bases de dades relacionals basades en SQL, d'una manera senzilla i transparent. Utilitzant ODBC, les aplicacions poden obrir connexions a la base de dades, enviar consultes, actualitzacions i gestionar els resultats.</li> <li>JDBC (Java Database Connectivity), que defineix una API multiplataforma que els programes Java poden utilitzar per connectar-se al SGBD.</li> </ul>"},{"location":"UD2_Connectors/2_Connectors/#13-jdbc","title":"1.3. JDBC","text":"<p>Com hem dit, JDBC \u00e9s una API de connexi\u00f3 a bases de dades espec\u00edfica de Java. El seu mode de funcionament \u00e9s el seg\u00fcent:</p> <ul> <li>S'ofereix una API, encapsulada en classes, que garanteix uniformitat en la manera en qu\u00e8 les aplicacions es connecten a la base de dades, independentment del SGBD subjacent.</li> <li>Necessitarem un controlador per a cada base de dades a la qual volem connectar-nos. Java no t\u00e9 cap llibreria ODBC espec\u00edfica, per\u00f2, per no perdre el potencial d'aquestes connexions, s'han incorporat controladors especials que actuen com a adaptadors entre JDBC i ODBC, de manera que \u00e9s possible, a trav\u00e9s d'aquest pont, connectar qualsevol aplicaci\u00f3 Java amb qualsevol connexi\u00f3 ODBC. Actualment, gaireb\u00e9 tots els SGBD tenen controladors JDBC, per\u00f2 en cas que no en tingueu coneixement, podeu fer servir aquest pont ODBC-JDBC.</li> </ul>"},{"location":"UD2_Connectors/2_Connectors/#131-arquitectura-jdbc","title":"1.3.1. Arquitectura JDBC","text":"<p>La biblioteca est\u00e0ndard JDBC proporciona un conjunt d'interf\u00edcies independents de la implementaci\u00f3. Els controladors de cada DBMS seran els encarregats de la implementaci\u00f3. Les aplicacions, per accedir a la base de dades, hauran d'utilitzar les interf\u00edcies JDBC, de manera que la implementaci\u00f3 de cada DBMS sigui completament transparent per a l'aplicaci\u00f3.</p> <p></p> <p>Com podem veure, les aplicacions Java accedeixen als diferents m\u00e8todes que l'API especifica com a interf\u00edcies, per\u00f2 s\u00f3n els controladors els que accedeixen a la base de dades.</p> <p>Cal dir que les aplicacions poden utilitzar diversos controladors JDBC simult\u00e0niament i accedir, per tant, a m\u00faltiples bases de dades. L'aplicaci\u00f3 especifica un controlador JDBC utilitzant una URL (Universal Resource Locator) al gestor de controladors, i aquest \u00e9s el responsable d'establir correctament les connexions amb les bases de dades a trav\u00e9s dels controladors. Els controladors poden ser de diferents tipus:</p> <ul> <li>Tipus I o controladors de pont, caracteritzats per fer \u00fas de tecnologia externa a JDBC i actuar com a adaptadors entre JDBC i la tecnologia espec\u00edfica utilitzada. Un exemple \u00e9s el pont JDBC-ODBC.</li> <li>Tipus II o controladors amb API parcialment nativa, o controladors natius. Estan entrenats d'una banda en Java i de l'altra fan \u00fas de llibreries del sistema operatiu. El seu \u00fas es deu a alguns SGBD que incorporen connectors propietaris que no segueixen cap est\u00e0ndard (normalment pre-ODBC/JDBC).</li> <li>Tipus III o controladors Java a trav\u00e9s de protocol de xarxa, que s\u00f3n controladors desenvolupats en Java que tradueixen les crides JDBC a un protocol de xarxa contra un servidor intermedi. \u00c9s un sistema molt flexible, ja que els canvis en la implementaci\u00f3 de la base de dades no afecten les aplicacions.</li> <li>Tipus IV o 100% Java pures, tamb\u00e9 anomenats protocol natius, i aquests s\u00f3n controladors escrits \u00edntegrament en Java. Les sol\u00b7licituds al SGBD es realitzen a trav\u00e9s del protocol de xarxa que utilitza el mateix SGBD, de manera que no \u00e9s necessari cap codi natiu al client ni un servidor intermediari. \u00c9s l'alternativa que s'ha acabat imposant, ja que no requereix cap tipus d'instal\u00b7laci\u00f3.</li> </ul>"},{"location":"UD2_Connectors/2_Connectors/#14-mysql-docker-workbench","title":"1.4. MySQL, Docker, Workbench","text":"<p>Aquest any farem servir MySQL com a SGBD, per la seva \u00e0mplia utilitzaci\u00f3 en diversos contextos i per la seva simplicitat. Per utilitzar-lo, has d'instal\u00b7lar <code>mysql-server</code> com a servei al teu sistema, com has estudiat els \u00faltims anys.</p> <p>El servidor MySQL es pot instal\u00b7lar al teu ordinador, o b\u00e9 pots instal\u00b7lar-lo en una m\u00e0quina virtual o configurar-lo com a contenidor Docker. Per tenir un sistema m\u00e9s net, l'opci\u00f3 recomanada \u00e9s amb contenidor Docker, ja que podr\u00e0s executar diverses versions de MySQL sense interfer\u00e8ncies entre elles.</p> <p>Note</p> <p>Teniu una documentaci\u00f3 addicional sobre com crear un contenidor MySQL en un document anomenat Docker per a MySQL. Aix\u00ed doncs, i pel que fa a la resta del document, assumirem que ja teniu la imatge de Docker de MySQL i un contenidor en execuci\u00f3 al port <code>3308</code> (MySQL utilitza el port 3306 per defecte, per\u00f2 en el nostre contenidor exposarem el servei al port 3308, en cas que ja tingueu un servidor MySQL local en execuci\u00f3 al port 3306).</p> Bash<pre><code># Remember that to create the container (only fisrt time)\n\ndocker run --name mysql-srv\n      -p 3308:3306\n      -e MYSQL_ROOT_PASSWORD=\"root\"\n      -d mysql:latest\n\n# It will create and start the container\n\n# To stop the container\ndocker stop mysql-srv\n\n# And to start the container ( AVOID TO run IT AGAIN !!!)\ndocker start mysql-srv\n</code></pre> <p>I finalment, per\u00f2 no menys important, evidentment, podeu utilitzar una eina gr\u00e0fica per accedir a MySQL, com ara <code>mysql-workbench</code> o <code>dbeaver</code>. Heu de configurar una connexi\u00f3 al port de Docker:</p> <p></p> <p>Espai</p> <p>Revisa les notes del teu m\u00f2dul de bases de dades sobre com treballar amb Workbench:</p> Text Only<pre><code>- Carrega i executa scripts SQL\n- Recupera l'estructura de la base de dades\n- Edita i crea SQL\n- Edita i guarda dades\n</code></pre> <p>Disposes del scrip Esquema BD Jocs per carregar els exemples dels apunts</p>"},{"location":"UD2_Connectors/3_Connecting/","title":"1. Connectant a bases de dades","text":""},{"location":"UD2_Connectors/3_Connecting/#11-controlador-jdbc-de-mysql","title":"1.1. Controlador JDBC de MySQL","text":"<p>Per tal de crear programes Java utilitzant el controlador de MySQL, necessitem carregar-lo en el nostre programa i pr\u00e8viament en el nostre entorn de desenvolupament. Com utilitzarem <code>Gradle</code>, anem a veure com fer-ho:</p> <ol> <li>Hem de trobar la versi\u00f3 del controlador del nostre servidor JDBC, i ho podem trobar al repositori central de Maven https://mvnrepository.com.</li> <li>Cerquem <code>mysql jdbc</code>, i obtindrem com a primer resultat MySQL Connector/J.</li> <li>Assegureu-vos de seleccionar la versi\u00f3 correcta, i despr\u00e9s seleccioneu el gestor de paquets (gradle, maven, etc.) i obtindreu:</li> </ol> Bash<pre><code>// https://mvnrepository.com/artifact/mysql/mysql-connector-java\nimplementation group: 'mysql', name: 'mysql-connector-java', version: '8.0.30'\n</code></pre> <ol> <li>Quan deseu o compileu el vostre projecte, podreu importar els controladors correctament.</li> </ol> <p></p>"},{"location":"UD2_Connectors/3_Connecting/#12-url-de-connexio","title":"1.2. URL de connexi\u00f3","text":"<p>Un cop hagueu importat el controlador, heu de dir al vostre programa Java com connectar-vos a la vostra base de dades i finalment connectar-vos-hi. Per a aquesta tasca, hem de crear una <code>Connection</code> utilitzant una URL especial anomenada URL de connexi\u00f3. Com altres URL, una URL de connexi\u00f3 pot contenir:</p> <ul> <li>Protocol \\(\\rightarrow\\) utilitzarem <code>jdbc</code>.</li> <li>SGBD \\(\\rightarrow\\) podr\u00edem utilitzar <code>mysql</code>, <code>postgres</code>, <code>sqlite</code>, <code>sqlserver</code> o qualsevol SGBD amb un connector JDBC.</li> <li>Adre\u00e7a del servidor \\(\\rightarrow\\) podem utilitzar tant un nom complet com l'adre\u00e7a IP del servidor.</li> <li>[opcional]Port \\(\\rightarrow\\) el port on el servidor est\u00e0 escoltant. Si no s'utilitza cap, el controlador intentar\u00e0 connectar-se al port per defecte. Recordeu separar el port de l'adre\u00e7a amb <code>:</code>.</li> <li>Altres par\u00e0metres, separant-los amb <code>?</code> al principi i amb <code>&amp;</code> entre els par\u00e0metres. Per exemple:<ul> <li>user=<code>usuari</code></li> <li>pass=<code>contrasenya</code></li> <li>useUnicode=<code>true</code></li> <li>characterEncoding=<code>UTF-8</code></li> </ul> </li> </ul> <p>Una mostra de URL de connexi\u00f3 pot ser:</p> Java<pre><code>String connectionUrl = \"jdbc:mysql://localhost:3308/Cycling?useUnicode=true&amp;characterEncoding=UTF-8&amp;user=root&amp;password=root\";\n</code></pre> <p>Una opci\u00f3 millor seria:</p> Java<pre><code>String server=\"localhost\";\nint port=3308;\nString user=\"root\";\nString pass=\"root\";\nString DBName=\"Cycling\";\nString connectionUrl = \"jdbc:mysql://\"+server+\":\"+port;\nconnectionUrl+=\"/\" + DBName;\nconnectionUrl+=\"?useUnicode=true&amp;characterEncoding=UTF-8\";\nconnectionUrl+=\"&amp;user=\"+user;\nconnectionUrl+=\"&amp;password=\"+pass;\n</code></pre> <p>Atenci\u00f3</p> <p>Tingueu en compte que tots dos exemples s\u00f3n codi hard-coded, ja que teniu els valors del servidor (usuari i contrasenya) escrits dins de cadenes de text. \u00c9s millor opci\u00f3 emmagatzemar aquests valors dins de variables o fitxers de propietats.</p>"},{"location":"UD2_Connectors/3_Connecting/#13-classe-connection","title":"1.3. Classe <code>Connection</code>","text":"<p>En Java, la classe necess\u00e0ria per gestionar el controlador \u00e9s <code>java.sql.DriverManager</code>. Intenta carregar els controladors del sistema quan llegeix la propietat dels controladors JDBC, per\u00f2 podem indicar que es carregui utilitzant la instrucci\u00f3:</p> Java<pre><code>Class.forName(\"com.mysql.cj.jdbc.Driver\");\n</code></pre> <p>La classe que centralitzar\u00e0 totes les operacions amb la base de dades \u00e9s <code>java.sql.Connection</code>, i l'hem d'obtenir des del <code>DriverManager</code> amb qualsevol dels 3 m\u00e8todes est\u00e0tics que t\u00e9:</p> <ul> <li><code>static Connection getConnection(String url)</code> \\(\\rightarrow\\) Retorna una connexi\u00f3, si \u00e9s possible, a la base de dades amb els par\u00e0metres especificats a la URL de connexi\u00f3. Recordeu de crear una URL de connexi\u00f3 a partir de la part anterior.</li> <li><code>static Connection getConnection(String url, Properties info)</code> \\(\\rightarrow\\) Retorna una connexi\u00f3, si \u00e9s possible, a la base de dades, amb alguns par\u00e0metres especificats a la URL i altres en un objecte de propietats (<code>Properties</code> classe estudiada a la unitat 1). Veurem exemples m\u00e9s endavant.</li> <li><code>static Connection getConnection(String url, String user, String pass)</code> \\(\\rightarrow\\) Retorna una connexi\u00f3, si \u00e9s possible, a la base de dades amb els par\u00e0metres especificats a la URL. Les dades d'usuari i contrasenya es proporcionen en dos par\u00e0metres addicionals, de manera que no cal escriure'ls a la URL de connexi\u00f3.</li> </ul> <p>Una mostra inicial ser\u00e0:</p> Java<pre><code>public static void main (String [] args ) \n  throws ClassNotFoundException, SQLException{\n\n    Class.forName(\"com.mysql.cj.jdbc.Driver\");\n    String server=\"localhost\";\n    int port=3308;\n    String user=\"root\";\n    String pass=\"root\";\n    String DBName=\"Cycling\";\n    String connectionUrl = \"jdbc:mysql://\"+server+\":\"+port;\n    connectionUrl+=\"/\" + DBName;\n    connectionUrl+=\"?useUnicode=true&amp;characterEncoding=UTF-8\";\n\n   Connection conn = DriverManager.getConnection(connectionUrl,user,pass);\n\n   // if no exception is catched, you are connected to your DBMS\n</code></pre> <p>Amb l'objecte <code>Connection</code> que tenim ara connectat, enviarem les nostres consultes i demanarem informaci\u00f3, com veurem m\u00e9s endavant.</p>"},{"location":"UD2_Connectors/3_Connecting/#14-organitzant-la-nostra-connexio","title":"1.4. Organitzant la nostra connexi\u00f3","text":"<p>La nostra aplicaci\u00f3 s'ha de connectar a una (o m\u00e9s) bases de dades. Podem fer moltes peticions a aquestes base de dades, i si estem implementant una aplicaci\u00f3 multithreaded, el nombre de peticions pot augmentar molt. Per aix\u00f2, hem de controlar on i quan es creen i es tanquen les connexions. Una bona idea \u00e9s crear una classe que encapsuli tots aquests processos. L'esquelet d'aquesta classe seria el seg\u00fcent:</p> Java<pre><code>public class ConnexioBD {\n\n    private Connection laConnexio = null;\n\n    // write here access variables, like user, server or whatever\n\n    private void connect() {\n        // do the connetion (look the sample). \n        // Take care. private method. It will be called inside the class\n    }\n\n    // close connection, if it's opened\n    public void disConnect() {\n        if (laConnexio != null) {\n            laConnexio.close();\n        }\n    }\n\n    // returns the connection. \n    // It will be create first time of after closed\n    public Connection getConexio(){\n        if (laConnexio == null) {\n            this.connect();\n        }\n        return this.laConnexio;\n    } \n}\n</code></pre>"},{"location":"UD2_Connectors/3_Connecting/#141-exercici-resolt","title":"1.4.1. Exercici resolt","text":"<p>Crea un projecte \u00fanic amb dues classes. Una per connectar-te a la teva base de dades, com l'\u00faltim exemple, i una classe principal que es connecti i mostri si hi ha hagut algun error.</p> <p>La soluci\u00f3 de l'exercici est\u00e0 enlla\u00e7ada aqu\u00ed connexio.properties i ConnexioDB.java</p>"},{"location":"UD2_Connectors/4_Resultset/","title":"1. Classe <code>ResultSet</code>.","text":"<p>Ara que estem connectats a la base de dades, \u00e9s hora de comen\u00e7ar a demanar informaci\u00f3 al DBMS. Aquesta informaci\u00f3 es proporcionar\u00e0 en forma de consultes (SQL) o altres m\u00e8todes, per\u00f2 gaireb\u00e9 el 90% de les vegades, com en el cas de les consultes SQL, la informaci\u00f3 retornada es troba en un format tabular. Els formats tabulars s\u00f3n ben coneguts perqu\u00e8 programes com MySQL Workbench o DBeaver mostren les dades d'aquesta manera.</p> <p>En Java, la classe que permet treballar amb dades en format tabular provinents de bases de dades es diu <code>Resultset</code>. Un <code>Resultset</code> est\u00e0 compost per una taula (files i columnes) i un punter a una fila, anomenat cursor.</p> <p></p> <ol> <li>Quan recuperem dades de les bases de dades, la informaci\u00f3 es guarda a la taula i el cursor apunta a una fila imagin\u00e0ria buida anomenada <code>beforeFirst</code>.</li> <li><code>Resultset</code> cont\u00e9 un m\u00e8tode especial anomenat <code>next()</code>, que fa dues accions:</li> <li>Retorna <code>true</code> si hi ha una fila de dades despr\u00e9s de la fila actual apuntada pel cursor i <code>false</code> en cas contrari.</li> <li>Avan\u00e7a el cursor i apunta a la seg\u00fcent fila, sols si hi havia una.</li> <li>Quan el cursor d'un <code>Resultset</code> retorna <code>false</code>, significa que s'han visitat totes les files i ara el cursor apunta a una altra fila imagin\u00e0ria anomenada <code>afterLast</code>.</li> </ol> <p>Quan el cursor apunta a una fila real, \u00e9s quan podem recuperar les dades de les columnes de la fila actual. Podem utilitzar un m\u00e8tode especial i sobrecarregat, de la seg\u00fcent manera:</p> <ul> <li><code>getXXX(int posici\u00f3Columna)</code> \\(\\rightarrow\\) retorna les dades, on <code>XXX</code> \u00e9s un tipus de dades (Int, Float, Double, String, etc.) de la posici\u00f3 de la columna, comen\u00e7ant per 1.</li> <li><code>getXXX(String nomColumna)</code> \\(\\rightarrow\\) retorna les dades, on <code>XXX</code> \u00e9s un tipus de dades (Int, Float, Double, String, etc.) de la columna amb el nom proporcionat.</li> </ul> <p>Perill</p> <p>Tingueu en compte:</p> <ul> <li>Les columnes comencen en 1 en lloc de 0, a difer\u00e8ncia dels arrays.</li> <li>Si no coneixeu el tipus de dades d'una columna, podeu utilitzar <code>getObject</code> i aquest retornar\u00e0 un <code>Object</code> gen\u00e8ric.</li> <li>Aquests m\u00e8todes poden generar una <code>SQLException</code> si el rang o el nom de la columna est\u00e0 fora de rang o no existeix.</li> </ul>"},{"location":"UD2_Connectors/4_Resultset/#11-resulsetmetadata","title":"1.1. ResulSetMetaData","text":"<p>Els ResultSets d'una consulta tamb\u00e9 tenen un conjunt de metadades. Aquestes metadades es poden obtenir utilitzant <code>ResultSetMetaData</code>. Els m\u00e8todes m\u00e9s rellevants d'aquesta classe s\u00f3n:</p> <ul> <li><code>int getColumnCount()</code> \\(\\rightarrow\\) Obt\u00e9 el nombre de columnes al ResultSet.</li> <li><code>String getColumnName(index)</code> \\(\\rightarrow\\) Obt\u00e9 el nom de la columna indicada en l'\u00edndex (recorda que el primer \u00e9s 1).</li> <li><code>String getColumnTypeName(index)</code> \\(\\rightarrow\\) Obt\u00e9 el tipus de la columna.</li> </ul> <p>ResulSetMetaData s'obt\u00e9 de cada ResultSet generat pr\u00e8viament, amb el m\u00e8tode <code>getMetaData()</code>.</p>"},{"location":"UD2_Connectors/4_Resultset/#12-algorisme-resultset","title":"1.2. Algorisme ResultSet","text":"<p>Independentment del contingut de dades del teu ResultSet, la manera en qu\u00e8 hem de treballar \u00e9s la seg\u00fcent:</p> Java<pre><code>// Connect to DB\nConnection conn = ...;\n\n// recover data\nResultSet rst= conn...\n\n// while data available exists\nwhile (rst.next()){\n    //process the current row\n}\n</code></pre> <p>Sigues conscient de que:</p> <ul> <li>Dins del bucle while no cal cridar <code>next()</code> de nou. Es salta una fila en cas contrari.</li> <li>Quan s'han processat les darreres files, <code>next()</code> retorna <code>false</code> i el bucle finalitza.</li> </ul>"},{"location":"UD2_Connectors/4_Resultset/#13-exemple","title":"1.3. Exemple","text":"<p>En aquest bloc de codi, anem a veure un exemple breu per executar una consulta (<code>Select * from table</code>). Veurem altres consultes en les seccions seg\u00fcents.</p> Java<pre><code>//with a previous connection\nString taula=\"Jocs\";\nResultSet rst = con.createStatement().executeQuery(\"SELECT * FROM \" +taula);\nSystem.out.println(Colors.Cyan);\nSystem.out.println(\"\");\nSystem.out.println(\"Contingut de \" + taula);\nSystem.out.println(\"******************************\");\n\nResultSetMetaData rsmdQuery = rst.getMetaData();\n\n// print the columns name\nfor (int i = 1; i &lt;= rsmdQuery.getColumnCount(); i++)\n  System.out.print(String.format(\"%-25.25s\",rsmdQuery.getColumnName(i)));\n\nSystem.out.println();\nSystem.out.println(Colors.Reset);\n\n// print the values\nwhile (rs.next()) {\n  for (int i = 1; i &lt;= rsmdQuery.getColumnCount(); i++)\n  System.out.print(String.format(\"%-25.25s \",rst.getString(i)));\n  System.out.println();\n}\n</code></pre>"},{"location":"UD2_Connectors/5_Metadata/","title":"1. Metadata de la base de dades","text":"<p>Abans de recuperar dades, estudiarem com obtenir informaci\u00f3 sobre la base de dades a la qual estem connectats. Les metadades d'una base de dades descriuen l'estructura que t\u00e9: les taules que componen la base de dades, els camps que formen aquestes taules, els tipus d'aquests camps, etc. Tot i que normalment coneixem aquesta estructura pr\u00e8viament, \u00e9s possible que en necessitem informaci\u00f3 en alguna ocasi\u00f3, per aix\u00f2 tenim les interf\u00edcies <code>DatabaseMetaData</code> i <code>ResultSetMetaData</code>.</p> <p>La interf\u00edcie <code>DatabaseMetaData</code> ens proporciona informaci\u00f3 sobre les taules i vistes de la base de dades, aix\u00ed com la seva estructura. A continuaci\u00f3 tenim alguns dels m\u00e8todes m\u00e9s rellevants d'aquesta interf\u00edcie.</p> <ul> <li><code>String getDatabaseProductName()</code> \\(\\rightarrow\\) Obt\u00e9 el nom del SGBD.</li> <li><code>String getDriverName()</code> \\(\\rightarrow\\) Obt\u00e9 el nom del controlador JDBC que s'est\u00e0 utilitzant.</li> <li><code>String getURL()</code> \\(\\rightarrow\\) Obt\u00e9 l'URL de la connexi\u00f3.</li> <li><code>String getUserName()</code> \\(\\rightarrow\\) Obt\u00e9 el nom de l'usuari connectat a la base de dades.</li> <li><code>ResultSet getTables(String catalog, String schema, String patternTableName, String[] type)</code> \\(\\rightarrow\\) Obt\u00e9 informaci\u00f3 de les taules disponibles en el cat\u00e0leg indicat.</li> <li><code>ResultSet getColumns(String catalog, String schema, String patternNameTable, String patternColumnName)</code> \\(\\rightarrow\\) Obt\u00e9 informaci\u00f3 dels camps de la taula especificada en el cat\u00e0leg i esquema indicats.</li> <li><code>ResultSet getPrimaryKeys(String catalog, String schema, String patternNameTable)</code> \\(\\rightarrow\\) Obt\u00e9 la llista de camps que formen la clau prim\u00e0ria.</li> <li><code>ResultSet getImportedKeys(String catalog, String schema, String patternNameTable)</code> \\(\\rightarrow\\) Obt\u00e9 una llista amb les claus externes definides a la taula.</li> <li><code>ResultSet getExportedKeys(String catalog, String schema, String patternNameTable)</code> \\(\\rightarrow\\) Obt\u00e9 una llista amb les claus externes que apunten a aquesta taula.</li> </ul> <p>Informaci\u00f3</p> <p>En aquest punt, cal assenyalar que els termes cat\u00e0leg i esquema tendeixen a confondre's. Segons els est\u00e0ndards, un cat\u00e0leg cont\u00e9 diversos esquemes, amb informaci\u00f3 detallada del sistema, des de la forma d'emmagatzematge intern fins als esquemes conceptuals. En un cat\u00e0leg, sembla que hi ha un esquema anomenat INFORMATION_SCHEMA, amb les vistes i dominis de l'esquema d'informaci\u00f3 del sistema.</p> <p>En tot cas, la majoria dels SGBD coincideixen el cat\u00e0leg amb el nom de la base de dades. A m\u00e9s, en aquesta consulta especifiquem el nom de la base de dades com a cat\u00e0leg, mentre que si obrim MySQLWorkbench, la base de dades es representa com un esquema. Podeu trobar m\u00e9s informaci\u00f3 sobre aix\u00f2 en aquests enlla\u00e7os:</p> <ul> <li>https://stackoverflow.com/questions/7022755/whats-the-difference-between-a-catalog-and-a-schema-in-a-relational-database</li> <li>https://www.quora.com/What-is-the-difference-between-system-catalog-and-database-schemain-a-Database</li> </ul>"},{"location":"UD2_Connectors/5_Metadata/#11-exercisi-resolt","title":"1.1. Exercisi resolt","text":"<p>Anem a crear un programa Java que mostri informaci\u00f3 interna d'una base de dades <code>BDJocs</code>, mitjan\u00e7ant <code>DataBaseMetaData</code>. Veurem el programa pas a pas.</p> <p>Info</p> <p>Podeu veure tota la informaci\u00f3 del m\u00e8tode i com les dades s'emmagatzemen en cada ResultSet del m\u00e8tode en aquest enlla\u00e7.</p>"},{"location":"UD2_Connectors/5_Metadata/#111-crear-la-connection","title":"1.1.1. Crear la connection","text":"<p>Recorda com connectar-te a un SGBD de manera senzilla:</p> Java<pre><code>// load JDBC driver\n2 Class.forName(\"com.mysql.cj.jdbc.Driver\");\n3 // Connecto to DBMS and DB BDJosc, with user and pass\n4 Connection con = DriverManager.getConnection(\"jdbc:mysql://localhost:3308/BDJocs\", \"root\", \"root\");\n</code></pre> <p>Molt senzill, carrega el controlador i connecta't a la base de dades de la manera que hem estudiat.</p>"},{"location":"UD2_Connectors/5_Metadata/#112-recupera-les-metadades-del-sgbd-i-mostra-les-en-un-format-amigable","title":"1.1.2. Recupera les metadades del SGBD i mostra-les en un format amigable","text":"<p>Utilitzarem la classe <code>Color</code> per mostrar les dades en format de text en la consola. Teniu aquesta classe a l'APAC1, dins del projecte.</p> Java<pre><code>// get the metadata\nDatabaseMetaData dbmd = con.getMetaData();\n\nSystem.out.println(Colors.Blue+\"\\nDBMS information--------\"+Colors.Reset);\nSystem.out.println(Colors.Bright_White+\"SGBD:\\t\"+Colors.Reset + dbmd.getDatabaseProductName());\nSystem.out.println(Colors.Bright_White+\"SGBD:\\t\"+Colors.Reset + dbmd.getDriverName());\nSystem.out.println(Colors.Bright_White+\"SGBD:\\t\"+Colors.Reset + dbmd.getURL());\nSystem.out.println(Colors.Bright_White+\"SGBD:\\t\"+Colors.Reset + dbmd.getUserName());\n</code></pre> <p>Com podeu veure, obtenim el nom del SGBD, el controlador, l'URL i l'usuari que estem utilitzant. \u00d2bviament, \u00e9s el mateix que vam posar quan vam crear l'objecte <code>Connection</code>, per\u00f2 \u00e9s un bon exemple per mostrar informaci\u00f3.</p>"},{"location":"UD2_Connectors/5_Metadata/#113-recuperar-taules-en-un-esquemabase-de-dades","title":"1.1.3. Recuperar taules en un esquema/base de dades","text":"<p>Utilitzant el m\u00e8tode <code>getTables()</code> podem recuperar les taules i m\u00e9s informaci\u00f3. Suposem que <code>BDJocs</code> existeix al nostre SGBD:</p> Java<pre><code>System.out.println(Colors.Bright_White+String.format(\"%-15s %-15s %-15s\",\"Database\",\"Table\",\"Type\"));\nSystem.out.println(\"-------------------------------------------------------\"+Colors.Reset);\nResultSet rsmd = dbmd.getTables(\"BDJocs\", null, null, null);\nwhile (rsmd.next()) {\n  System.out.println(String.format(\"%-15s %-15s %-15s\",rsmd.getString(1),rsmd.getString(3),rsmd.getString(4)));\n}\n</code></pre> <p>Comentaris:</p> <p>Repassa <code>String.format()</code> per establir una longitud espec\u00edfica de cada columna.</p> <p>Segons la documentaci\u00f3 de javadoc, obtenim que el ResultSet retornat per <code>getTables</code> t\u00e9 les seg\u00fcents columnes:</p> <ol> <li>TABLE_CAT String \u2192 cat\u00e0leg de la taula (pot ser nul)</li> <li>TABLE_SCHEM String \u2192 esquema de la taula (pot ser nul)</li> <li>TABLE_NAME String \u2192 nom de la taula</li> <li>TABLE_TYPE String \u2192 tipus de taula. Els tipus t\u00edpics s\u00f3n \"TABLE\", \"VIEW\", \"SYSTEM TABLE\", \"GLOBAL TEMPORARY\", \"LOCAL TEMPORARY\", \"ALIAS\", \"SYNONYM\".</li> <li>REMARKS String \u2192 comentari explicatiu sobre la taula</li> <li>TYPE_CAT String \u2192 cat\u00e0leg dels tipus (pot ser nul)</li> <li>TYPE_SCHEM String \u2192 esquema dels tipus (pot ser nul)</li> <li>TYPE_NAME String \u2192 nom del tipus (pot ser nul)</li> <li>SELF_REFERENCING_COL_NAME String \u2192 nom de la columna \"identificador\" designada d'una taula indicada (pot ser nul)</li> <li>REF_GENERATION String \u2192 especifica com es creen els valors a SELF_REFERENCING_COL_NAME. Els valors poden ser \"SYSTEM\", \"USER\", \"DERIVED\". (pot ser nul)</li> </ol> <p>Obtenim les columnes 1, 3 i 4.</p>"},{"location":"UD2_Connectors/5_Metadata/#114-obtenir-les-columnes-de-la-taula","title":"1.1.4. Obtenir les columnes de la taula","text":"<p>\u00c9s el moment d'obtenir les columnes d'una taula, utilitzant el m\u00e8tode <code>getColumns()</code>:</p> Java<pre><code>String table=...; // we set the name of an existing table\nResultSet columnes = dbmd.getColumns(\"BDJocs\",null , taula, null);\nSystem.out.println(Colors.Bright_White+String.format(\"%-25s %-15 s%-15s\",\"Atribut/Claus\",\"Tipus\",\"Pot ser nul?\"+Colors.reset));\n\nwhile (columnes.next()){\n    String columnName=columnes.getString(4);\n    String tipus=columnes.getString(6);\n    String nullable=columnes.getString(18);\n\n    System.out.println(String.format(\"%-25s %-15s %15s\",columnName,tipus,nullable));\n}\n</code></pre> <p>Comentaris:</p> <ul> <li><code>getColumns()</code> retorna un ResultSet amb 24 columnes, amb molta informaci\u00f3 de la taula. Nom\u00e9s obtenim les columnes 4, 6 i 18 amb el nom, el tipus i si pot ser nul. Podeu consultar la documentaci\u00f3 de javadoc per obtenir m\u00e9s informaci\u00f3.</li> <li>De la mateixa manera, per obtenir informaci\u00f3 sobre les claus, podem utilitzar:<ul> <li><code>getPrimaryKeys()</code> retorna un ResultSet amb les claus prim\u00e0ries de les taules.</li> <li><code>getExportedKeys()</code> retorna un ResultSet amb les columnes que apunten a la clau prim\u00e0ria de la taula actual. Aix\u00f2 significa tots els camps d'altres taules que apunten a la clau prim\u00e0ria de la taula actual.</li> <li><code>getImportedKeys()</code> retorna un ResultSet amb les columnes que s\u00f3n claus prim\u00e0ries importades a la taula actual. Aix\u00f2 significa les columnes que s\u00f3n claus externes (i apunten a una clau prim\u00e0ria d'altres taules).</li> </ul> </li> </ul> <p>Teniu tot l'exemple a la carpeta <code>DatabaseMeta</code> de l'aplicaci\u00f3 d'exemple i al seg\u00fcent enlla\u00e7.</p>"},{"location":"UD2_Connectors/6_CRUD/","title":"1. Statements and CRUD operations","text":"<p>En aquesta secci\u00f3 estudiarem l'objectiu principal de treballar amb bases de dades: manipular dades. Sempre treballarem amb la mateixa plantilla:</p> <ol> <li>Connectar a la base de dades.</li> <li>Preparar la consulta.</li> <li>Executar la consulta.</li> <li>Processament de les dades, si \u00e9s necessari.</li> </ol> <p>El punt 1 s'ha estudiat a les seccions anteriors.</p> <p>Per crear les consultes, haurem d'utilitzar les seg\u00fcents classes/interfaces:</p> <ul> <li><code>Statement</code> \\(\\rightarrow\\) Es fa servir de manera general i \u00e9s \u00fatil quan volem realitzar sent\u00e8ncies SQL est\u00e0tiques, ja que no accepta par\u00e0metres. Creem un <code>Statement</code> amb el m\u00e8tode <code>createStatement()</code> de la classe <code>Connection</code>.</li> <li><code>PreparedStatement</code> \\(\\rightarrow\\) Es fa servir quan volem llan\u00e7ar diverses consultes i, a m\u00e9s, es permet realitzar sent\u00e8ncies din\u00e0miques. Creem un <code>PreparedStatement</code> amb el m\u00e8tode <code>prepareStatement()</code> de la classe <code>Connection</code>.</li> <li><code>CallableStatement</code> \\(\\rightarrow\\) Es fa servir per accedir a procediments emmagatzemats a la base de dades i tamb\u00e9 accepta par\u00e0metres d'entrada. Creem un <code>CallableStatement</code> amb el m\u00e8tode <code>prepareCall()</code> de la classe <code>Connection</code>.</li> </ul> <p>Quan la sent\u00e8ncia est\u00e0 preparada, la podem executar amb:</p> <ul> <li><code>executeQuery</code> \\(\\rightarrow\\) Executa sent\u00e8ncies que esperem que retornin dades (consultes SELECT). El valor de retorn d'aquesta execuci\u00f3 \u00e9s, com ja suposareu, un ResultSet.</li> <li><code>executeUpdate</code> \\(\\rightarrow\\) Executa sent\u00e8ncies que no s'espera que retornin dades, per\u00f2 que s'utilitzaran per modificar la base de dades connectada (consultes INSERT, DELETE, UPDATE i CREATE TABLE).</li> </ul>"},{"location":"UD2_Connectors/6_CRUD/#11-create-insert","title":"1.1. Create (Insert)","text":"<p>Anem a veure un exemple senzill de declaraci\u00f3 <code>INSERT</code>.</p> Java<pre><code>ConnexioDB conDB=new ConnexioDB(\"BDJocs\");\nConnection con=conDB.getConnexio();\n\nString SQL=\"INSERT INTO Joc VALUES (1, 'Double Dragon', 'Dos germans bessons experts en arts marcials s`han de fer cam\u00ed en un escenari urb\u00e0 on  membres de bandes rivals volen deixar-los fora de combat.', 1);\";\n\nStatement st=con.createStatement();\n\nint affectedRows=st.executeUpdate(SQL);\n\nSystem.out.println(affectedRows+ \"row has been inserted\");\n</code></pre> <p>Com podeu veure, \u00e9s molt f\u00e0cil d'entendre el codi. Creem una declaraci\u00f3 buida i despr\u00e9s executem l'SQL \"per se\". L'execuci\u00f3 retorna el nombre de files inserides. Veurem millors maneres d'inserir dades, utilitzant scripts.</p> <p>Info</p> <p>Aquest codi \u00e9s una versi\u00f3 redu\u00efda, ja que quan treballem amb bases de dades poden apar\u00e8ixer <code>SQLException</code>. Suposem que el proc\u00e9s de connexi\u00f3 ja s'ha realitzat.</p>"},{"location":"UD2_Connectors/6_CRUD/#12-read-select","title":"1.2. Read (Select)","text":"<p>La lectura \u00e9s el proc\u00e9s m\u00e9s important que farem, ja que nom\u00e9s amb el proc\u00e9s d'inici de sessi\u00f3 dins d'una aplicaci\u00f3 estem recuperant informaci\u00f3 d'una base de dades. En tots els casos, hem d'escriure la sent\u00e8ncia (SQL), executar-la i finalment processar les dades retornades. Depenent de com preparem la sent\u00e8ncia, podem distingir entre:</p> <ol> <li>Sent\u00e8ncies fixes</li> <li>Sent\u00e8ncies variables</li> <li>Sent\u00e8ncies preparades</li> </ol> <p>Veurem amb detall ambdues maneres. Utilitzarem per aix\u00f2 l'script <code>Instituto.sql</code> i la base de dades.</p>"},{"location":"UD2_Connectors/6_CRUD/#121-sentencies-fixes","title":"1.2.1. Sent\u00e8ncies fixes","text":"<p>Aquestes sent\u00e8ncies, com el seu nom indica, s\u00f3n sent\u00e8ncies fixes o constants. L'SQL \u00e9s fixa i no t\u00e9 cap variable.</p> Java<pre><code>// The query\nString SQL=\"Select * from Persona\";\n// The statement\nStatement st=con.createStatement();\n// The execution\nResultSet rst=st.executeQuery(SQL);\n\n// processing\nwhile(rst.next()){\n    System.out.print(ConsoleColors.BLUE_BRIGHT+ \"Person: \"+ ConsoleColors.RESET);\n    /*\n    System.out.println(\n            rst.getString(3)+ \", \"+\n            rst.getString(2)+ \" \"+\n            rst.getInt(4));\n    */\n    System.out.println(\n            rst.getString(\"apellidos\")+ \", \"+\n            rst.getString(\"nombre\")+ \" \"+\n            rst.getInt(\"edad\"));\n}\n\nrst.close();\n</code></pre> <p>En el processament de la informaci\u00f3, ResultSet t\u00e9:</p> <ul> <li><code>type getType(int columnIndex)</code> \\(\\rightarrow\\) m\u00e8tode sobrecarregat que retorna el tipus de dades donat, utilitzant l'\u00edndex de columna del ResultSet. Recorda que la primera columna \u00e9s 1 en comptes de 0. El tipus pot ser Int, String, Double, etc. si coneixes el tipus. Per a columnes desconegudes, pots utilitzar <code>Object</code> com a tipus gen\u00e8ric.</li> <li><code>type getType(String columnName)</code> $\\rightarrow` mateix que el m\u00e8tode anterior, per\u00f2 accedint a la columna amb el nom que hem seleccionat a la consulta o el nom a la taula.</li> </ul>"},{"location":"UD2_Connectors/6_CRUD/#122-sentencies-variables","title":"1.2.2. Sent\u00e8ncies variables","text":"<p>Imagina que vols recuperar noms que continguen la cadena <code>Ma</code> dins seu.</p> SQL<pre><code>String SQL=\"Select * from Persona where nombre like '%Ma%'\";\n</code></pre> <p>En aquest cas, aquesta consulta est\u00e0 codificada directament, i si vols canviar la part del text, has de modificar el teu codi. Per evitar la codificaci\u00f3 directa, podem escriure:</p> Java<pre><code>ConnexioDB conDB=new ConnexioDB(\"Instituto\");\n\nConnection con=conDB.getConnexio();\n\n// hardcoded String\n// String SQL=\"Select * from Persona where nombre like '%Ma%'\";\n\nString nombre=Utilitats.leerTextoC(\"Give me part of the name: \");\n// The query\nString SQL=\"Select * from Persona where nombre like '%\" + nombre + \"%'\";\n// The statement\nStatement st=con.createStatement();\n// The execution\nResultSet rst=st.executeQuery(SQL);\n\n// processing\nwhile(rst.next()){\n    System.out.print(ConsoleColors.BLUE_BRIGHT+ \"People with \" +nombre+\": \"+ ConsoleColors.RESET);\n    System.out.println(\n            rst.getString(\"apellidos\")+ \", \"+\n            rst.getString(\"nombre\")+ \" \"+\n            rst.getInt(\"edad\"));\n}\n\nrst.close();\n</code></pre> <p>Com podem veure, les dades ara estan en variables, per\u00f2 la construcci\u00f3 de l'SQL \u00e9s m\u00e9s complexa. Cal tenir en compte que els textos han d'estar entre cometes i els n\u00fameros no, el que facilita cometre errors. Per\u00f2 pot ser pitjor, aquest tipus de codi pot inc\u00f3rrer en problemes d'injecci\u00f3 SQL, com veiem a l'exemple seg\u00fcent:</p> Java<pre><code>String idPersona=Read.readText(\"Tell me the id to consult: \");\nString SQL = \"Select * from Person where idPersona=\"+idPersona;\n</code></pre> <ul> <li>Si l'usuari introdueix <code>4</code> \\(\\rightarrow\\) Es mostrar\u00e0 la persona amb ID igual a 4</li> <li>Si l'usuari introdueix <code>4 o 1=1</code> \\(\\rightarrow\\) Es mostraran totes les persones</li> </ul> <p>Cal evitar aquest tipus de consultes en les declaracions de validaci\u00f3 d'usuari, per a les quals farem servir les sent\u00e8ncies preparades i, \u00f2bviament, ser molt cautelosos en la verificaci\u00f3 de les entrades.</p>"},{"location":"UD2_Connectors/6_CRUD/#123-sentencies-preparades","title":"1.2.3. Sent\u00e8ncies preparades","text":"<p>Per evitar el problema de l'injecci\u00f3 SQL, sempre que tinguem par\u00e0metres a la nostra consulta, farem servir sent\u00e8ncies preparades. En les sent\u00e8ncies preparades, on hem de fer servir un marcador, en lloc de compondre-la amb concatenacions dins de la cadena, l'indicarem amb un interrogant (<code>?</code>), un car\u00e0cter anomenat placeholder.</p> <p>A continuaci\u00f3, haurem d'assignar valors a aquests placeholders, utilitzant els m\u00e8todes <code>setType(int pos)</code> on <code>Type</code> \u00e9s el tipus de dades que assignarem i <code>pos</code> \u00e9s la posici\u00f3 del placeholder, comen\u00e7ant per <code>1</code>. Veurem l'exemple:</p> Java<pre><code>ConnexioDB conDB=new ConnexioDB(\"Instituto\");\n\nConnection con=conDB.getConnexio();\n\nString ID=Utilitats.leerTextoC(\"Give me an id: \");\n// The query\nString SQL=\"Select * from Persona where idPersona = ?\" ;\n// The statement\nPreparedStatement pst=con.prepareStatement(SQL);\n// fill placeholders\n\npst.setString(1, ID);\n\n// The execution\nResultSet rst=pst.executeQuery();\n\n// processing\nwhile(rst.next()){\n    System.out.print(ConsoleColors.BLUE_BRIGHT+ \"People with \" +ID+\": \"+ ConsoleColors.RESET);\n    System.out.println(\n            rst.getString(\"apellidos\")+ \", \"+\n            rst.getString(\"nombre\")+ \" \"+\n            rst.getInt(\"edad\"));\n}\n\nrst.close();\n</code></pre> <p>Consell</p> Text Only<pre><code>Pots combinar ResultSet amb ResultSetMetaData per obtenir els noms de les columnes i els tipus de dades emmagatzemats a la base de dades. Trobar\u00e0s un exemple a la plataforma.\n</code></pre>"},{"location":"UD2_Connectors/6_CRUD/#13-actualitzacio-update-i-esborrat-delete","title":"1.3. Actualitzaci\u00f3 (Update) i Esborrat (Delete)","text":"<p>L'actualitzaci\u00f3 i l'esborrat d'una fila es consideren com a actualitzacions de la base de dades, ja que modifiquen l'estat de la base de dades. De fet, tamb\u00e9 considerem la inserci\u00f3 com una actualitzaci\u00f3 de la base de dades. Totes dues tasques s'incloent en el m\u00e8tode <code>executeUpdate()</code>. Anem a estudiar-ho a trav\u00e9s d'exemples:</p>"},{"location":"UD2_Connectors/6_CRUD/#131-exemple-desborrat","title":"1.3.1. Exemple d'esborrat","text":"<p>Anem a esborrar files d'una taula de persones entre les edats donades:</p> Java<pre><code>ConnexioDB conDB = new ConnexioDB(\"Instituto\");\nConnection con = conDB.getConnexio();\n\n// give the age's bounds\nint minAge = Utilitats.leerEnteroC(\"Give me minimal age: \");\nint maxAge = Utilitats.leerEnteroC(\"Give me maximun age: \");\n\n// The query\nString SQL = \"Delete from Persona where edad between ? and ?\";\n\n// The statement\nPreparedStatement pst = con.prepareStatement(SQL);\n\n// fill placeholders            \npst.setInt(1, minAge);\npst.setInt(2, maxAge);\n\n// show the query after resolve placeholders\nSystem.out.println(pst);\n\n// The execution\nint deletedtedRows = pst.executeUpdate();\n\n// how many roas affecte\nSystem.out.println(deletedtedRows + \" has been deleted.\");\n</code></pre> <p>Perill</p> <p>Eliminar dades \u00e9s una operaci\u00f3 molt delicada. Tingues cura de:</p> <ul> <li>No oblidis la cl\u00e0usula <code>WHERE</code> quan elimines, ja que eliminar\u00e0s totes les dades de la taula.</li> <li>Si vols eliminar tota la taula, incloent l'estructura (definici\u00f3 + taula), has d'utilitzar <code>DROP TABLE</code> en compte de <code>DELETE</code>.</li> <li>Si intentes eliminar una fila que est\u00e0 referenciada per una clau externa, obtindr\u00e0s l'excepci\u00f3 <code>SQLIntegrityConstraintViolationException</code> i un missatge com No es pot eliminar o actualitzar una fila pare: falla una restricci\u00f3 de clau externa.</li> </ul>"},{"location":"UD2_Connectors/6_CRUD/#132-exemple-dactualitzacio","title":"1.3.2. Exemple d'Actualitzaci\u00f3","text":"<p>Anem a afegir anys a les persones amb l'ID donat:</p> Java<pre><code>ConnexioDB conDB = new ConnexioDB(\"Instituto\");\n\nConnection con = conDB.getConnexio();\n\n// give the age's bounds\nint difAge = Utilitats.leerEnteroC(\"Give me number oy years: \");\nint idMin = Utilitats.leerEnteroC(\"Give me minimum id: \");\n\n// The query\nString SQL = \"Update Persona set edad=edad+ ? where idPersona &gt; ?\";\n\n// The statement\nPreparedStatement pst = con.prepareStatement(SQL);\n\n// fill placeholders            \npst.setInt(1, difAge);\npst.setInt(2, idMin);\n\nSystem.out.println(pst);\n// The execution\nint updatedRows = pst.executeUpdate();\n\nSystem.out.println(updatedRows + \" has been updated.\");\n</code></pre> <p>Warning</p> <p>Recorda que:</p> <ul> <li>La cl\u00e0usula <code>UPDATE</code> no necessita <code>FROM</code> perqu\u00e8 indiquem directament el nom de la taula.</li> <li>Apareix la cl\u00e0usula <code>SET</code>, amb parells <code>camp=valor_actualitzat</code>, per assignar el nou valor als camps seleccionats.</li> <li>Si oblidem la cl\u00e0usula <code>FROM</code>, s'actualitzaran totes les files.</li> </ul>"},{"location":"UD2_Connectors/6_CRUD/#14-scripts","title":"1.4. Scripts","text":"<p>Un script, que normalment s'ha creat en un fitxer extern, \u00e9s un conjunt d'instruccions SQL executades en ordre de dalt a baix. Podem prendre com a estrat\u00e8gia llegir el fitxer l\u00ednia per l\u00ednia i executar-lo una per una, per\u00f2 JDBC permet executar un conjunt d'instruccions en bloc. Per fer aix\u00f2, el primer que hem de fer \u00e9s habilitar m\u00faltiples execucions afegint un par\u00e0metre a la connexi\u00f3, que \u00e9s <code>allowMultiQueries=true</code>.</p> <p>A continuaci\u00f3, hem de carregar el fitxer i compondre una cadena amb tot el script. Per normalitzar-lo i fer-lo totalment port\u00e0til, hem de tenir cura amb els salts de l\u00ednia, ja que depenent del sistema \u00e9s una combinaci\u00f3 <code>\\n</code> o <code>\\r\\n</code>. Podem llegir l\u00ednia per l\u00ednia i guardar-ho en un <code>StringBuilder</code>, afegint <code>System.getProperty(\"line.separator\")</code> com a separadors.</p> <p>Despr\u00e9s nom\u00e9s necessitarem crear una declaraci\u00f3 amb aquesta cadena i executar-la amb <code>executeUpdate()</code>. Ho veurem a continuaci\u00f3:</p> Java<pre><code>ConnexioDB conDB = new ConnexioDB(\"Instituto\");\n\nConnection con = conDB.getConnexio();\n\nFile script = new File(\"sql/EsquemaCine.sql\");\n\nBufferedReader bfr = bfr = new BufferedReader(new FileReader(script));\n\nString line = null;\nStringBuilder sb = new StringBuilder();\n\n// Obtenemos el salto de linea del sistema subyacente\nString breakLine = System.getProperty(\"line.separator\");\n\nwhile ((line = bfr.readLine()) != null) {\n    sb.append(line);\n    sb.append(breakLine);\n}\n\nString query = sb.toString();   // generemos el Script en un String\nStatement stm = con.createStatement();\nint result = stm.executeUpdate(query);\nSystem.out.println(\"Script ejecutado con salida \" + result);\n</code></pre> <p>Consell</p> <p>Recordes les classes <code>Files</code> i <code>Paths</code>? Reescriu l'\u00faltim exemple per obtenir un codi m\u00e9s net.</p>"},{"location":"UD2_Connectors/6_CRUD/#15-transaccions","title":"1.5. Transaccions","text":"<p>Si volem protegir la integritat de les dades, aix\u00ed com evitar situacions de bloqueig inesperades en aplicacions multithread, hem de protegir les nostres operacions, especialment aquelles que modifiquen les dades mitjan\u00e7ant l'\u00fas de transaccions.</p> <p>Una transacci\u00f3 defineix un entorn d'execuci\u00f3 en qu\u00e8 les operacions de desament es mantenen emmagatzemades a la mem\u00f2ria fins que la transacci\u00f3 es completi. Si en un moment determinat alguna cosa falla, l'estat es torna al punt inicial de la mateixa (punt inicial) o a algun punt de marca intermedi. Per defecte, obrir una connexi\u00f3 inicia una transacci\u00f3:</p> <ul> <li>Cada execuci\u00f3 a la connexi\u00f3 genera una transacci\u00f3 per si mateixa.</li> <li>Si volem desactivar aquesta opci\u00f3 perqu\u00e8 la transacci\u00f3 abasti diverses execucions, hem de marcar-ho mitjan\u00e7ant <code>Connection.setAutoCommit(false);</code>.</li> <li>Per acceptar definitivament la transacci\u00f3 ho farem mitjan\u00e7ant <code>Connection.commit();</code></li> <li>Per cancel\u00b7lar la transacci\u00f3 <code>Connection.rollback();</code></li> </ul>"},{"location":"UD2_Connectors/6_CRUD/#16-resultsets-actualitzables","title":"1.6. ResultSets actualitzables","text":"<p>Els m\u00e8todes de treball revisats a les seccions anteriors, especialment quan s'actualitzen o esborren files, funcionen directament a la base de dades. Aix\u00f2 significa que esborreu o actualitzeu una fila sense carregar-la pr\u00e8viament a la mem\u00f2ria. Qu\u00e8 passa si voleu mostrar les dades a l'usuari i despr\u00e9s l'usuari decideix esborrar o actualitzar la fila? En aquest cas, \u00e9s millor utilitzar ResultSets actualitzables.</p> <p>Hem estudiat ResultSet com una col\u00b7lecci\u00f3 de files i l'hem utilitzat nom\u00e9s per a la lectura. Tamb\u00e9 podem utilitzar-lo per editar i esborrar dades. Per fer-ho, hem de obrir el ResultSet d'una manera diferent de la que hem vist fins ara. I, per \u00faltim, per\u00f2 no menys important, dependr\u00e0 de la base de dades la disponibilitat de crear aquest tipus de ResultSets.</p> <p>Per aconseguir-ho, no dep\u00e8n del ResultSet ni de com es va crear l'Statement. Hem d'utilitzar aquest constructor:</p> Java<pre><code>public abstract Statement createStatement(\n    int arg0,   // resultSetType           \n    int arg1,   // resultSetConcurrency\n    int arg2)   // resultSetHoldability\n    throws SQLException\n</code></pre> <p>Com podeu veure, hi ha 3 arguments per indicar quin tipus de ResultSet donem al final. Aquests tres arguments poden ser:</p> <ul> <li><code>resultSetType</code> \\(\\rightarrow\\) aquestes s\u00f3n opcions sobre com moure's i passar per les files del ResultSet:<ul> <li><code>TYPE_FORWARD_ONLY</code> \\(\\rightarrow\\) opci\u00f3 per defecte. El ResultSet nom\u00e9s es pot passar una vegada.</li> <li><code>TYPE_SCROLL_INSENSITIVE</code> \\(\\rightarrow\\) Permet rebobinar i saltar a una posici\u00f3 absoluta o relativa.</li> <li><code>TYPE_SCROLL_SENSITIVE</code> \\(\\rightarrow\\) Igual que abans, per\u00f2 permet veure els canvis realitzats a la base de dades.</li> </ul> </li> <li><code>ResultSetConcurrency</code> \\(\\rightarrow\\) aquestes s\u00f3n opcions sobre si es pot actualitzar el ResultSet o no:<ul> <li><code>CONCUR_READ_ONLY</code> \\(\\rightarrow\\) opci\u00f3 per defecte. Nom\u00e9s lectura. Si volem actualitzar alguna cosa, nom\u00e9s podem utilitzar les cl\u00e0usules <code>DELETE</code> o <code>UPDATE</code>.</li> <li><code>CONCUR_UPDATABLE</code> \\(\\rightarrow\\) Les files del ResultSet es poden actualitzar o esborrar.</li> </ul> </li> <li><code>ResultSetHoldability</code> aquestes opcions s\u00f3n sobre el comportament en tancar el ResultSet:<ul> <li><code>HOLD_CURSORS_OVER_COMMIT</code> \\(\\rightarrow\\) El ResultSet es mant\u00e9 obert despr\u00e9s de confirmar la transacci\u00f3.</li> <li><code>CLOSE_CURSORS_AT_COMMIT</code> \\(\\rightarrow\\) El ResultSet es tanca despr\u00e9s de confirmar la transacci\u00f3. Millora el rendiment.</li> </ul> </li> </ul> <p>En el seg\u00fcent exemple, podem preguntar al nostre DBMS si aquests tipus de ResultSet estan suportats:</p> Java<pre><code>ConnexioDB conDB = new ConnexioDB(\"Instituto\");\nConnection con = conDB.getConnexio();\nDatabaseMetaData dbmd = con.getMetaData();\n\nSystem.out.println(\"TYPE_FORWARD_ONLY: \" + dbmd.supportsResultSetType(ResultSet.TYPE_FORWARD_ONLY));\nSystem.out.println(\"TYPE_SCROLL_INSENSITIVE: \" + dbmd.supportsResultSetType(ResultSet.TYPE_SCROLL_INSENSITIVE));\nSystem.out.println(\"TYPE_SCROLL_SENSITIVE: \" + dbmd.supportsResultSetType(ResultSet.TYPE_SCROLL_SENSITIVE));\nSystem.out.println(\"CONCUR_READ_ONLY: \" + dbmd.supportsResultSetConcurrency(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY));\nSystem.out.println(\"CONCUR_UPDATABLE: \" + dbmd.supportsResultSetConcurrency(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE));\n</code></pre>"},{"location":"UD2_Connectors/6_CRUD/#161-moviment-del-resultset","title":"1.6.1. Moviment del ResultSet","text":"<p>Com podem veure, no nom\u00e9s podem moure el cursor cap endavant:</p> <ul> <li><code>next</code>, <code>previous</code>, <code>first</code> i <code>last</code> \\(\\rightarrow\\) com el seu nom indica, es mouen cap endavant, cap enrere, al principi i a l'\u00faltima fila. Retorna true si el cursor apunta a una fila i false en cas contrari.</li> <li><code>beforeFirst</code> i <code>afterLast</code> \\(\\rightarrow\\) el cursor apuntar\u00e0 fora de les files, abans de la primera o despr\u00e9s de l'\u00faltima fila.</li> <li><code>relative(int n)</code> \\(\\rightarrow\\) el cursor es mou n files (cap endavant o cap enrere, depenent del signe).</li> <li><code>absolute(int n)</code> \\(\\rightarrow\\) el cursor apunta a la fila n.</li> </ul>"},{"location":"UD2_Connectors/6_CRUD/#162-eliminacio-de-files-en-un-resultset","title":"1.6.2. Eliminaci\u00f3 de files en un ResultSet","text":"<p>Despr\u00e9s de col\u00b7locar el cursor a la fila que es vol eliminar, es pot eliminar del ResultSet (i de la base de dades) amb el m\u00e8tode <code>deleteRow()</code>. Quan s'elimina una fila, el cursor apuntar\u00e0 a la fila anterior a la que s'ha eliminat.</p>"},{"location":"UD2_Connectors/6_CRUD/#163-actualitzacio-de-files-en-un-resultset","title":"1.6.3. Actualitzaci\u00f3 de files en un ResultSet","text":"<p>Despr\u00e9s de col\u00b7locar el cursor a la fila desitjada, s'ha de:</p> <ol> <li>Actualitzar les columnes desitjades, utilitzant el m\u00e8tode <code>updateType(int column, type newValue)</code>, on la columna i-\u00e8ssima (o amb el seu nom) s'assigna el nou valor del tipus donat.</li> <li>Un cop s'hagin modificat totes les columnes desitjades, es guarden els canvis amb <code>updateRow()</code>.</li> </ol> <p>Consell</p> <p>No podem actualitzar una fila sencera, hem de actualitzar columna per columna i despr\u00e9s actualitzar la fila.</p>"},{"location":"UD2_Connectors/6_CRUD/#164-insercio-de-files-en-un-resultset","title":"1.6.4. Inserci\u00f3 de files en un ResultSet","text":"<p>Si volem inserir una nova fila en un ResultSet, hem de:</p> <ol> <li>Generar una nova fila buida, i aix\u00f2 s'aconsegueix amb el m\u00e8tode <code>moveToInsertRow()</code>.</li> <li>En aquesta fila, apliquem el m\u00e8tode <code>updateType(int column, type newValue)</code> a totes les columnes a les quals volem assignar un valor, i finalment</li> <li>Procedim a inserir la nova fila amb <code>insertRow()</code>.</li> </ol> <p>Important</p> <ul> <li>Aquestes operacions d'actualitzaci\u00f3, eliminaci\u00f3 i inserci\u00f3 nom\u00e9s es poden realitzar en consultes que provenen d'una taula sense agrupacions.</li> <li>Per evitar complexitat en els nostres programes, val la pena avaluar la conveni\u00e8ncia de traduir les actualitzacions del ResultSet a SQL pur i executar-les directament a les bases de dades mitjan\u00e7ant noves sent\u00e8ncies.</li> </ul>"},{"location":"UD2_Connectors/7_Row_to_Object/","title":"1. De files a Objectes","text":"<p>Finalment, per tancar la unitat, treballarem de manera natural: recuperarem dades de la base de dades, crearem objectes a partir del <code>ResultSet</code> i guardarem les dades a la base de dades.</p> <p>Estudiarem una nova manera de crear els nostres POJO (i BEAN), utilitzant una llibreria moderna anomenada Lombok.</p>"},{"location":"UD2_Connectors/7_Row_to_Object/#11-pojo-bean-i-projecte-lombok","title":"1.1. POJO, BEAN i Projecte Lombok","text":"<p>Hem de crear classes segons el nostre model orientat a objectes. Depenent de com haguem fet les classes, poden ser POJO o BEAN o un altre tipus de classes. Anem a entendre-ho (extret d'aqu\u00ed: enlla\u00e7).</p>"},{"location":"UD2_Connectors/7_Row_to_Object/#111-pojo","title":"1.1.1. POJO","text":"<p>Aix\u00f2 significa Plain Old Java Object. \u00c9s una classe que:</p> <ul> <li>No ha d'estendre cap classe.</li> <li>No ha d'implementar cap interf\u00edcie.</li> <li>No ha de contenir anotacions espec\u00edfiques.</li> </ul> <p>No hi ha restriccions en els modificadors d'acc\u00e9s dels camps. Poden ser privats, per defecte, protegits o p\u00fablics. Tampoc \u00e9s necessari incloure cap constructor en aquest.</p> <p>Un exemple de POJO seria, per exemple:</p> Java<pre><code>// AS POJO\npublic class Modul {\n  // attributes\n  String nom;\n  int hores;\n  double nota;\n  // constructor\n  public Modul(String nom, int hores, double nota) {\n      this.nom = nom;\n      this.hores = hores;\n      this.nota = nota;\n  }\n  // getters\n  public String getModul(){return this.nom;}\n  public int getHores() {return this.hores;}\n  public double getNota() {return this.nota;}\n\n  @Override\n  public String toString() {\n      return \"Modul{\" + \"nom=\" + nom + \", hores=\" + hores + \", nota=\" + nota + '}';\n  } \n}\n</code></pre> <p>Com podeu veure, un POJO \u00e9s la m\u00ednima classe que podem fer.</p>"},{"location":"UD2_Connectors/7_Row_to_Object/#112-bean","title":"1.1.2. BEAN","text":"<p>Els Beans s\u00f3n un tipus especial de POJO. Hi ha algunes restriccions perqu\u00e8 un POJO sigui un Bean.</p> <ul> <li>Tots els JavaBeans s\u00f3n POJOs, per\u00f2 no tots els POJOs s\u00f3n JavaBeans.</li> <li><code>Serializable</code>, han d'implementar la interf\u00edcie Serializable. No obstant aix\u00f2, alguns POJOs que no implementen la interf\u00edcie Serializable es diuen POJOs perqu\u00e8 Serializable \u00e9s una interf\u00edcie marcadora i, per tant, no suposa una c\u00e0rrega excessiva.</li> <li>Els camps han de ser privats. Aix\u00f2 proporciona un control complet sobre els camps.</li> <li>Els camps han de tenir getters o setters o tots dos.</li> <li>Ha d'haver-hi un constructor sense arguments en un Bean.</li> <li>Els camps nom\u00e9s s'accedeixen mitjan\u00e7ant el constructor o els getters i setters.</li> </ul> Java<pre><code>// AS POJO\npublic class Modul {\n  // attributes\n  private String nom;\n  private int hores;\n  private double nota;\n  // constructor\n  public Modul() { }\n  // getters\n  public String getModul(){return this.nom;}\n  public int getHores() {return this.hores;}\n  public double getNota() {return this.nota;}\n// setters\n  public void getModul(){return this.nom;}\n  public void getHores() {return this.hores;}\n  public void getNota() {return this.nota;}\n\n  @Override\n  public String toString() {\n      return \"Modul{\" + \"nom=\" + nom + \", hores=\" + hores + \", nota=\" + nota + '}';\n  } \n}\n</code></pre> <p>Per resumir, les classes POJO i Beans s'utilitzen per definir objectes Java per augmentar la seva llegibilitat i reutilitzaci\u00f3. Els POJOs no tenen altres restriccions mentre que els beans s\u00f3n POJOs especials amb algunes restriccions.</p>"},{"location":"UD2_Connectors/7_Row_to_Object/#113-lombok","title":"1.1.3. Lombok","text":"<p>Independentment de si utilitzem POJO o BEAN, hi ha algunes tasques repetitives que hem de fer per crear les nostres classes. La majoria d'aquestes tasques s\u00f3n implementades pels IDE, com ara crear getters, setters, encapsular camps, crear constructors, etc. Project Lombok \u00e9s una llibreria que evita fer aquestes tasques repetitives, i diem el que volem i la llibreria i el compilador fan la resta.</p> <p>En aquest enlla\u00e7 configuraci\u00f3 de Lombok trobar\u00e0s com configurar la llibreria en cada gestor de projectes (gradle, maven, etc.) i en cada IDE (Netbeans, Eclipse, IntelliJ, etc.).</p> <p>Un cop instal\u00b7lada, nom\u00e9s cal dir mitjan\u00e7ant anotacions el que vols:</p> <ul> <li><code>@Getter</code> \\(\\rightarrow\\) generar\u00e0 tots els getters.</li> <li><code>@Setter</code> \\(\\rightarrow\\) generar\u00e0 tots els setters.</li> <li><code>@Data</code> \\(\\rightarrow\\) tots els m\u00e8todes que necessiten un POJO, incloent <code>ToString</code>.</li> <li><code>@AllArgsConstructor</code> o <code>@NoArgsConstructor</code> \\(\\rightarrow\\) generar\u00e0 el constructor que vulguis.</li> </ul> <p>Al seg\u00fcent v\u00eddeo s'explica com afegir la depend\u00e8ncia de Gradle i utilitzar Lombok.</p>"},{"location":"UD2_Connectors/7_Row_to_Object/#12-carregant-objectes","title":"1.2. Carregant objectes","text":"<p>Anem a finalitzar amb un exemple:</p>"},{"location":"UD2_Connectors/7_Row_to_Object/#121-classe-persona","title":"1.2.1. Classe Persona","text":"<p>Aquesta classe \u00e9s el POJO d'una persona. Crear\u00e0 getters, setters, toString i els m\u00e8todes principals amb nom\u00e9s unes poques l\u00ednies i algunes anotacions.</p> Java<pre><code>@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class Persona {\n    private int idPersona;\n    private String nombre;\n    private String apellidos;\n    private int edad;\n}\n</code></pre> <p>Cal tenir en compte que amb Lombok la feina es fa f\u00e0cil.</p>"},{"location":"UD2_Connectors/7_Row_to_Object/#122-omplint-un-array","title":"1.2.2. Omplint un Array","text":"<p>Per omplir una estructura de dades des de la base de dades, primer cal obtenir les dades. Cal crear l'objecte <code>Statement</code> o <code>PreparedStatement</code> i executar la consulta.</p> <p>La tasca principal \u00e9s transformar el <code>ResultSet</code> en una llista, per\u00f2 \u00e9s una tasca senzilla:</p> <ul> <li>Recorre el ResultSet (amb next), i per a cada fila:<ul> <li>Crea un objecte amb els valors emmagatzemats a les columnes</li> <li>Afegeix aquest objecte a la llista</li> </ul> </li> </ul> Java<pre><code>ArrayList&lt;Persona&gt; lasPersonas= new ArrayList();\n\nConnexioDB conDB=new ConnexioDB(\"Instituto\");\n\nConnection con=conDB.getConnexio();\n\nString SQL=\"Select * from Persona\" ;\n// The statement\nStatement st=con.createStatement(\n        ResultSet.TYPE_SCROLL_INSENSITIVE,\n        ResultSet.CONCUR_READ_ONLY);\n\n// The execution\nResultSet rst=st.executeQuery(SQL);\n\nif (!rst.next()){\n    System.out.println(\"No people in DB\");\n}\nelse{\n    rst.beforeFirst();\n    while(rst.next()){\n        Persona p= new Persona(\n                rst.getInt(1),\n                rst.getString(2),\n                rst.getString(3),\n                rst.getInt(4));\n        System.out.println(\"Adding \" +p);\n        lasPersonas.add(p);\n    }\n}\n\nSystem.out.println(\"Added \" + lasPersonas.size() + \" people\");\nrst.close();\n</code></pre> <p>Ara podr\u00e0s canviar la informaci\u00f3 en els objectes i, finalment, si s'ha fet alguna modificaci\u00f3, haur\u00e0s de guardar-la a la base de dades. Les preguntes s\u00f3n:</p> <ul> <li>Com puc saber si s'ha actualitzat un objecte?</li> <li>Com puc saber quin camp s'ha de desar?</li> </ul> <p>Com pots veure, hi ha diverses tasques que requereixen un control de la modificaci\u00f3 de les dades i com desar-les. Aquesta tasca ser\u00e0 f\u00e0cil amb ORM i l'estudiarem.</p> <p> Versi\u00f3 Autor Data 0 Joan Gerard Camarena Juliol de 2021 1 Joan Gerard Camarena Octubre de 2022 2 Joan Gerard Camarena Setembre de 2024 <p></p>"},{"location":"en/about/","title":"About me","text":"<p>Joan Gerard Camarena Estruch</p> <p>Abstract TO-DO</p>"},{"location":"en/","title":"Data Access","text":""},{"location":"en/#multiplatform-applications-development","title":"Multiplatform Applications Development","text":""},{"location":"en/#2024-2025","title":"2024 - 2025","text":"<p>Teacher:</p> <ul> <li>Joan Gerard Camarena Estruch jg.camarenaestruch at edu.gva.es</li> </ul>"},{"location":"en/license/","title":"License","text":"<p>This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.</p> <p>You are free to:</p> <ul> <li>Share \u2014 copy and redistribute the material in any medium or format</li> <li>Adapt \u2014 remix, transform, and build upon the material</li> </ul> <p>Under the following terms:</p> <ul> <li>Attribution \u2014 You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use.</li> <li>NonCommercial \u2014 You may not use the material for commercial purposes.</li> <li>ShareAlike \u2014 If you remix, transform, or build upon the material, you must distribute your contributions under the same license as the original.</li> </ul> <p>For more details, please refer to the full license text at https://creativecommons.org/licenses/by-nc-sa/4.0/legalcode.</p>"},{"location":"en/Practiques/APAC1/","title":"1. Environment and program execution","text":"<p>In this first Data Access CEPA (Continuous Evaluation Practice Activity), we are going to implement the file persistence part of a geometric figures project partially done.</p> <p>You are provided with a compressed file with the APAC1_AD Gradle project, with the figure hierarchy implementation and various utilities. The project has been created with <code>gradle init</code>, which creates a small structure of directories and files for us, such as the <code>gradlew</code> and <code>gradlew.bat</code> launchers (which we will not use).</p> <p>In order to build the project we will:</p> Bash<pre><code>$ gradle build\nBUILD SUCCESSFUL in 1 s\n5 actionable tasks : 5 up-to-date\n</code></pre> <p>and to run the project:</p> Bash<pre><code>gradle run --console plain\n</code></pre> <p>the <code>--console plain</code> option skip showing messages saying about the program execution. In addition, to pass some arguments to the program (in our program the height and width of the canvas) we must indicate as follows <code>--args=\"500 500\"</code>. The string in the double quotes will be the args variable of main.</p> <p>Once the program is running, the following prompt will be showed:</p> Text Only<pre><code># Figura: \n</code></pre> <p>This program let us draw a scene formed by several figures. The available options supported by the current version are (in Valencian):</p> <ul> <li><code>dimensions ample alt</code> : It sets the height and with of the canvas.</li> <li><code>cercle x y radi #color</code> : It adds a circle to the current scene. The circle will be placed at <code>x,y</code> coordinates, with the given radius and a color, in <code>#RRGGBB</code> format. This color is validated by a utility function.</li> <li><code>rectangle x y height width #color</code>: It adds a rectangle placed in <code>x,y</code> coordinates, with the given measures and color.</li> <li><code>linia x1 y1 x2 y2 #color</code>: It adds a line from the <code>(x1,y1)</code> starting point to the <code>(x2,y2)</code> final point and specified color. A fixed thickness by 3 pixels is establishe by the program.</li> <li><code>draw</code>: It will open a JavaFX window and draw all the figures stored and introduced in a canvas. When we will close the windows, the app will be finished.</li> </ul>"},{"location":"en/Practiques/APAC1/#2-new-behaviors","title":"2. New behaviors","text":"<p>In order to improve the base program, we must add the date persistence, adding functions to store and recover scenes. The orders wue have to implement are:</p> <ul> <li><code>import [file.txt | file.obj]</code> \\(\\rightarrow\\) It will import from disk scenes configurations, stored in text files or object files. The program will decide the format taking into account the file extension.</li> <li><code>export [file.txt | file.obj |file.svg | file.json]</code> \\(\\rightarrow\\) It will export to disk current scene configuration, saving it in text files, object files, svg format (a special xml format) or json format. The program will decide the format taking into account the file extension.</li> </ul> <p>Note</p> <p>All the files will be saved in the root project folder</p>"},{"location":"en/Practiques/APAC1/#21-sample-files-of-scenes","title":"2.1. Sample files of scenes","text":"<p>Text file</p> <p>Text Only<pre><code>dimensions 500 500\nrectangle 10 10 480 480 #ccccee \ncercle 250 250 100 #aaaaaa\nlinia 50 250 450 250 #aaaaaa\nlinia 50 50 50 450 #aaaaaa\nlinia 450 40 450 450 #aaaaaa\n</code></pre> SVG file</p> XML<pre><code>&lt;?xmlversion=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?&gt;\n&lt;svg height=\"500\" width=\"500\"&gt;\n  &lt;rect fill=\"#ccccee\" height=\"480\" width=\"480\" x=\"10\" y=\"10\"/&gt;\n  &lt;circle cx=\"250\" cy=\"250\" fill=\"#aaaaaa\" r=\"100\"/&gt;\n  &lt;line stroke=\"#aaaaaa\" stroke-width=\"3\" x1=\"50\" x2=\"450\" y1=\"250\" y2=\"250\"/&gt;\n  &lt;line stroke=\"#aaaaaa\" stroke-width=\"3\" x1=\"50\" x2=\"50\" y1=\"50\" y2=\"450\"/&gt;\n  &lt;line stroke=\"#aaaaaa\" stroke-width=\"3\" x1=\"450\" x2=\"450\" y1=\"40\" y2= \"450\"/&gt;\n&lt;/svg&gt;\n</code></pre> <p>Note</p> <p>This kind of xml is maded because after export this scene, you may open it with Inkscape. You can use it to prove you have done it well.</p> <p>JSON format</p> JSON<pre><code>{\"escena\": {\n    \"width\": 320,\n    \"height\": 320\n    \"figuras\": [\n        {\"cercle\": {\n            \"r\": \"26\",\n            \"cx\": \"166\",\n            \"cy\": \"105\",\n            \"fill\": \"#94c147\"\n        }},\n        {\"rectangle\": {\n            \"x\": \"137\",\n            \"width\": \"58\",\n            \"y\": \"108\",\n            \"fill\": \"#ffffff\",\n            \"height\": \"58\"\n        }},\n        {\"rectangle\": {\n            \"x\": \"139\",\n            \"width\": \"52\",\n            \"y\": \"111\",\n            \"fill\": \"#94c147\",\n            \"height\": \"52\"\n        }}\n     ],\n}}\n</code></pre>"},{"location":"en/Practiques/APAC1/#3-project-structure","title":"3. Project structure","text":"<p>First, we have <code>build.gradle</code> file, with information about project building, with graphics and JSON libraries. In our project structure, we have:</p> <p>Text Only<pre><code>main\n  |-- java\n  |   `--com\n  |      `-- ieseljust\n            `-- ad\n                `-- figures\n                    |-- App.java\n                    |-- cercle.java\n                    |-- escena.java\n                    |-- figura.java\n                    |-- FileManager.java\n                    |-- HexColorValidator.java\n                    |-- Linia.java\n                    |-- punt.java\n                    `-- Rectangle.java\n</code></pre> as you can view, inside src folder, we could take into account:</p> <ul> <li>App \\(\\rightarrow\\) main class. It shows the prompt and it creates the canvas. You don't have to modify this class.</li> <li>figura, cercle, linia, rectangle, punt \\(\\rightarrow\\) these classes form the inheritance tree (except punt). They have the necessary attributes and methods. You probably need to add methods to get the representation of that class to text, json or xml. You must do the necessary classes serializables too.</li> <li>escena \\(\\rightarrow\\) it contains some attributes and the collection of figures</li> <li>FileManager \\(\\rightarrow\\) class that have to deal with the storing process. We have to do the main work on it, as we can show in the next point.</li> </ul>"},{"location":"en/Practiques/APAC1/#4-filemanager-class","title":"4. <code>FileManager</code> class","text":"<p>As we explained, here is where you have to store and recover the information in several formats.</p>"},{"location":"en/Practiques/APAC1/#41-exists-method","title":"4.1. exists method","text":"Java<pre><code>public Boolean Exists(String file)\n</code></pre> <p>It will return a logic value depending on the existence of the file or no.</p>"},{"location":"en/Practiques/APAC1/#42-importfromtext-method","title":"4.2. <code>importFromText</code> method","text":"<p>Java<pre><code>public Escena importFromText(String file)\n</code></pre> Import a scene in text format, in the format indicated at the beginning of this document. In the imgs folder, you have a couple of images to test. As you can see, it receives the path to the file in String format, and it will return an object of type Scene.</p> <p>Note that, in addition to the figures, the dimensions command may appear, which will indicate that we will have to modify the dimensions of the Scene.</p>"},{"location":"en/Practiques/APAC1/#43-importfromobj-method","title":"4.3. <code>importFromObj</code> method","text":"Java<pre><code>public Escena importFromObj(String file)\n</code></pre> <p>Importing a serialized scene in object format, in the format indicated at the beginning of this document. In the imgs folder, you have a couple of images to test. As you can see, it receives the path to the file in String format, and it will return an object of type Scene.</p>"},{"location":"en/Practiques/APAC1/#44-exporttext-method","title":"4.4. <code>exportText</code> method","text":"Java<pre><code>public Boolean exportText(Escena escena, String file)\n</code></pre> <p>This method will export a given scene to a text file, in the format specified above, to be able to read them with <code>importFromText</code>.</p> <p>The method will receive the Scene object, and a String with the name of the file to be saved, with a <code>.txt</code> extension.</p> <p>For the implementation of this method, you will find it useful to implement a method called <code>getAsText</code> (or similar) in each type of figure, and returns the figure itself in the format of interest. In this way, to export the scene, we will go through the different figures and obtain the representation of each one.</p>"},{"location":"en/Practiques/APAC1/#45-exportobj-method","title":"4.5. <code>exportObj</code> method","text":"Java<pre><code>public Boolean exportObj(Escena escena, String file)\n</code></pre> <p>This method will export a given scene to an objects file, to be able to read it with <code>importFromObj</code>.</p> <p>The method will receive the Scene object, and a String with the name of the file to be saved, with an <code>.obj</code> extension.</p> <p>Warning</p> <p>Remember the use of <code>Serializable</code> modifier on the needed classes.</p>"},{"location":"en/Practiques/APAC1/#46-exportsvg-method","title":"4.6. <code>exportSVG</code> method","text":"Java<pre><code>public Boolean exportSVG(Escena escena, String file)\n</code></pre> <p>This method will export a given scene to a svg file, in the xml format specified above in the previous pages. The method will receive the Scene object, and a String with the name of the file to be saved, with a <code>.svg</code> extension.</p> <p>Some details of the format:</p> <ul> <li>We include <code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?&gt;</code> always.</li> <li>The root element is the <code>&lt;svg&gt;</code> tag, with two attributes width and height.</li> <li>Every figure inheritor will be the equivalent <code>rect</code>, <code>circle</code> and <code>line</code> tag. Look at the document sample.</li> <li>To do a correct circle position, you have to add the radius to the figure position: <code>this.posicio.getX()+this.radi</code> and <code>this.posicio.getY()+this.radi</code></li> </ul> <p>Note</p> <p>To get a correct implementation of this method (and others that will become) is interesting to proceed as we notice:</p> <ul> <li>declare an abstract method in Figura class. <code>getAsSVG()</code>, for instance.</li> <li>implement this method on every descent class.</li> </ul>"},{"location":"en/Practiques/APAC1/#47-exportjson-method","title":"4.7. <code>exportJSON</code> method","text":"Java<pre><code>public Boolean exportJSON(Escena escena,String filename)\n</code></pre> <p>This method will create a JSON representation of the scene that the method receives. As the note given in the last point, is an interesting practice to create the <code>getAsJson()</code> method in the top class an implement in the bottom classes. </p> <p>:::note</p> <p>To do a more efficient work, implement the methods as follows:</p> <ul> <li><code>importFromText</code>, so you can import a full scene provided and could draw it.</li> <li><code>exportToText</code>, so you can check your scene will be the same as the original one.</li> <li><code>exportToObj</code>, so you can save a scene imported from text</li> <li><code>importFromObj</code>, to check the exported one has been well done.</li> <li>At the end the rest of exports, to SVG and JSON :::</li> </ul>"},{"location":"en/Practiques/APAC1/#5-practice-delivery","title":"5. Practice delivery","text":"<p>To do the practice upload you have to fulfill the following:</p> <ul> <li>Execute <code>gradle clean</code> in order to clean all the packages and libraries.</li> <li>Compress the project folder. Zip format is mandatory.</li> <li>Upload the practice at the aules platform, avoiding emails or other communication tools.</li> </ul>"},{"location":"en/Practiques/APAC2/","title":"1. Overview","text":"<p>Let's go to create a DBMS client, like MySQL workbench, but in a console version with a shell and a prompt. Our client allows us to connect to a server, select a database and finally throws several SQL queries.</p>"},{"location":"en/Practiques/APAC2/#11-server-mode","title":"1.1. Server Mode","text":"<p>When starting our program, it will ask for server's data</p> Bash<pre><code>gradle run --console plain\n...\n$ Server: 127.0.0.1\n$ Port: 3308\n$ Username: root\n$ Password:\n$ (root) on 127.0.0.1:3308&gt;\n</code></pre> <p>As you can see on last line, prompt is <code>(user) on IP:port&gt;</code>. Our client show where we are connected always.</p> <p>List of order tha will be accepted by or client when connected are (server mode):</p> <ul> <li><code>show databases</code> or <code>sh db</code> \\(\\rightarrow\\) show a list with all databases in our DBMS.</li> <li><code>info</code> \\(\\rightarrow\\) show information abaut DBMS and connection settings.</li> <li><code>import script_name</code> \\(\\rightarrow\\) Allow to load a sql scrip from a file.</li> <li><code>use db_name</code> \\(\\rightarrow\\) change our program to database mode.</li> <li><code>quit</code> \\(\\rightarrow\\) finish our program.</li> </ul>"},{"location":"en/Practiques/APAC2/#12-database-mode","title":"1.2. Database Mode","text":"<p>Once we are connected to a server, and selected a database, our client will enter in database mode:</p> Bash<pre><code>$ (root) on 127.0.0.1:3308&gt;use Ciclismo\n$ (root) on 127.0.0.1:3308[Ciclismo]&gt;\n</code></pre> <p>you can view that database name is added to the prompt, and now the program is waiting for commands to the database. You must implement these orders :</p> <ul> <li><code>sh tables</code> \\(\\rightarrow\\) show all tables on selected database.</li> <li><code>describe table_name</code> \\(\\rightarrow\\) show description of this table: fields, data types and primary keys at least.</li> <li><code>insert Nom_de_la_Taula</code> \\(\\rightarrow\\)  on an interactive way, ask to the user for each field value, and insert a new row.</li> <li><code>sql</code> \\(\\rightarrow\\) It runs whatever query on selected database.</li> <li><code>quit</code> \\(\\rightarrow\\) returns to DBMS mode.</li> </ul>"},{"location":"en/Practiques/APAC2/#2-project-structure-and-tips","title":"2. Project structure and tips","text":"<p>The project contains theses classes:</p> <p></p> <p>Let's go to revise the class functions</p>"},{"location":"en/Practiques/APAC2/#21-servermanager","title":"2.1. ServerManager","text":"<p>It contains main, and when starting, ask the user for the server information. Then, it starts <code>ConnectionManager</code> class with the given values.</p>"},{"location":"en/Practiques/APAC2/#22-connectionmanager","title":"2.2. ConnectionManager","text":"<p>It manages the main program shell, and has as attributes:</p> Java<pre><code>String server;\nString port;\nString user;\nString pass;\n</code></pre> <p>and as methods:</p> <ul> <li><code>ConnectionManager()</code> \\(\\rightarrow\\) default const.</li> <li><code>ConnectionManager(String server, String port, String user, String pass)</code> \\(\\rightarrow\\) general const.</li> <li><code>public Connection connectDBMS()</code> \\(\\rightarrow\\) starts and returns a connection.</li> <li><code>public void showInfo()</code> \\(\\rightarrow\\)  show server's information.</li> <li><code>public void showDatabases()</code> \\(\\rightarrow\\) show server's tables.</li> <li><code>public void importScript(String script)</code> \\(\\rightarrow\\) loads and run a script.</li> <li><code>public void startShell()</code> \\(\\rightarrow\\) inits the server's mode shell. This shell is almost implemented.</li> </ul>"},{"location":"en/Practiques/APAC2/#23-databasemanager","title":"2.3. DatabaseManager","text":"<p>It manage the database mode shell, and need an extra attribute than Connection manager:</p> Java<pre><code>String server;\nString port;\nString user;\nString pass;\nString dbname;\n</code></pre> <p>and as methods:</p> <ul> <li><code>DatabaseManager()</code> \\(\\rightarrow\\) default const.</li> <li><code>DatabaseManager(String server, String port, String user, String pass,String dbname)</code> \\(\\rightarrow\\) general const.</li> <li><code>public Connection connectDatabase()</code> \\(\\rightarrow\\) starts and returns a connection to the current database.</li> <li><code>public void insertIntoTable(String table)</code> \\(\\rightarrow\\) starts the insertion assistant to the given table.</li> <li><code>public void showDescTable(String table)</code> \\(\\rightarrow\\) show table metadata.</li> <li><code>public void executeSelect(String query)</code> \\(\\rightarrow\\) run a given query (of any type) and show results on screen, if any.</li> <li><code>public void startShell()</code> \\(\\rightarrow\\) inits the database's mode shell. You have to do a full implementation.</li> </ul>"},{"location":"en/Practiques/APAC2/#3-tables-insertions","title":"3. Table's insertions.","text":"<p>The <code>insertIntoTable</code> is probably the hardest method in the task, due to need to ask for table metadata first, in order to know the table fields and data types, and then ask to the user for the values and formats.</p> <p>The advice that will be given is to set three list with:</p> <ol> <li>Fields list that need to insert</li> <li>Values list to we are going to set</li> <li>Types list of each field</li> </ol> <p>Furthermore, you need to generate a placeholders list or String, with so many <code>?</code> as you need.</p> <p>Advice</p> <p>Remember that asking for table metadata, the columns that you need are:</p> <ul> <li>Column 4 : column name</li> <li>Column 6: column data type</li> <li>Column 18 nullable or not. This field is mandatory if were not null.</li> <li>Column 23: incremental or not. You don't need this field, if were incremental.</li> </ul> <p>And last, a fine tunning is placeholders assignation, because it depends of data type. Take into account that:</p> <ul> <li>If data type is <code>INT</code>, we will use <code>setInt</code>.</li> <li>If data type is <code>DATETIME</code>, we will use <code>setDate</code> with a casting to <code>java.sql.Data</code> (not <code>java.Date</code>).</li> <li>For a default or very specific type, you could setString, and hope that casts works properly.</li> </ul> <p>\u00a9 Joan Gerard Camarena, October-2022</p> <p>\u00a9 Last revision, October-2024</p>"},{"location":"en/Practiques/APAC3/","title":"Pr\u00e0ctica 3","text":"<p>About the practice</p> <p>This practice is a free statement practice. You have to create your own task, with several limits, obviously. You have to do the maintenance of a database of your choice: you can create it from zero, you can choose one of last course, you can get from internet etc. </p>"},{"location":"en/Practiques/APAC3/#1-the-database","title":"1. The database","text":"<p>The database restrictions are:</p> <ul> <li>It must contains at least three entities.</li> <li>It must contains at least three relationships, one of each class: <code>1-1</code>, <code>1-M</code> and <code>N:M</code>. If you want, you can create a reflexive relation.</li> <li>Use MySQL</li> </ul>"},{"location":"en/Practiques/APAC3/#2-the-program","title":"2. The program","text":""},{"location":"en/Practiques/APAC3/#21-structure","title":"2.1. Structure","text":"<p>Create an Hibernate program with the goal of doing the basic CRUD operations in the database (Create, Read, Update and Delete). Map all the entities and relationships of the database.</p>"},{"location":"en/Practiques/APAC3/#22-crud","title":"2.2. CRUD","text":"<p>As all the work of each entity is the same (changing the entity's name), you must create only one Entity full CRUD. Then, create methods to insert, delete, update and select information of one entity.</p>"},{"location":"en/Practiques/APAC3/#23-relationships","title":"2.3. Relationships","text":"<p>Imagine that we have a <code>1:M</code> relationship, an <code>Author</code> writes several <code>Books</code>. With your own relationships do the same as follows:</p>"},{"location":"en/Practiques/APAC3/#231-task-1","title":"2.3.1. Task 1","text":"<p>You have to show records from a entity, for instance <code>show Author</code>. This command will show all Authors in database. But if the command is <code>show -r Author</code> it will show for each author the books that has written. (<code>r</code> means recursively)</p>"},{"location":"en/Practiques/APAC3/#232-task-2","title":"2.3.2. Task 2","text":"<p>When you want to insert a new Book, you can run <code>add Book</code>, and then, in an interactive way, the program will ask the values of the book and create it and store it, establishing the Author to <code>null</code>. But if you run <code>add -r Book</code>, the program will show all Authors in the database. The user will select one, and this Author is setted as book's author. </p> <p>In the Author selection process,  there will be an extra option (Author 0, for instance) when the book's author is not in the database, and we will create a new Author, and then assign to the Book. Both Author and Book will be saved.</p>"},{"location":"en/Practiques/APAC3/#3-task","title":"3. Task.","text":"<p>To upload the task on the platform, you only need to write a link to a private repository of student's GitHub. You must add your teacher's user as a guest of your repo (<code>joange</code> - jgcamarena@ieseljust.com). The task will be presented as next points.</p> <p>In your work's folder you must have:</p> <ol> <li>A script with the database create table and some sample data. You must generate it with MySQL Workbench sql dump.</li> <li>A picture of your database structure, created with MySQL Workbench reverse engineering.</li> <li>A maven project that implement the requirements of this text.</li> <li><code>Readme.md</code> file with documentation about your program. </li> </ol>"},{"location":"en/Practiques/APAC3/#31-checkpoint-1-the-database","title":"3.1. Checkpoint 1. The database.","text":"<p>In this task you must present your repo when you finish part 1 and 2. The teacher will mark it as <code>OK</code> before you start to program with part 3.</p>"},{"location":"en/Practiques/APAC3/#32-checkpoint-2-the-program","title":"3.2. Checkpoint 2. The program.","text":"<p>When you finish the task, present your repo.</p> <p>(c) Joan Gerard Camarena Estruch, November 2022</p>"},{"location":"en/UD1_Files/00_Exercises/","title":"File System","text":""},{"location":"en/UD1_Files/00_Exercises/#ls-la","title":"<code>ls -la</code>","text":"<p>In this exercise we are going to implement a tuned version of the <code>ls</code> program. It will list a directory in a specific view mode. Both directory and view will be indicated when we start the program.</p> <p>The view mode can be list, columns or table:</p> <ul> <li>List \\(\\rightarrow\\) The file names one above others.</li> <li>Columns \\(\\rightarrow\\) The same as list but in several columns</li> <li>Table \\(\\rightarrow\\) File information will be showed, like this pattern: <code>DFRWH name size mod_data</code>:</li> <li><code>D</code> \\(\\rightarrow\\) it's a directory</li> <li><code>F</code> \\(\\rightarrow\\) it's a file</li> <li><code>R</code> \\(\\rightarrow\\) we can read the file</li> <li><code>W</code> \\(\\rightarrow\\) we can write the file</li> <li><code>H</code> \\(\\rightarrow\\) the file is hidden</li> </ul>"},{"location":"en/UD1_Files/00_Exercises/#submission","title":"Submission","text":"<p>A single <code>.java</code> file with the program. To help you with some task here is some code to format a string list in columns. The <code>MAX_FILES_BY_COLUMN = 4</code> must be initialized.</p> Java<pre><code>public static void ListaColumnas(String[] filenames){\n  int columnas = (filenames.length / MAX_FILES_BY_COLUMN)+1; \n  String[][] salida = new String[MAX_FILES_BY_COLUMN][columnas];\n  for (int i=0;i&lt;filenames.length;i++){\n    salida[i % MAX_FILES_BY_COLUMN][i / MAX_FILES_BY_COLUMN]=\n        filenames[i];\n  }\n  //bucle para mostrar salida ls\n  for (int i=0;i&lt;MAX_FILES_BY_COLUMN;i++){ \n    for (int j=0; j&lt;columnas;j++)\n      System.out.print(salida[i][j] + \" - \"); \n    System.out.println(\" /n\");\n  }\n}\n</code></pre>"},{"location":"en/UD1_Files/00_Exercises/#hidden-files","title":"Hidden files","text":"<p>Write a Java program that find out all the hidden files of a directory and its subdirectories recursively.</p>"},{"location":"en/UD1_Files/00_Exercises/#biggest-file","title":"Biggest file","text":"<p>Write a Java program to find the big file of a set of files in a directory.</p>"},{"location":"en/UD1_Files/00_Exercises/#text-files","title":"Text Files","text":""},{"location":"en/UD1_Files/00_Exercises/#how-many-vowels","title":"How many vowels?","text":"<p>Write a program who receives a name of a text based file, and a vowel. The program will show the number of times that appear that vowel on the file.</p>"},{"location":"en/UD1_Files/00_Exercises/#tail-and-head","title":"<code>tail</code> and <code>head</code>","text":"<p>Write your own version of tail and head gnu utils. You can find out information in:</p> <ul> <li>tail</li> <li>head</li> </ul> <p>:::note</p> <p>Remember that these programs show the last and first ten lines by default. If you want to modify it, you can adjust with <code>-nX</code> where X is the number of lines you want to show. :::</p>"},{"location":"en/UD1_Files/00_Exercises/#binary-files","title":"Binary Files","text":""},{"location":"en/UD1_Files/00_Exercises/#find-size-of-an-image-file-hard","title":"Find size of an image file (HARD)","text":"<p>According to the specification of bmp or png pictures, as you can see:</p> <ul> <li>BMP specification</li> <li>PNG specification</li> </ul> <p>write a program that recieves a filename of a png or a bmp file and returns the image's width and height</p>"},{"location":"en/UD1_Files/00_Exercises/#csv-files","title":"CSV Files","text":"<p>Make a function to show a CSV file, according to the next requirements:</p> <ul> <li>We must indicate to the function the separator character.</li> <li>We must indicate to the function if the CSV has a header line or not.</li> <li>(Improvement) The function must calculate the max column size for each line, and show each column in the size previously calculated, as mysql show its tables. </li> </ul> <p>On the platform you have a MLB players names CSV files, but you can choose a file by your own.</p>"},{"location":"en/UD1_Files/00_Exercises/#xml-files","title":"XML Files","text":"<p>In the platform you will find a file called <code>monaco2017.xml</code> containing a lot of information about the F1 2017 championship race in Monaco. Apart from other information, we could find:</p> XML<pre><code>&lt;Result number=\"5\" position=\"1\" positionText=\"1\" points=\"25\"&gt;\n    &lt;Driver driverId=\"vettel\" code=\"VET\" url=\"http://en.wikipedia.org/wiki/Sebastian_Vettel\"&gt;\n        &lt;PermanentNumber&gt;5&lt;/PermanentNumber&gt;\n        &lt;GivenName&gt;Sebastian&lt;/GivenName&gt;\n        &lt;FamilyName&gt;Vettel&lt;/FamilyName&gt;\n        &lt;DateOfBirth&gt;1987-07-03&lt;/DateOfBirth&gt;\n        &lt;Nationality&gt;German&lt;/Nationality&gt;\n    &lt;/Driver&gt;\n    &lt;Constructor constructorId=\"ferrari\" url=\"http://en.wikipedia.org/wiki/Scuderia_Ferrari\"&gt;\n        &lt;Name&gt;Ferrari&lt;/Name&gt;\n        &lt;Nationality&gt;Italian&lt;/Nationality&gt;\n    &lt;/Constructor&gt;\n    &lt;Grid&gt;2&lt;/Grid&gt;\n    &lt;Laps&gt;78&lt;/Laps&gt;\n    &lt;Status statusId=\"1\"&gt;Finished&lt;/Status&gt;\n    &lt;Time millis=\"6284340\"&gt;1:44:44.340&lt;/Time&gt;\n    &lt;FastestLap rank=\"2\" lap=\"38\"&gt;\n        &lt;Time&gt;1:15.238&lt;/Time&gt;\n        &lt;AverageSpeed units=\"kph\"&gt;159.669&lt;/AverageSpeed&gt;\n    &lt;/FastestLap&gt;\n&lt;/Result&gt;\n</code></pre> <p>Within the <code>Result</code> we will find as attributes the pilot's number (<code>number</code> attribute) and the position in which he finished the race (<code>position</code>). In addition, we will find the following elements:</p> <ul> <li>Driver: information about who the driver is.</li> <li>Manufacturer: information about the brand of the car</li> <li>Grid: Position in which the driver has started</li> <li>Laps: Laps completed</li> <li>Status: which tells us with the <code>statusID=1</code> attribute that the pilot finished the race.</li> <li>Time: which tells us the milliseconds attribute how long it took to complete the race (in ms), and in its value the difference with respect to the first ones.</li> <li>FastesLap: which tells us the classification with respect to the fast lap in its rank attribute.</li> </ul> <p>On the platform you will find:</p> <ul> <li>Driver class: full implemented, who need the driver portion of the XML to create a Driver object.</li> <li>ResultadoCarrera: partially implemented, with the following attributes:</li> </ul> Java<pre><code>private Driver d;\nprivate String constructor;\nprivate int initialPos;\nprivate int finalPos;\nprivate long timeMillis;\nprivate int completedLaps;\nprivate int rankFastesLap;\nprivate boolean finisher;\n</code></pre> <p>Complete the program, adding:</p> <ul> <li><code>Constructor(Element result)</code>, that receives a XML Element.</li> <li><code>public String toCSV()</code>, who will return all fields sepparated by <code>;</code>.</li> <li><code>public ArrayList&lt;ResultadoCarrera&gt; carregaResultadosXML(String nomXML)</code> who receive the name of XML file and will load all the results.</li> <li><code>public void saveAsCSV(String nomFitxer, ArrayList&lt;ResultadoCarrera&gt; elsResultats)</code> who will save on a csv text file the results loaded previously.</li> </ul>"},{"location":"en/UD1_Files/00_Exercises/#json-files","title":"JSON Files","text":"<p>On the platform you will find a file called <code>SW.json</code>. It recovers information about characters of the famous saga. Write a program to obtain:</p> <ul> <li>Characters that did not drive any vehicle.</li> <li>List of characters, ordered by number of films that it appears.</li> <li>Create an XML file like this, with a brief summary information:</li> </ul> XML<pre><code>&lt;character films=\"4\" vehicles=\"0\"&gt;\n  &lt;name&gt;Luke Skywalker&lt;/name&gt;\n  &lt;mass&gt;77&lt;/mass&gt;\n  &lt;url&gt;https://swapi.dev/api/people/1/&lt;/url&gt;\n&lt;/character&gt;\n</code></pre> <p>Let's go starting the course playing with databases and programs, to review all the concepts you need to begin with the main topics with a solid base.</p>"},{"location":"en/UD1_Files/01_APAC/","title":"Environment and program execution","text":"<p>In this first Data Access CEPA (APAC in spanish), we are going to implement the file persistence part of a geometric figures project partially done.</p> <p>You are provided with a compressed file with the APAC1_AD Gradle project, with the figure hierarchy implementation and various utilities. The project has been created with <code>gradle init</code>, which creates a small structure of directories and files for us, such as the <code>gradlew</code> and <code>gradlew.bat</code> launchers (which we will not use).</p> <p>In order to build the project we will:</p> Bash<pre><code>$ gradle build\nBUILD SUCCESSFUL in 1 s\n5 actionable tasks : 5 up-to-date\n</code></pre> <p>and to run the project:</p> Bash<pre><code>gradle run --console plain\n</code></pre> <p>the <code>--console plain</code> option skip showing messages saying about the program execution. In addition, to pass some arguments to the program (in our program the height and width of the canvas) we must indicate as follows <code>--args=\"500 500\"</code>. The string in the double quotes will be the args variable of main.</p> <p>Once the program is running, the following prompt will be showed:</p> Text Only<pre><code># Figura: \n</code></pre> <p>This program let us draw a scene formed by several figures. The available options supported by the current version are (in Valencian):</p> <ul> <li><code>dimensions ample alt</code> : It sets the height and with of the canvas.</li> <li><code>cercle x y radi #color</code> : It adds a circle to the current scene. The circle will be placed at <code>x,y</code> coordinates, with the given radius and a color, in <code>#RRGGBB</code> format. This color is validated by a utility function.</li> <li><code>rectangle x y height width #color</code>: It adds a rectangle placed in <code>x,y</code> coordinates, with the given measures and color.</li> <li><code>linia x1 y1 x2 y2 #color</code>: It adds a line from the <code>(x1,y1)</code> starting point to the <code>(x2,y2)</code> final point and specified color. A fixed thickness by 3 pixels is establishe by the program.</li> <li><code>draw</code>: It will open a JavaFX window and draw all the figures stored and introduced in a canvas. When we will close the windows, the app will be finished.</li> </ul>"},{"location":"en/UD1_Files/01_APAC/#new-behaviors","title":"New behaviors","text":"<p>In order to improve the base program, we must add the date persistence, adding functions to store and recover scenes. The orders wue have to implement are:</p> <ul> <li><code>import [file.txt | file.obj]</code> \\(\\rightarrow\\) It will import from disk scenes configurations, stored in text files or object files. The program will decide the format taking into account the file extension.</li> <li><code>export [file.txt | file.obj |file.svg | file.json]</code> \\(\\rightarrow\\) It will export to disk current scene configuration, saving it in text files, object files, svg format (a special xml format) or json format. The program will decide the format taking into account the file extension.</li> </ul> <p>:::note All the files will be saved in the root project folder :::</p>"},{"location":"en/UD1_Files/01_APAC/#sample-files-of-scenes","title":"Sample files of scenes","text":"<p>Text file</p> <p>Text Only<pre><code>dimensions 500 500\nrectangle 10 10 480 480 #ccccee \ncercle 250 250 100 #aaaaaa\nlinia 50 250 450 250 #aaaaaa\nlinia 50 50 50 450 #aaaaaa\nlinia 450 40 450 450 #aaaaaa\n</code></pre> SVG file</p> XML<pre><code>&lt;?xmlversion=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?&gt;\n&lt;svg height=\"500\" width=\"500\"&gt;\n  &lt;rect fill=\"#ccccee\" height=\"480\" width=\"480\" x=\"10\" y=\"10\"/&gt;\n  &lt;circle cx=\"250\" cy=\"250\" fill=\"#aaaaaa\" r=\"100\"/&gt;\n  &lt;line stroke=\"#aaaaaa\" stroke-width=\"3\" x1=\"50\" x2=\"450\" y1=\"250\" y2=\"250\"/&gt;\n  &lt;line stroke=\"#aaaaaa\" stroke-width=\"3\" x1=\"50\" x2=\"50\" y1=\"50\" y2=\"450\"/&gt;\n  &lt;line stroke=\"#aaaaaa\" stroke-width=\"3\" x1=\"450\" x2=\"450\" y1=\"40\" y2= \"450\"/&gt;\n&lt;/svg&gt;\n</code></pre> <p>:::note This kind of xml is maded because after export this scene, you may open it with Inkscape. You can use it to prove you have done it well. :::</p> <p>JSON format</p> JSON<pre><code>{\"escena\": {\n    \"width\": 320,\n    \"height\": 320\n    \"figuras\": [\n        {\"cercle\": {\n            \"r\": \"26\",\n            \"cx\": \"166\",\n            \"cy\": \"105\",\n            \"fill\": \"#94c147\"\n        }},\n        {\"rectangle\": {\n            \"x\": \"137\",\n            \"width\": \"58\",\n            \"y\": \"108\",\n            \"fill\": \"#ffffff\",\n            \"height\": \"58\"\n        }},\n        {\"rectangle\": {\n            \"x\": \"139\",\n            \"width\": \"52\",\n            \"y\": \"111\",\n            \"fill\": \"#94c147\",\n            \"height\": \"52\"\n        }}\n     ],\n}}\n</code></pre>"},{"location":"en/UD1_Files/01_APAC/#project-structure","title":"Project structure","text":"<p>First, we have <code>build.gradle</code> file, with information about project building, with graphics and JSON libraries. In our project structure, we have:</p> <p>Text Only<pre><code>main\n  |-- java\n  |   `--com\n  |      `-- ieseljust\n            `-- ad\n                `-- figures\n                    |-- App.java\n                    |-- cercle.java\n                    |-- escena.java\n                    |-- figura.java\n                    |-- FileManager.java\n                    |-- HexColorValidator.java\n                    |-- Linia.java\n                    |-- punt.java\n                    `-- Rectangle.java\n</code></pre> as you can view, inside src folder, we could take into account:</p> <ul> <li>App \\(\\rightarrow\\) main class. It shows the prompt and it creates the canvas. You don't have to modify this class.</li> <li>figura, cercle, linia, rectangle, punt \\(\\rightarrow\\) these classes form the inheritance tree (except punt). They have the necessary attributes and methods. You probably need to add methods to get the representation of that class to text, json or xml. You must do the necessary classes serializables too.</li> <li>escena \\(\\rightarrow\\) it contains some attributes and the collection of figures</li> <li>FileManager \\(\\rightarrow\\) class that have to deal with the storing process. We have to do the main work on it, as we can show in the next point.</li> </ul>"},{"location":"en/UD1_Files/01_APAC/#filemanager-class","title":"<code>FileManager</code> class","text":"<p>As we explained, here is where you have to store and recover the information in several formats.</p>"},{"location":"en/UD1_Files/01_APAC/#exists-method","title":"exists method","text":"Java<pre><code>public Boolean Exists(String file)\n</code></pre> <p>It will return a logic value depending on the existence of the file or no.</p>"},{"location":"en/UD1_Files/01_APAC/#importfromtext-method","title":"<code>importFromText</code> method","text":"<p>Java<pre><code>public Escena importFromText(String file)\n</code></pre> Import a scene in text format, in the format indicated at the beginning of this document. In the imgs folder, you have a couple of images to test. As you can see, it receives the path to the file in String format, and it will return an object of type Scene.</p> <p>Note that, in addition to the figures, the dimensions command may appear, which will indicate that we will have to modify the dimensions of the Scene.</p>"},{"location":"en/UD1_Files/01_APAC/#importfromobj-method","title":"<code>importFromObj</code> method","text":"Java<pre><code>public Escena importFromObj(String file)\n</code></pre> <p>Importing a serialized scene in object format, in the format indicated at the beginning of this document. In the imgs folder, you have a couple of images to test. As you can see, it receives the path to the file in String format, and it will return an object of type Scene.</p>"},{"location":"en/UD1_Files/01_APAC/#exporttext-method","title":"<code>exportText</code> method","text":"Java<pre><code>public Boolean exportText(Escena escena, String file)\n</code></pre> <p>This method will export a given scene to a text file, in the format specified above, to be able to read them with <code>importFromText</code>.</p> <p>The method will receive the Scene object, and a String with the name of the file to be saved, with a <code>.txt</code> extension.</p> <p>For the implementation of this method, you will find it useful to implement a method called <code>getAsText</code> (or similar) in each type of figure, and returns the figure itself in the format of interest. In this way, to export the scene, we will go through the different figures and obtain the representation of each one.</p>"},{"location":"en/UD1_Files/01_APAC/#exportobj-method","title":"<code>exportObj</code> method","text":"Java<pre><code>public Boolean exportObj(Escena escena, String file)\n</code></pre> <p>This method will export a given scene to an objects file, to be able to read it with <code>importFromObj</code>.</p> <p>The method will receive the Scene object, and a String with the name of the file to be saved, with an <code>.obj</code> extension.</p> <p>:::warning Remember the use of <code>Serializable</code> modifier on the needed classes. :::</p>"},{"location":"en/UD1_Files/01_APAC/#exportsvg-method","title":"<code>exportSVG</code> method","text":"Java<pre><code>public Boolean exportSVG(Escena escena, String file)\n</code></pre> <p>This method will export a given scene to a svg file, in the xml format specified above in the previous pages. The method will receive the Scene object, and a String with the name of the file to be saved, with a <code>.svg</code> extension.</p> <p>Some details of the format:</p> <ul> <li>We include <code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?&gt;</code> always.</li> <li>The root element is the <code>&lt;svg&gt;</code> tag, with two attributes width and height.</li> <li>Every figure inheritor will be the equivalent <code>rect</code>, <code>circle</code> and <code>line</code> tag. Look at the document sample.</li> <li>To do a correct circle position, you have to add the radius to the figure position: <code>this.posicio.getX()+this.radi</code> and <code>this.posicio.getY()+this.radi</code></li> </ul> <p>:::important To get a correct implementation of this method (and others that will become) is interesting to proceed as we notice:</p> <ul> <li>declare an abstract method in Figura class. <code>getAsSVG()</code>, for instance.</li> <li>implement this method on every descent class. :::</li> </ul>"},{"location":"en/UD1_Files/01_APAC/#exportjson-method","title":"<code>exportJSON</code> method","text":"Java<pre><code>public Boolean exportJSON(Escena escena,String filename)\n</code></pre> <p>This method will create a JSON representation of the scene that the method receives. As the note given in the last point, is an interesting practice to create the <code>getAsJson()</code> method in the top class an implement in the bottom classes. </p> <p>:::note</p> <p>To do a more efficient work, implement the methods as follows:</p> <ul> <li><code>importFromText</code>, so you can import a full scene provided and could draw it.</li> <li><code>exportToText</code>, so you can check your scene will be the same as the original one.</li> <li><code>exportToObj</code>, so you can save a scene imported from text</li> <li><code>importFromObj</code>, to check the exported one has been well done.</li> <li>At the end the rest of exports, to SVG and JSON :::</li> </ul>"},{"location":"en/UD1_Files/01_APAC/#practice-delivery","title":"Practice delivery","text":"<p>To do the practice upload you have to fulfill the following:</p> <ul> <li>Execute <code>gradle clean</code> in order to clean all the packages and libraries.</li> <li>Compress the project folder. Zip format is mandatory.</li> <li>Upload the practice at the aules platform, avoiding emails or other communication tools.</li> </ul>"},{"location":"en/UD1_Files/1_File_System/","title":"File system","text":""},{"location":"en/UD1_Files/1_File_System/#1-introduction","title":"1. Introduction","text":"<p>In the beginning of computer science, files were the only mechanism to store information. Nowadays, Operating Systems manage storage devices almost transparently to the user. Without going into details of the underlying storage technologies, they offer us an abstraction by means of which we have only to worry about two concepts: files and directories.</p> <ul> <li>File \u2192 information containers (all kind and format of the information).</li> <li>Directories \u2192 file organizers, and may contain files and other directories.</li> </ul> <p>Following with information (the content of the file), we can find a classical classification:</p> <ul> <li>Text File \u2192 the information is stored in files, so that can be viewed or opened with any plain text editor, like vi, nano, or notepad. </li> <li>Binary File \u2192 the information is stored coded in binary format. As the student know, any kind of information (text, numbers, photos, etc.) can be traduced to 0's and 1's. In our way (programmers) we can transform objects and variables in different ways.</li> </ul> <p>Notice than...</p> <ul> <li>Regardless that we store information in text file, it appears a new concept: structure. If we organize information in several ways, we can speak about csv files, xml files, json files. The csv, xml and json are structures, because at the end, all of them are text files.</li> <li>People think that text files are weak files to store information, but it is not true. Cryptographic technics offers us methods to store information inside text files safety. For example 'htpasswd' in 'apache' or '/etc/shadow' in Linux systems. At the bottom you can view a PGP public key sample, stored in a text file</li> </ul> Bash<pre><code>-----BEGIN PGP PUBLIC KEY BLOCK-----\nComment: Alice's OpenPGP certificate\nComment: https://www.ietf.org/id/draft-bre-openpgp-samples-01.html\n\nmDMEXEcE6RYJKwYBBAHaRw8BAQdArjWwk3FAqyiFbFBKT4TzXcVBqPTB3gmzlC/U\nb7O1u120JkFsaWNlIExvdmVsYWNlIDxhbGljZUBvcGVucGdwLmV4YW1wbGU+iJAE\n...\nDAAKCRDyMVUMT0fjjlnQAQDFHUs6TIcxrNTtEZFjUFm1M0PJ1Dng/cDW4xN80fsn\n0QEA22Kr7VkCjeAEC08VSTeV+QFsmz55/lntWkwYWhmvOgE=\n=iIGO\n-----END PGP PUBLIC KEY BLOCK-----\n</code></pre>"},{"location":"en/UD1_Files/1_File_System/#2-accessing-the-file-system-in-java","title":"2. Accessing the file system in Java","text":"<p><code>Java</code> offers us several ways to access the file system. This way is independent of the underlying device that stores the information. The device can be a hard disk, ssd disk, optical drive, etc. The class that offers us this possibility is the File class. We are going to review the main facts of this class, and then revise some samples.</p> <ul> <li>The constructor of the class is overloaded, as most java classes. We could use:</li> <li><code>File(File parent, String child)</code> \u2192 Creates a new File instance from a parent abstract pathname and a child pathname string.</li> <li><code>File(String pathname)</code> \u2192 Creates a new File instance by converting the given pathname string into an abstract pathname.</li> <li><code>File(String parent, String child)</code> \u2192 Creates a new File instance from a parent pathname string and a child pathname string.</li> <li> <p><code>File(URI uri)</code> \u2192 Creates a new File instance by converting the given file: URI into an abstract pathname.</p> </li> <li> <p>To access the file we must use a path name. This is the path, and we have two possibilities:</p> </li> <li>Absolute path \u2192 the path from the root directory of the system to the file we would, starting with <code>/</code> in Linux systems or <code>letter:</code> in Windows systems. Remember to use <code>/</code> to separate folders in Linux and <code>\\\\</code> in Windows. It is not an erratum, due to the backslash is a symbol with own meaning, we have to escape it, doubling it to get the meaning we would.</li> <li>Relative path \u2192 we suppose that the file we would is in the same folder that the project/program we are executing. In this case we only provide the file name, without any folder at the beginning of the path.</li> </ul> <p>Java<pre><code>// absolute paths\nFile f=new File(\"/home/joange/texto.md\") //  Linux\nFile f=new File(\"C:\\\\Usuarios\\\\joange\\\\Dektop\\\\texto.md\") //  Windows\n...\n// relative paths\nFile f=new File(\"texto.md\") //  Linux\nFile f=new File(\"docs\\\\texto.md\") //  Windows\n</code></pre> - The same class <code>File</code> is used to access either a regular file or a directory. Is task of the programmer to difference between them with the file methods as well as to check if a file exists. To do this, we could use several methods like:   - <code>boolean exists()</code> \u2192 returns true if the file object exists, and false otherwise.   - <code>boolean isFile()</code> and <code>isDirectory()</code> \u2192 returns true either the object is a regular file or a directori. Obviously, these methods are exclusive</p>"},{"location":"en/UD1_Files/1_File_System/#3-creating-files","title":"3. Creating files","text":"<p>If we want to create a folder or a regular file, we can use this methods</p> <ul> <li><code>boolean createNewFile()</code> \u2192 Atomically creates a new, empty file named by this abstract pathname if and only if a file with this name does not yet exist.</li> <li><code>static FilecreateTempFile(String prefix, String suffix)</code> \u2192 Creates an empty file in the default temporary-file directory, using the given prefix and suffix to generate its name.</li> <li><code>boolean mkdir()</code> \u2192 Creates the directory named by this abstract pathname.</li> <li><code>boolean mkdirs()</code> \u2192 Creates the directory named by this abstract pathname, including any necessary but nonexistent parent directories.</li> <li><code>boolean renameTo(File dest)</code> \u2192 Renames the file denoted by this abstract pathname.</li> <li><code>boolean delete()</code>\u2192 Deletes the file or directory denoted by this abstract pathname.</li> </ul> <p>Note</p> <ul> <li>In next sections we will study how to create files when we save content inside them. In other words, we do not need to create the file adhoc and then populate. There are mechanisms to create the file in an automatized way.</li> <li>The difference between mkdir and mkdirs is that the second option will create all directories between the root file system and the current directory meanwhile the first need that the path exists.</li> </ul>"},{"location":"en/UD1_Files/1_File_System/#4-asking-for-file-properties","title":"4. Asking for file properties","text":"<p>Normally we open files to write or read their content, but sometimes we need to ask for file properties, like size, permits and so. File class will help us again.</p> <p>General information:</p> <ul> <li><code>boolean exists()</code> \u2192 Tests whether the file or directory denoted by this abstract pathname exists.</li> <li><code>long lastModified()</code> \u2192 Returns the time that the file denoted by this abstract pathname was last modified.</li> <li><code>long length()</code> \u2192 Returns the length of the file denoted by this abstract pathname.</li> </ul> <p>Information about permits. This information is the information than the user can recover with <code>ls -la</code> in the <code>chmod</code> style:</p> <ul> <li><code>boolean canExecute()</code> \u2192 Tests whether the application can execute the file denoted by this abstract pathname.</li> <li><code>boolean canRead()</code> \u2192 Tests whether the application can read the file denoted by this abstract pathname.</li> <li><code>boolean canWrite()</code> \u2192 Tests whether the application can modify the file denoted by this abstract pathname.</li> </ul> <p>Content of a directory:</p> <ul> <li><code>String[] list()</code> \u2192 Returns an array of strings naming the files and directories in the directory denoted by this abstract pathname.</li> <li><code>File[] listFiles()</code> \u2192 Returns an array of abstract pathnames denoting the files in the directory denoted by this abstract pathname.</li> <li><code>String[] list(FilenameFilter filter)</code> \u2192 Returns an array of strings naming the files and directories in the directory denoted by this abstract pathname that satisfy the specified filter.</li> <li><code>File[] listFiles(FilenameFilter filter)</code> \u2192 Returns an array of abstract pathnames denoting the files and directories in the directory denoted by this abstract pathname that satisfy the specified filter.</li> </ul> <p>Tip</p> <p>We suggest the student to find out information about the class FilenameFilter</p>"},{"location":"en/UD1_Files/1_File_System/#41-solved-exercise","title":"4.1. Solved Exercise","text":"<p>Analyze and explain what this little program do:</p> Java<pre><code>public static void main(String[] args) {\n        String ruta = args[0];\n        File f = new File(ruta);\n\n        if (f.exists()) {\n            if (f.isFile()) {\n                System.out.println(\"El tama\u00f1o es de \" + f.length());\n                System.out.println(\"Puede ejecturase: \" + f.canExecute());\n                System.out.println(\"Puede leerse: \" + f.canRead());\n                System.out.println(\"Puede escribirse: \" + f.canWrite());\n            } else {\n                String[] losArchivos = f.list();\n                System.out.println(\"El directorio \" + ruta + \" contiene:\");\n                for (String archivo : losArchivos) {\n                    System.out.println(\"\\t\" + archivo);\n                }\n            }\n\n        } else {\n            System.out.println(\"El fichero o ruta no existe\");\n        }\n}\n</code></pre> <p>Solution</p> <ol> <li>This program read from the command line a path, and create a File object.</li> <li>Then, check if the path exist or no over the file system. In case it doesn't exist, the program finish.</li> <li>If the path exists, next test is to verify if it is a file:</li> <li>We read some trivial properties like size and permits </li> <li>If the path pointed by the file is a directory, we get the content of this directory, and show on the screen</li> </ol>"},{"location":"en/UD1_Files/2_Reading_and_writing_files/","title":"1. Reading and writing files","text":"<p>Java offers a wide variety of ways to manipulate the contents of files, bringing great power but complexity at the same time.</p> <p>The reading and writing of files in Java is done through data flows or <code>streams</code>, which may be either oriented to bytes or considered as a set of characters. The concept of file, which is static, must be differentiated from the concept of stream, which has a dynamic character: a file is stored on disk, but from the point of view of the application, we are interested in the transfer of this information from the file to our program. A classic comparison: streams would be like water pipes, while files would be reservoirs. The concept of data flow, apart from the scope of files, will also be applicable to the transfer of information, for example through the network or between processes.</p> <p>Streams can be classified into:</p> <ul> <li><code>Input Streams</code>: Those that go from a source (e.g. file) to the program.</li> <li><code>Output Streams</code>: Those that exit the program to a destination (e.g. file).</li> </ul> <p>When reading and storing data, we must be very careful with the types of data we work with, since the same sequence of bits on disk represents different information depending on the type of data used. Even when dealing with the same type of data, as in the case of characters, special care must be taken, since different systems may use different coding. Java, for example for the char type uses 16-bit Unicode (UTF-16), but we can try to access encoded files, for example with UTF-8 or ASCII.</p> <p>The parent superclasses for handling byte-oriented streams are <code>InputStream</code> and <code>OutputStream</code>. Others are derived from these, but for file management we are interested in two: <code>FileInputStream</code> and <code>FileOutputStream</code>.</p>"},{"location":"en/UD1_Files/2_Reading_and_writing_files/#11-fileinputstream","title":"1.1. FileInputStream","text":"<p>The <code>FileInputStream</code> class is used to access files for reading, and has two main constructors:</p> <ul> <li><code>FileInputStream (File f)</code> \u2192 Receives an object of type <code>File</code>, which will reference the object we will read from.</li> <li><code>FileInputStream (String name)</code> \u2192 Receives a string with the name or path of the location of the file to be read.</li> </ul> <p>The main methods we have for this class are:</p> <ul> <li><code>int read()</code> \u2192 Abstract sequential reading method: Returns an integer corresponding to the next byte of an input stream (file, byte array...). If it reaches the end of the sequence, it returns <code>-1</code>. On error, it will throw an exception of type <code>IOException</code>.</li> <li><code>int read(byte[] buffer)</code> \u2192 Reads a given number of bytes from the input (as long as the buffer), saving them to the buffer. It will return the number of bytes effectively read, which at most will be as large as the buffer. If no bytes are available return <code>-1</code>.</li> <li><code>int available()</code> \u2192 Indicates the bytes we have available for reading.</li> <li><code>long skip(long des)</code> \u2192 Skips as many bytes as the parameter indicates. The return value is the number of bytes that have been effectively dumped (they can be less than what we have indicated if we reach the end for example).</li> <li><code>int close()</code> \u2192 Closes the data stream.</li> </ul>"},{"location":"en/UD1_Files/2_Reading_and_writing_files/#12-fileoutputstream","title":"1.2. FileOutputStream","text":"<p>The FileOutputStream class is used to access files for writing. It has the following builders:</p> <ul> <li><code>FileOutputStream (File f)</code> \u2192 Receives an object of type <code>File</code> and opens it in write mode. In case it does not exist, it will be created, and if it exists, it will be overwritten.</li> <li><code>FileOutputStream (String name)</code> \u2192 Receives a string with the name or path of the location of the file to be written, and opens it in write mode. In case it does not exist, it will be created, and if it exists, it will be overwritten.</li> <li><code>FileOutputStream (File f, boolean append)</code> \u2192 Gets an object of type <code>File</code> and opens it in append mode, to write to the end. If it doesn't exist, it will be created, and if it exists, it will write behind it (only if append is set to True).</li> <li><code>FileOutputStream (String , boolean append)</code> \u2192 Receives a string with the name or path of the file location to be written and opens it in append mode, to be written at the end. If it doesn't exist, it will be created, and if it exists, it will write behind it (only if append is set to True).</li> </ul> <p>The main methods of the class are:</p> <ul> <li><code>write(int byte)</code> \u2192 Writes the byte to the output stream. Although this is an integer parameter, only one byte is written. If there is an error, an IOException is thrown.</li> <li><code>void write(byte[ ] buffer)</code> \u2192 Writes the contents of the buffer (byte vector) to the file. If the buffer is null, it will throw an exception.</li> <li><code>void write(byte[ ] buffer, int pos, int length)</code> \u2192 Writes the contents of the buffer (byte vector) from position pos, and as many bytes as given in length.</li> <li><code>void flush()</code> \u2192 Forces the remaining bytes in the write cache to be written to the output file.</li> <li><code>void close()</code> \u2192Closes the output stream and frees the resources.</li> </ul>"},{"location":"en/UD1_Files/2_Reading_and_writing_files/#121-solved-exercise","title":"1.2.1. Solved Exercise","text":"<p>Create a simple Java program that copies a file to another file byte to byte. Source and destination file will be indicated on the command line.</p> <p>Solution</p> Java<pre><code>class FileCopy {\n    /*\n    Class to test FileInputStream and FileOutputStream. \n\n    Copy byte to byte of files\n\n    Sintaxi:\n        FileCopy sourceFile destinationFile.\n\n    */\n    public static void main(String[] args) throws Exception {\n        // Byte readed from source\n        int bytes;        \n        // Bytes (effectively) writen to dest\n        long bytesCopied=0; \n\n        // Streams \n\n        FileInputStream fis= null;\n        FileOutputStream fos=null;\n\n        // To provide information about source\n        File f; \n\n\n        // Are the arguments ok?\n        if(args.length!=2){\n            System.out.println(\"Nombre d'arguments erroni. Sintaxi:\\n FileCopy fitxerOrigen fitxerDesti\");\n            return;\n        }\n\n        try{\n\n            // show source size\n            f=new File(args[0]);\n            System.out.println(\"Total: \"+f.length()+\" bytes\");\n\n            // Create streams          \n            fis=new FileInputStream(args[0]);\n            fos=new FileOutputStream(args[1]);\n\n            do {\n                // read one byte from source\n                bytes=fis.read();                 \n                // write in destination\n                if (bytes!=-1)\n                    fos.write(bytes);\n                // Update number of bytes\n                bytesCopied++;                    \n\n                // Show progress (think alternatives as exercise)\n                System.out.print(\"\\rCopiats \"+(bytesCopied-1)+\" bytes...\");\n            }while (bytes!=-1);\n            System.out.println(\"Done it!\");\n\n\n        }catch (IOException exc){\n            System.out.println(\"Error d'entrada i eixida: \"+exc);\n        }finally {\n            // At the end, we have to close the files, either an error exists or not.\n            try {\n                if (fis!=null) fis.close();\n            }catch (IOException exc){\n                System.out.println(\"Error en tancar el fitxer d'origen.\");\n            }\n            try {\n                if(fos!=null) fos.close();\n            }catch (IOException exc){\n                System.out.println(\"Error en tancar el fitxer dest\u00ed.\");\n            }\n        }\n    }\n}\n</code></pre> <p>Think and try</p> <p>With the sample program we have seen, we could copy files of every kind: text, audio, video. Try it as your own and test the content is the same.</p> <p>Challenge</p> <p>Try to change the last program in order to read data in 32 bytes chunks, using the accurate methods of the classes. Share your solution in the forum.</p>"},{"location":"en/UD1_Files/2_Reading_and_writing_files/#13-text-files","title":"1.3. Text Files","text":"<p>As stated, Java allows streams to be managed with either a byte orientation or a character orientation. The abstract classes for managing character-oriented streams are <code>Reader</code> and <code>Writer</code>. These are derived from others, but for the management of files we focus on <code>FileReader</code> and <code>FileWriter</code>.</p>"},{"location":"en/UD1_Files/2_Reading_and_writing_files/#131-filereader","title":"1.3.1. <code>FileReader</code>","text":"<p>The FileReader class serves to access files for reading, and has two constructors:</p> <ul> <li><code>FileReader (File f)</code> \u2192 Receives an object of type <code>File</code>, which will reference the object from which it is to be obtained.</li> <li><code>FileReader (String name)</code> \u2192 Receives a String with the name or path to the file.</li> </ul> <p>The methods we have for this class are pretty much the same as we have for <code>FileInputStream</code>, with the difference that we now read characters instead of bytes. One aspect to consider is that these characters will be represented in the format of the host operating system (UTF-8 in the case of Linux), unlike the UTF-16 used by other internal storage classes:</p> <ul> <li><code>int read()</code> \u2192 Reads the next character from the input stream and returns it as an integer. If there are no characters left, it returns -1, and if there is an error, it throws an exception of type IOException.</li> <li><code>int read(char[] buffer)</code> \u2192 Fills the buffer with as many characters from the input as it has (at most). It returns the number of characters effectively read. This number will be the length of the buffer or less if there are not enough characters to read. If none, return -1.</li> <li><code>int available()</code> \u2192 Returns the number of characters available to read.</li> <li><code>long skip(long des)</code> \u2192 Skips as many characters as the parameter indicates. The return value is the number of characters that have been effectively thrown (they can be less than what we have indicated if we reach the end for example)</li> <li><code>int close()</code> \u2192 Closes the data stream</li> </ul>"},{"location":"en/UD1_Files/2_Reading_and_writing_files/#132-filewriter","title":"1.3.2. <code>FileWriter</code>","text":"<p>The FileWriter class would be the equivalent of <code>FileOutputStream</code> in character-oriented streams version. The class constructors are:</p> <ul> <li><code>FileWriter (File f)</code> \u2192 Opens the file specified by <code>File</code> for writing. If the file does not exist, it will be created, and if it exists, it will delete the contents.</li> <li><code>FileWriter (String name)</code> \u2192 Opens the file specified by a string with name and path in writing mode. If it does not exist, it will be created, and if it exists, it will delete the content</li> <li><code>FileWriter (File f, boolean append)</code> \u2192 Receives an object of type File and opens it in append mode, to write at the end. If it doesn't exist, it will be created, and if it exists, it will write behind it.</li> <li><code>FileWriter (String name_f, boolean append)</code> \u2192 Receives a string with the name or path of the location of the file to be written and opens it in append mode, to write at the end. If it doesn't exist, it will be created, and if it exists, it will write behind it.</li> </ul> <p>The main methods of the FileWriter class are very similar to those of <code>OutputStream</code>:</p> <ul> <li><code>write(int character)</code> \u2192 Writes the character to the output stream, with the operating system's own encoding. If there is an error, an IOException is thrown.</li> <li><code>void write(char[] buffer)</code> \u2192 Writes the contents of the buffer (character vector) to the file. If the buffer is null, it will throw an exception.</li> <li><code>void write(char[] buffer, int pos, int length)</code> \u2192 Writes the contents of the buffer (character array) from position pos, and as many bom bytes are given in length.</li> <li><code>void flush()</code> \u2192 Forces the remaining bytes in the write cache to be written to the output file.</li> <li><code>void close()</code> \u2192 Closes the output stream and frees the resources.</li> <li><code>void write(String text)</code> \u2192 Writes the entire text content to the file.</li> </ul>"},{"location":"en/UD1_Files/2_Reading_and_writing_files/#133-solved-exercise","title":"1.3.3. Solved Exercise","text":"<p>Create a simple Java program that merge all the files inside a folder in a unique file. The source folder and destination file will be indicated in program's call. We suppose all the files inside that folder are text files.</p> <p>Solution</p> Java<pre><code>class MergeTexts {\n    /*\n\n\n    Sintax:\n        MergeTexts DirectoriOrigen FitxerDest\u00ed\n\n    */\n    public static void main(String[] args) throws Exception {\n\n        File dir; // Source dir\n        // Collection of files from that dir\n        File[] files; \n\n        // readed characters\n        int characters;\n\n        // Input and Output Streams \n        FileReader fin=null;\n        FileWriter fout=null;\n\n        // Check the args\n        if(args.length!=2){\n            System.out.println(\"Nombre d'arguments erroni. Sintaxi:\\n mergeTexts DirectoriOrigen fitxerDesti\");\n            return;\n        }\n\n        try{\n\n            // We get the list of Files\n            dir=new File(args[0]);\n            files=dir.listFiles();\n\n\n            // Open and close output stream (in order to create the file)\n            fout=new FileWriter(args[1]);\n            fout.close();\n\n            // Re-open it\n            fout=new FileWriter(args[1], true);\n\n            // Iterate among the list\n            for (int i=0; i&lt;files.length; i++){\n                // open input stream\n                fin=new FileReader(args[0]+\"/\"+files[i].getName());\n                System.out.println(\"Merging \"+args[0]+\"/\"+files[i].getName());\n                // and merge to the output one\n                do {\n                    characters=fin.read();                 \n                    if (characters!=-1)\n                        fout.write(characters);\n                }while (characters!=-1);\n                fin.close(); //close the file merged\n\n            }\n            fout.close(); //close the output file\n\n        }catch (Exception exc){\n            // Catch all the exception (we coud improve it)\n            System.out.println(\"Input/Output error: \"+exc);\n        }\n    }\n}\n</code></pre> <p>Improve your code</p> <p>Try to improve the last code creating a <code>merge()</code> function. We should call it inside the main loop</p>"},{"location":"en/UD1_Files/2_Reading_and_writing_files/#14-decorators","title":"1.4. Decorators","text":"<p>Decorator Design Pattern</p> <p>Decorator classes are those that inherit from a certain class, and they provide added functionality to the original. In the case of input and output streams, we have decorators that allow us to read or write complete lines, instead of byte by byte, or save certain data format. It simplifies our work, adding a more natural and human-friendly way to use the base classes.</p> <p>The <code>InputStream</code> class has several decorators, but we'll stick with the following:</p> <ul> <li><code>DataInputStream</code> \u2192 Allows reading data of any type (integer, logical, etc.)</li> <li><code>ObjectInputStream</code> \u2192 Add the option to reads an entire object</li> </ul> <p>The <code>OutputStream</code> class, on the other hand, also has different decorators, among which we highlight:</p> <ul> <li><code>DataOutputStream</code> \u2192 Allows writing data of any type (integer, logical, etc.)</li> <li><code>PrintStream</code> \u2192 Allows writing data of any type, and also accepts <code>printf</code> and <code>println</code> methods</li> <li><code>ObjectOutputStream</code> \u2192 Allows writing (serializing) objects</li> </ul> <p>Regarding the decorator classes for character-oriented streams, we have, on the one hand, the (most prominent) <code>Reader</code> decorators:</p> <ul> <li><code>BufferedReader</code> \u2192 Creates an input buffer, allowing for example to read a complete line</li> </ul> <p>And for writer:</p> <ul> <li><code>BufferedWriter</code> \u2192 Creates an output buffer, allowing for example to write a full line</li> <li><code>PrintWriter</code> Allows the writing of data of different types, and has methods such as printf and println</li> </ul> <p>The <code>BufferedReader</code> class, among others, has the <code>readLine()</code> method, which allows reading an entire line of the file up to the end of the line, very useful in text files.</p> <p>On their behalf, the BufferedWriter class provides the <code>newLine()</code> method to enter the carriage return character, and the <code>write(String chain, int start, int length)</code> method to write a string or a specific part.</p> <p>The other decorator for writing is the <code>PrintWriter</code>, which offers us the methods <code>print(data)</code>, <code>println(data)</code> and <code>printf()</code>, for formatting.</p> <p>Alternatives to...</p> <p>Obviously, you could :</p> <ul> <li>concatenate <code>\\n</code> at the end of every String on every <code>print()</code> method instead calling <code>newLine()</code>.</li> <li>use <code>println()</code> instead calling <code>newLine()</code>.</li> </ul>"},{"location":"en/UD1_Files/2_Reading_and_writing_files/#141-solved-exercise","title":"1.4.1. Solved Exercise","text":"<p>Create a program to copy a text file adding the number lines at the beginning of each line.</p> <p>Solution</p> Java<pre><code>public class NumberLines {\n    public static void main(String[] args) throws Exception {\n\n        // Input and Output\n        BufferedReader fin;\n        PrintWriter fout;\n\n        // line counter\n        int num_linia;\n        // readed line\n        String linia;\n\n        // check args\n        if (args.length != 2) {\n            System.out.println(\"Nombre d'arguments erroni. Sintaxi:\\n numberLines fitxer eixida\");\n            return;\n        }\n\n        // Creare decorators\n        fin = new BufferedReader(new FileReader(args[0]));\n        fout = new PrintWriter(new FileWriter(args[1]));\n\n        num_linia = 1;\n        do {\n            // Read the line\n            linia = fin.readLine();\n            if (linia != null) {\n                fout.println(num_linia + \". \" + linia);\n            }\n            num_linia++;\n        } while (linia != null); // until we can't read\n\n        // close all\n        fin.close();\n        fout.close();\n\n    }\n}\n</code></pre>"},{"location":"en/UD1_Files/2_Reading_and_writing_files/#15-binary-files","title":"1.5. Binary Files","text":"<p>In this section and the following we will see how to storage different types of data and objects in files of different formats: binary files, XML or JSON files. Now, we will focus on binary files, both for storing structured data on the one hand, and objects, on the other, a process known as serialization.</p>"},{"location":"en/UD1_Files/2_Reading_and_writing_files/#151-storing-structured-data-in-binary-files","title":"1.5.1. Storing structured data in binary files","text":"<p>In the previous section we saw how to work with character and byte files. In the case of byte files, we have seen how to read and write them sequentially, byte by byte to the end of the file. Let's now see how to store structured data in binary files and how to be able to read them.</p> <p>Let's imagine that we want to save the following table, which combines data of different types. This sample will appear in next sections.</p> Module Hours Qualification Acc\u00e9s a Dades 6 8.45 Programaci\u00f3 de serveis i processos 3 9.0 Desenvolupament d'interf\u00edcies 6 8.0 Programaci\u00f3 Multim\u00e8dia i dispositius m\u00f2bils 5 7.34 Sistemes de Gesti\u00f3 Empresarial 5 8.2 Empresa i iniciativa emprenedora 3 7.4 <p>As we can see, we have text data, integer and floating point numeric data. If we want to maintain the types, character-oriented streams like <code>Reader</code> or <code>Writer</code> will not be useful, so we should use <code>InputStream</code> and <code>OutputStream</code>. The disadvantage is that it would be necessary to know exactly how many bytes each type of data occupies.</p> <p>In order to efficiently save these structures, we can make use of the <code>DataInputStream</code> and <code>DataOutputStream</code> classes, which are stream decorators and which offer us the following methods to save or retrieve data of different types, without worrying about what they occupy internally each. As you can see, there are reciprocal methods to read and write every base types.</p> <code>DataInputStream</code> <code>DataOutputStream</code> Description <code>byte readByte()</code> <code>void writeByte(int)</code> a byte <code>short readShort()</code> <code>void writeShort(short)</code> short int <code>int readInt()</code> <code>void writeInt(int)</code> an int <code>long readLong()</code> <code>void writeLong(long)</code> a long int <code>float readFloat()</code> <code>void writeFloat(float)</code> single precision <code>double readDouble()</code> <code>void writeDouble(double)</code> double precision <code>char readChar()</code> <code>void writeChar(int)</code> a Unicode char <code>String readUTF()</code> <code>void writeUTF(String)</code> a UTF-8 string <p>Warning</p> <p>A UTF-8 string is different of a single String. When a String is written, as is evident, the whole characters are storage. Saving it as UTF-8 string, add information about the string's length, and this information is essential to cut this strings when you will read in a future.</p> <p>Imagine you save two strings, \"euro\" and \"sport\". The result will be, at the end \"eurosport\". When somebody open this file in the future, how do he or she know the number of string stored (\"euro\", \"sport\" or simply \"eurosport\" (TV channel))</p> <p>Saving as UTF-8, when you save \"euro\" and \"sport\", the result is \"4euro5sport\". When somebody try to read it, first of all see a '4', and read \"euro\". Then, see a '5', and then read \"sport\". Notice that if \"eurosport\" is stored, the result is \"9eurosport\". Try to write a sample program with this string, opening the resulting file with amn hexadecimal editor.</p>"},{"location":"en/UD1_Files/2_Reading_and_writing_files/#152-solved-exercise","title":"1.5.2. Solved exercise","text":"<p>Write a program who has data stored in three parallel arrays, storing modules data of DAM. Write two functions, one for write this data on a file and another to read it. Consider to storage data group by module, instead name, hours and grade.</p> <p>Soluci\u00f3</p> Java<pre><code>public class Moduls{\n\n    // several arrays with modules data\n    String[] moduls={\"Acc\u00e9s a Dades\", \"Programaci\u00f3 de serveis i processos\", \"Desenvolupament d'interf\u00edcies\", \"Programaci\u00f3 Multim\u00e8dia i dispositiud m\u00f2bils\", \"Sistemes de Gesti\u00f3 Empresarial\", \"Empresa i iniciativa emprenedora\"};\n    int[]  hores={6, 3, 6, 5, 5, 3};\n    double[] notes={8.45, 9.0, 8.0, 7.34, 8.2, 7.4};\n\n    public void readFiLe(String name) throws IOException {\n        // Per lleginr el fitxer binari, creem un DataInputStream\n        // a partir del FileInputStream creat a partir del nom\n        DataInputStream f = new DataInputStream(new FileInputStream(name));\n\n        // Mentre el DataInputStream tinga dades disponibles\n        while (f.available()&gt;0){\n            // Llegirem del fitxer cada dada, amb l'ordre corresponent\n            // en funci\u00f3 del tipus\n            // (per tant, hem de saber l'ordre en qu\u00e8 guardem!)\n            System.out.println(\"M\u00f2dul: \" + f.readUTF());\n            System.out.println(\"Hores: \" + f.readInt());\n            System.out.println(\"Notes: \" + f.readDouble());\n            System.out.println();\n        }\n        f.close();\n    }\n\n    public void writeFile(String name) throws IOException{\n        // Per escriure el fitxer, fem \u00fas de DataOutputStream\n        DataOutputStream f = new DataOutputStream(new FileOutputStream(name));\n\n        // Recorrerem qualsevol dels vectors (tots haurien de tindre)\n        // la mateixa longitud\n        for (int i=0;i&lt;this.moduls.length;i++){\n            // I per a cada posici\u00f3, escriurem en funci\u00f3 del tipus de dada\n            f.writeUTF(this.moduls[i]);\n            f.writeInt(this.hores[i]);\n            f.writeDouble(this.notes[i]);\n\n        }\n        f.close();\n    }\n\n    public static void main(String[] args) throws IOException {\n\n        // Comprovem els arguments\n        if (args.length!=2){\n            System.out.println(\"Nombre d'arguments incorrecte.\\n\\nSintaxi: \\n\\t java Moduls [read | write] fitxer.dat\");\n            System.exit(0);\n        }\n\n        // Defining the class\n        Moduls moduls=new Moduls();\n\n        // Depending the args, we will proceed\n        if (args[0].equals(\"read\")) \n        moduls.readFiLe(args[1]);\n        else if (args[0].equals(\"write\")) \n        moduls.writeFile(args[1]);\n        else \n        System.out.println(\"No entenc l'ordre \"+args[0]+\"\\n\");\n    }\n}\n</code></pre>"},{"location":"en/UD1_Files/2_Reading_and_writing_files/#16-object-serialization","title":"1.6. Object serialization","text":"<p>Java provides a generic object serialization system: a recursive system that iterates over each object contained in an instance, until it reaches the primitive types, which it stores as an array of bytes. Apart from this information of the primitive types, additional information is also stored, or metadata specific to each class, such as the name or attributes among others. Thanks to this metadata, which describes the objects we save, we can automate serialization in a generic way, ensuring that we can read the objects later.</p> <p>The disadvantage of this method is that when we change the definition of the class (for example adding one more attribute, or changing its type), the metadata is modified, and we would not be able to read serialized objects with previous versions of the class In addition, it is also necessary to take into account that this is a specific mechanism of Java, and that we will not be able to consult these objects from other languages.</p> <p>For all of this, other techniques are preferable for the permanent storage of objects, which we will see later, but serialization can be useful for temporary storage, within the same execution of the application.</p> <p>What are this?</p> Text Only<pre><code>**Research:** try to find information about ***SerialVersionUID***, and what it use is important for.\n</code></pre>"},{"location":"en/UD1_Files/2_Reading_and_writing_files/#161-the-serializable-interface-and-decorators","title":"1.6.1. The <code>Serializable</code> interface and <code>Decorators</code>","text":"<p>If we want a class to be serializable, it must implement the Serializable interface, the purpose of which is simply to act as a marker to indicate to the JVM that the class can be serialized, so this class will have no methods.</p> <p>It should be said that all the classes corresponding to the basic types already implement the Serializable interface, as well as the String class, containers and Arrays. In the case of collections, it will depend on its contents, if its elements are serializable, the collection will be as well. If the object we want to serialize or those of any of its objects do not implement the Serializable interface, the exception <code>NotSerializableException</code> is thrown.</p> <p>The <code>ObjectInputStream</code> and <code>ObjectOutputStream</code> decorators offer us the ability to serialize any de-serializable object. In order to write an object, we will make use of the <code>writeObject</code> method of <code>ObjectOutputStream</code>, and to read it we will make use of <code>readObject</code>, of <code>ObjectInputStream</code>. </p> <p>Sheeps with sheeps</p> <p>Note that reading objects must be done on instances of the same class that was saved. Otherwise, a <code>ClassCastException</code> is thrown. Also, you must have the compiled code of the class, to avoid the <code>ClassNotFoundException</code> exception. </p> <p>In addition, <code>readObject</code> return an Object, and we need an object of a specific class. For this reason you have to cast from Object to the needed class. Inheritance concepts are very important to guarantee robust programs. </p>"},{"location":"en/UD1_Files/2_Reading_and_writing_files/#162-solved-exercise","title":"1.6.2. Solved exercise","text":"<p>Starting with the same base of the <code>Moduls</code> class in the previous exercise, we are going to create a <code>Modul</code> class, to store a single module. This kind of classes are called POJO's (Plain Old Java Objects), and are designed only to storage information. (It will appear later, togethre with BEAN's classes).</p> <p>Once the <code>Modul</code> class is created, write a program to save on a file objects directly. Later, write the complementary function to read all the stored objects from that file. </p> <p>Solution</p> Java<pre><code>/**\n    Class to storage a single module in memory\n*/\n\nclass Modul implements Serializable{\n    String nom;\n    int hores;\n    double nota;\n\n    public Modul(){\n        // Constructor buit\n    }\n\n    public Modul(String nom, int hores, double nota){\n        this.nom=nom;\n        this.hores=hores;\n        this.nota=nota;\n    }\n\n    public String getModul() {return this.nom;}\n    public int getHores() {return this.hores;}\n    public double getNota() {return this.nota;}\n} \n\n/**\n    Write and Read modules to/from file\n*/\n\npublic class Moduls2 {\n\n    // Arrays with source data\n    String[] moduls = {\"Acc\u00e9s a Dades\", \"Programaci\u00f3 de serveis i processos\", \"Desenvolupament d'interf\u00edcies\", \"Programaci\u00f3 Multim\u00e8dia i dispositiud m\u00f2bils\", \"Sistemes de Gesti\u00f3 Empresarial\", \"Empresa i iniciativa emprenedora\"};\n    int[] hores = {6, 3, 6, 5, 5, 3};\n    double[] notes = {8.45, 9.0, 8.0, 7.34, 8.2, 7.4};\n\n    public void EscriuObjecte(String nom) throws IOException {\n\n        //destination file\n        ObjectOutputStream f = new ObjectOutputStream(new FileOutputStream(nom));\n\n        Modul m; // Single object\n\n        // loop along the arrays\n        for (int i = 0; i &lt; this.moduls.length; i++) {\n            m = new Modul(this.moduls[i], this.hores[i], this.notes[i]);\n            f.writeObject(m);\n        }\n\n        // close the file\n        f.close();\n\n    }\n\n    public void LligObjecte(String nom) throws IOException, ClassNotFoundException {\n\n        // input file\n        ObjectInputStream f = new ObjectInputStream(new FileInputStream(nom));\n\n        Modul m;\n        // we don't know how many objects exists in the file.\n        try {\n            while (true) { // forever\n\n                m = (Modul) f.readObject();\n\n                // show the module\n                System.out.println(\"Modul: \" + m.getModul());\n                System.out.println(\"Hores: \" + m.getHores());\n                System.out.println(\"Nota: \" + m.getNota());\n                System.out.println();\n\n            }\n        } catch (EOFException ex) {\n            f.close();\n        }\n\n    }\n\n    public static void main(String[] args) throws IOException, ClassNotFoundException {\n\n        // test the args\n        if (args.length != 2) {\n            System.out.println(\"Nombre d'arguments incorrecte.\\n\\nSintaxi: \\n\\t java Moduls2 [ read | write ] fitxer.obj\");\n            System.exit(0);\n        }\n\n        Moduls2 moduls = new Moduls2();\n\n        // depending the args\n        if (args[0].equals(\"read\")) {\n            moduls.LligObjecte(args[1]);\n        } else if (args[0].equals(\"write\")) {\n            moduls.EscriuObjecte(args[1]);\n        } else {\n            System.out.println(\"No entenc l'ordre \" + args[0] + \"\\n\");\n        }\n\n    }\n\n}\n</code></pre> <p>Less work, but the same in the end</p> <p>You probably will think about it: If all in Java inherits from Object, an ArrayList is an Object...Can I save or load an entire ArrayList in one unique call?. Try it as an improvement of the last exercise.</p>"},{"location":"en/UD1_Files/3_XML_Files/","title":"1. XML Files","text":""},{"location":"en/UD1_Files/3_XML_Files/#11-why-xml","title":"1.1. Why XML?","text":"<p>When we want to save data that can be read by different applications and platforms, it is best to use standard storage formats that multiple applications can understand (portability). A very specific case is markup languages, and the best known is the XML (eXtensible Markup Language) standard.</p> <p>With XML documents we structure the information by inserting marks or tags between the information. These tags have a beginning and an end, and can nest inside others, as well as contain textual information. Since the information will be textual, we don't have the problem of different data representation, since any data, of whatever type, will be passed to text. In order to also avoid the problem of different text encoding systems, XML allows the encoding used to save the document to be included in the header of the document.</p> <p>The way to store information in XML, in a hierarchical way, is very similar to the way objects in an application do it, so that these can be translated in a relatively convenient way to an XML document. Starting with our previous sample:</p> Module Hours Qualification Acc\u00e9s a Dades 6 8.45 Programaci\u00f3 de serveis i processos 3 9.0 Desenvolupament d'interf\u00edcies 6 8.0 Programaci\u00f3 Multim\u00e8dia i dispositius m\u00f2bils 5 7.34 Sistemes de Gesti\u00f3 Empresarial 5 8.2 Empresa i iniciativa emprenedora 3 7.4 <p>can be represented with only tags or labels <code>xml</code>:</p> XML<pre><code>&lt;curs&gt;\n    &lt;modul&gt;\n      &lt;nom&gt;Acc\u00e9s a Dades&lt;/nom&gt;\n      &lt;hores&gt;6&lt;/hores&gt;\n      &lt;qualificacio&gt;8.45&lt;/qualificacio&gt;\n    &lt;/modul&gt;\n    &lt;modul&gt;\n      &lt;nom&gt;Programaci\u00f3 de serveis i processos&lt;/nom&gt;\n      &lt;hores&gt;3&lt;/hores&gt;\n      &lt;qualificacio&gt;9.0&lt;/qualificacio&gt;\n    &lt;/modul&gt;\n    &lt;modul&gt;\n      &lt;nom&gt;Desenvolupament d'interf\u00edcies&lt;/nom&gt;\n      &lt;hores&gt;6&lt;/hores&gt;\n      &lt;qualificacio&gt;8.0&lt;/qualificacio&gt;\n    &lt;/modul&gt;\n    &lt;modul&gt;\n      &lt;nom&gt;Programaci\u00f3 Multim\u00e8dia i dispositiud m\u00f2bils&lt;/nom&gt;\n      &lt;hores&gt;5&lt;/hores&gt;\n      &lt;qualificacio&gt;7.34&lt;/qualificacio&gt;\n    &lt;/modul&gt;\n    &lt;modul&gt;\n      &lt;nom&gt;Sistemes de Gesti\u00f3 Empresarial&lt;/nom&gt;\n      &lt;hores&gt;5&lt;/hores&gt;\n      &lt;qualificacio&gt;8.2&lt;/qualificacio&gt;\n    &lt;/modul&gt;\n    &lt;modul&gt;\n      &lt;nom&gt;Empresa i iniciativa emprenedora&lt;/nom&gt;\n      &lt;hores&gt;3&lt;/hores&gt;\n      &lt;qualificacio&gt;7.4&lt;/qualificacio&gt;\n    &lt;/modul&gt;\n&lt;/curs&gt;\n</code></pre> <p>or can be represented with tags and attributes:</p> <p>XML<pre><code>&lt;curs&gt;\n    &lt;modul nom=\"Acc\u00e9s a Dades\" hores=\"6\" qualificacio=\"8.45\" &gt;\n    &lt;modul nom=\"Programaci\u00f3 de serveis i processos\" \"hores\"=3 qualificacio=\"9.0\" &gt;\n    &lt;modul nom =\"Desenvolupament d'interf\u00edcies\" hores=\"6\" qualificacio=\"8.0\" &gt;\n    &lt;/modul&gt;\n    &lt;modul nom=\"Programaci\u00f3 Multim\u00e8dia i dispositiud m\u00f2bils\" hores=\"5\" qualificacio=\"7,34\"&gt;\n    &lt;modul nom=\"Sistemes de Gesti\u00f3 Empresarial\" hores=\"5\" \"qualificacio\"=8.2 /&gt;\n    &lt;modul nom=\"Empresa i iniciativa emprenedora\"  hores=\"3\" qualificacio=\"7.4\" /&gt;\n    &lt;/modul&gt;\n&lt;/curs&gt;\n</code></pre> An XML parser or analyzer is a class that allows you to analyze an XML file and extract information from it, relating it according to its position in the hierarchy. The analyzers, according to their way of functioning, can be:</p> <ul> <li>Sequential or syntactic analyzers, which extract the content as the opening and closing tags are discovered. They are very fast, but have the problem that you have to read the whole document in order to access a specific part. In Java there is the SAX (Simple API for XML) parser as a sequential parser.</li> <li>Hierarchical analyzers, which are usually the most used, and which save all the data of the XML document in memory, in the form of a hierarchical structure (DOM or Document Object Model, being the preferred ones for applications that have to read the data more continuously.</li> </ul>"},{"location":"en/UD1_Files/3_XML_Files/#12-the-document-object-model-dom","title":"1.2. The Document Object Model (DOM)","text":"<p>The DOM (Document Object Model) is the structure specified by the W3C where the information of XML documents is stored. The DOM has been linked mainly to the web world, with HTML and Javascript as the main drivers. In Java, the DOM is implemented using interfaces.</p> <p>The main interface of the DOM in Java is <code>Document</code>, and it represents the entire XML document. Since it is an interface, it can be implemented in several classes.</p> <p>Note</p> <p>An interface is a kind of template for building classes, and is generally composed of a set of unimplemented method header declarations that specify how one or more classes behave. In addition, a class can implement one or more interfaces. In this case, the class will have to declare and define all the methods of each of the interfaces, or declare itself as an abstract class.</p> <p>An interface should also not be confused with an abstract class, as there are some differences, as the interface has all abstract methods; cannot declare instance variables; a class can implement several interfaces, but not inherit from several superclasses; and the interface does not have to belong to any hierarchy, so that classes that do not have any inheritance relationship can implement the same interface.</p> <p>Apart from <code>Document</code>, the W3C also defines the abstract class <code>DocumentBuilder</code>, which allows to create the DOM from the XML. In addition, the <code>DocumentBuilderFactory</code> class is specified, which allows us to manufacture <code>DocumentBuilders</code>, since being abstract it cannot be instantiated directly.</p> <p>It should be said, as a warning, that Java offers many libraries from which to import Document. The libraries we will use to parse XMLs will be:</p> <ul> <li>The <code>java.xml.parsers.*</code> library, which will offer the <code>DocumentBuilderFactory</code> and <code>DocumentBuilder</code> classes, and</li> <li>The <code>org.w3c.dom.*</code> library for the <code>Document</code> class.</li> </ul>"},{"location":"en/UD1_Files/3_XML_Files/#121-documentbuilder-and-documentbuilderfactory","title":"1.2.1. <code>DocumentBuilder</code> and <code>DocumentBuilderFactory</code>","text":"<p>As discussed, <code>DocumentBuilder</code> defines an API for obtaining DOM instances from an XML document. In order to obtain an instance of the class, the <code>DocumentBuilderFactory</code> factory must be used, and specifically the <code>newDocumentBuilder()</code> method:</p> <p>On the other hand, in order to read and interpret the XML document, the <code>DocumentBuilderFactory</code> class provides the <code>parse()</code> method, which parses an XML indicated by a File, and returns a Document object.</p> <p>Let's see everything with an example. We continue with storing data about course modules, but now with XML. The following method will serve us, in order to open an XML document, parse it and return the DOM generated in a Document. We can use it everywhere in our programs, because the task is always similar:</p> Java<pre><code>public Document OpenXML(String name) throws IOException,SAXException, ParserConfigurationException, FileNotFoundException {\n\n    // Create an instance of DocumentBuilderFactory\n    DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n    // Using the DocumentBuilderFactory instance we create a DocumentBuilder\n    DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n    //And we use DocumentBuilder's \"parse\" method to get the document\n    Document doc = dBuilder.parse(new File(name));\n\n    return document;\n}\n</code></pre> <p>It should be said that the above function could have been simplified without using the intermediate statements, but it is a little offuscated:</p> Java<pre><code>public Document OpenXML(String name) throws IOException,SAXException, ParserConfigurationException, FileNotFoundException {\n     return DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(name);\n}\n</code></pre> <p>On the other hand, the <code>DocumentBuilder</code> class also allows us to create a new DOM, with the <code>newDocument()</code> method. This will serve us later in order to store the XML documents. The proceeding way is:</p> <ul> <li>First thing, we will have to do is create a new DOM with newDocument()</li> <li>Add the elements and </li> <li>then store it on a file. </li> </ul> <p>In later sections, we will see how to do all this. For now we're going to focus on interpreting and reading the DOM.</p> <p>You can visit this links in order to find more information about the DocumentBuilder and DocumentBuilderFactory classes can be found in the OpenJDK API:</p>"},{"location":"en/UD1_Files/3_XML_Files/#13-classes-and-methods-of-dom","title":"1.3. Classes and Methods of DOM","text":"<p>So far we've seen how to open and parse an XML document with DocumentBuilder to create an object of type Document. In this section we will see how to work with this document in order to access the different elements. As we know, the DOM has a hierarchical structure, made up of nodes. The different types of nodes we can find are:</p> <ul> <li><code>Document</code> \u2192 which is the main node and represents all the XML.</li> <li><code>Element</code> \u2192 which represents the different tags (including the root). In other words, all tags are Elements, ones nested inside othres.</li> <li><code>TextElement</code> \u2192 which represents the content of a text tag.</li> <li><code>Attribute</code> \u2192 which represents the attributes.</li> </ul> <p>All these interfaces derive from the <code>Node</code> interface, so they will inherit its attributes and methods, and in addition, they will provide their own attributes and methods.</p> <p>Let's see the most important methods of each interface:</p>"},{"location":"en/UD1_Files/3_XML_Files/#131-node-interface-methods","title":"1.3.1. Node interface methods","text":"<p>Methods related to obtaining information</p> <ul> <li><code>String getNodeName()</code> \u2192 Gets the name of the current node</li> <li><code>short getNodeType()</code> \u2192 Gets the node type (ELEMENT_NODE, ATTRIBUTE_NODE, TEXT_NODE...)</li> <li><code>String getNodeValue()</code>\u2192 Gets the value of the node</li> <li><code>NodeList getChildNodes()</code> \u2192 Gets a list with child nodes</li> <li><code>Node getFirstChild()</code> \u2192 Returns the first child</li> <li><code>Node getLastChild()</code> \u2192 Returns the last child</li> <li><code>NamedNodeMap getAttributes()</code> \u2192 Returns a list with the attributes of the node</li> <li><code>Node getParentNode()</code> \u2192 Returns the parent node</li> <li><code>String getTextContent()</code> \u2192 Returns the text contained in the element and its descendants</li> <li><code>boolean hasChildNodes()</code> \u2192 Returns true if the node has any children</li> <li><code>boolean hasAttributes()</code> \u2192 Returns true if the node has any attributes</li> </ul> <p>Methods related to writing</p> <ul> <li><code>Node appendChild(Node node)</code> \u2192 Appends a new node as the last child node.</li> <li><code>void removeChild(Node node)</code> \u2192 Removes the specified node from the child nodes.</li> </ul>"},{"location":"en/UD1_Files/3_XML_Files/#132-element-interface-methods","title":"1.3.2. Element interface methods:","text":"<p>Methods related to obtaining information</p> <ul> <li><code>String getAttribute(String name)</code> \u2192 Returns the value of the attribute given by name.</li> <li><code>NodeList getElementsByTagName(String name)</code> \u2192  Returns a list of child nodes that match the given name.</li> <li><code>boolean hasAttribute(String name)</code> \u2192 Returns true if the element has the given attribute.</li> </ul> <p>Methods related to writing</p> <ul> <li><code>void setAttribute(String name, String value)</code> \u2192 Adds an attribute to the element, with the given name and value.</li> <li><code>void removeAttribute(String name)</code> \u2192 Removes the attribute indicated by name.</li> </ul>"},{"location":"en/UD1_Files/3_XML_Files/#133-document-interface-methods","title":"1.3.3. Document interface methods:","text":"<p>Methods related to obtaining information</p> <ul> <li><code>Element getDocumentElement()</code> \u2192  Returns the root element of the document.</li> <li><code>NodeList getElementsByTagName(String name)</code> \u2192  Returns a list of child nodes that match the given name</li> </ul> <p>Methods related to writing</p> <ul> <li><code>Element createElement(String name)</code> \u2192 Creates a new element with the given name.</li> <li><code>Text createTextNode(String text)</code> \u2192 Creates a new text element.</li> <li><code>Node appendChild(Node node)</code> \u2192 Appends a new child node.</li> </ul> <p>Objects of type <code>NodeList</code>, which represent a list of nodes, offer the <code>item(int index)</code> method to access the different nodes in the list, indicating their order.</p>"},{"location":"en/UD1_Files/3_XML_Files/#14-reading-xml-files","title":"1.4. Reading XML files","text":"<p>Let's go to review all concepts in this section with a practice. We are going to create a class who includes all the necessary methods to open, read, show and write XML files. We work with the document in section \\ref{xmlDoc}. </p> <p>In order to start reading the document, the first thing we will have to do is get the root of the document, with <code>getDocumentElement()</code>, which returns an object of type <code>Element</code>. Remember that doc variable contains the whole DOM, read with method explained previously: Java<pre><code>Element root = doc.getDocumentElement();\n</code></pre></p> <p>With this root element, we could already display all the content with <code>getTextContent()</code>. It will show on screen as text format, only print:</p> Java<pre><code>System.out.println(root.getTextContent());\n</code></pre> <p>But what we're interested in is traversing the entire DOM and accessing its elements. For this, starting from this root element, we will follow the following steps:</p> <ol> <li>We will search for all <code>&lt;modul&gt;</code> tags with <code>getElementsByTagName</code>. This method returns us a list of nodes (object of type <code>NodeList</code>). </li> <li>It will be necessary to traverse the list of nodes (<code>NodeList</code>) to access each element. For this, you must use the <code>item(int index)</code> method, which will return an element of type <code>Node</code>, and which must be converted to <code>Element</code> explicitly with a cast operation.</li> <li>For each element, we'll access the node name to display the name and order, using <code>getNodeName()</code></li> <li>We look for the different tags found within each module ('name', 'hours' and 'grade') with <code>getElementsByTagName()</code>. This method have given us again a NodeList for each type of tag. Since we will only have one item, we only need to access the unique element, represented by <code>item(0)</code>.</li> <li>It should be noted that with the above we will have the first (and only) label 'name', 'hours' or 'grade' of the module, but we are not yet in the content, since this is an element of type <code>TEXT_NODE</code>. To access it, we will have to access the first child of the tag (<code>getFirstChild()</code>) and get its value with <code>getNodeValue()</code></li> </ol> Java<pre><code>    // We will get a list of nodes (Step 1)\n    NodeList modules = root.getElementsByTagName(\"modul\");\n\n    // For each node (Step 2)\n    for (int i = 0; i &lt; modules.getLength(); i++) {\n        Element el = (Element) modules.item(i);\n\n        // Display the node name (Step 3)\n        System.out.println(el.getNodeName() + \" \" + (i + 1));\n\n        // And we show the value of the different tags \n        System.out.println(\"Nom: \" + el.getElementsByTagName(\"nom\").item(0).getFirstChild().getNodeValue());\n        System.out.println(\"Hores: \" + el.getElementsByTagName(\"hores\").item(0).getFirstChild().getNodeValue());\n        System.out.println(\"Qualificaci\u00f3: \" + el.getElementsByTagName(\"qualificacio\").item(0).getFirstChild().getNodeValue());\n        System.out.println();\n    }\n}\n</code></pre>"},{"location":"en/UD1_Files/3_XML_Files/#15-writing-xml-files","title":"1.5. Writing XML Files","text":"<p>Now let's go to the writing part of the XML documents. For this, we will start from a file that already contains the information in binary format of the modules (for example from previous section), we will read it, and we will import its information in XML format.</p> <p>The first thing we need to do is read the object file using an <code>ObjectInputStream</code>:</p> Java<pre><code>ObjectInputStream f = new ObjectInputStream(new FileInputStream(file));\n</code></pre> <p>And create an empty Xml Document, using the <code>DocumentBuilder</code> and <code>DocumentBuilderFactory</code> classes:</p> Java<pre><code>Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n</code></pre> <p>Once we have the empty document, we create the root element (curso), and add it to the document:</p> Java<pre><code>Element root = doc.createElement(\"curso\");\ndoc.appendChild(root);\n</code></pre> <p>Remember that we will access the object file, so we will have to know exactly what the class we want to read is like, and access the corresponding methods in order to obtain information about it. For this, first, you need to define an object of type <code>Modul</code>, and we will read the object file with the <code>readObject</code> method of File. Once we have read an object, we will create the tag that encompasses each of them: the <code>modul</code> tag:</p> Java<pre><code>Modul m = (Modul) f.readObject();\nElement modul = doc.createElement(\"modul\");\n</code></pre> <p>And inside it, and as we extract the different properties of the Modul object, we will create child nodes and add them to the module. For example, for module name:</p> Java<pre><code>Element name = doc.createElement(\"nom\");\nname.appendChild(doc.createTextNode(m.getModul()));\nmodule.appendChild(name);\n</code></pre> <p>As we can see, we have created an object of type Element with the label 'name', and we have added as a child a node of type text (TEXT_NODE), which we have extracted directly from the object <code>Modul m</code> with its own function <code>getModul()</code>. Additionally, we added this tag to the <code>&lt;modul&gt;</code> tag, with appendChild.</p> <p>We will have to do the same for the hours of each module and the qualification, but for this, we will have to take into account that the getHores and getNota methods do not return a String, but an int and a double, so they will have to be converted to text:</p> Java<pre><code>Element hours = doc.createElement(\"hores\");\nhours.appendChild(doc.createTextNode(Integer.toString(m.getHores())));\nmodule.appendChild(hours);\n\nElement qualification = doc.createElement(\"qualificacio\");\nqualification.appendChild(doc.createTextNode(Double.toString(m.getNote())));\nmodule.appendChild(grade);\n</code></pre> <p>We'll put this entire procedure inside a loop that slides the entire object file. Once we have read each of the modules, we will have to add them to the root element with:</p> Java<pre><code>root.appendChild(module);\n</code></pre> <p>And we will already have our XML document at the root. Now we would have to convert this object of type <code>Element</code> into a text string in order to be able to write it to the disk. For this we will make use of the <code>Transformer</code> utility.</p>"},{"location":"en/UD1_Files/3_XML_Files/#151-transformer","title":"1.5.1. Transformer","text":"<p>Java offers us the <code>Transformer</code> utility to convert information between different hierarchical formats, such as the Document object that contains the DOM of our XML, to an XML text file.</p> <p>The <code>Transformer</code> class, like <code>DocumentBuilder</code>, is also an abstract class, so it also requires a factory to be instantiated. The Transformer class works with two types of adapters. Adapters are classes that make different hierarchies compatible. These adapters are <code>Source</code> and <code>Result</code>. The classes that implement these adapters will be responsible for making the different types of containers compatible with what the Transformer class requires. So, and to clarify, we have the <code>DOMSource</code>, <code>SAXSource</code> or <code>StreamSource</code> classes, which are adapters of the information source container for DOM, SAX or Stream; and of <code>DOMResult</code>, <code>SAXResult</code>, and <code>StreamResult</code> as equivalent adapters to the target container.</p> <p>For our case, since we have a DOM and want to convert it to a Stream, we will need a <code>DomSource</code> and a <code>StreamResult</code>. Let's see the code needed to do this:</p> Java<pre><code>Transformer trans = TransformerFactory.newInstance().newTransformer();\nDOMSource source = new DOMSource(doc);\nStreamResult result = new StreamResult(new FileOutputStream(file+\".xml\"));\n</code></pre> <p>The first thing we have done is to create an object of type Transformer with the newTransformer() method of an instance (newInstance()) of the Transformers factory TransformerFactory. Then we defined the source (source) and the result (result) for the transformation, the source being a DomSource created from the doc that contains our document, and the result a StreamResult, which will write the stream to disk through a FileOutputStream.</p> <p>And finally, we do the transformation from one element to another, which will automatically generate the output XML file:</p> Java<pre><code>trans.transform(source, result);\n</code></pre> <p>You can get</p> <p>The full sample is available on Aules platform</p>"},{"location":"en/UD1_Files/3_XML_Files/#16-advanced-techniques-xml-binding","title":"1.6. Advanced techniques: XML binding","text":"<p>The Binding technique consists of generating Java classes with specific formats, such as XML, so that each XML tag or attribute corresponds to a property of a certain class. This correspondence is called a mapping.</p> <p>In Java, there are different libraries for mapping or binding: JAXB, JuBX, XMLBinding, etc. JAXB (Java Architecture for XML Binding) is a powerful library that has been included in the standard since JDK 6, but has been removed in version 11, and is suggested to be included as a third-party package. JAXB makes use of annotations to get the information needed to map the binding. Annotations are special Java indications that allow you to associate information and functionality to objects, without interfering with the structure of the data model. Annotations can be associated with a package, class, attribute, or parameter, and are declared with the <code>@</code> symbol in front of the annotation name. When the compiler detects an annotation, it creates an instance and injects it into the affected element, without interfering with the class itself. When an application needs the information from the annotations, they can get the injected instance.</p> <p>For example, in the <code>Modul</code> class we had defined, we would use the annotation <code>@XmlRootElement</code> to indicate the root element of the module, and the annotations <code>@XmlElement</code>, to indicate that the setters of the class will also write XML elements.</p> Java<pre><code>@XmlRootElement\nclass Modul {\n\n    String nom;\n    int hores;\n    double nota;\n\n    public String getNom() { return nom; }\n    @XmlElement\n    public void setNom(String nom) { this.nom = nom; }\n\n\n    public int getHores() { return hores; }\n    @XmlElement\n    public void setHores(int hores) { this.hores = hores; }\n\n    public double getNota() { return nota; }\n    @XmlElement\n    public void setNota(double nota) { this.nota = nota;}\n\n\n}\n</code></pre> <p>With this we would have only the class with annotations ready to save a module as an XML document. To save the entire hierarchy we should create the <code>Curs</code> class, which would contain an <code>ArrayList</code> of modules.</p> <p>As for this course, we will not delve further into this technique, since for our purposes, the XML parsing that we have seen in previous sections is sufficient.</p> <p>More and more</p> <p>We are going to use lots of annotations this course, keep calm...</p>"},{"location":"en/UD1_Files/4_JSON_Files/","title":"1. JSON Files","text":"<p>JSON is another lightweight text format for data exchange. JSON stands for JavaScript Object Notation, and is a subset of the language's literal object notation, which has been adopted alongside XML as one of the major standards for data exchange and storage.</p> <p>One of the advantages of JSON over XML is the ease of writing parsers, but more important than that, is that it expresses the same thing as XML but in a much more concrete and concise way, so it is commonly used in environments where the flow of data is important, as is the case with the servers of Google, Yahoo, etc. serving millions of users.</p>"},{"location":"en/UD1_Files/4_JSON_Files/#11-json-format","title":"1.1. JSON format","text":"<p>The complete specification can be viewed here</p> <p>The types of data that we can represent in JSON are:</p> <ul> <li>Numbers, both integers and decimals.</li> <li>Strings, expressed between quotes and with the possibility of including escape sequences.</li> <li>Booleans, to represent the values <code>true</code> and <code>false</code>.</li> <li>Null, to represent the <code>null</code> value.</li> <li>Array, to represent lists of zero or more values, of any type, enclosed in square brackets and separated by commas.</li> <li>Objects, as collections of <code>&lt;key&gt;:&lt;value&gt;</code> pairs, separated by commas and braces, and of any value type.</li> </ul> <p>We will see it better with a well-known example: The one of the modules we are working with:</p> <p>JSON<pre><code>{\n  \"curs\": [\n        {\n          \"nom\": \"Acc\u00e9s a Dades\",\n          \"hores\": 6,\n          \"qualificacio\":  8.45\n        },\n        {\n          \"nom\": \"Programaci\u00f3 de serveis i processos\",\n          \"hores\": 3,\n          \"qualificacio\": 9.0\n        },\n        {\n          \"nom\": \"Desenvolupament d'interf\u00edcies\",\n          \"hores\": 6,\n          \"qualificacio\": 8.0\n        },\n        {\n          \"nom\": \"Programaci\u00f3 Multim\u00e8dia i dispositius m\u00f2bils\",\n          \"hores\": 5,\n          \"qualificacio\": 7.34\n        },\n        {\n          \"nom\": \"Sistemes de Gesti\u00f3 Empresarial\",\n          \"hores\": 5,\n          \"qualificacio\": 8.2\n        },\n        {\n          \"nom\": \"Empresa i iniciativa emprenedora\",\n          \"hores\": 3,\n          \"qualificacio\": 7.4\n        }\n      ]\n}\n</code></pre> Let's see how <code>curs</code> is an array or a list of modules (although we don't use the modul label now), which in this case are objects with three elements: the name which is a string of characters, the hours which is an integer, and the rating, which is represented as a decimal number. Note that, like XML, we also need a root object, in this case the current element.</p> <p>Internet is full of services that offers information in JSON format as well. For instance, you can visit:</p> <ul> <li>https://arkhamdb.com/api/public/card/01001</li> <li>https://swapi.dev/api/films/1/</li> <li>http://hp-api.herokuapp.com/api/characters</li> </ul> <p>There is a wide range of Java libraries for manipulating JSON documents (GSON, Jackson, JSON.simple...). In our case, we are going to use the <code>org.json</code> library, which we can check in the Maven repository: https://mvnrepository.com/artifact/org.json/json</p> <p>In the next section we will comment on the functionality of the library, and in an attached document, we will see how to incorporate it into our projects through the Gradle dependency manager.</p>"},{"location":"en/UD1_Files/4_JSON_Files/#12-orgjson","title":"1.2. <code>org.JSON</code>","text":"<p>The library provides a set of classes for parsing JSON documents for Java, as well as converters between JSON and XML. Among the classes it offers, we could highlight:</p> <ul> <li><code>JSONObject</code> \u2192 Store key-value pairs in unordered form. Values \u200b\u200bcan be Boolean, JSONArray, Number, String, and JSONObject.NULL. Their constructors take as input different representations (String, maps, beans) and store them as a set of key-value elements.</li> <li><code>JSONTokener</code> \u2192 Parses a JSON string, and is used internally by JSONObject and other classes to parse JSON strings.</li> <li><code>JSONArray</code> \u2192 Stores a sequence of values, and represents a JSON array.</li> <li><code>JSONWriter</code> \u2192 Provides a way to produce JSON text. It has an <code>append(String)</code> method, which adds more text to a JSON object of text type, in addition to the key(String) and value(String) methods for adding keys and values \u200b\u200bto a JSON string. The class also allows you to write an array.</li> </ul>"},{"location":"en/UD1_Files/4_JSON_Files/#13-creating-json-files","title":"1.3. Creating JSON files","text":"<p>Our samples are based on the data of DAM modules saw in previous sections. Consider this code block as starting point where an array <code>Curs</code> is created and populated with modules :</p> Java<pre><code>private void creaCurs() {    \n    // Aquest m\u00e8tode inicializa l'objecte \"Curs\" de la classe JSONLib\n    // que no \u00e9s m\u00e9s que un vector de m\u00f2duls\n\n    // Definim els vectors per inicialitzar dades\n    String[] moduls={\"Acc\u00e9s a Dades\", \"Programaci\u00f3 de serveis i processos\", \"Desenvolupament d'interf\u00edcies\", \"Programaci\u00f3 Multim\u00e8dia i dispositiud m\u00f2bils\", \"Sistemes de Gesti\u00f3 Empresarial\", \"Empresa i iniciativa emprenedora\"};\n    int[]  hores={6, 3, 6, 5, 5, 3};\n    double[] notes={8.45, 9.0, 8.0, 7.34, 8.2, 7.4};\n\n    // Recorrem els vectors, creant els objectes\n    // de tipus Modul i guardant-los en Curs\n    for (int i=0;i&lt;moduls.length;i++){\n        Modul m = new Modul(moduls[i], hores[i], notes[i]);\n        this.Curs.add(m);\n    }\n}\n</code></pre> <p>To create the whole JSON file, we need to create individual JSON's, representing every object. Due to this object gets the information from the objects, it is a good idea to create methods inside the module object to get the JSON representation of every object:</p> Java<pre><code>public JSONObject getModulJSON(){\n    JSONObject modul = new JSONObject();\n\n    modul.put(\"nom\", this.nom);        \n    modul.put(\"hores\", this.hores);\n    modul.put(\"nota\",  this.nota);\n\n    // Si volguerem afegir un element nul, \n    // hauriem de fer:\n    // modul.put(\"atribut\", JSONObject.NULL);\n\n    return modul;\n\n};\n</code></pre> <p>Once the individual JSON is solved, we need to create the main JSON, the one who contains all the modules. It is easy to guess that the main element will be an array, containing all the module objects inside it.</p> Java<pre><code>private JSONObject creaJSON() {\n\n        // root element \"Curs\"\n        JSONObject curs = new JSONObject();\n\n        // who is a JSONArray\n        JSONArray jsarray = new JSONArray();\n\n        // we populate the array with individual modules\n        for (Modul m : this.Curs) {\n            JSONObject modul_json = m.getModulJSON();\n            jsarray.put(modul_json);\n        }\n\n        // Create the curs element with the array\n        curs.put(\"curs\", jsarray);\n\n        return (curs);\n    }\n</code></pre> <p>Finally, we need to save it to disk in a text file. This code block stores a JSONObject, using a FileWriter with an specific indentation:</p> Java<pre><code>private void escriuJSON(String filename, JSONObject jso){\n\n    try {\n        FileWriter file = new FileWriter(filename);\n        file.write(jso.toString(4)); // 4 s\u00f3n els espais d'indentaci\u00f3\n        file.close();\n\n    } catch (IOException e) {\n        System.out.println(\"Error, no es pot crear el fitxer \"+filename);\n    }\n}\n</code></pre>"},{"location":"en/UD1_Files/4_JSON_Files/#14-reading-json-files","title":"1.4. Reading JSON files","text":"<p>In order to read JSON files, we have to split the task in two parts. Firstly, and very simple, is to read from the file to a String, and call to the JSONObject constructor with this string. Then, we need to process it.</p> Java<pre><code>private JSONObject LligJSON(String filename){\n    try {\n        // Amb FileReader llegirem car\u00e0cter a \n        // car\u00e0cter el fitxer i l'afegim al string myJson\n        FileReader file = new FileReader(filename); \n        String myJson=\"\";\n\n        int i;\n        while ((i=file.read()) != -1) \n            myJson=myJson+((char) i);\n\n        //System.out.println(myJson);\n        file.close();\n\n        // I fem \u00fas del constructor de JSONObject\n        // al que li passem un string amb el JSON:\n        return (new JSONObject(myJson));\n\n\n    } catch (Exception e)\n    {\n        System.out.println(\"Error llegint el fitxer\");\n        return null;\n    }\n\n}\n</code></pre> <p>Once we have the main <code>JSONObject</code>, we need to recover the <code>JSONArray</code> (called curs). We could use the length() method to go over all modules with a <code>for</code> loop. To obtain the single objects of a JSONObject, the <code>get(string label)</code> method is provided, returning the object labeled. We need to take care of the type, and do conversions when we need it. In the sample above we only show the JSON, instead of create objects in memory.</p> Java<pre><code>private void MostraJson(JSONObject json){\n\n    // amb el m\u00e8tode getJSONArray obtenim el primer\n    // element \"curs\", que era una llista\n    JSONArray jsa=json.getJSONArray(\"curs\");\n\n    // I ara recorrem aquesta llista:\n    for (int i = 0; i &lt; jsa.length(); i++) {\n        // Agafem cada element de l'array amb \"get\"\n        JSONObject modul=(JSONObject)jsa.get(i);\n        // Amb el get anterior tindrem objectes JSON \n        // de m\u00f2duls, tipus:\n        // {\"nom\": \"Modul\", \"hores\": hores, \"nota\": nota }\n        // Als valors d'aquests parells tamb\u00e9 accedirem amb get:\n        System.out.println(\"Modul: \"+ modul.get(\"nom\"));\n        System.out.println(\"Hores: \"+ modul.get(\"hores\"));\n\n        System.out.println(\"Nota: \"+modul.get(\"nota\"));\n\n        /*\n        En esta funci\u00f3 escrivim els objectes JSON. Si volgu\u00e9rem\n        crear de nou l'estructura d'objectes, crear\u00edem cadascun \n        dels m\u00f2duls amb:\n            Modul m=new Modul(modul.get(\"nom\"), modul.get(\"hores\"), modul.get(\"nota\"));\n        */\n    }\n}\n</code></pre>"},{"location":"en/UD1_Files/5_Extra_Formats/","title":"1. Extra formats","text":"<p>In this section we will study two type of text files that are used widely in computer science, and the way to work with it.</p>"},{"location":"en/UD1_Files/5_Extra_Formats/#11-csv-files","title":"1.1. CSV files","text":"<p>A comma-separated values (CSV) file is a standard text file which uses a comma (<code>,</code>) to separate value. Each line of the file consists of one or more fields, separated by commas. Each field may or may not be enclosed in double-quotes. In addition, several formats use different characters as separator, as semicolon (<code>;</code>) or hash (<code>#</code>). The RFC 4180 defines the format or definitions of a CSV file or text/csv file.</p> <p>In case that the symbol that is used as separator appears inside the values, enclose the content between quotation marks it is a good idea.</p> <p>A sample of csv can be viewed here:</p> Text Only<pre><code>Chevrolet Chevelle Concours (sw);0;8;350.0;165.0;4142.;11.5;70;US\nFord Torino (sw);0;8;351.0;153.0;4034.;11.0;70;US\nPlymouth Satellite (sw);0;8;383.0;175.0;4166.;10.5;70;US\nAMC Rebel SST (sw);0;8;360.0;175.0;3850.;11.0;70;US\nDodge Challenger SE;15.0;8;383.0;170.0;3563.;10.0;70;US\nPlymouth Cuda 340;14.0;8;340.0;160.0;3609.;8.0;70;US\nFord Mustang Boss 302;0;8;302.0;140.0;3353.;8.0;70;US\n</code></pre> <p>The way to process a csv in Java is:</p> <ol> <li>Open as a text file for reading. We need to read line by line, because every line is a register. Read one line into a String variable.</li> <li>Process individual records:</li> <li>We could separate every field. A good option is use <code>split(char)</code> method from string. We will obtain an array of string with the individual fields values.</li> <li>Process each field value by your own</li> </ol> <p>Attention</p> <p>It is a good idea to start using <code>Files</code> and <code>Paths</code> abstract classes. These classes improve the use of File and it inherited classes, offering useful methods that allow us to do quick operations with less code lines. For example, the following line, starting from the <code>filename</code> open it and then read the whole file, returning a <code>List</code> with lines separated on each item of the collection.</p> Java<pre><code>List&lt;String&gt; lines=Files.readAllLines(Paths.get(filename));\n</code></pre> <p>More info in:</p> <ul> <li>Files</li> <li>Paths</li> </ul>"},{"location":"en/UD1_Files/5_Extra_Formats/#12-properties-files","title":"1.2. Properties files","text":""},{"location":"en/UD1_Files/5_Extra_Formats/#121-properties-file","title":"1.2.1. Properties file","text":"<p>At last, but not least, we are going to show you an important kind of text file, who is properties files. This files stores, as you know, several properties that are used during program execution. The program, when starting, load these properties and do a tuning of several option.  Example of these files are <code>my.conf</code> in MySQL, <code>php.ini</code> in PHP, etc.</p> <p>The aspect of this file is several lines (one by property) and every line <code>attribute=value</code>. For example, a supposed file:</p> Text Only<pre><code># properties of my program\nport=1234\nvolume=90\nbright=56\nload_on_start=true\n</code></pre> <p>The way to process a properties file in Java is similar to a CSV:</p> <ol> <li>Open as a text file for reading. We need to read line by line, because every line is a different property. Read one line into a String variable.</li> <li>Process individual records:</li> <li>We could separate every field. A good option is use <code>split(char)</code> method from string. We will obtain an array of string with the individual fields values. The separators are normally <code>=</code>, <code>:</code>.</li> <li>Left of the separator is the property name</li> <li>Right of the separator is the property's value</li> <li>Notice that if a line starts with slash (<code>#</code>) should be a comment, and will be ignored</li> </ol>"},{"location":"en/UD1_Files/5_Extra_Formats/#122-java-properties-object","title":"1.2.2. Java Properties object","text":"<p>Java has an object very useful to manage this kind of information. With properties, we can store a set of properties with a hash table (basically a pair key-value). It has methods prepared to load and save from and to streams of text or, moreover XML files. Interesting method for properties are:</p> <p>Reading from file (text or XML)</p> <ul> <li><code>void load(InputStream inStream)</code> \u2192 Reads a property list (key and element pairs) from the input byte stream.</li> <li><code>void load(Reader reader)</code> \u2192 Reads a property list (key and element pairs) from the input character stream in a simple line-oriented format.</li> <li><code>void loadFromXML(InputStream in)</code> \u2192 Loads all of the properties represented by the XML document on the specified input stream into this properties table.</li> </ul> <p>Writing to file (text or XML)</p> <ul> <li><code>void store(OutputStream out, String comments)</code> \u2192 Writes this property list (key and element pairs) in this Properties table to the output stream in a format suitable for loading into a Properties table using the load(InputStream) method.</li> <li><code>void store(Writer writer, String comments)</code> \u2192 Writes this property list (key and element pairs) in this Properties table to the output character stream in a format suitable for using the load(Reader) method.</li> <li><code>void storeToXML(OutputStream os, String comment)</code> \u2192 Emits an XML document representing all the properties contained in this table.</li> </ul> <p>Working with properties (inherited from HashTable)</p> <ul> <li><code>Set&lt;K&gt; keySet()</code> \u2192 Returns a Set view of the keys contained in this map.</li> <li><code>V get(Object key)</code> \u2192<code>Returns the value (</code>V<code>)to which the specified</code>key<code>is mapped, or</code>null` if this map contains no mapping for the key.</li> <li><code>boolean  containsKey(Object key)</code> Tests if the specified object is a key in this hashtable. </li> <li><code>V put(K key, V value)</code> \u2192 Maps the specified key to the specified value in this hashtable.</li> <li><code>V remove(Object key)</code> \u2192 Removes the key (and its corresponding value is returned) from this hashtable.</li> </ul>"},{"location":"en/UD1_Files/5_Extra_Formats/#123-sample-program","title":"1.2.3. Sample program","text":"<p>In the next program you can view sample of reading and creating properties files in Java</p> Java<pre><code>    /**\n     * Load the file specified and show its properties in different ways\n     * @param filename \n     */\n    private void loadAndShowProperties(String filename) {\n\n        Properties properties = new Properties();\n\n        try {\n            properties.load(new FileInputStream(new File(filename)));\n\n            System.out.println(\"Whole set: \" + properties);\n\n            properties.list(System.out);\n\n            Set&lt;Object&gt; keys = properties.keySet( );\n\n            System.out.println(\"My listing: \");\n            for (Object key : keys) {\n                System.out.println(key + \" - \" + properties.getProperty((String) key));\n            }\n\n        } catch (FileNotFoundException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (IOException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n\n    }\n\n    /**\n     * Create a properties object, populated with samples and stores into a \n     * text file and a XML file\n     * @throws IOException \n     */\n    private void writeProperties() throws IOException {\n        Properties props = new Properties();\n\n        props.put(\"Color\", \"Green\");\n        props.put(\"Range\", \"123\");\n        props.put(\"Visible\", \"false\");\n        props.put(\"Size\", \"Big\");\n        props.put(\"Status\", \"functional\");\n        props.put(\"Value\", \"345.24\");\n\n        props.store(new FileWriter(new File(\"propis.properties\")), \"Sample props file\");\n\n        props.storeToXML(new FileOutputStream(new File(\"propis.xml\")), \"Sample XML Props\");\n    }\n</code></pre>"},{"location":"en/UD1_Files/5_Extra_Formats/#13-environment-env-files-and-dot_env","title":"1.3. Environment, <code>.env</code> files and <code>dot_env</code>","text":""},{"location":"en/UD1_Files/5_Extra_Formats/#131-why-using-environment","title":"1.3.1. Why using environment?","text":"<p>Environment variables are a crucial aspect of configuring and managing applications across different environments, such as development, testing, and production. They provide a way to dynamically pass configuration data to applications without hardcoding values directly in the source code. This approach enhances the flexibility, portability, and security of applications.</p> <p>In Java, accessing environment variables is straightforward, thanks to the <code>System</code> class, which provides methods to retrieve environment variables. This capability is especially useful for:</p> <ul> <li>Configuring application settings like database URLs, API keys, and file paths.</li> <li>Managing environment-specific configurations without altering the codebase.</li> <li>Keeping sensitive information, such as passwords and tokens, out of the source code.</li> </ul> <p>By understanding how to effectively utilize environment variables in Java, developers can create more adaptable and secure applications. </p>"},{"location":"en/UD1_Files/5_Extra_Formats/#132-getting-environment-variables","title":"1.3.2. Getting environment variables","text":"<p>To access environment variables in Java, you can use the <code>System.getenv()</code> method. This method is overloaded, and coud be:</p> <ul> <li><code>System.getenv()</code> \u2192 returns a <code>Map</code> object containing all the environment variables and their corresponding values.</li> <li><code>System.getenv(String)</code> \u2192 returns a <code>String</code> with the value of the specific environment variable or null if it does not exists.</li> </ul> <p>How to retrieve environment variables in Java:</p> Java<pre><code>Map&lt;String, String&gt; env = System.getenv();\n\n// Access a specific environment variable\nString value = env.get(\"VARIABLE_NAME\");\n\n// Print all environment variables\nfor (Map.Entry&lt;String, String&gt; entry : env.entrySet()) {\n    System.out.println(entry.getKey() + \" = \" + entry.getValue());\n}\n</code></pre> <p>Notice that:</p> <ul> <li>The Map class returns a collection of entries with pairs key-value</li> <li>The environment variables are case-sensitive, so make sure to use the correct casing when accessing them.</li> </ul>"},{"location":"en/UD1_Files/5_Extra_Formats/#133-the-dot-env-approach","title":"1.3.3. The <code>dot-env</code> approach","text":"<p>Storing configuration in the environment is one of the tenets of a twelve-factor app. Anything that is likely to change between deployment environments\u2013such as resource handles for databases or credentials for external services\u2013should be extracted from the code into environment variables.</p> <p>But it is not always practical to set environment variables on development machines or continuous integration servers where multiple projects are run. Dotenv load variables from a .env file into ENV when the environment is bootstrapped.</p> <p>Unfortunately, loading <code>.env</code> files in Java is not natively supported by the language itself, but you can use external libraries to accomplish this task. One of the popular libraries for this purpose is <code>dotenv-java</code>. This library allows you to easily load environment variables from a .env file into your Java application. https://github.com/cdimascio/dotenv-java</p> <p>Add the Dependency</p> <p>First, you need to add the dotenv-java library to your project. If you are using Maven, add the following dependency to your pom.xml file:</p> XML<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.github.cdimascio&lt;/groupId&gt;\n    &lt;artifactId&gt;java-dotenv&lt;/artifactId&gt;\n    &lt;version&gt;5.2.2&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>If you are using Gradle, add the following to your build.gradle file:</p> Text Only<pre><code>implementation 'io.github.cdimascio:java-dotenv:5.2.2'\n</code></pre> <p>Create <code>.env</code> file</p> <p>The <code>.env</code> file is like config files. You can store it on the root path of your application</p> Text Only<pre><code>DATABASE_URL=jdbc:mysql://localhost:3306/testdb\nDATABASE_USER=root\nDATABASE_PASSWORD=password\n</code></pre> <p>Load the configuration</p> Java<pre><code>import io.github.cdimascio.dotenv.Dotenv;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Load the .env file\n        Dotenv dotenv = Dotenv.load();\n\n        // Retrieve environment variables\n        String databaseUrl = dotenv.get(\"DATABASE_URL\");\n        String databaseUser = dotenv.get(\"DATABASE_USER\");\n        String databasePassword = dotenv.get(\"DATABASE_PASSWORD\");\n\n        // Print the values\n        System.out.println(\"Database URL: \" + databaseUrl);\n        System.out.println(\"Database User: \" + databaseUser);\n        System.out.println(\"Database Password: \" + databasePassword);\n\n        // Use the variables as needed\n        // For example, establish a database connection using these variables\n    }\n}\n</code></pre> <p>Attention</p> <p>Notice that with java dotenv library, you will use <code>dotenv.get()</code> instead of <code>System.getenv()</code> method, due to you are accessing local file.</p>"},{"location":"en/UD2_Connectors/1_Object_relational_impedance_mismatch/","title":"1. Object\u2013relational impedance mismatch","text":"<p>Database Management Systems (DBMS - SGBD in spanish) are mostly based in Entity-Relationship model (E/R), where information is stored in several tables related to each other. It is a simple and efficient technology, which has endured over the years, and which is still the model used by most databases and DBMSs today. Despite the success, the model has some limitations, such as the representation of poorly structured or complex information.</p> <p>Conceptual models help us model a complex reality, and are based on a process of reality abstraction. Each model has a way of capturing this reality, but, all of them are closer to the human mentality than to the memory of a computer.</p> <p>When we model a database, we make use of the Entity-Relationship conceptual model, and subsequently, we do a process of transform into tables and normalizing this model, to have a relational data model.</p> <p>In the case of object-oriented programming, we try to represent reality through objects and the relationships between them. This is another type of conceptual model, but one that aims to represent the same reality as the relational one.</p> <p>So, we have two different approaches to represent the reality of a problem: the Relational Model of the database and the Object-Oriented model of our applications.</p>"},{"location":"en/UD2_Connectors/1_Object_relational_impedance_mismatch/#11-representation-of-information-with-the-relational-model","title":"1.1. Representation of information with the relational model","text":"<p>The relational model is based on tables and the relationship between them:</p> <ul> <li>Each table has as many columns as attributes we want to represent, and as many rows as records or elements of that type contain.</li> <li>The tables have a primary key, which identifies each of the records, and can be formed by one or more attributes.</li> <li>The relationship between tables is represented by external keys, which consist of including in a table the primary key of another table, as a reference to it. When is removed a record of a table, whose primary key is referenced by another, must be ensured that we maintain the referential integrity of the database. Then, before this deletion of a primary key, we can:</li> <li>Do not allow deletion (NO ACTION),</li> <li>Carry out the deletion in cascade, also deleting all the records that referred to the primary key of the deleted record (CASCADE),</li> <li>Set to null (SET NULL), so that the external key referred to the primary key from the other table takes the value of <code>NULL</code>.</li> <li>The different fields of the tables can also have certain associated restrictions, as they can to be:</li> <li>Non-null value constraint, so the field cannot be null in any case,</li> <li>Uniqueness restriction on one or several fields, so that the value must be unique in the whole table. </li> <li>Domain restriction, or what is the same, can have a set of possible values default</li> </ul> <p>Attention</p> <p>Primary keys have both properties: non-null value and uniqueness.</p>"},{"location":"en/UD2_Connectors/1_Object_relational_impedance_mismatch/#1101-sample","title":"1.1.0.1. Sample","text":"<p>A database to store information about players, games etc., can be like this:</p> <p></p> <p>And implementing with <code>MySQL</code>:</p> SQL<pre><code>CREATE SCHEMA IF NOT EXISTS `BDJocs` DEFAULT CHARACTER SET utf8 ;\nUSE `BDJocs` ;\n\nCREATE TABLE IF NOT EXISTS `BDJocs`.`jugador` (\n  `id` INT NOT NULL,\n  `nick` VARCHAR(45) NULL,\n  `dataRegistre` DATETIME NULL,\n  PRIMARY KEY (`id`))\nENGINE = InnoDB;\n\nCREATE TABLE IF NOT EXISTS `BDJocs`.`Genere` (\n  `id` INT NOT NULL,\n  `nom` VARCHAR(45) NULL,\n  `descripci\u00f3` VARCHAR(256) NULL,\n  PRIMARY KEY (`id`))\nENGINE = InnoDB;\n\nCREATE TABLE IF NOT EXISTS `BDJocs`.`Joc` (\n  `id` INT NOT NULL,\n  `nom` VARCHAR(45) NULL,\n  `descripci\u00f3` VARCHAR(256) NULL,\n  `Genere_id` INT NOT NULL,\n  PRIMARY KEY (`id`),\n  INDEX `fk_Joc_Genere1_idx` (`Genere_id` ASC),\n  CONSTRAINT `fk_Joc_Genere1`\n    FOREIGN KEY (`Genere_id`)\n    REFERENCES `BDJocs`.`Genere` (`id`)\n    ON DELETE NO ACTION\n    ON UPDATE NO ACTION)\nENGINE = InnoDB;\n\nCREATE TABLE IF NOT EXISTS `BDJocs`.`Puntuacions` (\n  `jugador_id` INT NOT NULL,\n  `Joc_id` INT NOT NULL,\n  `puntuacio` INT NULL,\n  PRIMARY KEY (`jugador_id`, `Joc_id`),\n  INDEX `fk_jugador_has_Joc_Joc1_idx` (`Joc_id` ASC),\n  INDEX `fk_jugador_has_Joc_jugador1_idx` (`jugador_id` ASC),\n  CONSTRAINT `fk_jugador_has_Joc_jugador1`\n    FOREIGN KEY (`jugador_id`)\n    REFERENCES `BDJocs`.`jugador` (`id`)\n    ON DELETE NO ACTION\n    ON UPDATE NO ACTION,\n  CONSTRAINT `fk_jugador_has_Joc_Joc1`\n    FOREIGN KEY (`Joc_id`)\n    REFERENCES `BDJocs`.`Joc` (`id`)\n    ON DELETE NO ACTION\n    ON UPDATE NO ACTION)\nENGINE = InnoDB;\n</code></pre>"},{"location":"en/UD2_Connectors/1_Object_relational_impedance_mismatch/#12-representation-of-information-with-the-object-oriented-model","title":"1.2. Representation of information with the object-oriented model","text":"<p>Like the Entity-Relationship model, the Object-Oriented model is a conceptual data model, but which focuses the importance on the modeling of objects.</p> <p>An object can represent any conceptual element: entities, processes, actions... An object it does not only represent the characteristics or properties, but also focuses on the processes that they suffer. In terms of the object-oriented model, we say that an object is data plus operations or behavior.</p> <p>In the introductory unit we already reviewed object-oriented programming, so we will limit ourselves to a brief review of the main concepts:</p> <ul> <li>An object is an entity with certain properties and certain behavior.</li> <li>In terms of OOP, properties are known as attributes, and the set of their values determine the state of the object at a given moment.</li> <li>Behavior is determined by a series of functions and procedures that we call methods, and that modify the state of the object.</li> <li>An object will also have a name by which it is identified.</li> <li>A class is an abstraction of a set of objects, and an object must belong necessarily to some class.</li> <li>The classes define the attributes and methods that the objects of this class will possess.</li> <li>An object is said to be an instance of a class.</li> </ul> <p>The same sample that we have represented lately, with an object-oriented representation could be:</p> <p></p> <p>As we can see, it has a similar structure, to which we have also added some methods such as getters and the setters. In addition, the different classes do not have an identifier attribute, since each object he identifies himself. We see a small approximation of how we would implement this hierarchy in Java.</p> <p>The <code>Genere</code> class is a POJO class, that only stores information (name and description of the game kind)and implements getters and setters.</p> Java<pre><code>public class Genere {\n    protected String nom;\n    protected String descripcio;\n\n    public Genere(String nom, String descripcio) {\n        this.nom = nom;\n        this.descripcio = descripcio;\n    }\n\n    public String getNom() {return nom;}\n    public void setNom(String nom) {this.nom = nom;}\n\n    public String getDescripcio() {return descripcio;}\n    public void setDescripcio(String descripcio) {\n        this.descripcio = descripcio;\n    }\n}\n</code></pre> <p>Class <code>Joc</code> stores name, description and genre of the game. Unlike the relational model, where what is stored it would be an external key to genre, since we don't have external keys here, we store one object itself (the reference).</p> Java<pre><code>public class Joc {\n\n    protected String nom;\n    protected String descripcio;\n    protected Genere genere;\n\n    public Joc(String nom, String descripcio, Genere genere) {\n        this.nom = nom;\n        this.descripcio = descripcio;\n        this.genere = genere;\n\n    }\n\n    public String getNom() {return this.nom;}\n    public void setNom(String nom) {this.nom = nom;}\n\n    public String getDescripcio() {return this.descripcio;}\n    public void setDescripcio(String descripcio) {\n        this.descripcio= descripcio;\n    }\n\n    public Genere getGenere() {return this.genere;}\n\n    public void setGenere(Genere genere) {this.genere = genere;}\n}\n</code></pre> <p><code>Registre</code> class present the relation between <code>Jugador</code> and <code>Joc</code> (when a player plays a game), and stores points and a reference to the game.</p> Java<pre><code>public class Registre {\n    private int puntuacio;\n    private Joc joc;\n\n    public Registre(int puntuacio, Joc joc) {\n        this.puntuacio = puntuacio;\n        this.joc = joc;\n    }\n\n    public int getPuntuacio() {return puntuacio;}\n    public void setPuntuacio(int puntuacio) {\n        this.puntuacio = puntuacio;\n    }\n\n    public Joc getJoc() {return joc;}\n\n    public void setJoc(Joc joc) {this.joc = joc;}   \n}\n</code></pre> <p>And finally, the <code>Jugador</code> class stores nick and registry date for each player, and then, an array with all the games that the player has played:</p> Java<pre><code>public class Jugador {\n\n    private String nick;\n    private Date dataRegistre;\n    private Set&lt;Registre&gt; puntuacions;\n\n    public Jugador(String nick, Date dataRegistre) {\n        this.nick = nick;\n        this.dataRegistre = dataRegistre;\n    }\n\n    public String getNick() {return nick;}\n    public void setNick(String nick) {this.nick = nick;}\n\n    public Date getDataRegistre() {return dataRegistre;}\n    public void setDataRegistre(Date dataRegistre) {\n        this.dataRegistre = dataRegistre;\n    }\n\n    public Set getPuntuacions() {return this.puntuacions;}\n    public void setPuntuacio(Joc joc, int puntuacio) {\n        Registre registre = new Registre(puntuacio, joc);\n        this.puntuacions.add(registre);\n    }\n}\n</code></pre> <p>The <code>Set</code> interface and the <code>HashSet</code> class</p> <p><code>Set</code> is an interface of the <code>java.util</code> package that deals with a collection or set of elements uncluttered and without duplicates.</p> <p>On the other hand, <code>HashSet</code> is a class that implements the <code>Set</code> interface, and that is based on one hash table, a data structure that allows you to locate objects based on a key that indicates the position in the table, allowing direct access to the element, which makes them ideal for searches, insertions and deletions.</p>"},{"location":"en/UD2_Connectors/1_Object_relational_impedance_mismatch/#13-relational-vs-object-oriented-model","title":"1.3. Relational vs Object-Oriented model","text":"<p>Conceptually, the object-oriented model is a dynamic model, which focuses on objects and on the processes that these undergo, but which does not take into account, from the start, their persistence. We have to achieve, therefore, the ability to save the states of the objects permanently, and load them when the application needs them, as well as maintaining consistency between this stored data and the objects that represent them in the application.</p> <p>One way to offer this persistence to objects would be to use a Relational DBMS, but we will encounter some complications. The first, from a conceptual point of view, is that the entity-relationship model focuses on the data, while the object-oriented model focuses on the objects, understood as groups of data, and the operations performed on them.</p> <p>Another, quite important difference, is the linking of elements between one model and another. For one other hand, the relational model adds extra information to the tables in the form of a foreign key, while in the object-oriented model, we don't need this external data, but rather the binding between objects is done through references between them. An object, for example, won't need a key either primary, since the object is identified by itself.</p> <p>As we have seen in the example of the previous sections, the tables in the relational model had a key primary, to identify objects and external keys to express relationships, while in the object-oriented model, these disappear, expressing the relationships between objects through references. In addition, the way these relationships are expressed is also different. In the relational model, for example, the Scores record is a table that links the Player table to the Game table, and add to this the player's score in the game. On the other hand, in the Java implementation we have done, we have objects of type <code>Registre</code> that store a score and a reference to Game, however is the Player class, which maintains the set of Records of its scores.</p> <p>On the other hand, when manipulating the data, it must be taken into account that the relational model has of languages \u200b\u200b(mainly SQL) designed exclusively for this purpose, while in one object-oriented language works differently, so it will be necessary to incorporate mechanisms which allow these queries to be made from the programming language. Also, when we get the results of the query, we also encounter another problem, and that is the conversion of results. One querying a database always returns a result in the form of a table, so it will be necessary to transform these in states of the application objects.</p> <p>All these differences imply what is known as object-relational lag, and that it will force us to make certain conversions between objects and tables when we want to save the information in a DBMS. In this unit and the following ones, we will see how to overcome this lag from different approaches.</p>"},{"location":"en/UD2_Connectors/2_Connectors/#11-the-client-server-architecture-in-dbms","title":"1.1. The client-server architecture in DBMS","text":"<p>Once we know the object-relational lag, let's focus on how to access to relational databases from programming languages. The RDBMS, became popular in the 80s, and are the most widespread today. Except for some exceptions, they work following a client-server architecture, so we have a server where it runs the DBMS and various clients that connect to the server and make corresponding requests.</p> <p>RDBMS offered it own programming languages, but were closely tied to them, and the application maintenance was very expensive. For this reason, the trend was decouple (separate) the RDBMS from the programming language, and make use of connection standards between them.</p> <p>Thanks to the client-server architecture, RDBMS were able to separate data on the one hand, and the programs to access them by others. This versatility had a small drawback, and it is that it was necessary to develop on the one hand the server, but on the other, also the client side in order to be able to connect to servers. These connections between clients and servers will require protocols and specific languages. The concept of middleware is born here, understood as an intermediate layer of persistence, made up of libraries, languages \u200b\u200band protocols located on the client and server and that allow connecting the database with the applications.</p> <p>Although each DBMS initially implemented specific solutions, standards were imposed, among which we find the query language SQL (Structured Query Language), and which assumed a great advance, since it unified the way to access the databases, although the applications continued requiring an API to make use of SQL.</p>"},{"location":"en/UD2_Connectors/2_Connectors/#12-database-access-protocols","title":"1.2. Database access protocols","text":"<p>When we talk about DB access protocols, we come across two main connection rules:</p> <ul> <li>ODBC (Open Data Base Connectivity): This is an API (Application Program Interface) developed by Microsoft for Windows systems that allows you to add different plugins to several relational databases based on SQL, in a simple and transparent way. Using ODBC, applications can open connections to the database, send queries, updates and manage results.</li> <li>JDBC (Java Database Connectivity), which defines a cross-platform API, which they can use Java programs to connect to the DBMS.</li> </ul>"},{"location":"en/UD2_Connectors/2_Connectors/#13-jdbc","title":"1.3. JDBC","text":"<p>As we said, JDBC is a Java-specific database connection API. Its operation mode is as follows:</p> <ul> <li>An API is offered, encapsulated in classes, which guarantees uniformity in the way in which the applications connect to the database, regardless of the underlying RDBMS.</li> <li>We will need a controller for each database to which we want to connect. Java does not have any specific ODBC library, but it does, in order not to lose the potential of these connections, special drivers were incorporated that act as adapters between JDBC and ODBC, from so that it is possible, through this bridge, to connect any Java application with any ODBC connection. Currently, almost all DBMS have JDBC drivers, but in case you don't know about them have it, you can make use of this ODBC-JDBC bridge.</li> </ul>"},{"location":"en/UD2_Connectors/2_Connectors/#131-jdbc-architecture","title":"1.3.1. JDBC architecture","text":"<p>The JDBC standard library provides a set of implementation-free interfaces. Controllers of each DBMS will be in charge of implementation. Applications, in order to access the database, will have to use the JDBC interfaces, so it is for the implementation of each DBMS is completely transparent to the application.</p> <p></p> <p>As we can see, Java applications access the different methods that the API specifies as interfaces, but it is the controllers that access the database.</p> <p>It should be said that applications can use several JDBC drivers simultaneously, and access, therefore, to multiple databases. The application specifies a JDBC driver using a URL (Universal Resource Locator) to the Drivers manager, and this is the one responsible for correctly establishing the connections with the databases through the drivers. Controllers can be of different types:</p> <ul> <li>Type I or Bridge Controllers, characterized by making use of technology external to JDBC and acting of adapter between JDBC and the specific technology used. An example is the JDBC-ODBC bridge.</li> <li>Type II or drivers with partially native API, or native drivers. They are trained on one hand Java and on the other that makes use of operating system libraries. Its use is due to some DBMS that incorporate proprietary plugins that do not follow any standards (usually pre-ODBC/JDBC).</li> <li>Type III or Java controllers via network protocol, which are controllers developed in Java that translate JDBC calls to a network protocol against an intermediate server. Is a very flexible system, since changes in the implementation of the database do not affect applications.</li> <li>Type IV or pure/100% Java, also called native protocol, and these are drivers written entirely in Java. Requests to the DBMS are made through the network protocol that uses the DBMS itself, so there is no need for native code on the client or an intermediary server. Is the alternative that has ended up being imposed, since it does not require any type of installation.</li> </ul>"},{"location":"en/UD2_Connectors/2_Connectors/#14-mysql-docker-workbench","title":"1.4. MySQL, Docker, Workbench","text":"<p>This year we will use MySQL as DBMS, because its wide use in several contexts and for simplicity. To use it, you should install <code>mysql-server</code> as a service in your system, as you studied last years.</p> <p>The MySQL server can be installed in your machine, or you can install it on a virtual machine or can be configured as a Docker container. In order to have a cleaner system, the recommended option is with docker container, since you could run several versions of MySQL without interferences between them.</p> <p>Tip</p> <p>You have an extra documentation about how to create a MySQL container in a document called Docker per a MySQL. So, and for the rest of the document, we're going to assume that you already have the Docker image of MySQL and from a container running on port <code>3308</code> (MySQL uses 3306 by default, but in our container we will expose the service for 3308, in case you already have a local MySQL server running for   3306).</p> Bash<pre><code># Remember that to create the container (only fisrt time)\n\ndocker run --name mysql-srv\n      -p 3308:3306\n      -e MYSQL_ROOT_PASSWORD=\"root\"\n      -d mysql:latest\n\n# It will create and start the container\n\n# To stop the container\ndocker stop mysql-srv\n\n# And to start the container ( AVOID TO run IT AGAIN !!!)\ndocker start mysql-srv\n</code></pre> <p>And at last but not least, obviously, you could use a graphical tool to access MySQL, like <code>mysql-workbench</code> or <code>dbeaver</code>. You have to configure a connection to the port of Docker:</p> \\[\\begin{center} \\begin{minipage}{0.9\\textwidth} \\includegraphics[width=0.9\\columnwidth]{./img/WorkBench.png} \\end{minipage} \\end{center}\\] <p>Warning</p> <p>Review your Database Module's notes how to work in workbench:</p> <ul> <li>Load and run SQL scripts</li> <li>Retrieve database structure</li> <li>Edit and create SQL</li> <li>Edit and save data</li> </ul> <p>In the platform you will find a script DB Jocs Schemna. You will execute in order our samples work fine.</p>"},{"location":"en/UD2_Connectors/3_Connecting/","title":"1. Connecting to databases","text":""},{"location":"en/UD2_Connectors/3_Connecting/#11-mysql-jdbc-controller","title":"1.1. MySQL JDBC controller","text":"<p>In order to create Java programs using MySQL driver, we need to load in our program and previously in our development environment. As we will use <code>Gradle</code> let's go how to use it:</p> <ol> <li>We need to find our server JDBC version, and we can find it in maven central repository https://mvnrepository.com.</li> <li>We will search for <code>mysql jdbc</code>, and it will get as first result MySQL Connector/J.</li> <li>Be notice to select the correct version, and then select the package manager (gradle, maven, etc.) and you will get:</li> </ol> Bash<pre><code>// https://mvnrepository.com/artifact/mysql/mysql-connector-java\nimplementation group: 'mysql', name: 'mysql-connector-java', version: '8.0.30'\n</code></pre> <ol> <li>When you save or build your project, you will be able to import your drivers properly</li> </ol> <p></p>"},{"location":"en/UD2_Connectors/3_Connecting/#12-connection-url","title":"1.2. Connection URL","text":"<p>Once you have imported your driver, you need to tell your Java program how to connect to your database and finally connect to it. For this task we should create a <code>Connection</code> using a special URL called connection URL. As others URL, a connection URL may contain:</p> <ul> <li>Protocol \\(\\rightarrow\\) we will use <code>jdbc</code>.</li> <li>DBMS \\(\\rightarrow\\) we could use <code>mysql</code>, <code>postgres</code>, <code>sqlite</code>, <code>sqlserver</code> or any DBMS with a JDBC connector.</li> <li>Server address \\(\\rightarrow\\) we could use either a full name or the server IP.</li> <li>[optional]Port \\(\\rightarrow\\) the port where the server is listening. If none is used, the driver will try to connect to the default one. Remember to separate port from address with <code>:</code>.</li> <li>Other parameters, separating it with <code>?</code> at the beginning and with <code>&amp;</code> between parameters. For exemple:</li> <li>user=<code>username</code></li> <li>pass=<code>password</code></li> <li>useUnicode=<code>true</code></li> <li>characterEncoding=<code>UTF-8</code></li> </ul> <p>A sample connection URL can be:</p> Java<pre><code>String connectionUrl = \"jdbc:mysql://localhost:3308/Cycling?useUnicode=true&amp;characterEncoding=UTF-8&amp;user=root&amp;password=root\";\n</code></pre> <p>A better option will be:</p> Java<pre><code>String server=\"localhost\";\nint port=3308;\nString user=\"root\";\nString pass=\"root\";\nString DBName=\"Cycling\";\nString connectionUrl = \"jdbc:mysql://\"+server+\":\"+port;\nconnectionUrl+=\"/\" + DBName;\nconnectionUrl+=\"?useUnicode=true&amp;characterEncoding=UTF-8\";\nconnectionUrl+=\"&amp;user=\"+user;\nconnectionUrl+=\"&amp;password=\"+pass;\n</code></pre> <p>Warning</p> <p>Notice that both samples are hard-coded code, because you have values of the server (user and password) written inside Strings. Is a better option to store this values inside variables or in properties files.</p>"},{"location":"en/UD2_Connectors/3_Connecting/#13-connection-class","title":"1.3. <code>Connection</code> class","text":"<p>In Java the class needed to manage the driver is <code>java.sql.DriverManager</code>. It tries to load the drivers from the system when reading the JDBC drivers property, but we can indicate that it is loaded using the instruction:</p> Java<pre><code>Class.forName(\"com.mysql.cj.jdbc.Driver\");\n</code></pre> <p>The class that will centralize all operations with the database is <code>java.sql.Connection</code>, and we must obtain it from the <code>DriverManager</code> with any of the 3 static methods it has:</p> <ul> <li><code>static Connection getConnection(String url)</code> \\(\\rightarrow\\) Returns a connection, if it is possible, to the database whose parameters are specified in the connection URL. Remember from last part how to create a connection URL.</li> <li><code>static Connection getConnection(String url, Properties info)</code> \\(\\rightarrow\\) Returns a connection, if it is possible, to the database, with some parameters specified in the URL and others in a properties object (<code>Properties</code> class studied in unit 1). We will see samples later.</li> <li><code>static Connection getConnection(String url, String user, String pass)</code> \\(\\rightarrow\\) Returns a connection, if it is possible, to the database whose parameters are specified in the URL. User and password data are provided in two additional parameters, so you do not need to write in your connection URL.</li> </ul> <p>A first sample will be:</p> Java<pre><code>public static void main (String [] args ) \n  throws ClassNotFoundException, SQLException{\n\n    Class.forName(\"com.mysql.cj.jdbc.Driver\");\n    String server=\"localhost\";\n    int port=3308;\n    String user=\"root\";\n    String pass=\"root\";\n    String DBName=\"Cycling\";\n    String connectionUrl = \"jdbc:mysql://\"+server+\":\"+port;\n    connectionUrl+=\"/\" + DBName;\n    connectionUrl+=\"?useUnicode=true&amp;characterEncoding=UTF-8\";\n\n   Connection conn = DriverManager.getConnection(connectionUrl,user,pass);\n\n   // if no exception is catched, you are connected to your DBMS\n</code></pre> <p>With the <code>Connection</code> object that we have now connected, we will send our queries and ask for information, as we will see later.</p>"},{"location":"en/UD2_Connectors/3_Connecting/#14-organizing-our-connection","title":"1.4. Organizing our connection","text":"<p>Our application is going to connect to one (or more) databases. We can make many requests to said database, and if we are implementing a multithreaded application, the number of requests can increase a lot. That is why we have to control where and when connections are created and closed. A good idea is to create a class that encapsulates all these processes. The skeleton of such a class would be as follows:</p> Java<pre><code>public class ConnexioBD {\n\n    private Connection laConnexio = null;\n\n    // write here access variables, like user, server or whatever\n\n    private void connect() {\n        // do the connetion (look the sample). \n        // Take care. private method. It will be called inside the class\n    }\n\n    // close connection, if it's opened\n    public void disConnect() {\n        if (laConnexio != null) {\n            laConnexio.close();\n        }\n    }\n\n    // returns the connection. \n    // It will be create first time of after closed\n    public Connection getConexio(){\n        if (laConnexio == null) {\n            this.connect();\n        }\n        return this.laConnexio;\n    } \n}\n</code></pre>"},{"location":"en/UD2_Connectors/3_Connecting/#141-solved-exercise","title":"1.4.1. Solved exercise","text":"<p>Create a single project with two classes. One for connecting to your database, as the last sample, and a main class that connect and show if an error have happened.</p> <p>The exercise's solution is linked here connexio.properties and ConnexioDB.java</p>"},{"location":"en/UD2_Connectors/4_Resultset/","title":"1. <code>ResultSet</code> class.","text":"<p>Now, we are connected to the database, is time to start asking for information to the DBMS. This information will be in form of queries (SQL) or others methods, but almost 90% of times, as the SQL's, the information returned is in a tabular format. Tabular formats are well known because programs like MySQL Workbench or DBeaver show data in these way.</p> <p>In Java, the class who allow to works with data in tabular format coming from databases is called <code>Resultset</code>. A <code>Resultset</code> is composed by a table (rows and columns) and a pointer to a row, called <code>cursor</code>.</p> <p></p> <ol> <li>When we retrieve data from databases, the information is stored in the table, and the cursor points to an imaginary void row called <code>beforeFisrt</code>. </li> <li><code>Resultset</code> contains a special method called <code>next()</code>, that do two actions:</li> <li>Returns <code>true</code> if exists a data row after the current row pointed by the cursor, and <code>false</code> otherwise.</li> <li>Push forward the cursor, and points to the next row.</li> <li>When a <code>Resultset</code> cursor return <code>false</code>, is because all rows have been visited, and now, the cursor is pointing to another imaginary row called <code>afterLast</code></li> </ol> <p>When the cursor is pointing a real row, is when we can retrieve data of the columns of the current row. We can use a special and overloaded method, as follows:</p> <ul> <li><code>getXXX(int columnPosition)</code> \\(\\rightarrow\\) return the data, where <code>XXX</code> is a datatype (Int, Float, Double, String, etc.) of the position of the column, starting in 1.</li> <li><code>getXXX(String columnName)</code> \\(\\rightarrow\\) return the data, where <code>XXX</code> is a datatype (Int, Float, Double, String, etc.) of the column with the given name.</li> </ul> <p>Danger</p> <p>Take into account:</p> <ul> <li>The columns start in 1 instead of 0, unlike arrays</li> <li>If you do not know the data type of a column, you can use <code>getObject</code>and it returns a generic <code>Object</code>.</li> <li>These methods could throw <code>SQLException</code>, if the column rank or name is out of rank or not exists.</li> </ul>"},{"location":"en/UD2_Connectors/4_Resultset/#11-resulsetmetadata","title":"1.1. ResulSetMetaData","text":"<p>ResultSets from of a query also have a set of metadata. This metadata can be obtained using the <code>ResultSetMetaData</code>. Most relevant methods of this class are:</p> <ul> <li><code>int getColumnCount()</code> \\(\\rightarrow\\) Gets the number of columns in the ResultSet.</li> <li><code>String getColumnName(index)</code> \\(\\rightarrow\\) Gets the name of the column indicated in the index (remember that first is 1).</li> <li><code>String getColumnTypeName(index)</code> \\(\\rightarrow\\) Gets the type of the column</li> </ul> <p>ResulSetMetaData is obtained from each previously generated ResultSet, with <code>getMetaData()</code> method.</p>"},{"location":"en/UD2_Connectors/4_Resultset/#12-resultset-algorithm","title":"1.2. ResultSet algorithm","text":"<p>Regardless the data content of your ResultSet, the way in we should work is as follows:</p> Java<pre><code>// Connect to DB\nConnection conn = ...;\n\n// recover data\nResultSet rst= conn...\n\n// while data available exists\nwhile (rst.next()){\n    //process the current row\n}\n</code></pre> <p>Be notice than:</p> <ul> <li>Inside the while loop you don't need to call <code>next()</code> again. You skip one row otherwise.</li> <li>When the last row were processed, <code>next()</code> return <code>false</code>, and the loop finish.</li> </ul>"},{"location":"en/UD2_Connectors/4_Resultset/#13-sample","title":"1.3. Sample","text":"<p>In this block of code let's go to see a brief sample to run a query (<code>Select * from table</code>). We will see queries in next sections.</p> Java<pre><code>//with a previous connection\nString taula=\"Jocs\";\nResultSet rst = con.createStatement().executeQuery(\"SELECT * FROM \" +taula);\nSystem.out.println(Colors.Cyan);\nSystem.out.println(\"\");\nSystem.out.println(\"Contingut de \" + taula);\nSystem.out.println(\"******************************\");\n\nResultSetMetaData rsmdQuery = rst.getMetaData();\n\n// print the columns name\nfor (int i = 1; i &lt;= rsmdQuery.getColumnCount(); i++)\n  System.out.print(String.format(\"%-25.25s\",rsmdQuery.getColumnName(i)));\n\nSystem.out.println();\nSystem.out.println(Colors.Reset);\n\n// print the values\nwhile (rs.next()) {\n  for (int i = 1; i &lt;= rsmdQuery.getColumnCount(); i++)\n  System.out.print(String.format(\"%-25.25s \",rst.getString(i)));\n  System.out.println();\n}\n</code></pre>"},{"location":"en/UD2_Connectors/5_Metadata/","title":"1. Database Metadata","text":"<p>Before retrieving data, we are going to study how to get information about the database we are connected. The metadata of a database describe the structure it has: tables of which it is composed the database, the fields that make up these tables, the types of these fields, etc. Even though we usually know this structure beforehand, it is possible that we need it on occasion of her for this we have the <code>DatabaseMetaData</code> and <code>ResultsetMetaData</code> interfaces.</p> <p><code>DatabaseMetaData</code> interface provides us with information about the tables and views of the database, as well as its structure. In the following we have some of the most relevant methods of this interface.</p> <ul> <li><code>String getDatabaseProductName()</code> \\(\\rightarrow\\) Gets the name of the DBMS.</li> <li><code>String getDriverName()</code> \\(\\rightarrow\\) Gets the name of the JDBC driver in use.</li> <li><code>String getURL()</code> \\(\\rightarrow\\) Gets the URL of the connection.</li> <li><code>String getUserName()</code> \\(\\rightarrow\\) Gets the name of the user connected to the DB.</li> <li><code>ResultSet getTables(String catalog, String schema, String patternTableName, String[] type)</code> \\(\\rightarrow\\) Get information from the tables available in the catalog indicated.</li> <li><code>ResultSet getColumns(String catalog, String schema, String patternNameTable, String patternColumnName)</code> \\(\\rightarrow\\) Gets information from the columns of the table specified in the catalog and diagram indicated </li> <li><code>ResultSet getPrimaryKeys(String catalog, String schema, String patternNameTable)</code> \\(\\rightarrow\\) Gets the list of fields that make up the primary key.</li> <li><code>ResultSet getImportedKeys(String catalog, String schema, String patternNameTable)</code> \\(\\rightarrow\\) Gets a list with the foreign keys defined in the table.</li> <li><code>ResultSet getExportedKeys(String catalog, String schema, String patternNameTable)</code> \\(\\rightarrow\\) Gets a list with the foreign keys that point to this table</li> </ul> <p>Additional information</p> <p>At this point, it is necessary to point out that the terms catalog and scheme tend to be confused. By standards, a catalog contains several schematics, with detailed system information, from the form of internal storage to the conceptual schemes. In a catalog, there seems to be one schema called INFORMATION_SCHEMA, with the views and domains of the information schema of the system.</p> <p>In any case, most DBMS match the catalog with the database. Moreover, in this query we specify the database name as catalog, while if open MySQLWorkbench, the database is represented as a schema. We can find more information about it in these links:</p> <ul> <li>https://stackoverflow.com/questions/7022755/whats-the-difference-between-a-catalog-and-a-schema-in-a-relational-database</li> <li>https://www.quora.com/What-is-the-difference-between-system-catalog-and-database-schemain-a-Database</li> </ul>"},{"location":"en/UD2_Connectors/5_Metadata/#11-solved-exercise","title":"1.1. Solved Exercise","text":"<p>Let's go to create a Java program that shows internal information of a database <code>BDJocs</code>, through <code>DataBaseMetaData</code>. Let's view the program step by step.</p> <p>Info</p> <p>You can view all the information of the method and how the data is stored in each method's ResultSet in this link.</p>"},{"location":"en/UD2_Connectors/5_Metadata/#111-create-the-connection","title":"1.1.1. Create the connection","text":"<p>Remember how to connect to a DBMS in a easy way:</p> Java<pre><code>// load JDBC driver\n2 Class.forName(\"com.mysql.cj.jdbc.Driver\");\n3 // Connecto to DBMS and DB BDJosc, with user and pass\n4 Connection con = DriverManager.getConnection(\"jdbc:mysql://localhost:3308/BDJocs\", \"root\", \"root\");\n</code></pre> <p>Very simple, load the driver and connect to DB, in the way we have studied</p>"},{"location":"en/UD2_Connectors/5_Metadata/#112-retrieve-metadata-from-dbms-and-show-in-a-friendly-format","title":"1.1.2. Retrieve metadata from DBMS, and show in a friendly format","text":"<p>We will use <code>Color</code> class to show data to paint text in console. You have this class in CEPA 1, inside the project.</p> Java<pre><code>// get the metadata\nDatabaseMetaData dbmd = con.getMetaData();\n\nSystem.out.println(Colors.Blue+\"\\nDBMS information--------\"+Colors.Reset);\nSystem.out.println(Colors.Bright_White+\"SGBD:\\t\"+Colors.Reset + dbmd.getDatabaseProductName());\nSystem.out.println(Colors.Bright_White+\"SGBD:\\t\"+Colors.Reset + dbmd.getDriverName());\nSystem.out.println(Colors.Bright_White+\"SGBD:\\t\"+Colors.Reset + dbmd.getURL());\nSystem.out.println(Colors.Bright_White+\"SGBD:\\t\"+Colors.Reset + dbmd.getUserName());\n</code></pre> <p>As you can see, we get the name of the DBMS, driver, URL a user we are using. Obviously, is the same that we put when we created Connection object, but it's a good example to show information.</p>"},{"location":"en/UD2_Connectors/5_Metadata/#113-retrieve-tables-in-a-schemadatabase","title":"1.1.3. Retrieve tables in a schema/database","text":"<p>Using <code>getTables()</code> method we could recover the tables and more information. We suppose <code>BDJocs</code> exists in our DBMS:</p> Java<pre><code>System.out.println(Colors.Bright_White+String.format(\"%-15s %-15s %-15s\",\"Database\",\"Table\",\"Type\"));\nSystem.out.println(\"-------------------------------------------------------\"+Colors.Reset);\nResultSet rsmd = dbmd.getTables(\"BDJocs\", null, null, null);\nwhile (rsmd.next()) {\n  System.out.println(String.format(\"%-15s %-15s %-15s\",rsmd.getString(1),rsmd.getString(3),rsmd.getString(4)));\n}\n</code></pre> <p>Comments:</p> <p>Revise <code>String.format()</code> to set a specific column length. From javadoc, we get than the ResultSet returned by <code>getTables</code> has the following columns:</p> <ol> <li>TABLE_CAT String \u2192 table catalog (may be null)</li> <li>TABLE_SCHEM String \u2192 table schema (may be null)</li> <li>TABLE_NAME String \u2192 table name</li> <li>TABLE_TYPE String \u2192 table type. Typical types are \"TABLE\", \"VIEW\", \"SYSTEM TABLE\", \"GLOBAL TEMPORARY\", \"LOCAL TEMPORARY\", \"ALIAS\", \"SYNONYM\".</li> <li>REMARKS String \u2192 explanatory comment on the table</li> <li>TYPE_CAT String \u2192 the types catalog (may be null)</li> <li>TYPE_SCHEM String \u2192 the types schema (may be null)</li> <li>TYPE_NAME String \u2192 type name (may be null)</li> <li>SELF_REFERENCING_COL_NAME String \u2192 name of the designated \"identifier\" column of a typed table (may be null)</li> <li>REF_GENERATION String \u2192 specifies how values in SELF_REFERENCING_COL_NAME are created. Values are \"SYSTEM\", \"USER\", \"DERIVED\". (may be null)</li> </ol> <p>We get columns 1, 3 and 4.</p>"},{"location":"en/UD2_Connectors/5_Metadata/#114-get-the-tables-columns","title":"1.1.4. Get the table's columns","text":"<p>Is the moment to get the columns of a table, using <code>getColumns()</code> method:</p> Java<pre><code>String table=...; // we set the name of an existing table\nResultSet columnes = dbmd.getColumns(\"BDJocs\",null , taula, null);\nSystem.out.println(Colors.Bright_White+String.format(\"%-25s %-15 s%-15s\",\"Atribut/Claus\",\"Tipus\",\"Pot ser nul?\"+Colors.reset));\n\nwhile (columnes.next()){\n    String columnName=columnes.getString(4);\n    String tipus=columnes.getString(6);\n    String nullable=columnes.getString(18);\n\n    System.out.println(String.format(\"%-25s %-15s %15s\",columnName,tipus,nullable));\n}\n</code></pre> <p>Comments:</p> <ul> <li><code>getColumns()</code> returns 24 columns ResultSet, with a lot of table information. We get only columns 4, 6 and 18 with the name, type and if can be null. You can view javadoc for more information.</li> <li>In the same way, to get information about keys, we can use:</li> <li><code>getPrimaryKeys()</code> returns a ResultSet with the tables' primary keys.</li> <li><code>getExportedKeys()</code> returns a ResultSet with the columns that point to the current table primary key. It means all the fields in other table that point to current table primary key.</li> <li><code>getImportedKeys()</code> returns a ResultSet with the columns that are imported primary keys to the current table. It means the columns that are foreign key (and point to a primary key in other tables).</li> </ul> <p>You have the whole sample in package <code>DatabaseMeta</code> in sample application and following link.  </p>"},{"location":"en/UD2_Connectors/6_CRUD/","title":"1. Statements and CRUD operations","text":"<p>In this section we are going to study the main goal working with databases: manipulate data. We will always work with the same template:</p> <ol> <li>Connect to de database.</li> <li>Prepare the query</li> <li>Execute the query</li> <li>Data processing, if needed.</li> </ol> <p>Point 1 has been studied on previous sections. </p> <p>In order to create the queries, we should use the following classes/interfaces:</p> <ul> <li><code>Statement</code> \\(\\rightarrow\\) It is used in a general way, and it is useful when we want to perform static SQL statements, since no accepts parameters. We create <code>Statement</code> with <code>createStatement()</code> method from <code>Connection</code> class.</li> <li><code>PreparedStatement</code> \\(\\rightarrow\\) It is used when we want to launch several requests, and in addition, it is allowed to perform dynamic sentences. We create <code>PreparedStatement</code> with <code>prepareStatement()</code> method from <code>Connection</code> class.</li> <li><code>CallableStatement</code> \\(\\rightarrow\\) Used to access stored procedures in the database, and also accepts input parameters. We create <code>CallableStatement</code> with <code>prepareCall()</code> method from <code>Connection</code> class.</li> </ul> <p>When the statement is ready, we can execute it with:</p> <ul> <li><code>executeQuery</code> \\(\\rightarrow\\) Executes statements that we expect to return data (SELECT queries). The return value from this execution is, as you will guess, a ResultSet.</li> <li><code>executeUpdate</code> \\(\\rightarrow\\) Executes statements that are not expected to return data, but they will be used to modify the database connected (INSERT, DELETE, UPDATE queries and CREATE TABLE)</li> </ul>"},{"location":"en/UD2_Connectors/6_CRUD/#11-create-insert","title":"1.1. Create (Insert)","text":"<p>Let's go to see a simple <code>INSERT</code> statement sample.  </p> Java<pre><code>ConnexioDB conDB=new ConnexioDB(\"BDJocs\");\nConnection con=conDB.getConnexio();\n\nString SQL=\"INSERT INTO Joc VALUES (1, 'Double Dragon', 'Dos germans bessons experts en arts marcials s`han de fer cam\u00ed en un escenari urb\u00e0 on  membres de bandes rivals volen deixar-los fora de combat.', 1);\";\n\nStatement st=con.createStatement();\n\nint affectedRows=st.executeUpdate(SQL);\n\nSystem.out.println(affectedRows+ \"row has been inserted\");\n</code></pre> <p>As you can see, is very easy to understand the code. We create an empty Statement and the run the SQL \"per se\". The execution returns numbres of rows inserted. We will see better ways to insert data, using scripts.</p> <p>Info</p> <p>This code is a reduced version, because when we are working with databases <code>SQLException</code> could appear. We suppose that the connection process is already done.</p>"},{"location":"en/UD2_Connectors/6_CRUD/#12-read-select","title":"1.2. Read (Select)","text":"<p>Reading is the most important process we will do, because only with the login process inside an App are retrieving information from a database. In all cases we must write the sentence (SQL), execute it and finally process the returned data. Depending on the way we prepare the sentence, we could distinguish between:</p> <ol> <li>Fixed sentences</li> <li>Variable sentences</li> <li>Prepared sentences</li> </ol> <p>We will see both ways in details. We will use for this the <code>Instituto.sql</code> script and database.</p>"},{"location":"en/UD2_Connectors/6_CRUD/#121-fixed-sentences","title":"1.2.1. Fixed sentences","text":"<p>This sentence, as its name says, are fixed or constant sentences. The SQL is fixed, and it has not any variables.</p> Java<pre><code>// The query\nString SQL=\"Select * from Persona\";\n// The statement\nStatement st=con.createStatement();\n// The execution\nResultSet rst=st.executeQuery(SQL);\n\n// processing\nwhile(rst.next()){\n    System.out.print(ConsoleColors.BLUE_BRIGHT+ \"Person: \"+ ConsoleColors.RESET);\n    /*\n    System.out.println(\n            rst.getString(3)+ \", \"+\n            rst.getString(2)+ \" \"+\n            rst.getInt(4));\n    */\n    System.out.println(\n            rst.getString(\"apellidos\")+ \", \"+\n            rst.getString(\"nombre\")+ \" \"+\n            rst.getInt(\"edad\"));\n}\n\nrst.close();\n</code></pre> <p>In the processing of the information, ResultSet has:</p> <ul> <li><code>type getType(int columnIndex)</code> \\(\\rightarrow\\) overloaded method, that return the given datatype, using the ResultSet column's index. Remember that first column is 1 instead of 0. The type will be Int, String, Double, etc. if you know the type. For unknown columns you can use <code>Object</code> as a generic type.</li> <li><code>type getType(String columnName)</code> \\(\\rightarrow\\) same as above method but accessing to the column with the name that we have selected in the query or the name in the table.</li> </ul>"},{"location":"en/UD2_Connectors/6_CRUD/#122-variable-sentences","title":"1.2.2. Variable sentences","text":"<p>Imagine that you want to recover names with <code>Ma</code> inside him.</p> SQL<pre><code>String SQL=\"Select * from Persona where nombre like '%Ma%'\";\n</code></pre> <p>In this case, this query is hardcoded, and if you want to change the portion inside the text, you have to edit your code. To avoid hard-coding, we can write:</p> Java<pre><code>ConnexioDB conDB=new ConnexioDB(\"Instituto\");\n\nConnection con=conDB.getConnexio();\n\n// hardcoded String\n// String SQL=\"Select * from Persona where nombre like '%Ma%'\";\n\nString nombre=Utilitats.leerTextoC(\"Give me part of the name: \");\n// The query\nString SQL=\"Select * from Persona where nombre like '%\" + nombre + \"%'\";\n// The statement\nStatement st=con.createStatement();\n// The execution\nResultSet rst=st.executeQuery(SQL);\n\n// processing\nwhile(rst.next()){\n    System.out.print(ConsoleColors.BLUE_BRIGHT+ \"People with \" +nombre+\": \"+ ConsoleColors.RESET);\n    System.out.println(\n            rst.getString(\"apellidos\")+ \", \"+\n            rst.getString(\"nombre\")+ \" \"+\n            rst.getInt(\"edad\"));\n}\n\nrst.close();\n</code></pre> <p>As we can see, the data is now in variables, but the construction of the SQL is more complex. Note that the texts must be between quotation marks and the numbers must not, which makes very easy to do mistakes. But it can be worse, this type of code can incur SQL injection problems, as we see in the example that follows:</p> Java<pre><code>String idPersona=Read.readText(\"Tell me the id to consult: \");\nString SQL = \"Select * from Person where idPersona=\"+idPersona;\n</code></pre> <ul> <li>If the user enters <code>4</code> \\(\\rightarrow\\) It will show the person of ID equal to 4</li> <li>If the user enters <code>4 or 1=1</code> \\(\\rightarrow\\) It will show all the people</li> </ul> <p>We must avoid this type of queries in user validation statements, for which we will use the prepared statements and, obviously to be very careful checking the inputs.</p>"},{"location":"en/UD2_Connectors/6_CRUD/#123-prepared-sentences","title":"1.2.3. Prepared sentences","text":"<p>To avoid the SQL injection problem, as long as we have parameters in our query, we will make use of prepared statements. In the prepared statements, where we have to make use of a marker, instead of composing it with concatenations within the String, we will indicate it with a question mark (<code>?</code>), a character called placeholder.</p> <p>Next, we must assign values to these placeholders, using <code>setType(int pos)</code> methods where <code>Type</code> is the data type that we are going to assign and <code>pos</code> is the position of the placeholder, starting with 1. Let's see the example:</p> Java<pre><code>ConnexioDB conDB=new ConnexioDB(\"Instituto\");\n\nConnection con=conDB.getConnexio();\n\nString ID=Utilitats.leerTextoC(\"Give me an id: \");\n// The query\nString SQL=\"Select * from Persona where idPersona = ?\" ;\n// The statement\nPreparedStatement pst=con.prepareStatement(SQL);\n// fill placeholders\n\npst.setString(1, ID);\n\n// The execution\nResultSet rst=pst.executeQuery();\n\n// processing\nwhile(rst.next()){\n    System.out.print(ConsoleColors.BLUE_BRIGHT+ \"People with \" +ID+\": \"+ ConsoleColors.RESET);\n    System.out.println(\n            rst.getString(\"apellidos\")+ \", \"+\n            rst.getString(\"nombre\")+ \" \"+\n            rst.getInt(\"edad\"));\n}\n\nrst.close();\n</code></pre> <p>Advice</p> <p>You can combine ResultSet with ResultSetMetaData to get the columns name and data types stored in the database. Yoy will find a sample in the platform.</p>"},{"location":"en/UD2_Connectors/6_CRUD/#13-update-update-and-delete-delete","title":"1.3. Update (Update) and Delete (Delete)","text":"<p>Update and delete a row, are both considered as updates, because they modify the database status. In fact, we also consider inserting as database update too. Both tasks will be inclosed in a <code>executeUpdate()</code> method. Let's go to study through samples:</p>"},{"location":"en/UD2_Connectors/6_CRUD/#131-delete-sample","title":"1.3.1. Delete sample","text":"<p>Let's go to delete rows from a table of people between given ages:</p> Java<pre><code>ConnexioDB conDB = new ConnexioDB(\"Instituto\");\nConnection con = conDB.getConnexio();\n\n// give the age's bounds\nint minAge = Utilitats.leerEnteroC(\"Give me minimal age: \");\nint maxAge = Utilitats.leerEnteroC(\"Give me maximun age: \");\n\n// The query\nString SQL = \"Delete from Persona where edad between ? and ?\";\n\n// The statement\nPreparedStatement pst = con.prepareStatement(SQL);\n\n// fill placeholders            \npst.setInt(1, minAge);\npst.setInt(2, maxAge);\n\n// show the query after resolve placeholders\nSystem.out.println(pst);\n\n// The execution\nint deletedtedRows = pst.executeUpdate();\n\n// how many roas affecte\nSystem.out.println(deletedtedRows + \" has been deleted.\");\n</code></pre> <p>Warning</p> <p>Deleting data is a very sensitive operation. Be careful to:</p> <ul> <li>Don't forget <code>WHERE</code> clause when deleting, because you will delete all data from the table.</li> <li>If you want to delete all the table, including the structure (definition + table), you must use <code>DROP TABLE</code> instead of <code>DELETE</code>.</li> <li>If you try to delete a row pointed by a foreign key, you will get the <code>SQLIntegrityConstraintViolationException</code> and a message like Cannot delete or update a parent row: a foreign key constraint fails.</li> </ul>"},{"location":"en/UD2_Connectors/6_CRUD/#132-update-sample","title":"1.3.2. Update sample","text":"<p>Let's go to add years to given id people:</p> Java<pre><code>ConnexioDB conDB = new ConnexioDB(\"Instituto\");\n\nConnection con = conDB.getConnexio();\n\n// give the age's bounds\nint difAge = Utilitats.leerEnteroC(\"Give me number oy years: \");\nint idMin = Utilitats.leerEnteroC(\"Give me minimum id: \");\n\n// The query\nString SQL = \"Update Persona set edad=edad+ ? where idPersona &gt; ?\";\n\n// The statement\nPreparedStatement pst = con.prepareStatement(SQL);\n\n// fill placeholders            \npst.setInt(1, difAge);\npst.setInt(2, idMin);\n\nSystem.out.println(pst);\n// The execution\nint updatedRows = pst.executeUpdate();\n\nSystem.out.println(updatedRows + \" has been updated.\");\n</code></pre> <p>Warning</p> <p>Remember to: </p> <ul> <li><code>UPDATE</code> clause don't need <code>FROM</code> because we say the table name directly.</li> <li>It appears <code>SET</code> clause, with pairs <code>field=updatet_value</code>, to assign the new value to selected fields.</li> <li>If we forget <code>FROM</code> clause, all rows will be updated.</li> </ul>"},{"location":"en/UD2_Connectors/6_CRUD/#14-scripts","title":"1.4. Scripts","text":"<p>A script, which we usually have created in an external file, is a set of SQL statements executed in order from top to bottom. We could take as a strategy to read the file line by line and execute it one by one, but JDBC allows executing a set of instructions in block. To do this, the first thing we need to do is enable multiple execution by adding a parameter to the connection, which is <code>allowMultiQueries=true</code>.</p> <p>Next, we must load the file and compose a String with the entire script. To normalize it and make it totally portable, we must be careful with the line breaks, since depending on the system it is a <code>\\n</code> or a <code>\\r\\n</code> combination. We can read line by line and save it in a <code>StringBuilder</code>, adding <code>System.getProperty(\"line.separator\")</code> as separators.</p> <p>Then we will only need to create a statement with said String and execute it with <code>executeUpdate()</code>. Let's see it:</p> Java<pre><code>ConnexioDB conDB = new ConnexioDB(\"Instituto\");\n\nConnection con = conDB.getConnexio();\n\nFile script = new File(\"sql/EsquemaCine.sql\");\n\nBufferedReader bfr = bfr = new BufferedReader(new FileReader(script));\n\nString line = null;\nStringBuilder sb = new StringBuilder();\n\n// Obtenemos el salto de linea del sistema subyacente\nString breakLine = System.getProperty(\"line.separator\");\n\nwhile ((line = bfr.readLine()) != null) {\n    sb.append(line);\n    sb.append(breakLine);\n}\n\nString query = sb.toString();   // generemos el Script en un String\nStatement stm = con.createStatement();\nint result = stm.executeUpdate(query);\nSystem.out.println(\"Script ejecutado con salida \" + result);\n</code></pre> <p>Advice</p> <p>Do you remember <code>Files</code> and <code>Paths</code> classes? Rewrite last sample to get cleaner code.</p>"},{"location":"en/UD2_Connectors/6_CRUD/#15-transactions","title":"1.5. Transactions","text":"<p>If we want to protect data integrity, as well as avoid unexpected blocking situations in multithreaded applications, we must protect our operations, especially those that modify data through the use of transactions.</p> <p>A transaction defines an execution environment in which save operations remain stored in memory until the transaction is completed. If at a certain moment something fails, the state is returned to the initial point of the same (initial point), or some intermediate marking point. By default, opening a connection starts a transaction.</p> <ul> <li>Each execution on the connection generates a transaction on itself. </li> <li>If we want to disable this option so that the transaction encompasses several executions, we must mark it through <code>Connection.setAutoCommit(false);</code>.</li> <li>To definitively accept the transaction we will do it through <code>Connection.commit();</code> </li> <li>To cancel the transaction <code>Connection.rollback();</code></li> </ul>"},{"location":"en/UD2_Connectors/6_CRUD/#16-updatable-resultsets","title":"1.6. Updatable ResultSets","text":"<p>The working methods revised in previous sections, specially when updating or deleting rows, works directly on the database. It means that you delete or update a row without loading previously in memory. What happens if you want to show data to user and then the user decide to delete or update the row. In this time, is better to use updatable ResultSet.</p> <p>We have studied ResultSet as a collection of rows, and used it only for reading. We can use it to edit and delete data too. To do this, we need to open the ResultSet in different way as we have seen. For last, but not least, it will depend on the database the availability to crete this kind of ResultSets.</p> <p>To get it, not depends on ResultSet even how Statement was created. We must use this constructor:</p> Java<pre><code>public abstract Statement createStatement(\n    int arg0,   // resultSetType           \n    int arg1,   // resultSetConcurrency\n    int arg2)   // resultSetHoldability\n    throws SQLException\n</code></pre> <p>As you can see, there are 3 arguments to tell what kind or ResultSet we give in the end. These three arguments can be:</p> <ul> <li><code>resultSetType</code> \\(\\rightarrow\\) these are options about moving and passing through rows in the ResultSet:</li> <li><code>TYPE_FORWARD_ONLY</code> \\(\\rightarrow\\) default option. ResultSet can be passed one time only.</li> <li><code>TYPE_SCROLL_INSENSITIVE</code> \\(\\rightarrow\\) Allow rewinding and skipping to an absolute or relative position.</li> <li><code>TYPE_SCROLL_SENSITIVE</code> \\(\\rightarrow\\) Same as before but allow seeing changes done in the database.</li> <li><code>ResultSetConcurrency</code> \\(\\rightarrow\\) these are options about if ResultSet can be updated or no:</li> <li><code>CONCUR_READ_ONLY</code> \\(\\rightarrow\\) default option. Read only. If we want to update something, only cas use <code>DELETE</code> or <code>UPDATE</code> clauses.</li> <li><code>CONCUR_UPDATABLE</code> \\(\\rightarrow\\) ResultSet's rows can be updated or deleted.</li> <li><code>ResultSetHoldability</code> these options are about behavior closing ResultSet:</li> <li><code>HOLD_CURSORS_OVER_COMMIT</code> \\(\\rightarrow\\) ResultSet remains opened after commit the transaction.</li> <li><code>CLOSE_CURSORS_AT_COMMIT</code> \\(\\rightarrow\\) ResultSet is closed after commit the transaction. It improves performance.</li> </ul> <p>In next sample we could ask our DBMS if these kinds of ResultSet are supported:</p> Java<pre><code>ConnexioDB conDB = new ConnexioDB(\"Instituto\");\nConnection con = conDB.getConnexio();\nDatabaseMetaData dbmd = con.getMetaData();\n\nSystem.out.println(\"TYPE_FORWARD_ONLY: \" + dbmd.supportsResultSetType(ResultSet.TYPE_FORWARD_ONLY));\nSystem.out.println(\"TYPE_SCROLL_INSENSITIVE: \" + dbmd.supportsResultSetType(ResultSet.TYPE_SCROLL_INSENSITIVE));\nSystem.out.println(\"TYPE_SCROLL_SENSITIVE: \" + dbmd.supportsResultSetType(ResultSet.TYPE_SCROLL_SENSITIVE));\nSystem.out.println(\"CONCUR_READ_ONLY: \" + dbmd.supportsResultSetConcurrency(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY));\nSystem.out.println(\"CONCUR_UPDATABLE: \" + dbmd.supportsResultSetConcurrency(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE));\n</code></pre>"},{"location":"en/UD2_Connectors/6_CRUD/#161-resultset-movement","title":"1.6.1. ResultSet movement","text":"<p>As we can see, not only could move cursor forward:</p> <ul> <li><code>next</code>, <code>previous</code>, <code>first</code> and <code>last</code> \\(\\rightarrow\\) as the name says, move forward, backward, beginning and last row. It returns true if the cursor is pointing over a row and false otherwise.</li> <li><code>beforeFirst</code> and <code>afterLast</code>\\(\\rightarrow\\) the cursor will point out of the rows, before the first or after the last row.</li> <li><code>relative(int n)</code> \\(\\rightarrow\\) the cursor moves n rows (forward or backward, depending on the sign).</li> <li><code>absolute(int n)</code> \\(\\rightarrow\\) the cursor is pointed on row n.</li> </ul>"},{"location":"en/UD2_Connectors/6_CRUD/#162-deleting-rows-in-a-resultset","title":"1.6.2. Deleting rows in a ResultSet","text":"<p>After placing the cursor on the row to be deleted we can delete it from the ResultSet (and from the database) with the <code>deleteRow()</code> method. When deleting a row, the cursor will be pointing to the row before the one deleted.</p>"},{"location":"en/UD2_Connectors/6_CRUD/#163-updating-rows-in-a-resultset","title":"1.6.3. Updating rows in a ResultSet","text":"<p>After placing the cursor on the desired row, we must:</p> <ol> <li>Update the desired columns, using the <code>updateType(int column, type newValue)</code> method, where the i-th column (or with its name) is assigned the new value of the given type.</li> <li>Once all the desired columns have been modified, the changes are saved with <code>updateRow()</code>.</li> </ol> <p>Advice</p> <p>We can't update an entire row, we should update column by column and then update the row.</p>"},{"location":"en/UD2_Connectors/6_CRUD/#164-inserting-rows-in-a-resultset","title":"1.6.4. Inserting rows in a ResultSet","text":"<p>If we want to insert a new row in a ResultSet, we must:</p> <ol> <li>Generate a new empty row, and this is achieved with the <code>moveToInsertRow()</code>. </li> <li>On this row we apply the <code>updateType(int column, type newValue)</code> method to all the columns that we must set a value, and finally</li> <li>We will proceed to insert the new row with <code>insertRow()</code>.</li> </ol> <p>!!! warning \"Important</p> Text Only<pre><code>- These Update, Delete and Insert operations can only be performed on queries that originate in a table without groupings.\n- To avoid complexity in our programs, it is worth assessing the convenience of translating the ResultSet updates to pure SQL and executing it natively in the databases through new statements.\n</code></pre>"},{"location":"en/UD2_Connectors/7_Row_to_Object/","title":"1. From rows to Objects","text":"<p>Finally, to close the unit, we are going to work in the natural way: recover data from database, create objects from ResultSet, and save data into database.</p> <p>We will study a new way to create ours POJO's (and BEAN's), using a modern library called Lombok.</p>"},{"location":"en/UD2_Connectors/7_Row_to_Object/#11-pojos-beanss-and-project-lombok","title":"1.1. POJO's, BEANS's and Project Lombok","text":"<p>We must create classes according to our object-oriented model. Depending on how we made classes, could be POJO's or BEAN's or another kind of classes. Let's go to understand it (extracted from here).</p>"},{"location":"en/UD2_Connectors/7_Row_to_Object/#111-pojo","title":"1.1.1. POJO","text":"<p>It means Plain Old Java Object. It is a class who:</p> <ul> <li>It should not extend any class.</li> <li>It should not implement any interface.</li> <li>It should not contain specific annotations.</li> </ul> <p>There is no restriction on access-modifiers of fields. They can be private, default, protected, or public. It is also not necessary to include any constructor in it.</p> <p>A sample of POJO is, for instance:</p> Java<pre><code>// AS POJO\npublic class Modul {\n  // attributes\n  String nom;\n  int hores;\n  double nota;\n  // constructor\n  public Modul(String nom, int hores, double nota) {\n      this.nom = nom;\n      this.hores = hores;\n      this.nota = nota;\n  }\n  // getters\n  public String getModul(){return this.nom;}\n  public int getHores() {return this.hores;}\n  public double getNota() {return this.nota;}\n\n  @Override\n  public String toString() {\n      return \"Modul{\" + \"nom=\" + nom + \", hores=\" + hores + \", nota=\" + nota + '}';\n  } \n}\n</code></pre> <p>As you can see, a POJO is the minimalist class that we can do.</p>"},{"location":"en/UD2_Connectors/7_Row_to_Object/#112-bean","title":"1.1.2. BEAN","text":"<p>Beans are special type of POJO's. There are some restrictions on POJO to be a BEAN.</p> <ul> <li>All JavaBeans are POJOs but not all POJOs are JavaBeans.</li> <li><code>Serializable</code>, they should implement Serializable interface. Still, some POJOs who don\u2019t implement a Serializable interface are called POJOs because Serializable is a marker interface and therefore not of many burdens.</li> <li>Fields should be private. This is to provide complete control on fields.</li> <li>Fields should have getters or setters or both.</li> <li>A no arguments constructor should be there in a bean.</li> <li>Fields are accessed only by constructor or getter setters.</li> </ul> Java<pre><code>// AS POJO\npublic class Modul {\n  // attributes\n  private String nom;\n  private int hores;\n  private double nota;\n  // constructor\n  public Modul() { }\n  // getters\n  public String getModul(){return this.nom;}\n  public int getHores() {return this.hores;}\n  public double getNota() {return this.nota;}\n// setters\n  public void getModul(){return this.nom;}\n  public void getHores() {return this.hores;}\n  public void getNota() {return this.nota;}\n\n  @Override\n  public String toString() {\n      return \"Modul{\" + \"nom=\" + nom + \", hores=\" + hores + \", nota=\" + nota + '}';\n  } \n}\n</code></pre> <p>To sum up, POJO classes and Beans both are used to define java objects to increase their readability and reusability. POJOs don\u2019t have other restrictions while beans are special POJOs with some restrictions.</p>"},{"location":"en/UD2_Connectors/7_Row_to_Object/#113-lombok","title":"1.1.3. Lombok","text":"<p>Regardless using POJO or BEAN, there are some repetitive tasks that we have to do to create our classes. Most of this task are implemented by IDE's, as well as create getters, setters, encapsulate fields, create constructors, etc. Project Lombok is a library that avoid doing this repetitive tasks, and saying what we want and the library and compiler do the rest.</p> <p>In this link setup Lombok you will find how to set up the library, in each project manager (gradle, maven, etc.) and in each IDE (Netbeans, Eclipse, IntelliJ, etc.). </p> <p>Once you have installed, you only need to say through annotations, what do you want:</p> <ul> <li><code>@Getter</code> \\(\\rightarrow\\) will generate all Getters.</li> <li><code>@Setter</code> \\(\\rightarrow\\) will generate all Setters.</li> <li><code>@Data</code> \\(\\rightarrow\\) all methods that needs a POJO, including <code>ToString</code></li> <li><code>@AllArgsConstructor</code> ou <code>@NoArgsConstructor</code> \\(\\rightarrow\\) generate the constructor you want</li> </ul> <p>In this v\u00eddeo you will find an explanation about how to add gradle dependency and using Lombok.</p>"},{"location":"en/UD2_Connectors/7_Row_to_Object/#12-loading-objects","title":"1.2. Loading objects","text":"<p>Let's go to finish with a sample:</p>"},{"location":"en/UD2_Connectors/7_Row_to_Object/#121-class-persona","title":"1.2.1. Class Persona","text":"<p>This class is the POJO of one person. It will create getters, setter, toString and the main methods with only a few lines and some annotations.</p> Java<pre><code>@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class Persona {\n    private int idPersona;\n    private String nombre;\n    private String apellidos;\n    private int edad;\n}\n</code></pre> <p>Notice that with Lombok work is made easy.</p>"},{"location":"en/UD2_Connectors/7_Row_to_Object/#122-filling-an-array","title":"1.2.2. Filling an Array","text":"<p>To fill a data structure from database, you have to get data first. You must create the Statement or PreparedStatement, run the query. </p> <p>The main task is transforming the ResultSet into a List, but it's a easy task:</p> <ul> <li>Loop over the ResultSet (with next), and for each row:</li> <li>Create an object with the values stored in the columns</li> <li>Add this object to the List</li> </ul> Java<pre><code>ArrayList&lt;Persona&gt; lasPersonas= new ArrayList();\n\nConnexioDB conDB=new ConnexioDB(\"Instituto\");\n\nConnection con=conDB.getConnexio();\n\nString SQL=\"Select * from Persona\" ;\n// The statement\nStatement st=con.createStatement(\n        ResultSet.TYPE_SCROLL_INSENSITIVE,\n        ResultSet.CONCUR_READ_ONLY);\n\n// The execution\nResultSet rst=st.executeQuery(SQL);\n\nif (!rst.next()){\n    System.out.println(\"No people in DB\");\n}\nelse{\n    rst.beforeFirst();\n    while(rst.next()){\n        Persona p= new Persona(\n                rst.getInt(1),\n                rst.getString(2),\n                rst.getString(3),\n                rst.getInt(4));\n        System.out.println(\"Adding \" +p);\n        lasPersonas.add(p);\n    }\n}\n\nSystem.out.println(\"Added \" + lasPersonas.size() + \" people\");\nrst.close();\n</code></pre> <p>Now you could change the information in the objects, and finally, if any modification has been done, you should save on database. The questions are:</p> <ul> <li>How do I know if an object has been update?</li> <li>How do I know what field should save?</li> </ul> <p>As you can see, there are several tasks that require a control of data modification and how to save it. This task will be easy with ORM, and we will study them.</p> <p> Versi\u00f3 Autor Data 0 Joan Gerard Camarena Juliol de 2021 1 Joan Gerard Camarena Octubre de 2022 2 Joan Gerard Camarena Setembre de 2024 <p></p>"}]}